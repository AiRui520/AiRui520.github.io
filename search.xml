<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo+GitHub搭建博客</title>
    <url>/2022/07/01/Hexo+GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.zyiz.net%2Fupload%2F202002%2F18%2F202002182223498227.png&refer=http%3A%2F%2Fwww.zyiz.net&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1659501869&t=eedef2a99fe19a8fd51bafe9ae2a1177" alt="img"></p>
<span id="more"></span>

<p>搭建博客千千万，最后受欢迎的9还是Hexo和Jekyll,用户用的非常多的两个静态博客生成系统。本文就介绍利用Hexo结合github page来搭建个人博客。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="什么是Hexo？"><a href="#什么是Hexo？" class="headerlink" title="什么是Hexo？"></a>什么是Hexo？</h3><p>Hexo 是一个基于 node.js 制作的快速、简洁且高效的博客框架。Hexo 可以将我们撰写的 Markdown 文档解析渲染成静态的 HTML 网页。</p>
<h3 id="Hexo和Jekyll的区别"><a href="#Hexo和Jekyll的区别" class="headerlink" title="Hexo和Jekyll的区别"></a>Hexo和Jekyll的区别</h3><p>·本地环境<br>Jeklly 是由 Ruby 语言编写，需要到官网下载并安装 RubyInstaller。Hexo 则需要安装 Node.js 环境。网上经常看到很多人吐槽安装 Jekyll 经常碰到各种问题。</p>
<p>·速度<br>说是比较 Hexo 和 Jeklly 这两个框架，其实要比较 Ruby 和 Node.js 的运行速度。Node.js 是一个 Javascrip t运行环境(Runtime)。实际上它是对 Google V8 引擎进行了封装。众所周知，Google JS Runtime 速度非常快，性能非常好。在本地预览上，Jekyll 是生成了页面然后进行预览，而 Hexo 是没有在根目录生成文件的，速度也快不少。因此，Hexo 在性能和速度上面更胜一筹。</p>
<p>·部署<br>Jeklly 是将整个工程源码上传到 Github 仓库，然后 Github 会自动生成静态文件。而 Hexo 需要事先在本地生成整个站点页面，再将 Html 文件、资源文件等上传到 Github 上。</p>
<p>·主题<br>Jekyll 使用 Liquid；它是有 Ruby 语言编写的开源模板语言。Hexo 使用的是 EJS；EJS 是 JavaScript 模板库，用来从 JSON 数据中生成 HTML 字符串。EJS 相对比较复杂，所以可实现的功能更加的多。从开发一个主题难度上看，Hexo 实现起来更方便、更简单些。</p>
<h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><p>1、本机系统：Windows 10（64位）<br>2、Node.js：v6.9.2LTS（64位）</p>
<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>简单的说 Node.js 就是运行在服务端的 JavaScript。Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I&#x2F;O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。<br>打开官网下载链接Node.js:<a href="https://nodejs.org/en/">https://nodejs.org/en/</a> (选择长期服务，版本更稳定)</p>
<p><img src="https://i.loli.net/2021/10/19/PWDijRHqgzxFbyn.jpg" alt="img"></p>
<p>下载完成之后直接双击安装包，只需点击下一步（默认所有选项），然后改变安装路径即可。</p>
<p>测试安装是否成功：</p>
<p>按【win+R】键，输入cmd，再按回车弹出命令窗口</p>
<p>输入：(显示版本行)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node -v </span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>

<p>显示结果：</p>
<p><img src="https://i.loli.net/2021/10/19/fDzgWhEbnkxPevL.jpg" alt="img"></p>
<p>即安装成功；</p>
<h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p>Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。 也是Linus Torvalds为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。</p>
<p><strong>从一般开发者的角度来看，git有以下功能：</strong><br>1、从服务器上克隆完整的Git仓库（包括代码和版本信息）到单机上。<br>2、在自己的机器上根据不同的开发目的，创建分支，修改代码。<br>3、在单机上自己创建的分支上提交代码。<br>4、在单机上合并分支。<br>5、把服务器上最新版的代码fetch下来，然后跟自己的主分支合并。<br>6、生成补丁（patch），把补丁发送给主开发者。</p>
<p>打开官网下载链接：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a> (选择windows版本即可)</p>
<p><img src="https://i.loli.net/2021/10/19/7UgXJ4y3MV6Bpri.jpg" alt="img"></p>
<p>下载完成之后直接双击安装包，只需点击下一步（出下图外选项，默认所有选项），然后改变安装路径即可。</p>
<p><img src="https://i.loli.net/2021/10/19/oT9CgyscVXWPnbF.jpg" alt="img"></p>
<p>测试是否安装成功：</p>
<p>按【win+R】键，输入cmd，再按回车弹出命令窗口，再输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git</span><br></pre></td></tr></table></figure>

<p>显示结果:</p>
<p><img src="https://i.loli.net/2021/10/19/y5LnHxaYiID93Cs.jpg" alt="img"></p>
<h2 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h2><h3 id="在Git安装目录中点击【git-bash-exe】-输入命令：（输入时引号不要删）"><a href="#在Git安装目录中点击【git-bash-exe】-输入命令：（输入时引号不要删）" class="headerlink" title="在Git安装目录中点击【git-bash.exe】,输入命令：（输入时引号不要删）"></a>在Git安装目录中点击【git-bash.exe】,输入命令：（输入时引号不要删）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;Github注册的邮箱&quot;</span><br></pre></td></tr></table></figure>

<p>然后按四次【enter】即可，生成后如下图：</p>
<p><img src="https://i.loli.net/2021/10/19/6S8LwDAmHTMvqJz.jpg" alt="img"></p>
<h3 id="打开Github-点击头像–-gt-【setting】"><a href="#打开Github-点击头像–-gt-【setting】" class="headerlink" title="打开Github,点击头像–&gt;【setting】"></a>打开Github,点击头像–&gt;【setting】</h3><p><img src="https://i.loli.net/2021/10/19/15flbemyaNIu4MU.jpg" alt="img"></p>
<h3 id="点击【SSH-and-GPG-keys】–-gt-【New-SSH-key】"><a href="#点击【SSH-and-GPG-keys】–-gt-【New-SSH-key】" class="headerlink" title="点击【SSH and GPG keys】–&gt;【New SSH key】"></a>点击【SSH and GPG keys】–&gt;【New SSH key】</h3><p><img src="https://i.loli.net/2021/10/19/JNnuwh4dAMHFILT.jpg" alt="img"></p>
<h3 id="输入title（可以随便输），但Key你需要用记事本或Notepad-打开磁盘中c-x2F-用户-x2F-用户名-x2F-ssh-x2F-id-rsa-pub然后复制粘贴里面的内容到key中，最后点击【ADD-SSH-key】；"><a href="#输入title（可以随便输），但Key你需要用记事本或Notepad-打开磁盘中c-x2F-用户-x2F-用户名-x2F-ssh-x2F-id-rsa-pub然后复制粘贴里面的内容到key中，最后点击【ADD-SSH-key】；" class="headerlink" title="输入title（可以随便输），但Key你需要用记事本或Notepad++打开磁盘中c:&#x2F;用户&#x2F;用户名&#x2F;.ssh&#x2F;id_rsa.pub然后复制粘贴里面的内容到key中，最后点击【ADD SSH key】；"></a>输入title（可以随便输），但Key你需要用记事本或Notepad++打开<strong>磁盘中c:&#x2F;用户&#x2F;用户名&#x2F;.ssh&#x2F;id_rsa.pub</strong>然后复制粘贴里面的内容到key中，最后点击【ADD SSH key】；</h3><p><img src="https://i.loli.net/2021/10/19/uglR7p4jMUSbfxe.jpg" alt="img"></p>
<h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>在想要搭建博客的目录下创建文件夹名为blog，按【win+R】键，输入cmd，再按回车弹出命令窗口，cd到创建的文件夹下，输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/19/pwBHNlgo2cdZiA4.jpg" alt="img"></p>
<p>不要关闭刚才的命令窗口，在刚才的窗口中初始化hexo，输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init 你的博客名</span><br></pre></td></tr></table></figure>

<h3 id="在博客目录中安装依赖"><a href="#在博客目录中安装依赖" class="headerlink" title="在博客目录中安装依赖"></a>在博客目录中安装依赖</h3><p>在刚才的窗口中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd 博客名</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>安装完成之后进行测试，窗口中输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s -p 5555</span><br></pre></td></tr></table></figure>

<p>在浏览器上输入 localhost:5555</p>
<p><img src="https://i.loli.net/2021/10/19/KFMBiULjA1yY8st.jpg" alt="img"></p>
<h3 id="安装Sublime-Text"><a href="#安装Sublime-Text" class="headerlink" title="安装Sublime Text"></a>安装Sublime Text</h3><p>打开官网下载链接：<a href="https://www.sublimetext.com/">https://www.sublimetext.com/</a> （点击DPWNLOAD FOR WINDOWS）</p>
<p><img src="https://i.loli.net/2021/10/19/kAnXiPatsr2zxDc.jpg" alt="img"></p>
<p>下载完成之后直接双击安装包，只需点击下一步（默认所有选项），然后改变安装路径即可。</p>
<p>打开Sublime 直接将博客目录拖进Sublime即可；</p>
<p><img src="https://i.loli.net/2021/10/19/RMkyeoixVCAt81f.jpg" alt="img"></p>
<h3 id="hexo发布到Github"><a href="#hexo发布到Github" class="headerlink" title="hexo发布到Github"></a>hexo发布到Github</h3><p>使用Sublime打开博客根目录中_config.yml 修改第16行的url 改为自己的网址（如 https:&#x2F;&#x2F;自己的博客名.github.io ）</p>
<p><img src="https://i.loli.net/2021/10/20/QHMrJse8xOnjWl5.jpg" alt="img"></p>
<p>打开Github网页点击【Your repositories】 最后复制链接</p>
<p><img src="https://i.loli.net/2021/10/20/u1w8kDULWQBvGzs.jpg" alt="img"><img src="https://i.loli.net/2021/10/20/6cGuVNTXKWFSZsw.jpg" alt="img"><img src="https://i.loli.net/2021/10/20/Sn8IUm5Tsq6dDcg.jpg" alt="img"></p>
<p>在_config.yml文件最后一行添加repo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repo: </span><br></pre></td></tr></table></figure>

<p>将你复制的链接添加到repo之后，用引号隔开（切记引号后面必须要有空格）</p>
<p>在最后一行添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">branch: main</span><br></pre></td></tr></table></figure>

<p>type后添加git</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type: git</span><br></pre></td></tr></table></figure>

<p>如下图<br><img src="https://i.loli.net/2021/10/21/b4Px7pFjTvI5ea2.jpg" alt="img"></p>
<p>在博客根目录下添加插件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<h3 id="获取个人访问令牌"><a href="#获取个人访问令牌" class="headerlink" title="获取个人访问令牌"></a>获取个人访问令牌</h3><p>对密码身份验证的支持已于 2021 年 8 月 13 日移除。现在改用个人访问令牌。简单点说就是需要把你的密码换成 token。</p>
<p>在个人设置页面，找到 Settings<br><img src="https://i.loli.net/2021/10/19/15flbemyaNIu4MU.jpg" alt="img"><br>找到 Developer settings<br><img src="https://i.loli.net/2021/10/21/VkyOgL5Z1746mzT.jpg" alt="img"><br>选择个人访问令牌 Personal access tokens，然后点击生成令牌 Generate new token<br><img src="https://i.loli.net/2021/10/21/KsVtaRpmhUSLorF.jpg" alt="img"><br>设置 token 的有效期，访问权限等，生成令牌 Generate token<br><img src="https://i.loli.net/2021/10/21/6Kdwmi7Qr2MWUJf.jpg" alt="img"><br>如下为生成的令牌<br><img src="https://i.loli.net/2021/10/21/LMsRWZaq8oSUwnh.jpg" alt="img"></p>
<p>注意<br>记得把 token 保存下来，当你再次刷新网页的时候，就没办法看见了</p>
<p>最后，把 token 直接添加远程仓库链接中，这样就可以避免同一个仓库每次提交代码都要输入 token 了。</p>
<p>添加到如下图位置：（使用“@”和后面内容隔开）</p>
<p><img src="https://i.loli.net/2021/10/21/WCX7dgp9UNFxJ1B.jpg" alt="img"></p>
<h3 id="git中设置你的用户名和邮件名"><a href="#git中设置你的用户名和邮件名" class="headerlink" title="git中设置你的用户名和邮件名"></a>git中设置你的用户名和邮件名</h3><p>这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;you@example.com&quot;</span><br></pre></td></tr></table></figure>



<h3 id="生成提交"><a href="#生成提交" class="headerlink" title="生成提交"></a>生成提交</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>打开你的浏览器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://博客名.github.io</span><br></pre></td></tr></table></figure>

<p>恭喜您，您的博客现在已制作完成，现在只需要添加你喜欢的主题既可以开始你的博客之旅了。</p>
<h3 id="添加主题"><a href="#添加主题" class="headerlink" title="添加主题"></a>添加主题</h3><p>hexo主题网站：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a><br><img src="https://i.loli.net/2021/10/21/AhUeqK8sB53jp4k.jpg" alt="img"></p>
<p>找到你喜欢的主题，例如next主题 点击【next】<br><img src="https://i.loli.net/2021/10/21/ciqEGsyQ3l9Oorp.jpg" alt="img"></p>
<p>按照文件中所说下载和修改即可<br><img src="https://i.loli.net/2021/10/21/b16RkjZFNDQAEic.jpg" alt="img"></p>
<p>在博客根目录中打开【Git Bash Here】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-themes-next</span><br></pre></td></tr></table></figure>

<p>安装完成后，打开 Hexo 配置文件(_config.yml)并将theme变量设置为next.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<h3 id="现在来介绍常用的Hexo-命令"><a href="#现在来介绍常用的Hexo-命令" class="headerlink" title="现在来介绍常用的Hexo 命令"></a>现在来介绍常用的Hexo 命令</h3><p>npm install hexo -g #安装Hexo<br>npm update hexo -g #升级<br>hexo init #初始化博客</p>
<p>命令简写<br>hexo n “我的博客” &#x3D;&#x3D; hexo new “我的博客” #新建文章<br>hexo g &#x3D;&#x3D; hexo generate #生成<br>hexo s &#x3D;&#x3D; hexo server #启动服务预览<br>hexo d &#x3D;&#x3D; hexo deploy #部署</p>
<p>hexo server #Hexo会监视文件变动并自动更新，无须重启服务器<br>hexo server -s #静态模式<br>hexo server -p 5000 #更改端口<br>hexo server -i 192.168.1.1 #自定义 IP<br>hexo clean #清除缓存，若是网页正常情况下可以忽略这条命令</p>
]]></content>
  </entry>
  <entry>
    <title>Jquery基础知识点</title>
    <url>/2022/07/08/Jquery%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.taodabai.com%2Fupload%2Fb6%2F47%2Fb647ba5763db7cdb66603673771da718.jpg&refer=http%3A%2F%2Fimg.taodabai.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1659875204&t=eb5f718fab6f53be30c47dd30429dfac" alt="img"></p>
<span id="more"></span>

<h1 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h1><h2 id="JQuery定义"><a href="#JQuery定义" class="headerlink" title="JQuery定义"></a>JQuery定义</h2><p>它是JavaScript的封装，它可以说是开源的JavaScript的函数库<br>使用它简化了JavaScript开发</p>
<h2 id="JQuery的下载及引用"><a href="#JQuery的下载及引用" class="headerlink" title="JQuery的下载及引用"></a>JQuery的下载及引用</h2><p>下载：<a href="https://jquery.com/download/">https://jquery.com/download/</a><br>下载好之后需要通过script标签引用，切记其位置必须是其它JavaScript代码之上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;jquery-3.6.0.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="comment">//调用Jquery代码</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>JQuery与JavaScript比较</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">html<span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;jquery-3.6.0.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   $(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//使用has方法</span></span></span><br><span class="line"><span class="language-javascript">   $(<span class="string">&quot;div&quot;</span>).<span class="title function_">has</span>(<span class="string">&quot;#demo&quot;</span>).<span class="title function_">css</span>(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">   &#125;)</span></span><br><span class="line"><span class="language-javascript">   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>eq(索引)，表示选取指定索引的元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;jquery-3.6.0.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   $(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">   $(<span class="string">&quot;div&quot;</span>).<span class="title function_">eq</span>(<span class="number">0</span>).<span class="title function_">children</span>().<span class="title function_">css</span>(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">   &#125;)</span></span><br><span class="line"><span class="language-javascript">   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;这是第一个div里面的input&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;这是第二个div里面的input&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="选择转移"><a href="#选择转移" class="headerlink" title="选择转移"></a>选择转移</h2><p>我们可以以一个元素为参照，找到其它元素（节点选择）</p>
<p>详细如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#box&#x27;</span>).<span class="title function_">prev</span>(); 表示选择id是box元素的兄弟节点</span><br><span class="line">$(<span class="string">&#x27;#box&#x27;</span>).<span class="title function_">prevAll</span>(); 表示选择id是box元素的上面所有的同级元素</span><br><span class="line">$(<span class="string">&#x27;#box&#x27;</span>).<span class="title function_">next</span>(); 表示选择id是box元素的兄弟节点</span><br><span class="line">$(<span class="string">&#x27;#box&#x27;</span>).<span class="title function_">nextAll</span>(); 表示选择id是box元素的下面所有的同级元素</span><br><span class="line">$(<span class="string">&#x27;#box&#x27;</span>).<span class="title function_">parent</span>(); 表示选择id是box元素的父元素</span><br><span class="line">$(<span class="string">&#x27;#box&#x27;</span>).<span class="title function_">children</span>(); 表示选择id是box元素的所有子元素</span><br><span class="line">$(<span class="string">&#x27;#box&#x27;</span>).<span class="title function_">siblings</span>(); 表示选择id是box元素的其它同级元素</span><br><span class="line">$(<span class="string">&#x27;#box&#x27;</span>).<span class="title function_">find</span>(<span class="string">&#x27;.myClass&#x27;</span>); 表示选择id是box元素的<span class="keyword">class</span>等于myClass的元素</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;jquery-3.6.0.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">     $(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="comment">//确定参照节点</span></span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">var</span> $div = $(<span class="string">&quot;#demo&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">     $div.<span class="title function_">prev</span>().<span class="title function_">css</span>(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">     $div.<span class="title function_">prevAll</span>().<span class="title function_">css</span>(<span class="string">&quot;font-size&quot;</span>,<span class="number">33</span>);</span></span><br><span class="line"><span class="language-javascript">     $div.<span class="title function_">next</span>().<span class="title function_">css</span>(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;blue&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">     $div.<span class="title function_">nextAll</span>().<span class="title function_">css</span>(<span class="string">&quot;background&quot;</span>,<span class="string">&quot;gray&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">     $div.<span class="title function_">parent</span>().<span class="title function_">css</span>(<span class="string">&quot;background&quot;</span>,<span class="string">&quot;#ff6700&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">     $div.<span class="title function_">children</span>().<span class="title function_">css</span>(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;gold&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">     &#125;)</span></span><br><span class="line"><span class="language-javascript">   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span>这是一个div</span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>这是div里面的span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h3</span>&gt;</span>这又是一个标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>这是一个a标签<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="html方法的使用"><a href="#html方法的使用" class="headerlink" title="html方法的使用"></a>html方法的使用</h2><p>在jquery中可以通过html属性为元素设置html内容</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;jquery-3.6.0.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">     $(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">var</span> $div = $(<span class="string">&quot;#demo&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">     <span class="comment">//如果要获取内容</span></span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">var</span> rs = $div.<span class="title function_">html</span>();</span></span><br><span class="line"><span class="language-javascript">     <span class="title function_">alert</span>(rs)</span></span><br><span class="line"><span class="language-javascript">     $div.<span class="title function_">html</span>(<span class="string">&quot;&lt;span style=&#x27;color: red&#x27;&gt;哈嘿~~~~&lt;/span&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">     <span class="comment">//在元素后追加内容</span></span></span><br><span class="line"><span class="language-javascript">     $div.<span class="title function_">append</span>(<span class="string">&quot;&lt;span style=&#x27;color: red&#x27;&gt;大宝贝&lt;/span&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">     &#125;)</span></span><br><span class="line"><span class="language-javascript">   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="获取和设置元素的属性"><a href="#获取和设置元素的属性" class="headerlink" title="获取和设置元素的属性"></a>获取和设置元素的属性</h2><p>prop方法：css方法可以设置元素的样式属性，而该方法可以设置元素的其它属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;jquery-3.6.0.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">     $(function () &#123;</span><br><span class="line">     var $a = $(&quot;#aId&quot;);</span><br><span class="line">     var $input = $(&quot;#InputId&quot;);</span><br><span class="line">     //可以获取</span><br><span class="line">     var Sa = $a.prop(&quot;id&quot;);</span><br><span class="line">     // alert(Sa);</span><br><span class="line">     //设置元素属性</span><br><span class="line">     $a.prop(&#123;&quot;href&quot;:&quot;http://www.baidu.com&quot;,&quot;class&quot;:&quot;aClass&quot;,&quot;title&quot;:&quot;这是</span><br><span class="line">    标题&quot;&#125;);</span><br><span class="line">     //获取input中的属性value使用的是val()方法</span><br><span class="line">     // var Sinput = $input.prop(&quot;value&quot;);</span><br><span class="line">     // alert(Sinput);</span><br><span class="line">     var Sinput = $input.val();</span><br><span class="line">     alert(Sinput);</span><br><span class="line">     //设置value值</span><br><span class="line">     $input.val(&quot;12313212&quot;);</span><br><span class="line">     &#125;)</span><br><span class="line"> <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;aId&quot;</span>&gt;</span>这是a标签<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;InputId&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;InputId&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JQuery事件"><a href="#JQuery事件" class="headerlink" title="JQuery事件"></a>JQuery事件</h2><p>常用事件</p>
<ul>
<li><p>click() 鼠标点击事件</p>
</li>
<li><p>blur() 离焦事件</p>
</li>
<li><p>focus() 聚焦事件</p>
</li>
<li><p>mouseover() 鼠标进入事件</p>
</li>
<li><p>mouseout() 鼠标离开事件</p>
</li>
<li><p>ready() DOM加载完毕触发</p>
</li>
<li><p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line"> &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line"> &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line"> &lt;script src=&quot;jquery-3.6.0.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">     $(function () &#123;</span><br><span class="line">     var $li = $(&quot;.list li&quot;);</span><br><span class="line">     var $input = $(&quot;#in_one&quot;);</span><br><span class="line">     var $btn = $(&quot;#btn&quot;);</span><br><span class="line">     var $div = $(&quot;#demo&quot;);</span><br><span class="line">     //点击事件</span><br><span class="line">     $li.click(function () &#123;</span><br><span class="line">     $(this).css(&#123;&quot;background&quot;:&quot;red&quot;&#125;);</span><br><span class="line">     //index()方法可以获取当前元素的索引值</span><br><span class="line">     //alert($(this).index())</span><br><span class="line">     &#125;);</span><br><span class="line">     //获取焦点</span><br><span class="line">     $input.focus(function () &#123;</span><br><span class="line">    • JQuery事件</span><br><span class="line">     分区 新分区 1 的第 7 页 </span><br><span class="line">     $input.focus(function () &#123;</span><br><span class="line">     $(this).val(&quot;嗨嗨嘿&quot;);</span><br><span class="line">     &#125;)</span><br><span class="line"> &#125;)</span><br><span class="line"> &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">   &lt;div id=&quot;demo&quot;&gt;</span><br><span class="line">   &lt;ul class=&quot;list&quot;&gt;</span><br><span class="line">     &lt;li&gt;这是一行字&lt;/li&gt;</span><br><span class="line">     &lt;li&gt;这是一行字&lt;/li&gt;</span><br><span class="line">     &lt;li&gt;这是一行字&lt;/li&gt;</span><br><span class="line">     &lt;li&gt;这是一行字&lt;/li&gt;</span><br><span class="line">   &lt;/ul&gt;</span><br><span class="line">     &lt;input type=&quot;text&quot; id=&quot;in_one&quot;/&gt;</span><br><span class="line">     &lt;input type=&quot;submit&quot; id=&quot;btn&quot; value=&quot;点一下&quot;/&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>html基础（一）</title>
    <url>/2022/07/08/html%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.iisp.com%2Fimage%2F20161011%2F20161011180825_78244.jpg&refer=http%3A%2F%2Fimg.iisp.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1659877024&t=24bae5fadeb346539de3c527885be3df" alt="img"></p>
<span id="more"></span>

<h1 id="HTML基础"><a href="#HTML基础" class="headerlink" title="HTML基础"></a>HTML基础</h1><h2 id="HTML简介"><a href="#HTML简介" class="headerlink" title="HTML简介"></a>HTML简介</h2><p>​     HTML的英文全称是 Hyper Text Markup Language，即超文本标记语言。HTML是由Web的发明者 Tim Berners-Lee和同事 Daniel W. Connolly于1990年创立的一种标记语言，它是标准通用化标记语言SGML的应用。用HTML编写的超文本文档称为HTML文档，它能独立于各种操作系统平台(如UNIX， Windows等)。使用HTML，将所需要表达的信息按某种规则写成HTML文件，通过专用的浏览器来识别，并将这些HTML文件“翻译”成可以识别的信息，即现在所见到的网页。<br>     自1990年以来，HTML就一直被用作万维网的信息表示语言，使用HTML描述的文件需要通过web浏览器显示出效果。HTML是一种建立网页文件的语言，通过标记式的指令(Tag)，将影像、声音、图片、文字动画、影视等内容显示出来。事实上，每一个HTML文档都是一种静态的网页文件，这个文件里面包含了HTML指令代码，这些指令代码并不是一种程序语言，只是一种排版网页中资料显示位置的标记结构语言，易学易懂，非常简单。HTML的普遍应用就是带来了超文本的技术―通过单击鼠标从一个主题跳转到另一个主题，从一个页面跳转到另一个页面，与世界各地主机的文件链接超文本传输协议规定了浏览器在运行HTML文档时所遵循的规则和进行的操作。HTTP的制定使浏览器在运行超文本时有了统一的规则和标准。<br>      <a href="https://baike.baidu.com/item/%E4%B8%87%E7%BB%B4%E7%BD%91"> 万维网</a>（world wide web，简称www）上的一个<a href="https://baike.baidu.com/item/%E8%B6%85%E5%AA%92%E4%BD%93/1750647">超媒体</a>文档称之为一个<a href="https://baike.baidu.com/item/%E9%A1%B5%E9%9D%A2">页面</a>（<a href="https://baike.baidu.com/item/%E5%A4%96%E8%AF%AD">外语</a>：page）。作为一个组织或者个人在<a href="https://baike.baidu.com/item/%E4%B8%87%E7%BB%B4%E7%BD%91/215515">万维网</a>上放置开始点的页面称为<a href="https://baike.baidu.com/item/%E4%B8%BB%E9%A1%B5">主页</a>（外语：Homepage）或首页，主页中通常包括有指向其他相关页面或其他节点的<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88">指针</a>（<a href="https://baike.baidu.com/item/%E8%B6%85%E7%BA%A7%E9%93%BE%E6%8E%A5">超级链接</a>），所谓超级链接，就是一种<a href="https://baike.baidu.com/item/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E5%99%A8">统一资源定位器</a>（Uniform Resource Locator，<a href="https://baike.baidu.com/item/%E5%A4%96%E8%AF%AD">外语</a><a href="https://baike.baidu.com/item/%E7%BC%A9%E5%86%99">缩写</a>：<a href="https://baike.baidu.com/item/URL">URL</a>）指针，通过激活（点击）它，可使<a href="https://baike.baidu.com/item/%E6%B5%8F%E8%A7%88%E5%99%A8">浏览器</a>方便地获取新的网页。这也是HTML获得广泛应用的最重要的原因之一。在逻辑上将视为一个整体的一系列<a href="https://baike.baidu.com/item/%E9%A1%B5%E9%9D%A2">页面</a>的有机集合称为<a href="https://baike.baidu.com/item/%E7%BD%91%E7%AB%99">网站</a>（<a href="https://baike.baidu.com/item/Website">Website</a>或<a href="https://baike.baidu.com/item/Site/10831143">Site</a>）。超文本标记语言（英文缩写：HTML）是为“<a href="https://baike.baidu.com/item/%E7%BD%91%E9%A1%B5">网页</a>创建和其它可在<a href="https://baike.baidu.com/item/%E7%BD%91%E9%A1%B5%E6%B5%8F%E8%A7%88%E5%99%A8">网页浏览器</a>中看到的信息”设计的一种<a href="https://baike.baidu.com/item/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80">标记语言</a>。<br>     网页的本质就是超文本<a href="https://baike.baidu.com/item/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/5964436">标记语言</a>，通过结合使用其他的<a href="https://baike.baidu.com/item/Web%E6%8A%80%E6%9C%AF">Web技术</a>（如：<a href="https://baike.baidu.com/item/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80">脚本语言</a>、<a href="https://baike.baidu.com/item/%E5%85%AC%E5%85%B1%E7%BD%91%E5%85%B3%E6%8E%A5%E5%8F%A3">公共网关接口</a>、<a href="https://baike.baidu.com/item/%E7%BB%84%E4%BB%B6">组件</a>等），可以创造出功能强大的网页。因而，超文本标记语言是万维网（<a href="https://baike.baidu.com/item/Web">Web</a>）编程的基础，也就是说万维网是建立在超文本基础之上的。超文本标记语言之所以称为超文本标记语言，是因为文本中包含了所谓“超级链接”点。</p>
<h2 id="HTML版本"><a href="#HTML版本" class="headerlink" title="HTML版本"></a>HTML版本</h2><p>​        HTML是用来标记Web信息如何展示以及其他特性的一种语法规则，它最初于1989年由CERN的Tim Berners-Lee发明。HTML基于更古老一些的语言SGML定义，并简化了其中的语言元素。这些元素用于告诉浏览器如何在用户的屏幕上展示数据，所以很早就得到各个Web浏览器厂商的支持。 [5]<br>HTML历史上有如下版本： [5]<br>①HTML 1.0：在1993年6月作为互联网工程工作小组(IETF)工作草案发布。<br>②HTML 2.0：1995年1 1月作为RFC 1866发布，于2000年6月发布之后被宣布已经过时。<br>③HTML 3.2：1997年1月14日，W3C推荐标准。<br>④HTML 4.0：1997年12月18日，W3C推荐标准。<br>⑤HTML 4.01（微小改进）：1999年12月24日，W3C推荐标准。<br>⑥<a href="https://baike.baidu.com/item/HTML%205/8762673">HTML 5</a>：HTML5是公认的下一代Web语言，极大地提升了Web在富媒体、富内容和富应用等方面的能力，被喻为终将改变移动互联网的重要推手。Internet Explorer 8及以前的版本不支持。</p>
<h2 id="迎接新的Web时代"><a href="#迎接新的Web时代" class="headerlink" title="迎接新的Web时代"></a>迎接新的Web时代</h2><p>​        HTML5并不是革命性的改变，而只是发展性的。而且对于之前HTML4的很多标准都是兼容的，所有通过最新HTML5标准制作的Web应用也可以轻松的在老版本的浏览器上运行。HTML5标准中的确是集成了很多实用的功能比如：音视频、本地存储、Socket通信、动画等都是之前应用开发中确实感觉到Web端的鸡肋才得到重视和升级的。<br>       HTML5的目标是：它通过一些新标签，新功能为开发更加简、独立、标准的通用Web应用提供了标准。新的标准解决了三大问题：浏览器兼容问题，解决了文档结构不明确的问题，解决了Web应用程序功能受限等问题。<br>号称“CSS之父”的Hakon Wium Lie认为，HTML5与CSS3将是全球互联网发展的未来趋势。<br>自从2010年HTML5正式推出以来，它就以一种惊人的速度被迅速推广使用，微软也因此在IE上做了关于HTML5的标准改进，使其能够支持HTML5，google Chrome，Safari，Opera，Mozilla等主要Web浏览器也针对HTML5制定了相应的支持措施。<br>     目前主流的浏览器厂商也纷纷在研发HTML5相关产品，从目前这些浏览器对HTML5的支持来看，Web的未来属于HTML5</p>
<h2 id="HTML的开发环境和运行环境"><a href="#HTML的开发环境和运行环境" class="headerlink" title="HTML的开发环境和运行环境"></a>HTML的开发环境和运行环境</h2><p>​        HTML本质上就是一个文档，市面上常见的一些简单的文本编辑器都是可以用来开发HTML，编辑之后只需将后缀修改为”.html”即可 如：记事本，EditPlus等<br>前端开发也有众多专业的开发软件，如：Webstrom，Sublime Text，Dreamweaver，HBuilder等，本书主要以  webstrom为主要开发软件<br>        HTML运行环境即各种浏览器，如:IE，edge，Chrome，Firefox，Safari等均可作为HTML的运行环境</p>
<h2 id="HTML文档结构"><a href="#HTML文档结构" class="headerlink" title="HTML文档结构"></a>HTML文档结构</h2><p>​    HTML文档有明确的文档结构，包含三个部分：&lt;HTML&gt;中包含&lt;head&gt;…&lt;&#x2F;head&gt;部分和&lt;body&gt;…&lt;&#x2F;body&gt;部分</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注：</p>
<ol>
<li><p>第1行，HTML5的文档声明，声明开发版本</p>
</li>
<li><p>第2行，&lt;html&gt;表示HTML的文档起点，”lang&#x3D;en”表示开发语言为英语，与之对应的在文档的最后一行&lt;&#x2F;html&gt;表示文档的结束位置</p>
</li>
<li><p>第3，6行，表示文档的头部信息，该部分中的内容不在浏览器的主体中显示，文档头部中主要用来做一些辅助功能。</p>
</li>
<li><p>第4行，&lt;meta&gt;是&lt;head&gt;中的一个辅助性标签，不包含任何内容，它的属性定义了与文档相关联的名称&#x2F;值，它提供了相关页面的元信息如：针对搜索引擎和更新频度的描述和关键词， 详见下节&lt;meta&gt;标签</p>
</li>
<li><p>第5行，&lt;title&gt;用来添加网页的标题，网页标题显示在浏览器的标题栏中</p>
<p>​</p>
</li>
</ol>
<h2 id="lt-meta-gt-标签"><a href="#lt-meta-gt-标签" class="headerlink" title="&lt;meta&gt;标签"></a>&lt;meta&gt;标签</h2><ul>
<li>&lt;meta&gt;标签位于&lt;head&gt;标签区域内提供了HTML的文档元数据（注：元数据是数据的数据信息且元数据不会显示在客户端，但是会被浏览器解析）</li>
<li>&lt;meta&gt;标签提供了文档的字符集，使用语言，作者等基本信息，此外还涉及关键词和网页等级设定</li>
<li>&lt;meta&gt;标签常用属性表</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://baike.baidu.com/item/charset">charset</a></td>
<td><em>character_set</em></td>
<td>定义文档的字符编码。</td>
</tr>
<tr>
<td><a href="https://baike.baidu.com/item/content">content</a></td>
<td><em>text</em></td>
<td>定义与 http-equiv 或 name 属性相关的元信息。</td>
</tr>
<tr>
<td>http-equiv</td>
<td>content-typedefault-stylerefresh</td>
<td>把 content 属性关联到 HTTP 头部。</td>
</tr>
<tr>
<td>name</td>
<td>application-nameauthordescriptiongeneratorkeywords</td>
<td>把 content 属性关联到一个名称。</td>
</tr>
<tr>
<td><a href="https://baike.baidu.com/item/scheme/8379129">scheme</a></td>
<td><em>format&#x2F;URI</em></td>
<td>HTML5不支持。定义用于翻译 content 属性值的格式。</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--声明文档的字符编码，中文常用的还有GBK，gb2312--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--页面关键词--&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;软件咨询，软件开发，影视后期&quot;</span>/&gt;</span></span><br><span class="line">　　<span class="comment">&lt;!--页面描述--&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;软件开发，影视后期，我们可以快速的帮你提升职业技能水平&quot;</span>&gt;</span></span><br><span class="line">　　<span class="comment">&lt;!--网页作者--&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Mr.cai&quot;</span>&gt;</span></span><br><span class="line">　　<span class="comment">&lt;!--搜索引擎抓取robots是一组使用逗号（，）分割的值，通常有如下几种取值：none，noindex，nofollow，all，index和follow。--&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;noindex&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--上面示例定义了此网页不被搜索引擎索引进数据库，但搜索引擎可以通过此网页的链接继续索引其它网页--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;nofollow&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--上面示例定义此网页被搜索引擎索引进数据库，但搜索引擎不可以通过此网页的链接继续索引其它网页--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;none&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--上面示例定义了此网页不被搜索引擎索引进数据库，且搜索引擎不可以通过此网页的链接继续索引其它网页--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--针对谷歌GOOGLEBOT使用robots--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--可以将name的属性只定义为GOOGLEBOT标识为谷歌搜索引擎。 使用元标记拦截或删除网页--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;googlebot&quot;</span> <span class="attr">content</span>=<span class="string">&quot;noindex, nofollow&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--针对百度baiduspider使用robots--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--可以将name的属性只定义为baiduspider标识为百度搜索引擎。禁止搜索引擎收录的方法--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;baiduspider&quot;</span> <span class="attr">content</span>=<span class="string">&quot;noarchive&quot;</span>/&gt;</span></span><br><span class="line">　　<span class="comment">&lt;!--页面重定向和刷新--&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;0;url=http://www.baidu.com&quot;</span>/&gt;</span></span><br><span class="line">　　<span class="comment">&lt;!--禁止Chrome浏览器中自动提示翻译--&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;google&quot;</span> <span class="attr">value</span>=<span class="string">&quot;notranslate&quot;</span>&gt;</span></span><br><span class="line">　　<span class="comment">&lt;!--禁止百度转码--&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Cache-Control&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-siteapp&quot;</span>&gt;</span></span><br><span class="line">　　<span class="comment">&lt;!--自定义标签：app版本号说明--&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;app-version&quot;</span><span class="attr">content</span>=<span class="string">&quot;1.13.3&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>meta<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h2><p>HTML文档由HTML元素定义，一个基本元素由“开始标签”，“元素内容”，“结束标签”构成</p>
<table>
<thead>
<tr>
<th>&lt;开始标签&gt;</th>
<th>元素内容</th>
<th>&lt;&#x2F;结束标签&gt;</th>
</tr>
</thead>
<tbody><tr>
<td>HTML元素以开始标签起始</td>
<td>元素内容即开始标签和结束标签之间的内容</td>
<td>HTML元素以结束标签终结</td>
</tr>
</tbody></table>
<h2 id="块级标签和行级标签"><a href="#块级标签和行级标签" class="headerlink" title="块级标签和行级标签"></a>块级标签和行级标签</h2><p>HTML中，所有标签都是预定义的，也就是说所有的标签都有各自的特点属性，根据这些特点可将标签分为块级标签和行级标签两类</p>
<h4 id="块级标签"><a href="#块级标签" class="headerlink" title="块级标签"></a>块级标签</h4><p>块级标签编译后在浏览器中默认没有高度，其高度由其添加的内容决定，其宽度默认为屏幕宽度，也就是说块级标签默认占一行</p>
<h4 id="行级标签"><a href="#行级标签" class="headerlink" title="行级标签"></a>行级标签</h4><p>行级标签编译后在浏览器中默认没有宽度和高度，其宽高均有添加的内容决定，也就是说行级标签在其内容不满一行时不会换行</p>
<h2 id="HTML常用标签"><a href="#HTML常用标签" class="headerlink" title="HTML常用标签"></a>HTML常用标签</h2><h4 id="常用的块级标签"><a href="#常用的块级标签" class="headerlink" title="常用的块级标签"></a>常用的块级标签</h4><ul>
<li><p>标题标签</p>
</li>
<li><ul>
<li>标题（Heading）通过&lt;h1&gt;….&lt;h6&gt;标签定义，表示一级标题至六级标题，其中&lt;h1&gt;最大，&lt;h6&gt;最小</li>
<li>标题标签只用于标题</li>
<li>标题标签不单单用于字体放大加粗，更多的是为搜索引擎使用标题帮助网页索引</li>
</ul>
</li>
<li><p>段落标签</p>
</li>
<li><ul>
<li>段落通过&lt;p&gt;…&lt;&#x2F;p&gt;标签定义，表示文档中的一个自然段</li>
<li>注：段落标签不能嵌套使用，若想要段落标签中的内容换行显示可使用<br/>标签换行</li>
</ul>
</li>
<li><p>div标签</p>
</li>
<li><ul>
<li><p>div标签用于定义文档中的分区或节</p>
</li>
<li><p>可以把文档分割为独立的，不同的部分</p>
</li>
<li><p>在后期通过学习样式表，div可以与CSS配合对整个网页进行页面布局，模块划分，让网页制作不再有难度</p>
</li>
<li><p>div若不带样式单独使用则与段落标签<p>相似，没有特定的含义</p>
<p>​</p>
</li>
</ul>
</li>
<li><p>无序列表</p>
</li>
<li><ul>
<li>列表可以结合链接标签用来定义新闻标题等一些较为常用的标题类链接</li>
<li>无序列表使用<ul>定义列表，<li>定义列表中的条目，默认此列项目使用黑色小圆点进行标记</li>
<li>通过在<ul>中添加type属性更改列表的展示标记，其中disc表示实心圆，square表示矩形显示，circle表示空心圆</li>
</ul>
</li>
<li><p>有序列表</p>
</li>
<li><ul>
<li>有序列表使用<ol>定义列表，<li>定义列表中的条目，默认此列项目使用阿拉伯数字进行标记</li>
<li>通过在<ol>中添加type属性更改列表的展示标记，其中‘A’表示大写字母，‘a’表示小写字母，‘I’表示大写罗马数字，‘i’表示小写罗马数字，‘1’表示阿拉伯数字（默认）</li>
</ul>
</li>
<li><p>自定义列表</p>
</li>
<li><ul>
<li>使用<dl>定义列表，<dt>定义列表中的项目，<dd>定义列表条目</li>
<li>自定义列表不单单只用了区分项目，后期通过样式，标签嵌套可以胜任诸多任务，如：商城，外卖类网站商品的模块划分</li>
</ul>
</li>
</ul>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>自定义列表<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dt</span>&gt;</span>pc端游戏<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>穿越火线<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>英雄联盟<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CSGO<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dt</span>&gt;</span>手机游戏<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>和平精英<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>王者荣耀<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>阴阳师<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>嵌套列表</p>
</li>
<li><ul>
<li>列表可以通过多层嵌套实现多级列表</li>
</ul>
</li>
</ul>
<h4 id="常用的行级标签"><a href="#常用的行级标签" class="headerlink" title="常用的行级标签"></a>常用的行级标签</h4><ul>
<li><p>内联元素</p>
</li>
<li><ul>
<li>使用<span>…<span>表示</li>
<li>单独使用没有特定的含义</li>
<li>当与CSS一同使用，用来组合文档中的行内元素，如：在一行文字中给某一个字单独设置样式，再或者在某行字中添加小图标</li>
</ul>
</li>
<li><p>链接标签</p>
</li>
<li><ul>
<li>使用<a href="url">…</a>表示</li>
<li>用于从一个页面跳转到另一个页面</li>
<li>href表示跳转的链接目标</li>
<li>默认情况下链接将以以下形式出现在网页中</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>在未点击访问时链接字体程蓝色并带同色下划线</li>
<li>在点击后链接字体会程红色显示并带同色下划线</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>标签常用属性</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>属性值</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>download</td>
<td>filename</td>
<td>指定下载链接</td>
</tr>
<tr>
<td>href</td>
<td>URL</td>
<td>规定链接目标</td>
</tr>
<tr>
<td>target</td>
<td>_blank_parent_self_top</td>
<td>_blank：新窗口打开。_parent：在父窗口中打开链接。_self：默认，当前页面跳转。_top：在当前窗体打开链接，并替换当前的整个窗体(框架页)。</td>
</tr>
</tbody></table>
<ul>
<li><ul>
<li>在网页开发中常用的链接有以下四种：</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>链接分类</th>
<th>属性参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>空链接</td>
<td>href&#x3D;”#”href&#x3D;”javascript:void(0)”</td>
<td>空链接即只能点击不会做页面跳转的链接，用于向页面上添加对象或行为  如：设为首页，添加收藏等</td>
</tr>
<tr>
<td>本地链接</td>
<td>href&#x3D;”本地路径”</td>
<td>用于本地工程&#x2F;服务器页面之间的相互跳转</td>
</tr>
<tr>
<td>网络链接</td>
<td>herf&#x3D;”url”</td>
<td>用于给网站添加外部链接，点击后跳转到其它网站</td>
</tr>
<tr>
<td>锚链接</td>
<td>href&#x3D;”#name”</td>
<td>用于添加页面内快速引导，可以从页面的一个位置快速的转到另一个位置</td>
</tr>
</tbody></table>
<p>空链接“#”与“javascript:void(0)”的区别：</p>
<ol>
<li>“#”包含一个位置信息，默认为网页顶端，当页面高度大于一屏时，点击后会跳转到网页顶部</li>
<li>“javascript:void(0)”是一个伪协议，表示url内容通过javascript执行，而void(0)则表示不作任何操作，这样该标签既保留了链接样式还能防止页面跳转</li>
<li>空链接通常通过添加javascript事件去做一些其它操作，如：设置收藏，设置首页，弹窗等，这些会在本书javascript事件章节详细讲解</li>
</ol>
<p>绝对路径和相对路径</p>
<p>绝对路径：是指文件在硬盘上的真正存在的路径，如：一张名为“头像.jpg”的图片或一个名为“index.html”的网页存放在我计算机中的“C:\Users\document\WebstormProjects\untitled15”目录中，则图片的绝对路径为“C:\Users\document\WebstormProjects\untitled15\头像.jpg”，网页的绝对路径为“C:\Users\document\WebstormProjects\untitled15\index.html”，但在开发时很少使用绝对路径，当指定了决定路径后在项目路径在本地计算机上是没问题的，但上传到服务器或在其它计算机上时很可能会出现找不到路径，路径错误等问题。</p>
<p>相对路径：指由文件本身相对于目标文件的路径，使用相对路径的三种写法，下边以网页index.html引用网页Login.html为例说明：</p>
<p>1.若Login.html相对index.html是在同一目录，那么网页在引用图片时则只需要通过Login.html名称+后缀引用即可</p>
<table>
<thead>
<tr>
<th>位置关系图示</th>
<th>代码示例</th>
</tr>
</thead>
<tbody><tr>
<td><img src="https://cdn.nlark.com/yuque/0/2021/png/22038106/1626061269598-89399a32-cf28-42f3-beff-1c35ca4a7265.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_Qnl0ZeWtpumZog==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></td>
<td><img src="https://cdn.nlark.com/yuque/0/2021/png/22038106/1626061301889-949b6f4d-7725-47f2-85f0-dbf5806facd0.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_12,text_Qnl0ZeWtpumZog==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></td>
</tr>
</tbody></table>
<p>​             2.若网页Login.html存在某个文件夹中，文件夹与网页index.html属于同一目录，那么网页index.html在引用网页Login.html时则需要通过找到文件夹使用分隔符“&#x2F;”才能找到文件夹中相对的网页Login.html文件，这里需要注意：绝对路径使用分隔符“\”，相对路径使用分隔符“&#x2F;”</p>
<table>
<thead>
<tr>
<th>位置关系图示</th>
<th>代码示例</th>
</tr>
</thead>
<tbody><tr>
<td><img src="https://cdn.nlark.com/yuque/0/2021/png/22038106/1626061376948-03e21db6-7ff0-47a9-8211-aac16e6f9369.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_13,text_Qnl0ZeWtpumZog==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></td>
<td><img src="https://cdn.nlark.com/yuque/0/2021/png/22038106/1626061390608-6d2708e8-bee4-41a4-b85d-dbec01b0f42d.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_15,text_Qnl0ZeWtpumZog==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></td>
</tr>
</tbody></table>
<p>3.若网页index.html和网页Login.html都存在不同的文件夹中，两个不同的文件夹属于同一目录，那么网页index.html在引用网页Login.html时则需要通过“..&#x2F;”返回上一级路径再去引用存放网页Login.html的文件夹再使用分隔符“&#x2F;”引用网页Login.html，这里需要注意一个“..&#x2F;”，表示网上返回一级，如果要返回多个则需要使用多个“..&#x2F;”</p>
<p>网络链接示例代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>网络链接<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com&quot;</span>&gt;</span>百度一下<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>锚链接示例代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;top&quot;</span>&gt;</span>这是网页顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#middle&quot;</span>&gt;</span>跳转至网页中部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#bottom&quot;</span>&gt;</span>跳转至网页底部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>网页内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>....<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这里省略若干行相同内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;middle&quot;</span>&gt;</span>这是网页中部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#top&quot;</span>&gt;</span>跳转至网页顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#bottom&quot;</span>&gt;</span>跳转至网页底部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>网页内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>....<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这里省略若干行相同内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#middle&quot;</span>&gt;</span>跳转至网页中部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#top&quot;</span>&gt;</span>跳转至网页顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;bottom&quot;</span>&gt;</span>这是网页底部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>附：</p>
<ol>
<li>锚链接是在页面内的不同位置跳转，本质上就是元素间的跳转</li>
<li>使用锚链接首先要建立锚点目标，只需要给元素添加id或name属性即可 如：<a name="top">,<div id="top"></li>
<li>建立好锚点目标后再使用<a href="#id值或name值">引用锚点</li>
<li>如果不同页面跳转，同时存在锚点，则先跳转到要跳转的页面，然后在寻找锚点元素进行跳转</li>
</ol>
<ul>
<li><p>图片标签</p>
</li>
<li><ul>
<li>图片标签使用<img/>表示，图片标签没有结束标签“&#x2F;”表示结束</li>
<li>标签属性</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>属性值</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>src（必需）</td>
<td>url</td>
<td>图片路径或网络地址</td>
</tr>
<tr>
<td>title</td>
<td>text</td>
<td>图片标题描述，当鼠标悬停在图片上时显示</td>
</tr>
<tr>
<td>alt</td>
<td>text</td>
<td>图片替换文本，当图片路径发生错误时显示</td>
</tr>
<tr>
<td>width</td>
<td>pixels</td>
<td>图片宽度</td>
</tr>
<tr>
<td>height</td>
<td>pixels</td>
<td>图片高度</td>
</tr>
</tbody></table>
<ul>
<li><p>图片增强（map）</p>
</li>
<li><ul>
<li><code>&lt;map&gt;</code>标签有助于定义图像映射。图像映射指的是图像中包含一个或多个可点击区域。<code>&lt;map&gt;</code>标签与<code>&lt;area&gt;</code>标签一起确定可点击区域。可点击区域可以是矩形、圆形或多边形区域这些形状之一。如果不指定形状，就会认为是整个图像。</li>
</ul>
</li>
</ul>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;img src=&quot;../images/mapImages/4.png&quot; width=&quot;592&quot; height=&quot;182&quot; alt=&quot;mapSelect&quot; usemap=&quot;#circusmap&quot;&gt;</span><br><span class="line">        &lt;map name=&quot;circusmap&quot;&gt;</span><br><span class="line">            &lt;area shape=&quot;rect&quot; coords=&quot;82,70,155,133&quot; href=&quot;map2.html&quot;&gt;</span><br><span class="line">            &lt;area shape=&quot;rect&quot; coords=&quot;297,70,387, 133&quot; href=&quot;map1.html&quot;&gt;</span><br><span class="line">            &lt;area shape=&quot;rect&quot; coords=&quot;480,70,572, 133&quot; href=&quot;map3.html&quot;&gt;</span><br><span class="line">        &lt;/map&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>知识补充：</p>
<ul>
<li><ul>
<li><area>标签定义图像映射中的区域</li>
<li>shape属性</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>shape属性用于定义图像映射中对鼠标敏感的区域的形状</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>圆形（circ或circle）</li>
<li>多边形（poly或polygon）</li>
<li>矩形（rect或rectangle）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>coords属性</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>圆形：shape&#x3D;”circle”，coords&#x3D;”x,y,z”</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这里的 x 和 y 定义了圆心的位置（”0,0” 是图像左上角的坐标），z 是以像素为单位的圆形半径。</p>
<ul>
<li><ul>
<li><ul>
<li>多边形：shape&#x3D;”polygon”，coords&#x3D;”x1,y1,x2,y2,x3,y3,…”</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>每一对 “x,y” 坐标都定义了多边形的一个顶点（”0,0” 是图像左上角的坐标）。定义三角形至少需要三组坐标；高纬多边形则需要更多数量的顶点。</p>
<p>多边形会自动封闭，因此在列表的结尾不需要重复第一个坐标来闭合整个区域。</p>
<ul>
<li><ul>
<li><ul>
<li>矩形：shape&#x3D;”rectangle”，coords&#x3D;”x1,y1,x2,y2”</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>第一个坐标是矩形的一个角的顶点坐标，另一对坐标是对角的顶点坐标，”0,0” 是图像左上角的坐标。请注意，定义矩形实际上是定义带有四个顶点的多边形的一种简化方法。</p>
<ul>
<li>常用文本格式化标签</li>
</ul>
<table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><b></td>
<td>定义粗体文本</td>
</tr>
<tr>
<td><em></td>
<td>定义着重文字</td>
</tr>
<tr>
<td><i></td>
<td>定义斜体文字</td>
</tr>
<tr>
<td><small></td>
<td>定义小号文字</td>
</tr>
<tr>
<td><strong></td>
<td>定义加重语气</td>
</tr>
<tr>
<td><sub></td>
<td>定义下标字</td>
</tr>
<tr>
<td><sup></td>
<td>定义上标字</td>
</tr>
<tr>
<td><ins></td>
<td>定义插入字(加了下划线)</td>
</tr>
<tr>
<td><del></td>
<td>定义删除字(加了删除线)</td>
</tr>
</tbody></table>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">b</span>&gt;</span>定义粗体文本<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">em</span>&gt;</span>定义着重文字<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span>&gt;</span>定义斜体文字<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">small</span>&gt;</span>定义小号文字<span class="tag">&lt;/<span class="name">small</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">strong</span>&gt;</span>定义加重语气<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    定义下标字 <span class="tag">&lt;<span class="name">sub</span>&gt;</span>aa<span class="tag">&lt;/<span class="name">sub</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    定义上标字 <span class="tag">&lt;<span class="name">sup</span>&gt;</span>aa<span class="tag">&lt;/<span class="name">sup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ins</span>&gt;</span>定义插入字(加了下划线)<span class="tag">&lt;/<span class="name">ins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">del</span>&gt;</span>定义删除字(加了删除线)<span class="tag">&lt;/<span class="name">del</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>JavaScript基础</title>
    <url>/2022/07/08/JavaScript%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p><img src="https://img2.baidu.com/it/u=3364251630,2616048261&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=281" alt="img"></p>
<span id="more"></span>

<h1 id="JavaScript-基础"><a href="#JavaScript-基础" class="headerlink" title="JavaScript 基础"></a>JavaScript 基础</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​        JavaScript是一种属于网络的脚本语言,已经被广泛用于Web应用开发,常用来为网页添加各式各样的动态功能,为用户提供更流畅美观的浏览效果。通常JavaScript脚本是通过嵌入在HTML中来实现自身的功能的。<br>●是一种解释性脚本语言（代码不进行预编译）。<br>●主要用来向HTML（标准通用标记语言下的一个应用）页面添加交互行为。<br>●可以直接嵌入HTML页面，但写成单独的js文件有利于结构和行为的分离。<br>●跨平台特性，在绝大多数浏览器的支持下，可以在多种平台下运行（如Windows、Linux、Mac、Android、iOS等）。<br>        Javascript脚本语言同其他语言一样，有它自身的基本数据类型，表达式和算术运算符及程序的基本程序框架。Javascript提供了四种基本的数据类型和两种特殊数据类型用来处理数据和文字。而变量提供存放信息的地方，表达式则可以完成较复杂的信息处理。</p>
<h2 id="JavaScript能做什么"><a href="#JavaScript能做什么" class="headerlink" title="JavaScript能做什么"></a>JavaScript能做什么</h2><p>●使网页具有交互性，例如响应用户点击，给用户提供更好的体验<br>●可以处理表单，检验用户的输入，并提供及时反馈节省用户时间。例如，表单中要你输入电子邮箱而你却输入一个手机号，那么应该给你一个提醒。<br>●还可以根据用户的操作，动态的创建页面。例如，发邮件时，添加附件操作。<br>●设置cookie，cookie是存储在浏览器上的一些临时信息，例如你浏览过的网站地址，使用过的用户名<br>●JavaScript 是有规律地重复的HTML元素简化，减少下载时间。<br>●浏览器与服务器进行数据通讯，比如现在最流行的Ajax异步传输；</p>
<h2 id="JavaScript构成"><a href="#JavaScript构成" class="headerlink" title="JavaScript构成"></a>JavaScript构成</h2><p>●JavaScript由以下三部分组成：<br>○ECMAScript，它用来描述语法和基本对象<br>○文档对象模型Doucment Object       Model（DOM），用来处理网页内容</p>
<p><img src="https://files.catbox.moe/vxrm52.png"><br>○浏览器对象模型Borwser Object Model（BOM），用来处理浏览器交互<br><img src="https://files.catbox.moe/8s07n8.png"></p>
<h2 id="JavaScript的开发环境与运行环境"><a href="#JavaScript的开发环境与运行环境" class="headerlink" title="JavaScript的开发环境与运行环境"></a>JavaScript的开发环境与运行环境</h2><p>●JavaScript为轻型脚本语言，可在任意文本编辑器中编辑<br>●由于JavaScript是内嵌在HTML中执行，所以其运行环境即浏览器<br>10.5 JavaScript的使用<br>●JavaScript需在HTML中内嵌运行，其内嵌方式有两种：<br>○在网页中创建&lt;script&gt;&lt;&#x2F;script&gt;,在标签之间写JavaScript代码<br>JavaScript复制代码`<code>1﻿</code>&lt;script&gt;<code>2﻿</code>    alert(“hello world”)<code>3﻿</code>&lt;script&gt;&#96;</p>
<h2 id="JavaScript的使用"><a href="#JavaScript的使用" class="headerlink" title="JavaScript的使用"></a>JavaScript的使用</h2><ul>
<li><p>JavaScript需在HTML中内嵌运行，其内嵌方式有两种：</p>
</li>
<li><ul>
<li>在网页中创建&lt;script&gt;&lt;&#x2F;script&gt;,在标签之间写JavaScript代码</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  	<span class="title function_">alert</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&lt;script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>在外部创建“.js”文件，通过&lt;script src&#x3D;”文件路径”&gt;引入到HTML文件中执行</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;xxx/xxx.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript基础"><a href="#JavaScript基础" class="headerlink" title="JavaScript基础"></a>JavaScript基础</h2><ul>
<li><p>值</p>
</li>
<li><ul>
<li>数字类型的值（数字）</li>
<li>算术值（加减乘除等运算，需要两个或两个以上的数字）</li>
<li>特殊数字</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>在JavaScript中有三个特殊数值，他们被视为数字，但其行为不像普通数字那样</li>
<li>Infinity和-Infinity表示正无穷大和负无穷大</li>
<li>NaN代表不是数字，就是不当的算数运算得到不当的值（比如：0&#x2F;0或者Infinity-Infinity都会得到这样的值）</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>字符串（用于表示文本，使用引号引起来即可）</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>在字符串中还需要注意</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><p>在引号中添加特殊字符时比较难加，但是只需要添加反引号”&#96;“就可解决这个问题</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`hello my   &quot;son&quot;`</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>转义符（\）</p>
</li>
<li><ul>
<li><p>出现在引用文本中，表示后面有特殊字符</p>
</li>
<li><p>换行符（\n）</p>
</li>
<li><p>制表符（\t）</p>
</li>
<li><p>如果希望字符串中的斜杠只是斜杠，可以使用两个斜杠</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;l   input \&quot;\\n\&quot;&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>运算符</p>
</li>
<li><ul>
<li>一元运算符</li>
</ul>
</li>
<li><ul>
<li><p>在JavaScript中并非所有的运算符都是由符号构成的，还有由单词构成的符号，如：typeof运算符用来生成一个字符串，表示你输入数据的类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span>   <span class="number">2.2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span>   <span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>布尔值</p>
</li>
<li><ul>
<li>比较运算符（&gt;,&lt;,&lt;&#x3D;,&lt;&#x3D;……）</li>
</ul>
</li>
<li><ul>
<li><p>比较运算符属于二元运算符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>&lt;<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>字符串也是可以比较的</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>console.log(a&gt;b)</th>
</tr>
</thead>
<tbody><tr>
<td>字符串在比较时大致时按照字母的顺序比较，而小写字母的大于大写字母，在字符串比较是JavaScript从左道右遍历字符按照字母的unicode编码进行比较</td>
</tr>
<tr>
<td>注意：在JavaScript中只有一个值不等于它自己，他就是NaN（不是数字）console.log(NaN&#x3D;&#x3D;NaN)返回false</td>
</tr>
</tbody></table>
<ul>
<li><p>逻辑运算符（与，或，非）</p>
</li>
<li><ul>
<li>&amp;&amp;:表示逻辑与，表示结果为真才为真</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>console.log(true&amp;&amp;false)</th>
<th>false</th>
</tr>
</thead>
<tbody><tr>
<td>console.log(true&amp;&amp;true)</td>
<td>true</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><ul>
<li>||：表示逻辑或，表示一个为真，则为真</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>console.log(true||false)</th>
<th>true</th>
</tr>
</thead>
<tbody><tr>
<td>console.log(false||false)</td>
<td>false</td>
</tr>
</tbody></table>
<ul>
<li><ul>
<li>!：表示逻辑非，表示取反</li>
<li>在上边两种运算符混合使用时需要注意他们的优先级，一般情况下是,||具有最低优先级，然后时&amp;&amp;，然后是比较运算符，再然后时其他运算符</li>
<li>三元运算符，由问号和冒号写成</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>console.log(true?1:2)</th>
</tr>
</thead>
<tbody><tr>
<td>console.log(false?1:2)</td>
</tr>
</tbody></table>
<ul>
<li><p>空值</p>
</li>
<li><ul>
<li>再JavaScript中使用null和undefined表示空值</li>
</ul>
</li>
<li><p>自动类型转换</p>
</li>
<li><ul>
<li>JavaScript的包容性时相当高的，几乎可以接受你给他的任何程序</li>
<li>当运算符应用不同类型的值时，JavaScript会使用一组规则自动将值转换成所需要的类型供你使用（强制类型转换）</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>console.log(8*null)–&gt;0</th>
</tr>
</thead>
<tbody><tr>
<td>console.log(“3”-1)–&gt;2</td>
</tr>
<tr>
<td>console.log(“3”+1)–&gt;31</td>
</tr>
<tr>
<td>console.log(“six”*1)–&gt;NaN</td>
</tr>
<tr>
<td>console.log(false&#x3D;&#x3D;0)–&gt;true</td>
</tr>
<tr>
<td>console.log(null&#x3D;&#x3D;undefined)–&gt;true</td>
</tr>
<tr>
<td>console.log(null&#x3D;&#x3D;0)–&gt;false</td>
</tr>
</tbody></table>
<ul>
<li><p>表达式</p>
</li>
<li><ul>
<li>生成值得代码片段称之为表达式</li>
</ul>
</li>
<li><p>绑定（变量）</p>
</li>
<li><ul>
<li>·JavaScript为了让程序中得数据保持提供了一个称为绑定（binding）或变量（variable）得东西</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>let属于JavaScript关键字表示将定义一个绑定，它得后面是绑定名称，如果我们想给它一个值，则由”&#x3D;”运算符和表达式来完成</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>let a &#x3D;   1*2</th>
</tr>
</thead>
<tbody><tr>
<td>let num &#x3D;   10;  console.log(num*num);</td>
</tr>
</tbody></table>
<ul>
<li><ul>
<li><ul>
<li>当绑定值指向一个值时并部意味着它永远时该值，”&#x3D;”运算符随时可以更新绑定赋予绑定新值</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>在JavaScript中不单单可以使用let去做绑定,var和const两个也可以用于绑定</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>var   name&#x3D;”hello”;console.log(name);</th>
</tr>
</thead>
<tbody><tr>
<td>const demo   &#x3D; “world”;console.log(demo);</td>
</tr>
<tr>
<td>console.log(name+demo);</td>
</tr>
<tr>
<td>注：1.var全称(variable)表示变量，多用于以前得JavaScript中声明绑定2.const全称（constant），表示定义一个常量绑定，只要它存在，它就一直指向相同得值</td>
</tr>
</tbody></table>
<ul>
<li><p>JavaScript语句</p>
</li>
<li><ul>
<li>JavaScript语句是发给浏览器的命令</li>
<li>这些命令的作用是告诉浏览器要做的事情</li>
</ul>
</li>
<li><p>分号</p>
</li>
<li><ul>
<li>分号用于分隔JavaScript语句</li>
<li>通常我们在每条可执行的语句结尾添加分号，代表作一句JavaScript语句的结束</li>
<li>使用分号的另一个好处就是。。。。能在一行多写点代码嘛</li>
</ul>
</li>
<li><p>JavaScript代码</p>
</li>
<li><ul>
<li>JavaScript代码是JavaScript语句的序列</li>
<li>浏览器按照编写顺序依次执行每条语句</li>
</ul>
</li>
<li><p>JavaScript代码块</p>
</li>
<li><ul>
<li>JavaScript可以分批地组合起来</li>
<li>代码块以左花括号开始，以右花括号结束</li>
<li>代码块的作用是一并执行语句序列</li>
</ul>
</li>
<li><p>JavaScript语句标识符</p>
</li>
<li><ul>
<li>JavaScript语句通常以一个语句标识符为开始，并执行该语句。</li>
<li>语句标识符是保留关键字不能作为变量名使用</li>
<li>JavaScript语句标识符（关键字）</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>语句</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>break</td>
<td>用于跳出循环</td>
</tr>
<tr>
<td>catch</td>
<td>语句块，在try语句块执行出错时执行catch语句块</td>
</tr>
<tr>
<td>continue</td>
<td>跳过循环的一个迭代</td>
</tr>
<tr>
<td>do…while</td>
<td>执行一个语句块，在条件语句为true时继续执行该语句块</td>
</tr>
<tr>
<td>for</td>
<td>在条件语句为true时，可以将代码块执行指定的次数</td>
</tr>
<tr>
<td>for…in</td>
<td>用于遍历数组或对象的属性（对数组或者对象的属性进行循环操作）</td>
</tr>
<tr>
<td>function</td>
<td>定义一个函数</td>
</tr>
<tr>
<td>if…else</td>
<td>用于基于不同的条件来执行不同的动作</td>
</tr>
<tr>
<td>return</td>
<td>退出函数</td>
</tr>
<tr>
<td>switch</td>
<td>用于基于不同条件来执行不同的动作</td>
</tr>
<tr>
<td>throw</td>
<td>抛出错误</td>
</tr>
<tr>
<td>try</td>
<td>实现错误处理，与catch一同使用</td>
</tr>
<tr>
<td>var</td>
<td>声明一个变量</td>
</tr>
<tr>
<td>while</td>
<td>当条件语句为true时，执行语句块</td>
</tr>
</tbody></table>
<ul>
<li><p>代码折行</p>
<p><img src="https://files.catbox.moe/ydhbe5.png"></p>
</li>
</ul>
<h2 id="JavaScript数据类型"><a href="#JavaScript数据类型" class="headerlink" title="JavaScript数据类型"></a>JavaScript数据类型</h2><ul>
<li>javascript属于弱语言，它的变量没有明确的数据类型，它的数据类型是由它存储的值自己推断出来的</li>
<li>常见数据类型</li>
</ul>
<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th><strong>具体描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>number</td>
<td>能存储整数和小数类型</td>
</tr>
<tr>
<td>string</td>
<td>用单引号或双引号来声明的字符串</td>
</tr>
<tr>
<td>boolean</td>
<td>只能是两个值选择：true、false</td>
</tr>
<tr>
<td>undefined</td>
<td>变量被声明后，但未被赋值</td>
</tr>
<tr>
<td>object</td>
<td>javascript中的对象、数组和null</td>
</tr>
</tbody></table>
<ul>
<li><p>在JavaScript中可以使用typeof()函数来检查变量的返回值类型</p>
<p><img src="https://files.catbox.moe/wrq2r2.png"></p>
</li>
<li><p>JavaScript拥有动态类型，这意味着相同的变量可用作不同的类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x；<span class="comment">//x为undefined</span></span><br><span class="line"><span class="keyword">var</span>   x = <span class="number">5</span>；<span class="comment">//x为数字</span></span><br><span class="line"><span class="keyword">var</span>   x = <span class="string">&quot;hello&quot;</span>;<span class="comment">//x为字符串</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>JavaScript字符串</p>
</li>
<li><p>字符串是存储字符的变量</p>
<p>字符串可以是引号中的任意文本。可以使用单引号或者双引号</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name =   <span class="string">&quot;tom&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> name =   <span class="string">&#x27;tom&#x27;</span>;</span><br></pre></td></tr></table></figure>

</li>
<li><p>也可以在字符串中使用引号，只要不匹配包围字符串的引号即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> answer   = <span class="string">&quot;let&#x27;go&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> answer   = <span class="string">&quot;my name is &#x27;tom&#x27; &quot;</span>;</span><br></pre></td></tr></table></figure>

</li>
<li><p>JavaScript数字</p>
</li>
<li><p>JavaScript只有一种数字类型。数字可以带小数点。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> b =   <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure>

</li>
<li><p>极大或极小的数字可以通过科学计数来书写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a =   <span class="number">123e5</span>;<span class="comment">//12300000  </span></span><br><span class="line"><span class="keyword">var</span> b =   <span class="number">123e-5</span>;<span class="comment">//0.00123</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>JavaScript布尔</p>
</li>
<li><ul>
<li>布尔（逻辑）只能有两个值：true或false</li>
</ul>
</li>
<li><p>布尔常用在条件测试中。这个我们将在之后详解</p>
</li>
<li><p>JavaScript数组</p>
</li>
<li><ul>
<li>详见10.8节</li>
</ul>
</li>
<li><p>JavaScript对象</p>
</li>
<li><ul>
<li><p>详见10.9节</p>
</li>
<li><p>对象由花括号分隔。在扩号内部，对象的属性以名称和值对的形式（键值对 name：value）来定义，属性由逗号分隔</p>
</li>
<li><p>对象有两种寻址方式：</p>
<p><img src="https://files.catbox.moe/9ftj31.png"></p>
</li>
</ul>
</li>
<li><p>Undefined和Null</p>
</li>
<li><p>Undefined表示变量不含值</p>
<p>Null可以通过将变量的值设置为Null来清空变量</p>
<p><img src="https://files.catbox.moe/c70gx5.png"></p>
</li>
<li><p>声明变量类型</p>
</li>
<li><ul>
<li>当声明新变量时，可以使用关键词“new”来声明其类型</li>
</ul>
</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li><p>什么是数组</p>
</li>
<li><ul>
<li>数组对象是使用单独的变量名来存储一系列相同类型的值</li>
<li>数字可以用一个变量名存储所有的值，并且可以用变量名访问任何一个值</li>
<li>数组中的每个元素都有自己的ID，以便它可以很容易地被访问到</li>
</ul>
</li>
<li><p>创建数组，有几种不同的方式</p>
</li>
<li><p>常规方式</p>
<p><img src="https://files.catbox.moe/dl7qyu.png"></p>
</li>
<li><p>简洁方式</p>
<p><img src="https://files.catbox.moe/bxwyb8.png"></p>
</li>
<li><p>字面方式</p>
<p><img src="https://files.catbox.moe/1mwch8.png"></p>
</li>
<li><p>访问数组</p>
</li>
<li><ul>
<li>通过上边的几个例子，大家应该能看出来数组是怎么访问的</li>
<li>语法：数组名[下标]</li>
</ul>
</li>
<li><ul>
<li>在数组中[0]代表数组的第一个元素，[1]则代表的是第二个元素</li>
</ul>
</li>
<li><p>来个数组式循环弹窗看看</p>
<p><img src="https://files.catbox.moe/o4xcer.png"></p>
</li>
<li><p>在一个数组中可以有不同的对象</p>
</li>
<li><ul>
<li><p>所有的JavaScript变量都是对象，数组元素是对象，函数也是对象</p>
</li>
<li><p>因此，我们可以在数组中有不同的变量类型</p>
</li>
<li><p>我们可以在一个数组中包含对象元素，函数，数组</p>
<p><img src="https://files.catbox.moe/lpu5by.png"></p>
</li>
</ul>
</li>
<li><p>数组方法和属性</p>
</li>
<li><p>使用数组对象预定义属性和方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>    a = 数组名.<span class="property">length</span>       <span class="comment">//length元素的数量</span></span><br><span class="line"><span class="keyword">var</span>    b = 数组名.<span class="title function_">indexOf</span>(<span class="string">&quot;需要索引的字段&quot;</span>)    <span class="comment">//括号里面为索引值</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>更多的实例</p>
</li>
<li><ul>
<li><p>合并两个数组-concat()</p>
<p><img src="https://files.catbox.moe/kz1at0.png"></p>
</li>
</ul>
</li>
<li><ul>
<li><p>合并三个数组-concat()</p>
<p><img src="https://files.catbox.moe/l99gtm.png"></p>
</li>
</ul>
</li>
<li><p>用数组的元素组合字符串-join()</p>
</li>
<li><ul>
<li><p>join()方法用于把数组中的所有元素放入一个字符串</p>
</li>
<li><p>元素是同过指定的分隔符分隔的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.<span class="title function_">join</span>(separator)</span><br><span class="line">separator：指定要使用的分隔符，如果省略改参数，则使用逗号作为分隔符</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://files.catbox.moe/5ouzax.png"></p>
</li>
</ul>
<p><img src="https://files.catbox.moe/v2dt2m.png"></p>
<p><img src="https://files.catbox.moe/0z8fu1.png"></p>
<ul>
<li><p>删除数组的最后一个元素-pop()</p>
<p><img src="https://files.catbox.moe/o76e63.png"></p>
</li>
<li><p>数组的末尾添加新的元素-push()</p>
<p><img src="https://files.catbox.moe/xaqslo.png"></p>
</li>
<li><p>将一个数组中的元素的顺序反转排序-reverse()</p>
<p><img src="https://files.catbox.moe/lnlzsb.png"></p>
</li>
<li><p>删除数组的第一个元素-shift()</p>
<p><img src="https://files.catbox.moe/uq24ic.png"></p>
</li>
<li><p>从一个数组中选择元素-slice()</p>
</li>
<li><ul>
<li><p>slice()方法可提取字符串的某个部分，并以新的字符串返回被提取的部分</p>
</li>
<li><p>语法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">stringObject.<span class="title function_">slice</span>(start,end)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li>返回值</li>
</ul>
</li>
<li><ul>
<li><p>一个新的字符串，包括字符串stratObject从strat开始（包括strat）到end结束（不包括end）为止的所有字符串</p>
<p><img src="https://files.catbox.moe/qnpc9e.png"></p>
</li>
</ul>
</li>
<li><ul>
<li><p>数组排序（按字母顺序升序）-sort()</p>
<p><img src="https://files.catbox.moe/w4l39r.png"></p>
</li>
</ul>
</li>
<li><ul>
<li><p>数字排序（按数字顺序升序）-sort()</p>
<p><img src="https://files.catbox.moe/8z6azi.png"></p>
</li>
</ul>
</li>
<li><ul>
<li><p>数字排序（按数字顺序降序）-sort()</p>
<p><img src="https://files.catbox.moe/14e3wp.png"></p>
</li>
</ul>
</li>
<li><ul>
<li>在数组的第二位置添加一个元素 -splice()</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><p>splice()方法用于插入，删除，或者替换数组的元素</p>
</li>
<li><p>语法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.<span class="title function_">splice</span>(index,howmant,element1....,element1)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>index</td>
<td>必需。规定从何处添加&#x2F;删除元素。该参数是开始插入和(或)删除的数组元素的下标，必需是数字哦</td>
</tr>
<tr>
<td>howmant</td>
<td>必需。规定应该删除多少元素。必须是数字，但可以是（0）。如果未规定此参数，则删除从index开始到原数组结尾的所有元素</td>
</tr>
<tr>
<td>element1</td>
<td>可选。规定要添加到数组的新元素。从index所指的下标处开始插入</td>
</tr>
<tr>
<td>elementN</td>
<td>可选。可向数组添加若干元素。</td>
</tr>
</tbody></table>
<ul>
<li><ul>
<li>返回值</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>如果从arrayObject中删除了元素，则返回的是含有被删除的元素的数组</li>
</ul>
</li>
</ul>
</li>
<li><p>注意：splice()方法和slice()方法的作用是不同的，splice()方法会直接对数组,行修改。</p>
</li>
<li><p>下边的这个例子就是替换了下标“1”至“3”里面的内容，包含1和3下标的内容，也就是说我把数组里的“33，22，66”替换成了“88,44”。</p>
<p><img src="https://files.catbox.moe/xh8wnu.png"></p>
</li>
<li><p>转换数组到字符串 -toString()</p>
<p><img src="https://files.catbox.moe/c5oso5.png"></p>
</li>
<li><p>在数组的开头添加新元素 -unshift()</p>
<p><img src="https://files.catbox.moe/7nddbq.png"></p>
</li>
</ul>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul>
<li><p>JavaScript对象</p>
</li>
<li><ul>
<li>在JavaScript中，对象是拥有属性和方法的数据。</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>属性是与对象相关的值</li>
<li>方法是能够在对象上执行的动作</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><p>对象也是一个变量，但对象可以包含多个值（多个变量）</p>
<p><img src="https://files.catbox.moe/zbru2q.png"></p>
</li>
</ul>
</li>
<li><ul>
<li><p>上边这个例子中，三个值（**”Lamborghini”,999999,”black”**）赋予变量car</p>
</li>
<li><p>三个变量（”neme”,price,color）赋予变量car</p>
</li>
<li><p>JavaScript对象是变量的容器</p>
</li>
<li><p>定义JavaScript对象是可以跨越多行，空格跟换行不是必须的</p>
<p><img src="https://files.catbox.moe/1firyr.png"></p>
<p><img src="https://files.catbox.moe/8t2ieu.png"></p>
</li>
</ul>
</li>
<li><p>对象属性</p>
</li>
<li><ul>
<li>JavaScript对象是变量的容器</li>
<li>JavaScript对象是键值对的容器</li>
<li>键值对的基本写法为name:value（上边的例子就是喽）</li>
<li>键值对在JavaScript对象中统称为对象属性。</li>
<li>访问对象属性</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><p>可以用对象名点属性（如：person.one）</p>
</li>
<li><p>也可以用对象名[“属性”]（如：person[“one”]）</p>
<p><img src="https://files.catbox.moe/dad30x.png"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>对象方法</p>
</li>
<li><ul>
<li>对象的方法定义了一个函数，并作为对象的属性存储</li>
<li>对象方法通过添加()调用（当成函数调用）</li>
<li>下边的这个例子访问了person对象的all()方法（如果直接访问person对象的all属性，它将作为定义一个函数的字符串返回，也就是说把后边的代码直接返回，并且打印出来）</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><p>访问方法（例：person.all()）</p>
</li>
<li><p>访问属性（例：person.all）</p>
<p><img src="https://files.catbox.moe/trcnch.png"></p>
<p><img src="https://files.catbox.moe/gaplno.png"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>JavaScript对象</title>
    <url>/2022/07/08/JavaScript%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.debug8.com%2Fstatics%2Fuploads%2F2020%2F08%2F15%2F1597460167384632.jpeg&refer=http%3A%2F%2Fwww.debug8.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1659869298&t=98ffecf7bc2187582206328f237905ec" alt="img"></p>
<span id="more"></span>

<h1 id="JavaScript对象"><a href="#JavaScript对象" class="headerlink" title="JavaScript对象"></a>JavaScript对象</h1><h2 id="什么是对象"><a href="#什么是对象" class="headerlink" title="什么是对象"></a>什么是对象</h2><ul>
<li><p>对象是一种复合值，它汇聚多个值（原始值或者是其它对象），并且允许我们按照<br>名称存储和获取这些值。</p>
</li>
<li><p>对象是一个属性无序的集合，每个属性都有自己的名字和值，只有在对象中，其使<br>用起来与顺序无关，只需要打点即可调用。</p>
</li>
<li><p>在JavaScript中对象可以从其它对象继承属性</p>
</li>
<li><p>JavaScript对象是动态的，即可以动态的添加和删除对象属性</p>
<p>​</p>
</li>
</ul>
<h2 id="认识对象"><a href="#认识对象" class="headerlink" title="认识对象"></a>认识对象</h2><ul>
<li><p>创建自定义对象我们可以通过创建Object实例来实现，然后再给他添加属性和方法<br>（函数）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    person.<span class="property">name</span> = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">    person.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line">    person.<span class="property">job</span> = <span class="string">&quot;Teacher&quot;</span>; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>+<span class="string">&quot;，年龄&quot;</span>+<span class="variable language_">this</span>.<span class="property">age</span>+<span class="string">&quot;岁，他的工作是：&quot;</span>+<span class="variable language_">this</span>.<span class="property">job</span>);</span><br><span class="line">    person.<span class="property">work</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   <span class="keyword">let</span> person = &#123;</span><br><span class="line">    name = <span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">    age = <span class="number">18</span>,</span><br><span class="line">    job = <span class="string">&quot;Teacher&quot;</span>,</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>+<span class="string">&quot;，年龄&quot;</span>+<span class="variable language_">this</span>.<span class="property">age</span>+<span class="string">&quot;岁，他的工作</span></span><br><span class="line"><span class="string">是：&quot;</span>+<span class="variable language_">this</span>.<span class="property">job</span>);</span><br><span class="line">    <span class="title function_">work</span>(<span class="params"></span>)&#123;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="属性的类型"><a href="#属性的类型" class="headerlink" title="属性的类型"></a>属性的类型</h2><ul>
<li>JavaScript使用了一些内部特性来描述属性的特征，这些特性由JavaScript实现引<br>擎的规范定义的，所以开发者不能直接在JavaScript中访问这些访问。</li>
</ul>
<h3 id="属性的特性分两种"><a href="#属性的特性分两种" class="headerlink" title="属性的特性分两种"></a>属性的特性分两种</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**数据属性**</span><br></pre></td></tr></table></figure>

<ul>
<li><p>【Configurable】：表示属性是否可以通过delete删除并重新定义，</p>
<p>是否可以修改它的特性，以及是否可以把它改为访问器属性。其默认情况下为true</p>
</li>
<li><p>【Enumerable】：表示属性是否可以通过for-in循环返回，默认情况</p>
<p>也为true</p>
</li>
<li><p>【Writable】：表示属性的值是否可以被修改，其默认值为true</p>
</li>
<li><p>【Value】：包含属性的实际值，其默认值为undefined</p>
</li>
</ul>
<br/>

<ul>
<li><p>这些属性特性我们在定义对象时并不需要显式的添加前三个，而Value特性<br>也会被我们定义，如：name:”zhangsan</p>
</li>
<li><p>如果想要修改这些默认特性，就必须使用Object.defineProperty()方<br>法，这个方法在使用时接收三个参数：要给其添加属性的对象，属性的名<br>称，以及一个描述特性的对象及其参数</p>
</li>
<li><p>示例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person,<span class="string">&quot;name&quot;</span>,&#123;</span><br><span class="line">    <span class="attr">writable</span>:<span class="literal">false</span>,</span><br><span class="line">    <span class="attr">value</span>:<span class="string">&quot;王麻子&quot;</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>);</span><br><span class="line">    person.<span class="property">name</span> = <span class="string">&quot;张金条&quot;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person,<span class="string">&quot;name&quot;</span>,&#123;</span><br><span class="line">    <span class="comment">// configurable:true,</span></span><br><span class="line">    <span class="attr">configurable</span>:<span class="literal">false</span>,</span><br><span class="line">    <span class="attr">value</span>:<span class="string">&quot;王麻子&quot;</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>);</span><br><span class="line">    <span class="keyword">delete</span> person.<span class="property">name</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><ul>
<li><p>访问器属性不包含数据值，它包含一个获取（getter）函数以及一个设置<br>（setter）函数，不过这两个函数并非必须函数。</p>
</li>
<li><p>在读取访问器属性时，程序会自个调用获取函数，也就是说获取函数的主<br>要任务就是返回一个有效的值</p>
</li>
<li><p>访问器属性也有4个特性用了描述它们的行为</p>
<p>【Configurable】，默认值为true，表示能否通过delete删除属性从而<br>重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性<br>【Enumerable】，默认值为true，能否通过for-in循环返回属性<br>【get】读取这个属性时调用的函数 getter函数<br>【set】在为这个属性赋值时调用的函数 setter函数</p>
</li>
<li><p>以上这些属性也是不能直接定义的，必须通过Object-defineProperty()</p>
</li>
<li><p>示例</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">     <span class="keyword">let</span> book = &#123;</span><br><span class="line">       <span class="attr">name</span>:<span class="string">&quot;七侠五义&quot;</span>,</span><br><span class="line">       <span class="attr">price</span>:<span class="number">1</span></span><br><span class="line">     &#125;;</span><br><span class="line">  </span><br><span class="line">     book.<span class="property">name</span> = <span class="string">&quot;斗破苍穹&quot;</span>;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(book.<span class="property">name</span>);</span><br><span class="line">     <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(book,<span class="string">&quot;name&quot;</span>,&#123;</span><br><span class="line">     <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="title function_">set</span>(<span class="params">newValue</span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">name</span> = newValue;</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="对象合并"><a href="#对象合并" class="headerlink" title="对象合并"></a>对象合并</h2><ul>
<li><p>在开发JavaScript时我们会把多个对象合并使用</p>
</li>
<li><p>具体来说就是把一个对象的所有属性复制到了目标对象上，这种方式也被称之为混<br>入，通过对象的合并我们可以增强对象功能</p>
</li>
<li><p>JavaScript专门为合并对象提供了一个Object.assign()方法，这个方法接收一个目<br>标对象和一个或多个其它对象（源对象），然后将每个源对象中自有属性复制到目<br>标对象</p>
</li>
<li><p>示例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//目标对象</span></span><br><span class="line">    <span class="title class_">Obj1</span> = &#123;<span class="attr">name</span>:<span class="string">&quot;老八&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">//源对象</span></span><br><span class="line">    <span class="title class_">Obj2</span> = &#123;<span class="attr">name</span>:<span class="string">&quot;老八&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">//把2复制到目标对象中</span></span><br><span class="line">    result = <span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="title class_">Obj1</span>,<span class="title class_">Obj2</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Obj1</span> === result)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Obj2</span> === result)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">   </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="增强的对象语法"><a href="#增强的对象语法" class="headerlink" title="增强的对象语法"></a>增强的对象语法</h2><ul>
<li><p>ES6位对象定义了很多定义对象及其操作对象的语法特性，这些特性可以极大程度<br>提高对象处理的方便程度</p>
</li>
<li><p>属性值得简写</p>
<p>在给对象添加值时我们可以引用变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"> <span class="keyword">let</span> username= <span class="string">&quot;sanlvzi&quot;</span>;</span><br><span class="line"> <span class="keyword">let</span> person = &#123;</span><br><span class="line"> <span class="attr">username</span>:username</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(person)</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">还能简写（以下这种情况必须时变量名域对象的属性名相同才可以这么写）</span><br></pre></td></tr></table></figure></li>
</ul>
<br/>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   <span class="keyword">let</span> username= <span class="string">&quot;sanlvzi&quot;</span>;</span><br><span class="line">   username</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="keyword">let</span> person = &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(person)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ul>
<li><p>对象解构是从对象中检索属性键的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">name</span>:<span class="string">&quot;张麻子&quot;</span>,</span><br><span class="line"><span class="attr">age</span>:<span class="number">18</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>传统取值来说，我们可以使用打点表示法或者是下标法来从对象中检索值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> username = user.<span class="property">name</span>;</span><br><span class="line"><span class="keyword">let</span> age = user[<span class="string">&#x27;age&#x27;</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>以上这种方法是没有任何问题的，但是就当属性较多时，我们的代码中会产生<br>较多的重复代码，然后ES6就搞出来了一个技术叫做对象解构</p>
</li>
<li><p>对象解构也叫解构赋值，可以快速的获取值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;name,age&#125; = user;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="使用解构从嵌套的对象中获取值"><a href="#使用解构从嵌套的对象中获取值" class="headerlink" title="使用解构从嵌套的对象中获取值"></a>使用解构从嵌套的对象中获取值</h3><ul>
<li><p>嵌套即一个对象中还有对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">   <span class="attr">name</span>:<span class="string">&quot;Marry&quot;</span>,</span><br><span class="line">   <span class="attr">age</span>:<span class="number">27</span>,</span><br><span class="line">   <span class="attr">friend</span>:&#123;</span><br><span class="line">   <span class="attr">friend_1_Phone</span>:<span class="number">110</span>,</span><br><span class="line">   <span class="attr">address</span>:<span class="string">&quot;文景路凤城四路...&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用传统方式获取朋友对象的值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Person</span>.<span class="property">friend</span>.<span class="property">friend_1_Phone</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>换成解构赋值，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">   <span class="title class_">Pname</span>:<span class="string">&quot;Marry&quot;</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">let</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">   <span class="title class_">Uname</span>:<span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">   <span class="title class_">Uage</span>:<span class="string">&#x27;&#x27;</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//在解构时可以加上其它属性值</span></span><br><span class="line">   <span class="keyword">let</span> &#123;<span class="title class_">Pname</span>,<span class="title class_">Page</span> = <span class="number">18</span>&#125; = <span class="title class_">Person</span>;</span><br><span class="line">   <span class="keyword">let</span> &#123;<span class="title class_">Uname</span>,<span class="title class_">Uage</span> = <span class="number">18</span>&#125; = <span class="title class_">User</span>;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Pname</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="还可以给JavaScript解构对象创建别名"><a href="#还可以给JavaScript解构对象创建别名" class="headerlink" title="还可以给JavaScript解构对象创建别名"></a>还可以给JavaScript解构对象创建别名</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">User</span> = &#123;</span><br><span class="line"> <span class="attr">name</span>:<span class="string">&quot;Jack&quot;</span>,</span><br><span class="line"> <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">let</span>&#123;<span class="attr">age</span>:userAge&#125; =<span class="title class_">User</span>;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(userAge) </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="还可以使用对象解构处理动态名称属性"><a href="#还可以使用对象解构处理动态名称属性" class="headerlink" title="还可以使用对象解构处理动态名称属性"></a>还可以使用对象解构处理动态名称属性</h3><ul>
<li><p>我们在开发时经常会将API的一些响应数据作为Javascript对象处理，这些对象</p>
<p>可能包含一些动态数据，我们在客户端使用这些数据时可能连属性键时啥都不<br> 知道</p>
</li>
<li><p>我们可以将键当成时参数据传递，也就是说我们可以编写一个返回User对象属<br>性值得函数，然后我们可以接收参数，让JS从对象中去检索</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">   <span class="attr">name</span>:<span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">   <span class="attr">age</span>:<span class="string">&#x27;&#x27;</span></span><br><span class="line"> &#125;</span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">getProperty</span>(<span class="params">key</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> &#123;[key]:returnValue&#125; = <span class="title class_">User</span>;</span><br><span class="line">      <span class="keyword">return</span> returnValue;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">let</span> address = <span class="title function_">getProperty</span>(<span class="string">&#x27;address&#x27;</span>);</span><br><span class="line">   <span class="keyword">let</span> name = <span class="title function_">getProperty</span>(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(address,name);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="在函数参数和返回值中解构对象"><a href="#在函数参数和返回值中解构对象" class="headerlink" title="在函数参数和返回值中解构对象"></a>在函数参数和返回值中解构对象</h3>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解构赋值传参</span><br></pre></td></tr></table></figure>

  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">   <span class="attr">name</span>:<span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">   <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line"> &#125;</span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params">&#123;name,age&#125;</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(name,age)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title function_">fun</span>(<span class="title class_">User</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  解构函数对象返回值</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果一个函数的返回值是一个对象，我们可以直接解构对象为变量</span><br></pre></td></tr></table></figure>

  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">   <span class="attr">name</span>:<span class="string">&quot;Jack&quot;</span>, <span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="attr">name</span>:<span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">   <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="title class_">User</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">let</span>&#123;age&#125; = <span class="title function_">fun</span>();</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(age)</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">return</span>&#123;</span><br><span class="line">   <span class="attr">name</span>:<span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">   <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">let</span>&#123;age&#125; = <span class="title function_">fun</span>();</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(age)</span><br></pre></td></tr></table></figure>

<p>  在循环中使用对象解构</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">User</span> = [</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="string">&#x27;name&#x27;</span>:<span class="string">&quot;张三&quot;</span> ,</span><br><span class="line">     <span class="string">&#x27;age&#x27;</span>:<span class="number">18</span></span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="string">&quot;name&quot;</span>:<span class="string">&quot;李四&quot;</span>,</span><br><span class="line">     <span class="string">&quot;age&quot;</span>:<span class="number">19</span></span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="string">&quot;name&quot;</span>:<span class="string">&quot;王五&quot;</span>,</span><br><span class="line">     <span class="string">&quot;age&quot;</span>:<span class="number">20</span></span><br><span class="line">   &#125;</span><br><span class="line">   ];</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">let</span>&#123;name,age&#125; <span class="keyword">of</span> <span class="title class_">User</span>)&#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(name,age)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用其它方式创建对象"><a href="#使用其它方式创建对象" class="headerlink" title="使用其它方式创建对象"></a>使用其它方式创建对象</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><ul>
<li><p>工厂模式是程序中应用较为普遍的一种设计模式</p>
</li>
<li><p>在这里用于抽象对象创建的过程，按照特定的接口创建方式创建对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个方法，该方法用来规定创建对象的基本属性及行为</span></span><br><span class="line"> <span class="comment">//属性我们以方法的参数形式传递进来，让方法内部对这些属性进行处理</span></span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name,age,job</span>) &#123;</span><br><span class="line"> <span class="comment">//创建一个Object对象</span></span><br><span class="line"> <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"> <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"> <span class="comment">//给obj对象开始赋值</span></span><br><span class="line"> obj.<span class="property">name</span> = name;</span><br><span class="line"> obj.<span class="property">age</span> = age;</span><br><span class="line"> obj.<span class="property">job</span> = job;</span><br><span class="line"> obj.<span class="property">eat</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>+<span class="string">&quot;，吃饭时DuangDuang的&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">let</span> person_1 = <span class="title function_">createPerson</span>(<span class="string">&quot;张金条&quot;</span>,<span class="number">99</span>,<span class="string">&quot;修空调&quot;</span>);</span><br><span class="line"> <span class="keyword">let</span> person_2 = <span class="title function_">createPerson</span>(<span class="string">&quot;张银条&quot;</span>,<span class="number">98</span>,<span class="string">&quot;挖坑&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="构造函数方式"><a href="#构造函数方式" class="headerlink" title="构造函数方式"></a>构造函数方式</h3><ul>
<li><p>以函数的形式为自己的对象定义属性和方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name,age,job</span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">eat</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;干饭&quot;</span>);</span><br><span class="line">   &#125;;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//要创建对象就得new，也就是说通过new关键字调用Person方法来创建Person对象</span></span><br><span class="line">   <span class="keyword">let</span> person_1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张铜条&quot;</span>,<span class="number">88</span>,<span class="string">&quot;摆烂&quot;</span>);</span><br><span class="line">   <span class="keyword">let</span> person_2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张铁条&quot;</span>,<span class="number">90</span>,<span class="string">&quot;技师&quot;</span>);</span><br><span class="line">   person_1.<span class="title function_">eat</span>();</span><br><span class="line">   person_2.<span class="title function_">eat</span>();</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解析</p>
<p>在内存中创建一个新对象，每new一次就会创建一个新的对象</p>
<p>这个对象在方法内部只是为将要形成的对象属性指定了属性值和行为</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>JavaScript BOM与DOM</title>
    <url>/2022/07/08/JavaScript-BOM%E4%B8%8EDOM/</url>
    <content><![CDATA[<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.mk2048.com%2Fweb_upload%2Fblog_imgs%2F9%2Fhttps___user-gold-cdn-xitu-io_2018_5_29_163a9401f45c8ab1_w-1280_h-720_f-jpeg_s-54086.gif&refer=http%3A%2F%2Fwww.mk2048.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1659878697&t=22475cd2413ac8bfc0fc92f294e20a0b" alt="img"></p>
<span id="more"></span>

<h1 id="JavaScript-BOM与DOM"><a href="#JavaScript-BOM与DOM" class="headerlink" title="JavaScript BOM与DOM"></a>JavaScript BOM与DOM</h1><h2 id="BOM（borwser-object-Model）"><a href="#BOM（borwser-object-Model）" class="headerlink" title="BOM（borwser object Model）"></a>BOM（borwser object Model）</h2><h4 id="浏览器对象模型"><a href="#浏览器对象模型" class="headerlink" title="浏览器对象模型"></a>浏览器对象模型</h4><ul>
<li><ul>
<li>使用对象描述浏览器的各个部分</li>
<li>BOM提供与浏览器窗口交互的对象</li>
<li>BOM主要用于管理窗口与窗口之间的通讯，所以核心对象是窗口（window）</li>
</ul>
</li>
<li><p>BOM里有什么</p>
</li>
<li><ul>
<li><p>图示</p>
<p><img src="https://files.catbox.moe/ccpeyl.png"></p>
</li>
</ul>
</li>
<li><ul>
<li>与浏览器进行交互的一些对象</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>移动，调整浏览器大小的window对象</li>
<li>用于导航的location对象history</li>
<li>获取浏览器，用户屏幕信息的navigator与screen对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h5><ul>
<li><ul>
<li>open()方法用于打开一个新窗口或查找一个窗口</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>语法</li>
<li>window.open(url,name,feature,replace)</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>url</td>
<td>声明要在新窗口中显示文档的url</td>
</tr>
<tr>
<td>name</td>
<td>该字符声明了新窗口的名称。这个名称可以用作标记    <a> 和 <form> 的属性 target 的值。如果该参数指定了一个已经存在的窗口，那么 open()    方法就不再创建一个新窗口，而只是返回对指定窗口的引用。在这种情况下，features 将被忽略。</td>
</tr>
<tr>
<td>feature</td>
<td>声明了新窗口要显示的标准浏览器的特征</td>
</tr>
<tr>
<td>replace</td>
<td>一个可选的布尔值。规定了装载到窗口的     URL 是在窗口的浏览历史中创建一个新条目，还是替换浏览历史中的当前条目。支持下面的值：true - URL 替换浏览历史中的当前条目。false - URL 在浏览历史中创建新的条目。</td>
</tr>
</tbody></table>
<ul>
<li><p>案例 打开新窗口控制其外观样式</p>
<p><img src="https://files.catbox.moe/9cmg9b.png"></p>
</li>
<li><p>窗口特征表</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>channelmode&#x3D;yes|no|1|0</th>
<th>是否使用剧院模式显示窗口。默认为    no。</th>
</tr>
</thead>
<tbody><tr>
<td>directories&#x3D;yes|no|1|0</td>
<td>是否添加目录按钮。默认为    yes。</td>
</tr>
<tr>
<td>fullscreen&#x3D;yes|no|1|0</td>
<td>是否使用全屏模式显示浏览器。默认是    no。处于全屏模式的窗口必须同时处于剧院模式。</td>
</tr>
<tr>
<td>height&#x3D;pixels</td>
<td>窗口文档显示区的高度。以像素计。</td>
</tr>
<tr>
<td>left&#x3D;pixels</td>
<td>窗口的 x    坐标。以像素计。</td>
</tr>
<tr>
<td>location&#x3D;yes|no|1|0</td>
<td>是否显示地址字段。默认是    yes。</td>
</tr>
<tr>
<td>menubar&#x3D;yes|no|1|0</td>
<td>是否显示菜单栏。默认是    yes。</td>
</tr>
<tr>
<td>resizable&#x3D;yes|no|1|0</td>
<td>窗口是否可调节尺寸。默认是    yes。</td>
</tr>
<tr>
<td>scrollbars&#x3D;yes|no|1|0</td>
<td>是否显示滚动条。默认是    yes。</td>
</tr>
<tr>
<td>status&#x3D;yes|no|1|0</td>
<td>是否添加状态栏。默认是    yes。</td>
</tr>
<tr>
<td>titlebar&#x3D;yes|no|1|0</td>
<td>是否显示标题栏。默认是    yes。</td>
</tr>
<tr>
<td>toolbar&#x3D;yes|no|1|0</td>
<td>是否显示浏览器的工具栏。默认是    yes。</td>
</tr>
<tr>
<td>top&#x3D;pixels</td>
<td>窗口的 y    坐标。</td>
</tr>
<tr>
<td>width&#x3D;pixels</td>
<td>窗口的文档显示区的宽度。以像素计。</td>
</tr>
</tbody></table>
<ul>
<li><p>setInterval()每隔指定的毫秒运行指定的代码&#x2F;函数</p>
</li>
<li><p>案例</p>
<p><img src="https://files.catbox.moe/gezs9p.png"></p>
</li>
<li><p>setTimeout()经过指定毫秒数运行一次指定的代码&#x2F;函数</p>
</li>
<li><p>案例</p>
<p><img src="https://files.catbox.moe/r0dclo.png"></p>
</li>
<li><p>location地址栏对象</p>
</li>
<li><ul>
<li>href：设置或获取整个URL为字符串</li>
</ul>
</li>
<li><p>案例</p>
<p><img src="https://files.catbox.moe/rk4u5p.png"></p>
</li>
<li><p>reload()：重新加载</p>
</li>
<li><p>replace():用新文档替换当前文档</p>
</li>
<li><p>案例</p>
<p><img src="https://files.catbox.moe/e2r3lh.png"></p>
</li>
</ul>
<h5 id="屏幕对象（Screen）用来获取电脑屏幕的一些数据"><a href="#屏幕对象（Screen）用来获取电脑屏幕的一些数据" class="headerlink" title="屏幕对象（Screen）用来获取电脑屏幕的一些数据"></a>屏幕对象（Screen）用来获取电脑屏幕的一些数据</h5><ul>
<li><ul>
<li>availHeight：获取系统屏幕的工作区高度（浏览器的页面高度）</li>
</ul>
</li>
<li><ul>
<li><p>案例</p>
<p><img src="https://files.catbox.moe/k600si.png"></p>
</li>
</ul>
</li>
<li><p>availWidth：获取系统屏幕的工作区宽度（浏览器页面宽度）</p>
</li>
<li><p>height：获取屏幕的垂直分辨率</p>
</li>
<li><p>width：获取屏幕的水平分辨率 </p>
</li>
<li><ul>
<li><p>案例</p>
<p><img src="https://files.catbox.moe/oxiqgh.png"></p>
</li>
</ul>
</li>
</ul>
<h2 id="DOM编程"><a href="#DOM编程" class="headerlink" title="DOM编程"></a>DOM编程</h2><h4 id="文档对象模型（document）"><a href="#文档对象模型（document）" class="headerlink" title="文档对象模型（document）"></a>文档对象模型（document）</h4><ul>
<li>当一个html页面加载到浏览器的时候，那么浏览器会为每个标签都创建一个对应的对象，描述该标签的所有信息</li>
<li>我们此时所看到的网页信息实际上就是看到了这些标签的对象信息，如果我们需要操作页面的数据，我们就可以通过这些标签对象进行操作</li>
<li>图例</li>
<li><img src="https://files.catbox.moe/29phbz.png"></li>
</ul>
<h4 id="用来获取页面节点的方法"><a href="#用来获取页面节点的方法" class="headerlink" title="用来获取页面节点的方法"></a>用来获取页面节点的方法</h4><ul>
<li><p>获取页面的所有节点：document.all；</p>
</li>
<li><p>nodeName:节点名字</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>    elements =<span class="variable language_">document</span>.<span class="property">all</span>;</span><br><span class="line"><span class="title function_">alert</span>(elements);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> index = <span class="number">0</span>;index&lt;elements.<span class="property">length</span>;index++)&#123;</span><br><span class="line">   <span class="title function_">alert</span>(<span class="string">&quot;节点名：&quot;</span>+elements[index].<span class="property">nodeName</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
<li><p>通过标签属性找节点</p>
</li>
<li><ul>
<li><p>document.getElementById(“标签属性id”);</p>
</li>
<li><p>例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;test&quot;</span>&gt;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span>    a = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="title function_">alert</span>(a);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
</ul>
</li>
<li><p>通过标签名获取节点</p>
</li>
<li><ul>
<li><p>document.getElementsByTagName(标签名);</p>
</li>
<li><p>注：返回的是一个数组</p>
</li>
<li><p>例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="keyword">var</span>    a = <span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">     <span class="title function_">alert</span>(a);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
</ul>
</li>
<li><p>通过标签的Name属性获取节点</p>
</li>
<li><ul>
<li><p>document.getElementByName(“标签的name属性值”);</p>
</li>
<li><p>注：返回的是一个数组</p>
</li>
<li><p>例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div name=<span class="string">&quot;ElName&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span>    a = <span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&quot;ElName&quot;</span>);</span><br><span class="line">    <span class="title function_">alert</span>(a);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
</ul>
</li>
<li><p>通过关系找节点</p>
</li>
<li><ul>
<li>document可以通过一个节点，找到与它有关的节点</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><p>parentNode：获取当前元素的父节点</p>
</li>
<li><p>例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span>    a = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span>    f = a.<span class="property">parentNode</span>;</span><br><span class="line">    <span class="title function_">alert</span>(f);</span><br><span class="line">    f.<span class="property">innerHTML</span>=<span class="string">&quot;找到我了&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>childNodes：获取当前元素的所有下一级子元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">var</span>    a = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="keyword">var</span>    all = a.<span class="property">childNodes</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span>    index = <span class="number">0</span>;index&lt;all.<span class="property">length</span>;index++)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(all[index].<span class="property">nodeName</span>);</span><br><span class="line">    <span class="keyword">if</span>(all[index].<span class="property">nodeType</span>==<span class="number">1</span>)&#123;</span><br><span class="line">       all[index].<span class="property">style</span>.<span class="property">background</span>=<span class="string">&quot;red&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>nodeType常数值</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Node.ELEMENT_NODE</td>
<td>1</td>
<td>元素节点</td>
</tr>
<tr>
<td>Node.ATTRIBUTE_NODE</td>
<td>2</td>
<td>属性节点</td>
</tr>
<tr>
<td>Node.TEXT_NODE</td>
<td>3</td>
<td>文本节点</td>
</tr>
<tr>
<td>Node.CDATA_SECTION_NODE</td>
<td>4</td>
<td>字符数据节点（文本不会被解析器解析）</td>
</tr>
<tr>
<td>Node.ENTITY_REFERENCE_NODE</td>
<td>5</td>
<td>实体引用节点</td>
</tr>
<tr>
<td>Node.ENTITY_NODE</td>
<td>6</td>
<td>实体节点</td>
</tr>
<tr>
<td>Node.PROCESSING_INSTRUCTION_NODE</td>
<td>7</td>
<td>处理指令节点</td>
</tr>
<tr>
<td>Node.COMMENT_NODE</td>
<td>8</td>
<td>注释节点</td>
</tr>
<tr>
<td>Node.DOCUMENT_NODE</td>
<td>9</td>
<td>文档节点（DOM树的根节点）</td>
</tr>
<tr>
<td>Node.DOCUMENT_TYPE_NODE</td>
<td>10</td>
<td>向为文档定义的实体提供接口</td>
</tr>
<tr>
<td>Node.DOCUMENT_FRAGMENT_NODE</td>
<td>11</td>
<td>表示邻接节点和它们的子树。</td>
</tr>
<tr>
<td>Node.NOTATION_NODE</td>
<td>12</td>
<td>代表一个符号在DTD中的声明</td>
</tr>
</tbody></table>
<ul>
<li><p>firstChild：获取当前节点的第一个子节点</p>
</li>
<li><p>lastChild：获取当前节点的最后一个字节点</p>
</li>
<li><p>nextElementSibling：获取当前节点的下一个节点（兄弟节点）</p>
</li>
<li><p>previousElementSibling：获取当前节点的上一个节点（兄弟节点）</p>
</li>
<li><p>创建，删除，插入节点</p>
</li>
<li><ul>
<li><ul>
<li>创建：var 节点 &#x3D;  document.creatElement(“标签名”);创建新元素节点</li>
<li>节点 .setAttribute(“属性名”,”属性值”);</li>
<li>节点.appendChild(e);将某个节点添加到该节点的最后位置</li>
<li>节点.insertBefore(e,child);将某个新节点添加到该节点中，某个子节点之前</li>
<li>节点.removeChild(要删除的子节点)；删除指定的直接点</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>节点必须为直接父节点</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><p>例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>    trNode = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;tr&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> tdNode = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;td&quot;</span>);</span><br><span class="line">trNode.<span class="title function_">appendChild</span>(tdNode);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>利用节点操作css</p>
</li>
<li><ul>
<li>我们可以通过上边获取节点的方式获取到节点，我们可以通过节点对象去操作标签的的样式</li>
<li>语法</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>节点.style.要操作的样式&#x3D;”值”;</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="JavaScript中常用的事件"><a href="#JavaScript中常用的事件" class="headerlink" title="JavaScript中常用的事件"></a>JavaScript中常用的事件</h4><ul>
<li><p>js有可以通过某些方式触发函数的执行，我们把这种方式称之为事件</p>
</li>
<li><p>点击事件（onclick()）</p>
</li>
<li><ul>
<li><p>案例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">function</span>    <span class="title function_">sp</span>(<span class="params">elementid</span>)&#123;</span><br><span class="line"><span class="keyword">var</span>    a = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(elementid);</span><br><span class="line">a.<span class="property">style</span>.<span class="property">background</span>=<span class="string">&quot;red&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span>无标题文档<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"> </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>    <span class="attr">id</span>=<span class="string">&quot;test&quot;</span> <span class="attr">nzmd</span>=<span class="string">&quot;ElName&quot;</span>    <span class="attr">style</span>=<span class="string">&quot;height:100px;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">               <span class="tag">&lt;<span class="name">p</span>    <span class="attr">id</span>=<span class="string">&quot;elp&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;sp(&#x27;elp&#x27;)&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;ela&quot;</span>    <span class="attr">onclick</span>=<span class="string">&quot;sp(&#x27;ela&#x27;)&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
</ul>
</li>
<li><p>鼠标进入事件（onmouseover(),onmousemove()）</p>
</li>
<li><p>鼠标离开事件（onmouseout()）</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      <span class="selector-class">.box</span>&#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">height</span>: <span class="number">500px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">display</span>: none;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      <span class="selector-class">.boxOne</span>&#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">background-color</span>: red;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      <span class="selector-class">.boxTwo</span>&#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">background-color</span>: aqua;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">function</span> <span class="title function_">show</span>(<span class="params">idName</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//根据id获取要显示的元素</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> el = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(idName);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        el.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;block&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">function</span> <span class="title function_">hide</span>(<span class="params">idName</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> el = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(idName);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        el.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;none&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!--悬停事件：鼠标进入元素后触发--&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!--鼠标离开事件：鼠标离开元素后触发--&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">onmousemove</span>=<span class="string">&quot;show(&#x27;one&#x27;)&quot;</span> <span class="attr">onmouseout</span>=<span class="string">&quot;hide(&#x27;one&#x27;)&quot;</span>&gt;</span>导航一<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">onmousemove</span>=<span class="string">&quot;show(&#x27;two&#x27;)&quot;</span> <span class="attr">onmouseout</span>=<span class="string">&quot;hide(&#x27;two&#x27;)&quot;</span>&gt;</span>导航二<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box boxOne&quot;</span> <span class="attr">onmousemove</span>=<span class="string">&quot;show(&#x27;one&#x27;)&quot;</span> <span class="attr">onmouseout</span>=<span class="string">&quot;hide(&#x27;one&#x27;)&quot;</span> <span class="attr">id</span>=<span class="string">&quot;one&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box boxTwo&quot;</span> <span class="attr">onmousemove</span>=<span class="string">&quot;show(&#x27;two&#x27;)&quot;</span> <span class="attr">onmouseout</span>=<span class="string">&quot;hide(&#x27;two&#x27;)&quot;</span> <span class="attr">id</span>=<span class="string">&quot;two&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>获取焦点（onfocus()）</p>
</li>
<li><p>失去焦点（onblur()）</p>
</li>
<li><ul>
<li><p>案例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">function</span>    <span class="title function_">of</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">var</span>    a = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;eli&quot;</span>);</span><br><span class="line">   a.<span class="property">value</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span>    <span class="title function_">ob</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">var</span>    a = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;eli&quot;</span>);</span><br><span class="line">   a.<span class="property">value</span>=<span class="string">&quot;有字&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span>无标题文档<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"> </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span>    <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">onfocus</span>=<span class="string">&quot;of()&quot;</span> <span class="attr">onblur</span>=<span class="string">&quot;ob()&quot;</span>    <span class="attr">id</span>=<span class="string">&quot;eli&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">window</span>.<span class="property">onload</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span>    a = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;eli&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    a.<span class="property">onfocus</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        a.<span class="property">placeholder</span>=<span class="string">&quot;&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  a.<span class="property">onblur</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      a.<span class="property">placeholder</span>=<span class="string">&quot;有字&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span>无标题文档<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"> </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span>    <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;eli&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;hello&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>滚动事件(onscroll())</p>
</li>
<li><ul>
<li><p>案例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">               #test&#123;</span><br><span class="line"><span class="attr">width</span>:<span class="number">100</span>%;</span><br><span class="line"><span class="attr">height</span>:100px;</span><br><span class="line"><span class="attr">overflow</span>:scroll;</span><br><span class="line"><span class="attr">border</span>:1px    solid black;</span><br><span class="line">&#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">window</span>.<span class="property">onload</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">var</span>    a = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">a.<span class="property">onscroll</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">a.<span class="property">innerHTML</span>=<span class="string">&quot;aaaaaa&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span>无标题文档<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"> </span><br><span class="line">&lt;body&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>    <span class="attr">id</span>=<span class="string">&quot;test&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">               啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>键盘按下并松开（onkeypress()）</p>
</li>
<li><p>键盘按下事件（onkeydown()）</p>
</li>
<li><ul>
<li>onkeypress  和 onkeydown 是有区别，下面将讲解 onkeypress 与 onkeydown 事件的区别。 </li>
<li>onkeypress  事件在用户按下并放开任何字母数字键时发生。但是系统按钮（例如：箭头键、功能键）无法得到识别。 </li>
<li>onkeydown  事件在用户按下任何键盘键（包括系统按钮）时发生。 </li>
<li>具体区别： </li>
<li>\1.  一个放开一个没有放开，onkeydown 先于 onkeypress 发生。 </li>
<li>2.onkeypress  无法识别系统按钮。 </li>
<li>2.onkeydown  捕获的 keyCode 不区分字母大小，而 onkeypress 区分。</li>
</ul>
</li>
<li><p>键盘抬起事件（onkeyup()）</p>
</li>
<li><ul>
<li><p>案例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txt&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;txt&quot;</span>).<span class="property">onkeydown</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;键盘按下了&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;txt&quot;</span>).<span class="property">onkeyup</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;键盘抬起了&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
</ul>
</li>
<li><p>keyCode获取按下的键</p>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>数字值</strong></th>
<th><strong>实际键值</strong></th>
</tr>
</thead>
<tbody><tr>
<td>48到57</td>
<td>0到9</td>
</tr>
<tr>
<td>65到90</td>
<td>a到z（A到Z）</td>
</tr>
<tr>
<td>112到135</td>
<td>F1到F12</td>
</tr>
<tr>
<td>8</td>
<td>BackSpace（退格）</td>
</tr>
<tr>
<td>9</td>
<td>Tab</td>
</tr>
<tr>
<td>13</td>
<td>Enter（回车）</td>
</tr>
<tr>
<td>20</td>
<td>Caps_Lock（大写锁定）</td>
</tr>
<tr>
<td>32</td>
<td>Space（空格键）</td>
</tr>
<tr>
<td>37</td>
<td>Left（左箭头）</td>
</tr>
<tr>
<td>38</td>
<td>Up（上箭头）</td>
</tr>
<tr>
<td>39</td>
<td>Right（右箭头）</td>
</tr>
<tr>
<td>40</td>
<td>Down（下箭头）</td>
</tr>
</tbody></table>
<ul>
<li><p>案例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//页面的任何的位置.按下键盘,获取按键的值</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">onkeydown</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (e.<span class="property">keyCode</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">81</span>:</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;您按下的是Q&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">87</span>:</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;您按下的是W&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">69</span>:</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;您按下的是E&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">82</span>:</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;您按下的是R&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
<li><p>onmousedown &#x2F; onmouseup  鼠标按下&#x2F;抬起事件</p>
</li>
<li><ul>
<li>当鼠标左键或右键按下或者抬起的时候触发</li>
<li>按下或抬起滚动轮也会触发，滑动滚动轮不能触发</li>
<li>如果鼠标比较高级，有其他按键的情况下，按下或抬起也会触发</li>
<li>案例</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="selector-tag">div</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">            <span class="attribute">width</span>: <span class="number">50px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">            <span class="attribute">height</span>: <span class="number">50px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">            <span class="attribute">background-color</span>: pink;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;dv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;dv&quot;</span>).<span class="property">onmousedown</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;鼠标按下了&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;dv&quot;</span>).<span class="property">onmouseup</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;鼠标抬起了&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>html基础（二)(html5)</title>
    <url>/2022/07/15/html%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C)(html5)/</url>
    <content><![CDATA[<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.iisp.com%2Fimage%2F20161011%2F20161011180825_78244.jpg&refer=http%3A%2F%2Fimg.iisp.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1659877024&t=24bae5fadeb346539de3c527885be3df" alt="img"></p>
<span id="more"></span>

<h1 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h1><h2 id="新增元素"><a href="#新增元素" class="headerlink" title="新增元素"></a>新增元素</h2><h4 id="新增的结构元素"><a href="#新增的结构元素" class="headerlink" title="新增的结构元素"></a>新增的结构元素</h4><ul>
<li>&lt;section&gt;元素</li>
</ul>
<p>&lt;section&gt;元素表示页面中的内容区块，如：页眉，页脚，章节等部分</p>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>区域一<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>这里是区域一的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">h1</span>&gt;</span>区域二<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>这里是区域二的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>&lt;article&gt;元素</li>
</ul>
<p>&lt;article&gt;元素表示页面中的一块与上下文不相关的独立内容，如：新闻页中诸多文章中的某篇文章</p>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h1</span>&gt;</span>两个“万岁”<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>“伟大、光荣、正确的中国共产党万岁！”<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span>“伟大、光荣、英雄的中国人民万岁！”<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>&lt;aside&gt;元素</li>
</ul>
<p>&lt;aside&gt;表示&lt;article&gt;元素的内容之外的，它的内容应该与附近内容相关</p>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>神州十二号飞船成功升空<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h4</span>&gt;</span>飞船抵达中国空间站<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>6月19日上午，神舟十二号飞船抵达距离天和核心舱200米的停留点，开始进行对接准备。</span><br><span class="line">    通过使用最先进的快速交会对接自动化技术</span><br><span class="line">    这一切都要归功于从一次次太空飞行中总结的的经验。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>&lt;header&gt;元素</li>
</ul>
<p>&lt;header&gt;元素表示页面中的一个内容块或整个页面的标题</p>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>飞船抵达中国空间站<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      6月19日上午，神舟十二号飞船抵达距离天和核心舱200米的停留点，开始进行对接准备。</span><br><span class="line">      通过使用最先进的快速交会对接自动化技术</span><br><span class="line">      这一切都要归功于从一次次太空飞行中总结的的经验。</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>&lt;footer&gt;元素</li>
</ul>
<p>&lt;footer&gt;元素表示整个页面或页面中一个区域内的脚注，一般包含作者的基本信息</p>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="symbol">&amp;copy;</span>环球网<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      	<span class="tag">&lt;<span class="name">p</span>&gt;</span>发表时间：7-12<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>&lt;nav&gt;元素</li>
</ul>
<p>&lt;nav&gt;元素通常在内嵌套&lt;a&gt;标签表示页面的导航链接部分</p>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/html/&quot;</span>&gt;</span>HTML<span class="tag">&lt;/<span class="name">a</span>&gt;</span> |</span><br><span class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/css/&quot;</span>&gt;</span>CSS<span class="tag">&lt;/<span class="name">a</span>&gt;</span> |</span><br><span class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/js/&quot;</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">a</span>&gt;</span> |</span><br><span class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/jquery/&quot;</span>&gt;</span>jQuery<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>&lt;video&gt;元素</p>
</li>
<li><ul>
<li>&lt;video&gt;元素用来插入视频</li>
<li>&lt;video&gt;元素仅支持MP4，WebM，Ogg视频格式</li>
<li>元素属性表：</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.runoob.com/tags/att-video-autoplay.html">autoplay</a></td>
<td>autoplay</td>
<td>如果出现该属性，则视频在就绪后马上播放。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/tags/att-video-controls.html">controls</a></td>
<td>controls</td>
<td>如果出现该属性，则向用户显示控件，比如播放按钮。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/tags/att-video-height.html">height</a></td>
<td>pixels</td>
<td>设置视频播放器的高度。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/tags/att-video-loop.html">loop</a></td>
<td>loop</td>
<td>如果出现该属性，则当媒介文件完成播放后再次开始播放。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/tags/att-video-muted.html">muted</a></td>
<td>muted</td>
<td>如果出现该属性，视频的音频输出为静音。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/tags/att-video-poster.html">poster</a></td>
<td>URL</td>
<td>规定视频正在下载时显示的图像，直到用户点击播放按钮。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/tags/att-video-preload.html">preload</a></td>
<td>autometadatanone</td>
<td>如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/tags/att-video-src.html">src</a></td>
<td>URL</td>
<td>要播放的视频的 URL。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/tags/att-video-width.html">width</a></td>
<td>pixels</td>
<td>设置视频播放器的宽度。</td>
</tr>
</tbody></table>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">width</span>=<span class="string">&quot;320&quot;</span> <span class="attr">height</span>=<span class="string">&quot;240&quot;</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;movie.mp4&quot;</span>  <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;movie.ogg&quot;</span>  <span class="attr">type</span>=<span class="string">&quot;video/ogg&quot;</span>&gt;</span></span><br><span class="line">   您的浏览器不支持 HTML5 video 标签。</span><br><span class="line"> <span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>&lt;audio&gt;元素</p>
</li>
<li><ul>
<li>&lt;audio&gt;元素用来插入音频</li>
<li>&lt;audio&gt;元素仅支持Ogg和MP3格式</li>
<li>元素属性表</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.runoob.com/tags/att-audio-autoplay.html">autoplay</a></td>
<td>autoplay</td>
<td>如果出现该属性，则音频在就绪后马上播放。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/tags/att-audio-controls.html">controls</a></td>
<td>controls</td>
<td>如果出现该属性，则向用户显示音频控件（比如播放&#x2F;暂停按钮）。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/tags/att-audio-loop.html">loop</a></td>
<td>loop</td>
<td>如果出现该属性，则每当音频结束时重新开始播放。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/tags/att-audio-muted.html">muted</a></td>
<td>muted</td>
<td>如果出现该属性，则音频输出为静音。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/tags/att-audio-preload.html">preload</a></td>
<td>autometadatanone</td>
<td>规定当网页加载时，音频是否默认被加载以及如何被加载。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/tags/att-audio-src.html">src</a></td>
<td><em>URL</em></td>
<td>规定音频文件的 URL。</td>
</tr>
</tbody></table>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;music.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/ogg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;music.mp3&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/mpeg&quot;</span>&gt;</span></span><br><span class="line">您的浏览器不支持 audio 元素。</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>&lt;mark&gt;元素</li>
</ul>
<p>&lt;mark&gt;元素主要用来在视觉上向用户呈现哪些需要突出显示或高亮显示的文字，一般用在搜索结果中向用户高亮显示搜索关键词</p>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>神舟十二号航天员乘组圆满完成空间站阶段<span class="tag">&lt;<span class="name">mark</span>&gt;</span>首次出舱<span class="tag">&lt;/<span class="name">mark</span>&gt;</span>活动全部既定任务<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>&lt;ruby&gt;元素</li>
</ul>
<p>&lt;ruby&gt;表示中文注音或字符</p>
<ul>
<li>&lt;rt&gt;元素</li>
</ul>
<p>&lt;rt&gt;元素与&lt;ruby&gt;配合使用用来解释或发音</p>
<ul>
<li>&lt;rp&gt;元素</li>
</ul>
<p>&lt;rp&gt;元素与&lt;ruby&gt;一起使用，以定义不支持&lt;ruby&gt;元素的浏览器显示内容，以括号的形式出现如：汉字(Han Zi)</p>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ruby</span>&gt;</span></span><br><span class="line">  汉 <span class="tag">&lt;<span class="name">rp</span>&gt;</span>(<span class="tag">&lt;/<span class="name">rp</span>&gt;</span><span class="tag">&lt;<span class="name">rt</span>&gt;</span>Han<span class="tag">&lt;/<span class="name">rt</span>&gt;</span><span class="tag">&lt;<span class="name">rp</span>&gt;</span>)<span class="tag">&lt;/<span class="name">rp</span>&gt;</span></span><br><span class="line">  字 <span class="tag">&lt;<span class="name">rp</span>&gt;</span>(<span class="tag">&lt;/<span class="name">rp</span>&gt;</span><span class="tag">&lt;<span class="name">rt</span>&gt;</span>zi<span class="tag">&lt;/<span class="name">rt</span>&gt;</span><span class="tag">&lt;<span class="name">rp</span>&gt;</span>)<span class="tag">&lt;/<span class="name">rp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ruby</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>&lt;details&gt;元素</li>
</ul>
<p>&lt;details&gt;元素表示用户要求得到的细节信息，与&lt;summary&gt;配合使用，&lt;summary&gt;提供标题或图例，用户点击标题时，会显示户细节信息，&lt;summary&gt;元素应该是&lt;details&gt;元素的第一个元素</p>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">summary</span>&gt;</span>空间站<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line">        空间站（space station）又称太空站、航天站。</span><br><span class="line">      	是一种在近地轨道长时间运行、可供多名航天员巡访、长期工作和生活的载人航天器。</span><br><span class="line">      	空间站分为单模块空间站和多模块空间站两种。</span><br><span class="line">      	单模块空间站可由航天运载器一次发射入轨，多模块空间站则由航天运载器分批将各模块送入轨道，在太空中将各模块组装而成。</span><br><span class="line">      	在空间站中要有人能够生活的一切设施，空间站不具备返回地球的能力。</span><br><span class="line">    <span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="全局属性"><a href="#全局属性" class="headerlink" title="全局属性"></a>全局属性</h2><h4 id="contentEditable属性"><a href="#contentEditable属性" class="headerlink" title="contentEditable属性"></a>contentEditable属性</h4><p>contentEditable属性由微软开发并被其它浏览器反编译投入引用的一个全局属性，该属性允许用户编辑元素内容，该属性是一个布尔值的属性，可以被指定false或true</p>
<p>该属性默认inherit（继承）状态，属性为true时，元素被指定为允许编辑；属性为false时，元素被指定为不允许编辑状态；未指定值时，则由inherit状态决定，如果父元素是可编辑元素，则该元素也可编辑</p>
<p>在编辑完成后，如果想要保存其中的内容，只能把该元素的innerHTML发送到服务器端进行保存，目前还没有特别的API来保存编辑后的元素内容</p>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">contenteditable</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是预编译内容<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是预编译内容<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是预编译内容<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://files.catbox.moe/p2ks7u.png"></p>
<h4 id="designMode属性"><a href="#designMode属性" class="headerlink" title="designMode属性"></a>designMode属性</h4><p>designModel属性用来指定整个页面是否可编辑，当页面可编辑时，页面中任何支持contenteditable属性的元素都变成可编辑状态。该属性只能在JavaScript脚本里被编辑修改，该属性有两个值 “on”或“off”，当属性被指定为“on”时，页面为可编辑状态，为“off”时，页面不可编辑</p>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>designMode<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="property">designMode</span>=<span class="string">&quot;on&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是原有内容<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是原有内容<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是原有内容<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(0)&quot;</span>&gt;</span>链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://files.catbox.moe/lxs8pj.png"></p>
<h4 id="hidden属性"><a href="#hidden属性" class="headerlink" title="hidden属性"></a>hidden属性</h4><p>在HTML 5中，所有的元素都允许使用一个hidden属性。该属性类似于input元素中的 hidden元素，功能是通知浏览器不渲染该元素。使该元素处干不可见状态。但是元素中的内容还是浏览器创建的，也就是说页面装载后允许使用JavaScript脚本将该属性取消，取消后该元素变为可见状态，同时元素中的内容也即时显示出来。Hidden属性是一个布尔值的属性。当设为true时，元素处于不可见状态;当设为false时，元素处于可见状态</p>
]]></content>
  </entry>
  <entry>
    <title>html基础（二）（表单）</title>
    <url>/2022/07/15/html%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C)(%E8%A1%A8%E5%8D%95)/</url>
    <content><![CDATA[<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.iisp.com%2Fimage%2F20161011%2F20161011180825_78244.jpg&refer=http%3A%2F%2Fimg.iisp.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1659877024&t=24bae5fadeb346539de3c527885be3df" alt="img"></p>
<span id="more"></span>

<h1 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h1><p>表单是用来显示，收集，提交用户信息，表单在网页中主要负责数据采集功能，一个表单由三个基本部分组成：表单元素、表单域、按钮</p>
<h2 id="表单-1"><a href="#表单-1" class="headerlink" title="表单"></a>表单</h2><p>表单是一个包含表单元素的区域，使用&lt;form&gt;…&lt;&#x2F;form&gt;定义，通过在表单中添加对应的表单元素使得用户可以在网页上输入数据</p>
<p>&lt;form&gt;中含有诸多属性用来规定表单的格式，详见下表</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.runoob.com/tags/att-form-accept-charset.html">accept-charset</a></td>
<td><em>character_set</em></td>
<td>规定服务器可处理的表单数据字符集。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/tags/att-form-action.html">action</a></td>
<td><em>URL</em></td>
<td>规定当提交表单时向何处发送表单数据。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/tags/att-form-autocomplete.html">autocomplete</a></td>
<td>onoff</td>
<td>规定是否启用表单的自动完成功能。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/tags/att-form-enctype.html">enctype</a></td>
<td>application&#x2F;x-www-form-urlencodedmultipart&#x2F;form-datatext&#x2F;plain</td>
<td>规定在向服务器发送表单数据之前如何对其进行编码。（适用于 method&#x3D;”post” 的情况）</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/tags/att-form-method.html">method</a></td>
<td>getpost</td>
<td>规定用于发送表单数据的 HTTP 方法。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/tags/att-form-name.html">name</a></td>
<td><em>text</em></td>
<td>规定表单的名称。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/tags/att-form-novalidate.html">novalidate</a></td>
<td>novalidate</td>
<td>如果使用该属性，则提交表单时不进行验证。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/tags/att-form-target.html">target</a></td>
<td>_blank_self_parent_top</td>
<td>规定在何处打开 action URL。</td>
</tr>
</tbody></table>
<h2 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a>表单元素</h2><h4 id="输入标签"><a href="#输入标签" class="headerlink" title="输入标签"></a>输入标签</h4><p>多数情况下使用的表单元素是输入标签&lt;input&gt;</p>
<p>元素内输入类型有标签中的type属性定义，常用的元素类型如下表：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>type&#x3D;”text”</td>
<td>单行文本框，一般用来以明文的方式输入数据，如：用户名</td>
</tr>
<tr>
<td>type&#x3D;”password”</td>
<td>密码框，密码字符不会以明文方式显示，而是以“*”，“·”替代</td>
</tr>
<tr>
<td>type&#x3D;”color”</td>
<td>色盘，可以通过鼠标点击选择一个颜色，其值为十六进制值 如：#ff6700</td>
</tr>
<tr>
<td>type&#x3D;”radio”</td>
<td>单选按钮，通过在标签中添加相同的name属性值，以多选一的效果 如：性别</td>
</tr>
<tr>
<td>type&#x3D;”checkbox”</td>
<td>复选按钮，可以同时选中多个数据  如：爱好</td>
</tr>
<tr>
<td>type&#x3D;”date”</td>
<td>日期类型，规定输入的数据类型必须为日期类型，谷歌内核的浏览器可以唤出浏览器自带的日期的控件选择日期 日期格式：yyyy-MM-dd</td>
</tr>
<tr>
<td>type&#x3D;”time”</td>
<td>时间类型，规定输入的数据必须为时间</td>
</tr>
<tr>
<td>type&#x3D;”month”</td>
<td>月类型，规定输入的数据类型必须为月份</td>
</tr>
<tr>
<td>type&#x3D;”file”</td>
<td>文件类型，点击后可在本地选择文件</td>
</tr>
<tr>
<td>type&#x3D;”number”</td>
<td>数字类型，外观与text文本框相似，但不允许输入数值以外的数据</td>
</tr>
<tr>
<td>type&#x3D;”range”</td>
<td>数字范围选择器，具有max与min属性，使用滑动条的方式制定数值</td>
</tr>
<tr>
<td>type&#x3D;”email”</td>
<td>邮箱类型，外观与文本框相似，其值必须为邮箱格式，浏览器会对其内容做简单的验证</td>
</tr>
<tr>
<td>type&#x3D;”url”</td>
<td>url类型，外观与文本框相似，其中必须为url，浏览器会对其内容做简单验证</td>
</tr>
<tr>
<td>type&#x3D;”hidden”</td>
<td>隐藏域，表单提供一个不在界面显示的文本域</td>
</tr>
</tbody></table>
<h2 id="下拉标签"><a href="#下拉标签" class="headerlink" title="下拉标签"></a>下拉标签</h2><ul>
<li><p>&lt;select&gt;元素为表单控件，用于在表单中接收数据</p>
</li>
<li><ul>
<li>&lt;select&gt;元素可创建单选或多选菜单</li>
<li>&lt;option&gt;标签定义了菜单中的可选项</li>
</ul>
</li>
<li><p>下拉列表支持属性</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.runoob.com/tags/att-select-autofocus.html">autofocus</a></td>
<td>autofocus</td>
<td>规定在页面加载时下拉列表自动获得焦点。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/tags/att-select-disabled.html">disabled</a></td>
<td>disabled</td>
<td>当该属性为 true 时，会禁用下拉列表。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/tags/att-select-form.html">form</a></td>
<td><em>form_id</em></td>
<td>定义 select 字段所属的一个或多个表单。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/tags/att-select-multiple.html">multiple</a></td>
<td>multiple</td>
<td>当该属性为 true 时，可选择多个选项。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/tags/att-select-name.html">name</a></td>
<td><em>text</em></td>
<td>定义下拉列表的名称。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/tags/att-select-required.html">required</a></td>
<td>required</td>
<td>规定用户在提交表单前必须选择一个下拉列表中的选项。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/tags/att-select-size.html">size</a></td>
<td><em>number</em></td>
<td>规定下拉列表中可见选项的数目。</td>
</tr>
</tbody></table>
<h4 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h4><ul>
<li>按钮在网页中一般用于提交，重置页面数据，也可以与javascript配置做一些交互响应事件</li>
<li>在HTML中按钮一般使用&lt;input&gt;或&lt;button&gt;来定义</li>
<li>按钮属性</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.runoob.com/tags/att-button-autofocus.html">autofocus</a></td>
<td>autofocus</td>
<td>规定当页面加载时按钮应当自动地获得焦点。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/tags/att-button-disabled.html">disabled</a></td>
<td>disabled</td>
<td>规定应该禁用该按钮。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/tags/att-button-form.html">form</a></td>
<td><em>form_id</em></td>
<td>规定按钮属于一个或多个表单。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/tags/att-button-formaction.html">formaction</a></td>
<td><em>URL</em></td>
<td>规定当提交表单时向何处发送表单数据。覆盖 form 元素的 action 属性。该属性与 type&#x3D;”submit” 配合使用。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/tags/att-button-formenctype.html">formenctype</a></td>
<td>application&#x2F;x-www-form-urlencodedmultipart&#x2F;form-datatext&#x2F;plain</td>
<td>规定在向服务器发送表单数据之前如何对其进行编码。覆盖 form 元素的 enctype 属性。该属性与 type&#x3D;”submit” 配合使用。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/tags/att-button-formmethod.html">formmethod</a></td>
<td>get，post</td>
<td>规定用于发送表单数据的 HTTP 方法。覆盖 form 元素的 method 属性。该属性与 type&#x3D;”submit” 配合使用。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/tags/att-button-formnovalidate.html">formnovalidate</a></td>
<td>formnovalidate</td>
<td>如果使用该属性，则提交表单时不进行验证。覆盖 form 元素的 novalidate 属性。该属性与 type&#x3D;”submit” 配合使用。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/tags/att-button-formtarget.html">formtarget</a></td>
<td>_blank_self_parent_top<em>framename</em></td>
<td>规定在何处打开 action URL。覆盖 form 元素的 target 属性。该属性与 type&#x3D;”submit” 配合使用。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/tags/att-button-name.html">name</a></td>
<td><em>name</em></td>
<td>规定按钮的名称。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/tags/att-button-type.html">type</a></td>
<td>buttonresetsubmit</td>
<td>规定按钮的类型。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/tags/att-button-value.html">value</a></td>
<td><em>text</em></td>
<td>规定按钮的初始值。可由脚本进行修改。</td>
</tr>
</tbody></table>
<ul>
<li><p>&lt;button&gt;与&lt;input&gt;按钮区别</p>
</li>
<li><ul>
<li>&lt;button&gt;按钮如果不设置type属性，在不同浏览器中可能会提交不同值</li>
<li>&lt;button&gt;按钮是成对出现的，可放置文本，图像等，&lt;input&gt;标签只能通过value属性为其设置文本</li>
<li>需要注意的是虽然&lt;button&gt;按钮可以嵌套其它标签，但不能再去嵌套按钮</li>
</ul>
</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            文本：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            颜色色：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;color&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>单选：</span><br><span class="line">            男<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span>&gt;</span></span><br><span class="line">            女<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>复选：</span><br><span class="line">            爱好1<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span></span><br><span class="line">            爱好2<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span></span><br><span class="line">            爱好3<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span></span><br><span class="line">            爱好4<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            下拉：<span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> &gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>[请输入...]<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>选择数据一<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>选择数据二<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">select</span>&gt;</span>县</span><br><span class="line">            <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> &gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>[请输入...]<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>选择数据一<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>选择数据二<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">select</span>&gt;</span>村</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            日期：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            时间：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;time&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            月份：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;month&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            文件：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            数字：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            数字范围：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;range&quot;</span> <span class="attr">max</span>=<span class="string">&quot;10&quot;</span> <span class="attr">min</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            邮箱：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            地址：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;url&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            隐藏：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;input提交按钮&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;input重置按钮&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;input按钮&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>button提交按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span>button重置按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span>&gt;</span>button按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="HTML5-表单增强"><a href="#HTML5-表单增强" class="headerlink" title="HTML5 表单增强"></a>HTML5 表单增强</h2><h4 id="form属性"><a href="#form属性" class="headerlink" title="form属性"></a>form属性</h4><p>在HTML4中，表单内的从属元素必须书写在表单内部，但在HTML5中，可以把它书写在页面的任意地方，然后给该元素指定一个form属性，属性值为该表单的id，这样就可以声明该元素从属于指定的表单</p>
<p>示例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;formTest&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">form</span>=<span class="string">&quot;formTest&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码解析：</p>
<ol>
<li>第一个input标签从属form表单，它被书写在form表单内部，所以用不着对它指定form属性</li>
<li>第二个input表单被书写在form之外，但想要它从属form，这时就可以为其添加form属性并指定表单id让它从属form表单</li>
</ol>
<h4 id="formaction属性"><a href="#formaction属性" class="headerlink" title="formaction属性"></a>formaction属性</h4><p>在HTML 4中，一个表单内的所有元素都只能通过表单的action属性统一提交到另一个页面，而在HTML 5中可以给所有的提交按钮，诸如&lt;input type&#x3D;”submit”&gt;、&lt;inputtype&#x3D;”image”&gt;、&lt;button type&#x3D;”submit”&gt;都增加不同的formaction属性，使得点击不同的按钮，可以将表单提交到不同的页面，formaction属性的使用方法如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;testform&quot;</span> <span class="attr">action</span>=<span class="string">&quot; serve.jsp&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;s1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;v1&quot;</span> <span class="attr">formaction</span>=<span class="string">&quot;s1.jsp&quot;</span>&gt;</span>提交到s1</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;s2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;v2&quot;</span> <span class="attr">formaction</span>=<span class="string">&quot;s2.jsp&quot;</span>&gt;</span>提交到s2</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;s3&quot;</span> <span class="attr">value</span>=<span class="string">&quot;v3&quot;</span> <span class="attr">formaction</span>=<span class="string">&quot;s3.jsp&quot;</span>&gt;</span>提交到s3</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>= <span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注：该属性目前支持的浏览器并不多，慎重使用</strong></p>
<h4 id="list属性"><a href="#list属性" class="headerlink" title="list属性"></a>list属性</h4><p>在HTML 5中，为单行文本框(&lt;input type&#x3D;”text”&gt;)增加了一个list属性，该属性的值为某个datalist元素的id。datalist元素也是HTML 5中新增元素，该元素类似于选择框( select&gt;)，但是当用户想要设定的值不在选择列表之内时，允许其自行输入。该元素本身并不显示，而是当文本框获得焦点时以提示输入的方式显示。为了避免在没有支持该元素的浏览器上出现显示错误，可以用CSS等将它设定为不显示。</p>
<p>示例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    text: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot; greeting&quot;</span> <span class="attr">list</span>=<span class="string">&quot;greetings&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">&quot;greetings&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Good Morning&quot;</span>&gt;</span>Good Morning<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Hello&quot;</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Good Afternoon&quot;</span>&gt;</span>Good Afternoon<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="autocomplete属性"><a href="#autocomplete属性" class="headerlink" title="autocomplete属性"></a>autocomplete属性</h4><p>辅助输入所用的自动完成功能，是一个节省输入时间，同时也十分方便的功能。在HTML5之前，因为谁都可以看见输入的值，所以存在安全隐患，但只要使用autocomplete属性，安全性就可以得到很好的控制。.</p>
<p>对于autocomplete属性，可以指定“on”、“off”与“”(不指定）这三种值。不指定时，使用浏览器的默认值(取决于各浏览器的决定)。把该属性设为on时，可以显式指定候补输入的数据列表。使用detalist元素与list属性提供候补输入的数据列表，自动完成时，可以将该datalist元素中的数据作为候补输入的数据在文本框中自动显示。autocomplete属性的使用方法如下所示。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    text: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;greeting&quot;</span> <span class="attr">list</span>=<span class="string">&quot;greetings&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;on&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">&quot;greetings&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Good Morning&quot;</span>&gt;</span>Good Morning<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Hello&quot;</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Good Afternoon&quot;</span>&gt;</span>Good Afternoon<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="output标签"><a href="#output标签" class="headerlink" title="output标签"></a>output标签</h4><ul>
<li><p>output为H5的新增标签，用来定义不同类型的输出，长和form表单一起使用，用来输出显示计算结果</p>
</li>
<li><p>语法</p>
</li>
<li><p>标签属性</p>
</li>
<li><ul>
<li>for：定义输出域相关的一个或多个元素，以空格隔开；</li>
<li>form：定义输入字段所属的一个或多个表单，以空格隔开；</li>
<li>name：定义对象的唯一名称（表单提交时使用）。</li>
</ul>
</li>
</ul>
<p>示例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">oninput</span>=<span class="string">&quot;o.value=parseInt(a.value)&quot;</span>&gt;</span></span><br><span class="line">        选择数字范围：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;range&quot;</span> <span class="attr">min</span>=<span class="string">&quot;0&quot;</span> <span class="attr">max</span>=<span class="string">&quot;100&quot;</span> <span class="attr">id</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">output</span> <span class="attr">id</span>=<span class="string">&quot;o&quot;</span> &gt;</span>50<span class="tag">&lt;/<span class="name">output</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>示例二</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">oninput</span>=<span class="string">&quot;x.value=parseInt(a.value)+parseInt(b.value)&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">id</span>=<span class="string">&quot;a&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>&gt;</span> +</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">id</span>=<span class="string">&quot;b&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>&gt;</span> =</span><br><span class="line">        <span class="tag">&lt;<span class="name">output</span> <span class="attr">name</span>=<span class="string">&quot;x&quot;</span> <span class="attr">for</span>=<span class="string">&quot;a b&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">output</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注：</p>
<p>oninput为表单事件，表示当对元素输入数据时触发</p>
<p>parseInt为javascript函数，用来解析一个字符串，并返回一个整数</p>
<h4 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h4><p>在H5中，新增了大量在提交时对表单与表单内新增元素进行有效性验证的功能</p>
<h5 id="自动验证"><a href="#自动验证" class="headerlink" title="自动验证"></a><strong>自动验证</strong></h5><p>在H5中，新增的一些表单元素本身就带有简单的提交格式验证，如邮箱（email）就有固定的格式“@”，“.”，但普通的表单元素就要通过对元素使用属性的方法，来实现在表单提交时执行自动验证的功能</p>
<p><img src="https://files.catbox.moe/wz7j06.png"></p>
<p>普通表单元素的验证属性</p>
<ol>
<li>required属性</li>
</ol>
<p>HTML 5中新增的required属性可以应用在大多数输入元素上（除了隐藏元素、图片元素按钮上)。在提交时，如果元素中内容为空白，则不允许提交，同时在浏览器中显示信息提示文字，提示用户这个元素中必须输入内容。</p>
<p><img src="https://files.catbox.moe/d3k2br.png"></p>
<ol>
<li>pattern属性</li>
</ol>
<p>之前提到的一些新增的input元素，譬如email、number、url等，要求输入内容符合–定的格式，对input元素使用pattern属性，并且将属性值设为某个格式的正则表达式，在提交时会检查其内容是否符合给定格式。当输入的内容不符合给定格式时，则不允许提交，同时在浏览器中显示信息提示文字，提示输入的内容必须符合给定格式。譬如下面所示，要求输入内容为三个大写字母。</p>
<p><img src="https://files.catbox.moe/nbjzlx.png"></p>
<ol>
<li>min属性与max属性</li>
</ol>
<p>min与max这两个属性是数值类型或日期类型的input元素的专用属性，它们限制了在input元素中输入的数值与日期的范围。</p>
<p><img src="https://files.catbox.moe/7n6qhv.png"></p>
]]></content>
  </entry>
  <entry>
    <title>CSS样式表与选择器</title>
    <url>/2022/07/15/CSS%E6%A0%B7%E5%BC%8F%E8%A1%A8%E4%B8%8E%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/35eqd6.png"></p>
<span id="more"></span>

<h1 id="样式表与选择器"><a href="#样式表与选择器" class="headerlink" title="样式表与选择器"></a>样式表与选择器</h1><h2 id="样式表"><a href="#样式表" class="headerlink" title="样式表"></a>样式表</h2><p>css 是 web 标准中的表现标准，专门用来对网页标签进行布局和设置样式的一门语言，目前使用css3，css 又名层叠样式表.<br>样式表表示CSS代码的位置，目前CSS样式表分以下三类：</p>
<h3 id="内联样式表"><a href="#内联样式表" class="headerlink" title="内联样式表"></a>内联样式表</h3><p>●顾名思义内联样式写在标签中（在开始标签中添加style&#x3D;””属性，在双引号中添加样式属性，属性和属性之间用分号隔开）<br>●格式<br>&lt;开始标签 style&#x3D;”样式属性:属性值;样式属性:属性值;………”&gt;标签内容&lt;&#x2F;结束标签&gt;</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color: red&quot;</span>&gt;</span>内联样式<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h4><ul>
<li><p>写在html内部的样式（在html的头文件中嵌套&lt;style&gt;标签，在style标签中通过特有格式添加基本样式）</p>
</li>
<li><p>格式</p>
<p><img src="https://files.catbox.moe/93hfyf.png"></p>
</li>
</ul>
<p>示例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.demo</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span>内联样式<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h4><ul>
<li><p>外部样式表就是在html文件外创建一个后缀为.css的文件，然后html标签中使用link标签将外部.css文件引入到html文件中去使用</p>
</li>
<li><p>格式</p>
</li>
<li><p>创建外部样式表文件</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styleCss.css&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注：当三种样式表出现冲突时，三种样式表的优先级为  <strong>内联样式表&gt;内部样式表&gt;外部样式表</strong></p>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>选择器是CSS 中一个重要的内容。使用它可以大幅度提高开发人员书写或修改样式表时的工作效率。</p>
<h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h4><p>在HTML中，通过各种各样的属性，我们可以给元素增加很多附加信息。例如，通过width属性，我们可以指定div元素的宽度，通过id属性，我们可以将不同的div元素进行区分，并且通过JavaScript来控制这个div元素的内容和状态。</p>
<h5 id="类选择器-class选择器"><a href="#类选择器-class选择器" class="headerlink" title="类选择器(class选择器)"></a><strong>类选择器(class选择器)</strong></h5><ul>
<li>在开始标签中添加class&#x3D;””属性，并命名，在样式表中使用“.选择器名称{……}”可为该元素添加想要添加的样式属性</li>
<li>当然样式表中的样式与标签中的class&#x3D;”选择名称”，可以理解为是标签引用了选择器中的样式，一个标签中可以引用多个类选择器样式，名称和名称之间用空格隔开</li>
<li>格式</li>
</ul>
<table>
<thead>
<tr>
<th>元素</th>
<th>样式表</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;开始标签 class&#x3D;”ClassName”&gt;元素内容&lt;&#x2F;结束标签&gt;</td>
<td>.ClassName{   样式属性:属性值;   样式属性:属性值;   ……}</td>
</tr>
<tr>
<td>&lt;开始标签 class&#x3D;”ClassName  ClassNameTest”&gt;元素内容&lt;&#x2F;结束标签&gt;</td>
<td>.ClassName{   样式属性:属性值;   样式属性:属性值;   ……}.ClassNameTest{   样式属性:属性值;   样式属性:属性值;   ……}</td>
</tr>
</tbody></table>
<p>类选择器样式是可以重复使用的，也就是说一个样式可以由多个元素共同使用，这样可以提供代码的复用性，但是需要注意在做网页结构布局的时候对于结构不要过多的复用代码，保不准后期需要更改结构模块，复用的代码可以是一些不更改结构的样式，如文字，颜色，等</p>
<p>示例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.demo</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.color1</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.color2</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#3bee17</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo color1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo color2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a><strong>id选择器</strong></h5><ul>
<li>在开始标签中添加id&#x3D;””属性，并命名，在样式表中使用“#选择器名称{……}”可为该元素添加想要添加的样式属性</li>
<li>需要注意的是id选择器是唯一的，不可复用的，它是一个元素的唯一标识</li>
</ul>
<table>
<thead>
<tr>
<th>元素</th>
<th>样式表</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;开始标签 id&#x3D;”ClassName”&gt;元素内容&lt;&#x2F;结束标签&gt;</td>
<td>#ClassName{   样式属性:属性值;   样式属性:属性值;   ……}</td>
</tr>
</tbody></table>
<p>示例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#myElement</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myElement&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="通配选择器"><a href="#通配选择器" class="headerlink" title="通配选择器"></a><strong>通配选择器</strong></h5><ul>
<li>[att*&#x3D;val]选择器</li>
</ul>
<p>[att*&#x3D;val]属性选择器的含义是:如果元素用att表示的属性之属性值中包含用val指定的字符的话，则该元素使用这个样式。</p>
<ul>
<li>[att^&#x3D;val]选择器</li>
</ul>
<p>[att^&#x3D;val]属性选择器的含义是:如果元素用att表示的属性之属性值的开头字符为用val指定的字符的话，则该元素使用这个样式。</p>
<ul>
<li>[att$&#x3D;val]选择器</li>
</ul>
<p>[att$&#x3D;val]属性选择器的含义是:如果元素用att表示的属性之属性值的结尾字符为用val指定的字符的话，则该元素使用这个样式。</p>
<p>注：使用该属性时必须在指定匹配字符前加上“\”转义符，不能是纯数字</p>
<p>示例1</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="comment">/*只要包含e字符，全部添加一下样式*/</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-attr">[class*=e]</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;Element&quot;</span>&gt;</span>这是元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span>这是文字<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;Element2&quot;</span>&gt;</span>这是元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo1&quot;</span>&gt;</span>这是文字<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;Element3&quot;</span>&gt;</span>这是元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo2&quot;</span>&gt;</span>这是文字<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;Element4&quot;</span>&gt;</span>这是元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>示例2</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/*只要d开头，就添加以下样式*/</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-attr">[class^=d]</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;Element&quot;</span>&gt;</span>这是元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span>这是文字<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;Element2&quot;</span>&gt;</span>这是元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo1&quot;</span>&gt;</span>这是文字<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;Element3&quot;</span>&gt;</span>这是元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo2&quot;</span>&gt;</span>这是文字<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;Element4&quot;</span>&gt;</span>这是元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>示例3</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/*只要-2结尾，就添加以下样式*/</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-attr">[class$=\-2]</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;Element&quot;</span>&gt;</span>这是元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span>这是文字<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;Element-2&quot;</span>&gt;</span>这是元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo-1&quot;</span>&gt;</span>这是文字<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;Element-3&quot;</span>&gt;</span>这是元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo-2&quot;</span>&gt;</span>这是文字<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;Element-4&quot;</span>&gt;</span>这是元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h4><ul>
<li>标签选择顾名思义就是直接使用标签名在样式表中去给标签添加样式</li>
<li>注：标签选择器会给所有同名且没有其它选择器的标签添加相同的样式，不建议直接使用，可与结构选择器结合使用</li>
</ul>
<p>示例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.demo</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: <span class="number">#2279ee</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>这是一行字<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>这是一行字<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span>这是一行字<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>这是一行字<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>这是一行字<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>这是一行字<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="结构选择器"><a href="#结构选择器" class="headerlink" title="结构选择器"></a>结构选择器</h4><h5 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a><strong>后代选择器</strong></h5><ul>
<li>后代选择器又称包含选择器，后代选择器可以选择作为某元素后代（嵌套关系）的元素</li>
<li>我们可以定义后代选择器来创建一些规则，使这些规则在某些文档结构中起作用，而在另外一些结构中不起作用。</li>
<li>在后代选择器中，规则左边的选择器一端包括两个或多个用空格分隔的选择器。选择器之间的空格是一种结合符（combinator）。每个空格结合符可以解释为“… 在 … 找到”、“… 作为 … 的一部分”、“… 作为 … 的后代”，但是要求必须从右向左读选择器。</li>
</ul>
<p>示例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.dlOne</span> <span class="selector-tag">dd</span> <span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: white;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.dlOne</span> <span class="selector-tag">dd</span> <span class="selector-tag">a</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: <span class="number">#ff6700</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.dlTwo</span> <span class="selector-tag">dd</span> <span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: white;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#ff50ef</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.dlTwo</span> <span class="selector-tag">dd</span> <span class="selector-tag">a</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: <span class="number">#339fff</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dl</span> <span class="attr">class</span>=<span class="string">&quot;dlOne&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dt</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../images/mapImages/1.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一行字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>这是另一行字<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dl</span> <span class="attr">class</span>=<span class="string">&quot;dlTwo&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dt</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../images/mapImages/1.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>这还是一行字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>这又是另一行字<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="群组选择器"><a href="#群组选择器" class="headerlink" title="群组选择器"></a><strong>群组选择器</strong></h5><ul>
<li>要为不同的HTML元素定义相同的样式时，可以采用群组声明。</li>
<li>上述规则在选择器中指定了多个元素，元素之间用逗号来分隔。逗号告诉浏览器，规则中包含两个不同的选择器。这样的选择器叫群组选择器。</li>
<li>群组选择器可以减少样式的重复定义。可以把任意数量、任意类型的选择器放在群组中进行声明</li>
</ul>
<p>示例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.demo</span>,<span class="selector-tag">a</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span>Byte科技<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>棒滴很！！！<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="序号子选择器"><a href="#序号子选择器" class="headerlink" title="序号子选择器"></a><strong>序号子选择器</strong></h5><ul>
<li>序号选择器可以指定父元素中顺数或倒数某个子元素的样式</li>
<li>nth-child() 顺数</li>
<li>nth-last-child() 倒数</li>
</ul>
<p>示例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">nav</span> <span class="selector-tag">a</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>)&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">nav</span> <span class="selector-tag">a</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>)&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: <span class="number">#339fff</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">nav</span> <span class="selector-tag">a</span><span class="selector-pseudo">:nth-last-child</span>(<span class="number">1</span>)&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#339fff</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: white;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">nav</span> <span class="selector-tag">a</span><span class="selector-pseudo">:nth-last-child</span>(<span class="number">2</span>)&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#d442ff</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: <span class="number">#fff800</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>导航<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>导航<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>导航<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>导航<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>导航<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>导航<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="通用选择器"><a href="#通用选择器" class="headerlink" title="通用选择器"></a>通用选择器</h4><ul>
<li>通用选择器可以选择页面上的所有元素，并对它们应用样式，用 * 来表示。</li>
</ul>
<p>示例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        *&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>这是一行字<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这还是一行字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>这又是一行字<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h4><ul>
<li>伪类用于定义元素的特殊状态，由CSS提供</li>
<li>E:hover</li>
<li>E:active</li>
<li>E:link</li>
<li>E:visited</li>
<li>E:foucs</li>
</ul>
<p>示例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">a</span><span class="selector-pseudo">:link</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: <span class="number">#339fff</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">a</span><span class="selector-pseudo">:visited</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: <span class="number">#3bee17</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">a</span><span class="selector-pseudo">:active</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>: <span class="number">25px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.inputEL</span><span class="selector-pseudo">:focus</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#339fff</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span>这是一行字<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;inputEL&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>CSS概述及常用样式</title>
    <url>/2022/07/15/CSS%E6%A6%82%E8%BF%B0%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2Fimg_convert%2F1aa47966bb830f680023ffc8b3f29a11.png&refer=http%3A%2F%2Fimg-blog.csdnimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1660476083&t=6dadfca244396e41c6dc7b8116d30ca7" alt="点击查看图片来源"></p>
<span id="more"></span>

<h1 id="CSS3-概述"><a href="#CSS3-概述" class="headerlink" title="CSS3 概述"></a>CSS3 概述</h1><h2 id="CSS概述"><a href="#CSS概述" class="headerlink" title="CSS概述"></a>CSS概述</h2><h3 id="CSS-是什么"><a href="#CSS-是什么" class="headerlink" title="CSS 是什么"></a>CSS 是什么</h3><p>CSS全称 Cascading Style Sheets层叠样式表，是一种用来表现文件样式的计算机语言。<br>1.CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。<br>2.CSS 能够对网页中元素位置的排版进行像素级精确控制，支持几乎所有的字体字号样式。<br>3.CSS拥有对网页对象和模型样式编辑的能力。<br>4.在主页制作时采用CSS技术，可以有效地对页面的布局、字体、颜色等效果实现更加精确的控制。</p>
<h3 id="CSS历史"><a href="#CSS历史" class="headerlink" title="CSS历史"></a>CSS历史</h3><p>接下来，我们从总体上看一下CSS的发展历史。<br>CSS 1。<br>         1996年12月，CSS 1(Cascading Style Sheets,level 1)正式推出。在这个版本中，已经包含了font的相关属性、颜色与背景的相关属性、文字的相关属性、box的相关属性等。<br>CSS 2。<br>         1998年5月，CSS 2(Cascading Style Sheets,level 2)正式推出。在这个版本中开始使用样式表结构。<br>CSS 2.1。<br>         2004年2月，CSS 2.1(Cascading Style Sheets,level 2 revision 1)正式推出。它在CSS 2的基础上略微做了改动，删除了许多诸如text-shadow等不被浏览器所支持的属性。<br>现在所使用的CSS基本上是在1998年推出的CSS 2的基础上发展而来的。10年前在Internet刚开始普及的时候，就能够使用样式表来对网页进行视觉效果的统一编辑，确实是一件可喜的事情。但是在这10年间CSS可以说是基本上没有什么很大的变化，一直到2010年终于推出了一个全新的版本———CSS 3。</p>
<h2 id="使用CSS能做什么"><a href="#使用CSS能做什么" class="headerlink" title="使用CSS能做什么"></a>使用CSS能做什么</h2><h3 id="模块与模块化结构"><a href="#模块与模块化结构" class="headerlink" title="模块与模块化结构"></a>模块与模块化结构</h3><p>在CSS中，采用分工协作的模块化结构，如下表在CSS中，采用分工协作的模块化结构，如下表</p>
<table>
<thead>
<tr>
<th>模块名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>basic box model</td>
<td>定义各种与盒相关的样式</td>
</tr>
<tr>
<td>Line</td>
<td>定义各种与直线相关的样式</td>
</tr>
<tr>
<td>Lists</td>
<td>定义各种与列表相关的样式</td>
</tr>
<tr>
<td>Hyperlink Presentation</td>
<td>定义各种与超链接相关的样式。訾如锚的显示方式、激活时的视觉效果等</td>
</tr>
<tr>
<td>Presentation Levels</td>
<td>定义页面中元素的不同的样式级别</td>
</tr>
<tr>
<td>Speech</td>
<td>定义各种与语音相关的样式。譬如音量、音速、说话间歇时间等属性</td>
</tr>
<tr>
<td>Background and border</td>
<td>定义各种与背景和边框相关的样式</td>
</tr>
<tr>
<td>Text</td>
<td>定义各种与文字相关的样式</td>
</tr>
<tr>
<td>Color</td>
<td>定义各种与颜色相关的样式</td>
</tr>
<tr>
<td>Font</td>
<td>定义各种与字体相关的样式</td>
</tr>
<tr>
<td>Paged Media</td>
<td>定义各种页眉、页脚、页数等页面元数据的样式</td>
</tr>
<tr>
<td>Cascading and inheritance</td>
<td>定义怎样对属性进行赋值</td>
</tr>
<tr>
<td>Value and Units</td>
<td>将页面上各种各样的值与单位进行统一定义，以供其他模块使用</td>
</tr>
<tr>
<td>Image Values</td>
<td>定义对image元素的赋值方式</td>
</tr>
<tr>
<td>2D Transforms</td>
<td>在页面中实现2维空间上的变形效果</td>
</tr>
<tr>
<td>3D Transforms</td>
<td>在页面中实现3维空间上的变形效果</td>
</tr>
<tr>
<td>Transitions</td>
<td>在页面中实现平滑过渡的视觉效果</td>
</tr>
<tr>
<td>Animations</td>
<td>在页面中实现动画</td>
</tr>
<tr>
<td>CSSOM View</td>
<td>查看管理页面或页面的视觉效果，处理元素的位置信息</td>
</tr>
<tr>
<td>Syntax</td>
<td>定义CSS样式表的基本结构、样式表中的-一些语法细节、浏览器对于样式表的分析规则</td>
</tr>
<tr>
<td>Generated and Replaced Content</td>
<td>定义怎样在元素中插入内容</td>
</tr>
<tr>
<td>Marquee</td>
<td>定义当一些元素的内容太大，超出了指定的元素尺寸时，是否以及怎样显示溢出部分</td>
</tr>
<tr>
<td>Ruby</td>
<td>定义页面中ruby元素（用于显示拼音文字)的样式</td>
</tr>
<tr>
<td>Writing Modes</td>
<td>定义页面中文本数据的布局方式</td>
</tr>
<tr>
<td>Basic User Interface</td>
<td>定义在屏幕、纸张上进行输出时页面的渲染方式</td>
</tr>
<tr>
<td>Namespaces</td>
<td>定义使用命名空间时的语法</td>
</tr>
<tr>
<td>Media Queries</td>
<td>根据媒体类型来实现不同的样式</td>
</tr>
<tr>
<td>‘Reader’Media Type</td>
<td>定义用于屏幕阅读器之类的阅读程序时的样式</td>
</tr>
<tr>
<td>Multi-column Layout</td>
<td>在页面中使用多栏布局方式</td>
</tr>
<tr>
<td>Template Layout</td>
<td>在页面中使用特殊布局方式</td>
</tr>
<tr>
<td>Flexible Box Layout</td>
<td>创建自适应浏览器窗口的流动布局或自适应字体大小的弹性布局</td>
</tr>
<tr>
<td>Grid Position</td>
<td>在页面中使用网格布局方</td>
</tr>
<tr>
<td>Generated Content for Paged Media</td>
<td>在页面中使用印刷时使用的布局方式</td>
</tr>
</tbody></table>
<h1 id="第二章-CSS常用样式"><a href="#第二章-CSS常用样式" class="headerlink" title="第二章 CSS常用样式"></a>第二章 CSS常用样式</h1><h2 id="CSS-常用样式属性"><a href="#CSS-常用样式属性" class="headerlink" title="CSS 常用样式属性"></a>CSS 常用样式属性</h2><h4 id="宽高"><a href="#宽高" class="headerlink" title="宽高"></a>宽高</h4><ul>
<li><ul>
<li>宽width：像素值&#x2F;百分比（上一级标签的百分之多少）</li>
<li>高height：像素值&#x2F;百分比（上一级标签的百分之多少[注：当标签为body下的第一层标签时，高度使用百分比是不生效的]）</li>
</ul>
</li>
</ul>
<h4 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h4><ul>
<li><ul>
<li>文字大小</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>font-size：像素值</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>文字颜色</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>color:颜色单词&#x2F;十六进制值&#x2F;rgba值</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>文字对齐方式</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>text-align:居中&#x2F;靠左&#x2F;靠右</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>文字的字体设置</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>font-family:字体</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h4><ul>
<li><ul>
<li>标准文档流</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>web页面的制作不同于设计软件，它是个流，必须从上而下，先执行渲染显示上边的元素，依次向下渲染显示</li>
<li>我们知道元素分块级和行级元素两类，如果页面完全遵循文档流去开发就会导致很多页面排版不能实现或不能完全实现</li>
<li>通过浮动我们可以让元素脱离标准流，实现块级元素并排等一些效果</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>浮动特点</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>脱离标准流</li>
<li>元素并排（如果容器宽度足够元素则在容器宽度范围内并排，如果宽度不够则容器内元素会依次换行排列）</li>
<li>收缩（如果一个没有设置宽度的元素浮动，那么元素的宽度会自动收缩为内容宽度）</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>注：在学习初期关于浮动要遵循的一个原则：<strong>不要让一个元素单独浮动，要浮一起浮，要么都别浮</strong></li>
<li>浮动属性</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>左浮动    float:left;</li>
<li>右浮动    float:right</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><ul>
<li><ul>
<li>背景图 background-image:url(“图片地址”)</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>注：</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>在元素添加背景图时其运行时高度必须大于1</li>
<li>背景图处于元素的最底层不会占用元素内容的存储空间</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.demo</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;../images/mapImages/4.png&quot;</span>);</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>背景图大小 background-size:宽度  高度；</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>注：</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>为背景图设置大小时需要注意该图的纵横比（容易出现背景变形）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">       <span class="selector-class">.demo</span>&#123;</span></span><br><span class="line"><span class="language-css">           <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">           <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">           <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;../images/mapImages/1.png&quot;</span>);</span></span><br><span class="line"><span class="language-css">           <span class="attribute">background-size</span>: <span class="number">100%</span> <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">       &#125;</span></span><br><span class="line"><span class="language-css">   </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>背景重复 background-repeat:no-repeat&#x2F;repeat-x;repeat-y;</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>当图片宽高小于容器宽高时图片默认会铺满整个容器，会导致背景重复</li>
<li>背景重复属性值默认为repeat（重复），也可以设置为</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>no-repeat:不重复</li>
<li>repeat-x：X轴重复</li>
<li>repeat-y：Y轴重复</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.demo</span>&#123;</span></span><br><span class="line"><span class="language-css">          <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">          <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">          <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;../images/mapImages/1.png&quot;</span>);</span></span><br><span class="line"><span class="language-css">          <span class="comment">/*background-repeat: repeat-x;*/</span></span></span><br><span class="line"><span class="language-css">          <span class="comment">/*background-repeat: repeat-y;*/</span></span></span><br><span class="line"><span class="language-css">          <span class="attribute">background-repeat</span>: no-repeat;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>背景位移 background-position:x轴值  Y轴值；</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><p>当背景图大小小于容器大小的时候，容器中添加背景图后只能展示出部分背景图</p>
</li>
<li><p>通过背景位移，可以移动背景图片让容器中显示背景图中想要展示分部分</p>
</li>
<li><p>注：</p>
<p>​</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://files.catbox.moe/oyodj3.png"></p>
<ul>
<li><ul>
<li>背景色 background-color:颜色单词&#x2F;十六进制值&#x2F;rgba值</li>
</ul>
</li>
<li><ul>
<li><p>背景渐变</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">     <span class="selector-class">.demo</span>&#123;</span></span><br><span class="line"><span class="language-css">         <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">         <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">         <span class="attribute">background</span>:<span class="built_in">linear-gradient</span>(<span class="number">#ff0000</span>,<span class="number">#ffffff</span>);</span></span><br><span class="line"><span class="language-css">     &#125;</span></span><br><span class="line"><span class="language-css"> </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
</ul>
</li>
</ul>
<h4 id="阴影-box-shadow"><a href="#阴影-box-shadow" class="headerlink" title="阴影 box-shadow"></a>阴影 box-shadow</h4><ul>
<li><ul>
<li>语法：</li>
</ul>
</li>
</ul>
<p>box-shadow: h-shadow v-shadow blur spread color inset;</p>
<ul>
<li><ul>
<li>属性值：</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>h-shadow</td>
<td>必需的。水平阴影的位置。允许负值</td>
</tr>
<tr>
<td>v-shadow</td>
<td>必需的。垂直阴影的位置。允许负值</td>
</tr>
<tr>
<td>blur</td>
<td>可选。模糊距离</td>
</tr>
<tr>
<td>spread</td>
<td>可选。阴影的大小</td>
</tr>
<tr>
<td>color</td>
<td>可选。阴影的颜色。在<a href="https://www.runoob.com/cssref/css_colors_legal.aspx">CSS颜色值</a>寻找颜色值的完整列表</td>
</tr>
<tr>
<td>inset</td>
<td>可选。从外层的阴影（开始时）改变阴影内侧阴影</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.demo</span>&#123;</span></span><br><span class="line"><span class="language-css">          <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">          <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">          <span class="attribute">background-color</span>: white;</span></span><br><span class="line"><span class="language-css">          <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">0px</span> <span class="number">50px</span> <span class="number">2px</span> gainsboro;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.demo</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: white;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">box-shadow</span>:    <span class="number">0px</span> -<span class="number">10px</span> <span class="number">0px</span> <span class="number">0px</span> <span class="number">#ff0000</span>,   <span class="comment">/*上边阴影  红色*/</span></span></span><br><span class="line"><span class="language-css">            -<span class="number">10px</span> <span class="number">0px</span> <span class="number">0px</span> <span class="number">0px</span> <span class="number">#3bee17</span>,   <span class="comment">/*左边阴影  绿色*/</span></span></span><br><span class="line"><span class="language-css">            <span class="number">10px</span> <span class="number">0px</span> <span class="number">0px</span> <span class="number">0px</span> <span class="number">#2279ee</span>,    <span class="comment">/*右边阴影  蓝色*/</span></span></span><br><span class="line"><span class="language-css">            <span class="number">0px</span> <span class="number">10px</span> <span class="number">0px</span> <span class="number">0px</span> <span class="number">#eede15</span>;    <span class="comment">/*下边阴影  黄色*/</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="圆角-border-radius-圆角值"><a href="#圆角-border-radius-圆角值" class="headerlink" title="圆角 border-[--]radius:圆角值"></a>圆角 border-[<em>-</em>-]radius:圆角值</h4><p>圆形示例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">       <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="language-css">           <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">           <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">           <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">           <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">       &#125;</span></span><br><span class="line"><span class="language-css">   </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>单角示例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="language-css">          <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">          <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">          <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">          <span class="attribute">border-bottom-left-radius</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">          <span class="comment">/*border-bottom-right-radius: 20px;*/</span></span></span><br><span class="line"><span class="language-css">          <span class="comment">/*border-top-right-radius: 20px;*/</span></span></span><br><span class="line"><span class="language-css">          <span class="comment">/*border-top-left-radius: 20px;*/</span></span></span><br><span class="line"><span class="language-css">          </span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>CSS盒子模型及布局</title>
    <url>/2022/07/15/CSS%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/35eqd6.png"></p>
<span id="more"></span>

<h1 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h1><h2 id="盒子模型概述"><a href="#盒子模型概述" class="headerlink" title="盒子模型概述"></a>盒子模型概述</h2><p>盒子模型，顾名思义就是用来装东西的，它装的东西就是HTML元素的内容。<br>我们可以把一个HTML元素看成是一个盒子</p>
<h2 id="盒子构成"><a href="#盒子构成" class="headerlink" title="盒子构成"></a>盒子构成</h2><p>一个盒子由内容，内边距，边框，外边距构成</p>
<p><img src="https://files.catbox.moe/m1boy2.png"></p>
<ul>
<li><p>内容（content）：表示元素的宽高，若元素设置了宽度和高度，则内容空间就位宽高范围，若没有宽高，则内容空间为盒子中实际内容的所占空间</p>
</li>
<li><p>内边距（padding）：表示盒子内容与边框之间的距离</p>
</li>
<li><p>边框（border）：表示盒子的边框，位于内边距和外边距指甲剪</p>
</li>
<li><p>外边距（margin）：表示盒子边框以外的距离</p>
</li>
<li><p>注：</p>
</li>
<li><ul>
<li>盒子的内外边距是透明的</li>
<li>盒子的大小不是我们通过CSS设置的width和height，而是内容宽高+内边距+边框+外边距</li>
</ul>
</li>
</ul>
<h2 id="盒子属性解析"><a href="#盒子属性解析" class="headerlink" title="盒子属性解析"></a>盒子属性解析</h2><h4 id="内边距（padding）"><a href="#内边距（padding）" class="headerlink" title="内边距（padding）"></a>内边距（padding）</h4><p>就是盒子里的内容距离盒子边框的距离</p>
<ul>
<li><p>作用：</p>
</li>
<li><ul>
<li>可以让内容和盒子的边框有一定的距离</li>
</ul>
</li>
<li><p>属性值</p>
</li>
<li><ul>
<li>padding:Xpx;给盒子的内容四周都加上内边距</li>
<li>padding:Xpx  Xpx;两个值分别上下 ，左右</li>
<li>padding:Xpx Xpx Xpx Xpx;分别表示  上，右，下，左</li>
<li>padding-left&#x2F;right&#x2F;top&#x2F;bottom:Xpx;给内容的某一边加内边距</li>
</ul>
</li>
</ul>
<p>示例一</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.PDemo</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">150px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="边框（border）"><a href="#边框（border）" class="headerlink" title="边框（border）"></a>边框（border）</h4><p>表示盒子的边界</p>
<ul>
<li><p>作用</p>
</li>
<li><ul>
<li>为盒子四周或某一边添加带有颜色的边框</li>
</ul>
</li>
<li><p>属性</p>
</li>
<li><ul>
<li>border:边框宽度  实线&#x2F;虚线 颜色</li>
<li>border-left&#x2F;right&#x2F;top&#x2F;bottom:边框宽度  实线&#x2F;虚线 颜色</li>
</ul>
</li>
</ul>
<h4 id="外边距（margin）"><a href="#外边距（margin）" class="headerlink" title="外边距（margin）"></a>外边距（margin）</h4><p>表示盒子距离它周围的距离</p>
<ul>
<li><p>作用：可以用来调整元素与元素之间的间距，也可以用来移动元素（注：微调）</p>
</li>
<li><p>属性：</p>
</li>
<li><ul>
<li>margin:Xpx;给盒子的内容四周都加上外边距</li>
<li>margin:Xpx  Xpx;两个值分别上下 ，左右</li>
<li>margin:Xpx Xpx Xpx Xpx;分别表示  上，右，下，左（外边距它渲染显示的时候也是从左上开始）</li>
<li>margin-left&#x2F;right&#x2F;top&#x2F;bottom:Xpx;使盒子对四周的某一边有距离</li>
</ul>
</li>
<li><p>注：</p>
</li>
<li><ul>
<li>元素在渲染显示的时候左上属性优先</li>
</ul>
</li>
</ul>
<h1 id="第二章-布局"><a href="#第二章-布局" class="headerlink" title="第二章 布局"></a>第二章 布局</h1><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>布局是为了对整个网页进行排版，把网站内容安排在多个列中，用以丰富网页背景，色彩，内容等网页外观，就跟房子装修一样，我们需要把我们的房子装修漂漂亮亮的而且功能实用，总不能把床放在卫生间，把马桶放在燃气灶旁边吧</p>
<p>我么在制作前期需要对UI设计师提供的设计图片进行布局分析，明确那个模块在什么位置，我们需要通过布局将模块创建出来，放在它该有的位置上，然后对模块进行内容填充</p>
<h2 id="入门布局–圣杯布局"><a href="#入门布局–圣杯布局" class="headerlink" title="入门布局–圣杯布局"></a>入门布局–圣杯布局</h2><ul>
<li><p>入门图</p>
<p>​</p>
</li>
</ul>
<p><img src="https://files.catbox.moe/yov4tt.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        *&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.top</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">80px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.middle</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.middle</span> <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.middle</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>),<span class="selector-class">.middle</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-last-child</span>(<span class="number">1</span>)&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">30%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#339fff</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.middle</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>)&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">40%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#2279ee</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.bottom</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">80px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.color1</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#339fff</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--顶部--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;top color1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--中部--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--左--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--中--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--右--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--底部--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bottom color1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="弹性布局"><a href="#弹性布局" class="headerlink" title="弹性布局"></a>弹性布局</h2><h4 id="传统布局与弹性布局"><a href="#传统布局与弹性布局" class="headerlink" title="传统布局与弹性布局"></a>传统布局与弹性布局</h4><ol>
<li>传统布局方法遵循文档流的模式，依赖浮动，相较于一些特殊布局，不容易实现（如：垂直居中效果）</li>
<li>弹性布局诞生于2009年，弹性布局也称之为flex布局</li>
<li>弹性布局可以完整的响应式的实现各种页面布局</li>
</ol>
<h4 id="在使用弹性布局时需要知道的两个概念"><a href="#在使用弹性布局时需要知道的两个概念" class="headerlink" title="在使用弹性布局时需要知道的两个概念"></a>在使用弹性布局时需要知道的两个概念</h4><ol>
<li>容器：需要添加弹性布局的父元素</li>
<li>项目：弹性布局容器中的每一个子元素称之为项目</li>
</ol>
<h4 id="在使用弹性布局时需要了解的两个基本方向"><a href="#在使用弹性布局时需要了解的两个基本方向" class="headerlink" title="在使用弹性布局时需要了解的两个基本方向"></a>在使用弹性布局时需要了解的两个基本方向</h4><ol>
<li>主轴：在弹性布局中，需要通过样式属性去规定水平&#x2F;垂直方向为主轴</li>
<li>交叉轴：与主轴垂直的另一个方向称之为交叉轴</li>
</ol>
<h4 id="弹性布局的使用步骤"><a href="#弹性布局的使用步骤" class="headerlink" title="弹性布局的使用步骤"></a>弹性布局的使用步骤</h4><ol>
<li>给父元素添加display:flex&#x2F;inline-flex来规定该容器为弹性布局显示，而不遵循常规的文档流模式</li>
<li>添加弹性布局的相关属性样式</li>
<li>注：当元素采用了弹性布局后，子元素的浮动会失效</li>
<li>入门</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/*规定容器*/</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: aqua;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box</span> <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">20%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配合display:flex使用的12个属性（6个容器属性，6个项目属性）</p>
<h4 id="6个容器属性"><a href="#6个容器属性" class="headerlink" title="6个容器属性"></a>6个容器属性</h4><ol>
<li><ol>
<li><p>flex-direction  改属性决定主轴的方向（表示在容器中项目的排列方向）</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>方向</th>
</tr>
</thead>
<tbody><tr>
<td>row      默认值</td>
<td>主轴为水平方向，从父容器的左部开始渲染显示</td>
</tr>
<tr>
<td>row-reverse</td>
<td>主轴为水平方向，从父容器的右部开始渲染显示</td>
</tr>
<tr>
<td>column</td>
<td>主轴为垂直方向，从父容器的左上部开始渲染显示</td>
</tr>
<tr>
<td>column-reverse</td>
<td>主轴为垂直方向，从父容器的左下部开始渲染显示</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<p>​         b. flex-wrap   项目的排列方式（默认情况下，所有项目都排列在一条轴线上）              </p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>nowrap</td>
<td>不换行，当容器的宽度不够时，容器中的每个项目将会被挤压</td>
</tr>
<tr>
<td>wrap</td>
<td>换行，按项目的实际宽度执行排列，当容器宽度不够时自动换行，并且第一行在容器的最上方</td>
</tr>
<tr>
<td>wrap-reverse</td>
<td>换行，第一行在容器的最下方</td>
</tr>
</tbody></table>
<p>c.    flex-flow:flex-direction  flex-wrap</p>
<p>默认值为  flex-flow:row  wrap</p>
<p>d.    justify-content   定义了项目在主轴方向的对齐方式</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>flex-start</td>
<td>项目位于主轴的起点</td>
</tr>
<tr>
<td>flex-end</td>
<td>项目位于主轴的终点</td>
</tr>
<tr>
<td>center</td>
<td>居中对齐</td>
</tr>
<tr>
<td>space-between</td>
<td>两端对齐，项目间的间隔相等，开头项目和结束项目与容器两边没有间隔</td>
</tr>
<tr>
<td>space-around</td>
<td>两端对齐，项目间的间隔相等，开头项目和结束项目与容器两边有一定的间隔</td>
</tr>
</tbody></table>
<p>e.    align-items  交叉轴对齐方式</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>flex-start</td>
<td>交叉轴起点对齐</td>
</tr>
<tr>
<td>flex-end</td>
<td>交叉轴终点对齐</td>
</tr>
<tr>
<td>center</td>
<td>居中对齐</td>
</tr>
<tr>
<td>baseline</td>
<td>以项目的第一行文字为基线对齐，文字的行高，字体大小会直接影响后边的项目对齐</td>
</tr>
<tr>
<td>stretch</td>
<td>如果项目没有设置高度，则添加该属性后项目会占满整个容器</td>
</tr>
</tbody></table>
<p>f.    align-content 定义多根轴线的对齐方式，如果定义一根轴线则该属性不生效（不推荐出现多根轴线）</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>flex-start</td>
<td>与交叉轴的起点对齐</td>
</tr>
<tr>
<td>flex-end</td>
<td>与交叉轴的终点对齐</td>
</tr>
<tr>
<td>center</td>
<td>与交叉轴的中点对齐</td>
</tr>
<tr>
<td>space-between</td>
<td>与交叉轴的两端对齐，轴线之间的间隔平均分布，开头和结束项目与容器没间隔</td>
</tr>
<tr>
<td>space-around</td>
<td>与交叉轴的两端对齐，轴线之间的间隔都相等</td>
</tr>
<tr>
<td>stretch</td>
<td>轴线占满整个交叉轴</td>
</tr>
</tbody></table>
<h4 id="6个项目属性"><a href="#6个项目属性" class="headerlink" title="6个项目属性"></a>6个项目属性</h4><ol>
<li><ol>
<li>order 定义项目排列的顺序，数值越小，排列越靠前，默认值为0，当添加了大于0的值后，该项目则不遵循文档流的排列方式</li>
</ol>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/*规定容器*/</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/*主轴*/</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">flex-direction</span>: row;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/*flex-direction: row-reverse;*/</span></span></span><br><span class="line"><span class="language-css">            <span class="comment">/*flex-direction: column;*/</span></span></span><br><span class="line"><span class="language-css">            <span class="comment">/*flex-direction: column-reverse;*/</span></span></span><br><span class="line"><span class="language-css">            <span class="comment">/*排列方式*/</span></span></span><br><span class="line"><span class="language-css">            <span class="comment">/*flex-wrap: nowrap;*/</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">flex-wrap</span>: wrap;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/*flex-wrap: wrap-reverse;*/</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: aqua;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/*主轴对齐方式*/</span></span></span><br><span class="line"><span class="language-css">            <span class="comment">/*justify-content: flex-start;*/</span></span></span><br><span class="line"><span class="language-css">            <span class="comment">/*justify-content: flex-end;*/</span></span></span><br><span class="line"><span class="language-css">            <span class="comment">/*justify-content: space-around;*/</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">justify-content</span>: space-between;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/*多根轴线与交叉轴的对齐方式*/</span></span></span><br><span class="line"><span class="language-css">            <span class="comment">/*align-content: center;*/</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">align-content</span>: space-between;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box</span> <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">20%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.big</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">line-height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.orderStyle</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">order</span>: <span class="number">5</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.orderStyle1</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">order</span>: <span class="number">7</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.orderStyle2</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">order</span>: <span class="number">6</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.orderStyle3</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">order</span>: <span class="number">4</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;big orderStyle&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;orderStyle1&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;orderStyle2&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>7<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;orderStyle3&quot;</span>&gt;</span>8<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>9<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>10<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>b. flex-grow 用来定义项目的放大比例，默认为0，在为0的情况下，即使容器还有空间，项目也不会放大，当值大于零时容器还有空间余量的话则添加了该属性的项目会放大</p>
<p>c. flex-shrink  定义项目是否可压缩，默认值为1，若空间不够，该项目将被缩小，如果其中某一个项目的值被设置为0，则它的空间不会被压缩</p>
<p>d. flex-basis  定义了项目占据主轴的空间（设置项目的宽度，当项目添加了该属性后，width会失效）</p>
<p>e. align-self  设置某个项目在交叉轴上的对齐方式，其参数和align-items一致，当某个项目添加了该属性后，则会覆盖父容器上的align-itmes属性，其默认值为auto（表示继承父容器的align-itmes值）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/*规定容器*/</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/*主轴*/</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">flex-direction</span>: row;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/*flex-direction: row-reverse;*/</span></span></span><br><span class="line"><span class="language-css">            <span class="comment">/*flex-direction: column;*/</span></span></span><br><span class="line"><span class="language-css">            <span class="comment">/*flex-direction: column-reverse;*/</span></span></span><br><span class="line"><span class="language-css">            <span class="comment">/*排列方式*/</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">flex-wrap</span>: nowrap;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/*flex-wrap: wrap;*/</span></span></span><br><span class="line"><span class="language-css">            <span class="comment">/*flex-wrap: wrap-reverse;*/</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: aqua;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/*主轴对齐方式*/</span></span></span><br><span class="line"><span class="language-css">            <span class="comment">/*justify-content: flex-start;*/</span></span></span><br><span class="line"><span class="language-css">            <span class="comment">/*justify-content: flex-end;*/</span></span></span><br><span class="line"><span class="language-css">            <span class="comment">/*justify-content: space-around;*/</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">justify-content</span>: space-between;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box</span> <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">20%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.fs</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">flex-shrink</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">flex-basis</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">align-self</span>: flex-end;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.as</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">align-self</span>: flex-start;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;fs&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;as&quot;</span>&gt;</span>7<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>8<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>9<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>10<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>11<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>12<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>f. flex属性，该属性相当于flex-grow，flex-shrink，flex-basis的简写，默认值0,1 auto</p>
]]></content>
  </entry>
  <entry>
    <title>CSS动画</title>
    <url>/2022/07/15/CSS%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/35eqd6.png"></p>
<span id="more"></span>

<h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><p>CSS动画是W3C于2009年发布3D变形动画（标准草案），在年底发布了2D变形动画<br>浏览器支持使用代码形成网页动画，并且有些浏览器在添加时为了更好的兼容性，需要添加浏览器引擎的私有属性<br>1谷歌：-webkit-<br>2火狐：-moz-<br>3IE9：-ms-<br>4其它一些浏览器不需要添加这些私有属性</p>
<h2 id="CSS-2D动画"><a href="#CSS-2D动画" class="headerlink" title="CSS 2D动画"></a>CSS 2D动画</h2><p>●2D动画可以用于元素的旋转，缩放，位移等<br>●基本语法</p>
<table>
<thead>
<tr>
<th>transform:none|transform-function</th>
</tr>
</thead>
<tbody><tr>
<td>none为默认值</td>
</tr>
<tr>
<td>transform-function：变形函数（变形函数可以是一个，也可以是多个函数列表）   函数是以()结尾</td>
</tr>
</tbody></table>
<p>●常见的变形函数<br>○translate():移动元素<br>○scale():元素缩放，可以是任意尺寸发生变形<br>○rotate():旋转元素，取一个度数值，度数的后缀为deg，当度数为正时为顺时针旋转，为负时为逆时针旋转<br>○skew()：元素斜切，取度数值让元素发生形状变化<br>●旋转rotate()<br>○让元素逆时针或顺时针旋转</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">       <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="language-css">           <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">           <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">           <span class="attribute">background-color</span>: hotpink;</span></span><br><span class="line"><span class="language-css">           <span class="attribute">border</span>: <span class="number">2px</span> solid green;</span></span><br><span class="line"><span class="language-css">           <span class="attribute">margin</span>: <span class="number">200px</span> auto;</span></span><br><span class="line"><span class="language-css">       &#125;</span></span><br><span class="line"><span class="language-css">       <span class="comment">/*伪类样式：当鼠标悬停在元素上时触发里面的样式属性*/</span></span></span><br><span class="line"><span class="language-css">       <span class="selector-class">.box</span><span class="selector-pseudo">:hover</span>&#123;</span></span><br><span class="line"><span class="language-css">           <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">90deg</span>);</span></span><br><span class="line"><span class="language-css">       &#125;</span></span><br><span class="line"><span class="language-css">   </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>位置移动translate(左值，上值)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">       <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="language-css">           <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">           <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">           <span class="attribute">background-color</span>: hotpink;</span></span><br><span class="line"><span class="language-css">           <span class="attribute">border</span>: <span class="number">2px</span> solid green;</span></span><br><span class="line"><span class="language-css">       &#125;</span></span><br><span class="line"><span class="language-css">       <span class="selector-class">.two</span>&#123;</span></span><br><span class="line"><span class="language-css">           <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">100px</span>,<span class="number">100px</span>);</span></span><br><span class="line"><span class="language-css">       &#125;</span></span><br><span class="line"><span class="language-css">   </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>放大缩小（scale(宽度放大倍数,高度放大倍数)    当放大时两个值大于1，如果值位于0,1之间时为缩小）</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: hotpink;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">2px</span> solid green;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">200px</span> auto;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box</span><span class="selector-pseudo">:hover</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>,<span class="number">2</span>);</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>这是1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>斜切（skew(Y轴角度，X轴角度)），当度数为正值时从左边斜切，为负值时从右边斜切</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: hotpink;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">2px</span> solid green;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">200px</span> auto;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box</span><span class="selector-pseudo">:hover</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">transform</span>: <span class="built_in">skew</span>(<span class="number">45deg</span>,<span class="number">10deg</span>);</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="简易照片墙"><a href="#简易照片墙" class="headerlink" title="简易照片墙"></a>简易照片墙</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        *&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.PBox</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#efefef</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">flex-wrap</span>: nowrap;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">justify-content</span>: space-around;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.PBox</span> <span class="selector-tag">dl</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">10%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">70%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: white;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/*为了让照片看起来有那么点感觉，这里添加一个阴影*/</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">10px</span> <span class="number">30px</span> <span class="number">#8c8c8c</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin-top</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.PBox</span> <span class="selector-tag">dt</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">80%</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.PBox</span> <span class="selector-tag">dt</span> <span class="selector-tag">img</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.PBox</span> <span class="selector-tag">dd</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/*因为标签有一些默认的属性值，它在标签执行时就自动加载了，</span></span></span><br><span class="line"><span class="comment"><span class="language-css">            我们可以通过来提升自定义属性优先级来覆盖它*/</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">8px</span> <span class="number">0px</span><span class="meta">!important</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="comment">/*定义动画样式，让照片墙看起来不要那么规整*/</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.trans1</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">transform</span>: <span class="built_in">skew</span>(<span class="number">5deg</span>,<span class="number">2deg</span>);</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.trans2</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.9</span>,<span class="number">0.8</span>);</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.trans3</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">25deg</span>);</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.trans4</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">20deg</span>) <span class="built_in">scale</span>(<span class="number">1.1</span>,<span class="number">1.1</span>);</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.trans5</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">transform</span>: <span class="built_in">skew</span>(<span class="number">5deg</span>,<span class="number">2deg</span>) <span class="built_in">scale</span>(<span class="number">0.9</span>,<span class="number">0.9</span>);</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--网页版的照片墙，一共两行--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;PBox&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--单个照片--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dl</span> <span class="attr">class</span>=<span class="string">&quot;trans1&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dt</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/IMG_E1640.JPG&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dd</span>&gt;</span>这是照片名称<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dl</span> <span class="attr">class</span>=<span class="string">&quot;trans2&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dt</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/IMG_E1640.JPG&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dd</span>&gt;</span>这是照片名称<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dl</span> <span class="attr">class</span>=<span class="string">&quot;trans4&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dt</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/IMG_E1640.JPG&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dd</span>&gt;</span>这是照片名称<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dl</span> <span class="attr">class</span>=<span class="string">&quot;trans5&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dt</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/IMG_E1640.JPG&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dd</span>&gt;</span>这是照片名称<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dl</span> <span class="attr">class</span>=<span class="string">&quot;trans3&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dt</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/IMG_E1640.JPG&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dd</span>&gt;</span>这是照片名称<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dt</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/IMG_E1640.JPG&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dd</span>&gt;</span>这是照片名称<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;PBox&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--单个照片--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dt</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/IMG_E1640.JPG&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dd</span>&gt;</span>这是照片名称<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dl</span> <span class="attr">class</span>=<span class="string">&quot;trans5&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dt</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/IMG_E1640.JPG&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dd</span>&gt;</span>这是照片名称<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dl</span> <span class="attr">class</span>=<span class="string">&quot;trans2&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dt</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/IMG_E1640.JPG&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dd</span>&gt;</span>这是照片名称<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dl</span> <span class="attr">class</span>=<span class="string">&quot;trans1&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dt</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/IMG_E1640.JPG&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dd</span>&gt;</span>这是照片名称<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dl</span> <span class="attr">class</span>=<span class="string">&quot;trans3&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dt</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/IMG_E1640.JPG&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dd</span>&gt;</span>这是照片名称<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dl</span> <span class="attr">class</span>=<span class="string">&quot;trans4&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dt</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/IMG_E1640.JPG&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dd</span>&gt;</span>这是照片名称<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h2><ul>
<li>过渡是元素从一种样式逐渐改变成另一种样式</li>
<li>语法</li>
</ul>
<p>transition:过渡属性名称 [时间][效果]</p>
<table>
<thead>
<tr>
<th>过渡属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>transition</td>
<td>简写，该属性中包含了所有过渡属性</td>
</tr>
<tr>
<td>transition-property</td>
<td>规定应用过渡的CSS属性名称</td>
</tr>
<tr>
<td>transition-duration</td>
<td>过渡时间，默认为0</td>
</tr>
<tr>
<td>transition-delay</td>
<td>过渡从什么时候开始</td>
</tr>
<tr>
<td>…….</td>
<td>……..</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">       <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="language-css">           <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">           <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">           <span class="attribute">background-color</span>: hotpink;</span></span><br><span class="line"><span class="language-css">           <span class="attribute">border</span>: <span class="number">2px</span> solid green;</span></span><br><span class="line"><span class="language-css">           <span class="attribute">margin</span>: <span class="number">200px</span> auto;</span></span><br><span class="line"><span class="language-css">       &#125;</span></span><br><span class="line"><span class="language-css">       <span class="selector-class">.box</span><span class="selector-pseudo">:hover</span>&#123;</span></span><br><span class="line"><span class="language-css">           <span class="comment">/*transform: skew(45deg,10deg);*/</span></span></span><br><span class="line"><span class="language-css">           <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">2</span>,<span class="number">2</span>);</span></span><br><span class="line"><span class="language-css">           <span class="attribute">transition</span>: transform <span class="number">1s</span>;</span></span><br><span class="line"><span class="language-css">       &#125;</span></span><br><span class="line"><span class="language-css">   </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="通过过渡完善照片墙（当鼠标长按图片时，照片显示在网页的中间，并且照片角度回正，放大两倍）-长按（-active）"><a href="#通过过渡完善照片墙（当鼠标长按图片时，照片显示在网页的中间，并且照片角度回正，放大两倍）-长按（-active）" class="headerlink" title="通过过渡完善照片墙（当鼠标长按图片时，照片显示在网页的中间，并且照片角度回正，放大两倍）  长按（:active）"></a>通过过渡完善照片墙（当鼠标长按图片时，照片显示在网页的中间，并且照片角度回正，放大两倍）  长按（:active）</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//长按案例</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: hotpink;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">2px</span> solid green;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">200px</span> auto;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box</span><span class="selector-pseudo">:active</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/*transform: skew(45deg,10deg);*/</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">2</span>,<span class="number">2</span>);</span></span><br><span class="line"><span class="language-css">            <span class="attribute">transition</span>: transform <span class="number">1s</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>这是1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h2><ul>
<li>使用Animation功能可以实现更加复杂的动画</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
<th>初始值</th>
</tr>
</thead>
<tbody><tr>
<td>animation</td>
<td>包含所有属性</td>
<td></td>
</tr>
<tr>
<td>animation-name</td>
<td>动画名称</td>
<td>none</td>
</tr>
<tr>
<td>animation-duration</td>
<td>动画时间</td>
<td>0</td>
</tr>
<tr>
<td>animation-timing-function</td>
<td>动画播放方式</td>
<td>ease</td>
</tr>
<tr>
<td>animation-iteration-count</td>
<td>动画播放的次数</td>
<td>1，infinite为重复播放</td>
</tr>
</tbody></table>
<ul>
<li><p>制作动画需要以下两步</p>
</li>
<li><ul>
<li>第一步：需要在样式表中添加动画过程属性</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">@-webkit-keyframes name &#123;</span><br><span class="line">    /*动画开始时属性样式*/</span><br><span class="line">    0%&#123;</span><br><span class="line">    /*样式属性：属性值*/</span><br><span class="line">    &#125;</span><br><span class="line">    /*动画结束时属性样式*/</span><br><span class="line">    100%&#123;</span><br><span class="line">    /*样式属性：属性值*/</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @keyframes name &#123;</span><br><span class="line">    /*动画开始时属性样式*/</span><br><span class="line">    0%&#123;</span><br><span class="line">    /*样式属性：属性值*/</span><br><span class="line">    &#125;</span><br><span class="line">    /*动画结束时属性样式*/</span><br><span class="line">    100%&#123;</span><br><span class="line">    /*样式属性：属性值*/</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>第二步：将制作好的动画通过animation引入给标签使用</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//图片翻转</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        *&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;img/IMG_E1640.JPG&quot;</span>);</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-size</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/*引用动画*/</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">animation</span>:rotateImg <span class="number">10s</span> infinite;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/*制作动画执行过程*/</span></span></span><br><span class="line"><span class="language-css">        <span class="keyword">@-webkit-keyframes</span> rotateImg &#123;</span></span><br><span class="line"><span class="language-css">            <span class="number">0%</span>&#123;</span></span><br><span class="line"><span class="language-css">                <span class="comment">/*图片起始不动*/</span></span></span><br><span class="line"><span class="language-css">                -webkit-<span class="attribute">transform</span>: <span class="built_in">rotateY</span>(<span class="number">0deg</span>);</span></span><br><span class="line"><span class="language-css">            &#125;</span></span><br><span class="line"><span class="language-css">            <span class="number">50%</span>&#123;</span></span><br><span class="line"><span class="language-css">                -webkit-<span class="attribute">transform</span>: <span class="built_in">rotateY</span>(<span class="number">360deg</span>);</span></span><br><span class="line"><span class="language-css">            &#125;</span></span><br><span class="line"><span class="language-css">            <span class="number">100%</span>&#123;</span></span><br><span class="line"><span class="language-css">                -webkit-<span class="attribute">transform</span>: <span class="built_in">rotateY</span>(<span class="number">720deg</span>);</span></span><br><span class="line"><span class="language-css">            &#125;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>光盘旋转效果</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        *&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;img/IMG_E1640.JPG&quot;</span>);</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-size</span>: <span class="number">100%</span> <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/*引用大圆旋转动画*/</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">animation</span>: box <span class="number">30s</span> linear infinite;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.lb</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;img/IMG_1443.JPG&quot;</span>);</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-size</span>: <span class="number">100%</span> <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">align-self</span>: center;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">animation</span>: lb <span class="number">15s</span> linear infinite;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="comment">/*制作动画：大圆要顺时针旋转，稍慢*/</span></span></span><br><span class="line"><span class="language-css">        <span class="keyword">@-webkit-keyframes</span> box &#123;</span></span><br><span class="line"><span class="language-css">            <span class="number">0%</span>&#123;</span></span><br><span class="line"><span class="language-css">                -webkit-<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span></span><br><span class="line"><span class="language-css">            &#125;</span></span><br><span class="line"><span class="language-css">            <span class="number">100%</span>&#123;</span></span><br><span class="line"><span class="language-css">                -webkit-<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span></span><br><span class="line"><span class="language-css">            &#125;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="comment">/*制作动画：小圆要逆时针旋转，稍快*/</span></span></span><br><span class="line"><span class="language-css">        <span class="keyword">@-webkit-keyframes</span> lb &#123;</span></span><br><span class="line"><span class="language-css">            <span class="number">0%</span>&#123;</span></span><br><span class="line"><span class="language-css">                -webkit-<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span></span><br><span class="line"><span class="language-css">            &#125;</span></span><br><span class="line"><span class="language-css">            <span class="number">100%</span>&#123;</span></span><br><span class="line"><span class="language-css">                -webkit-<span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">360deg</span>) <span class="built_in">rotateY</span>(<span class="number">360deg</span>);</span></span><br><span class="line"><span class="language-css">            &#125;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;lb&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3D旋转相册</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">	<span class="attribute">background</span>:<span class="number">#06081B</span>;</span></span><br><span class="line"><span class="language-css">	<span class="attribute">perspective</span>:<span class="number">5000px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.show</span> &#123;</span></span><br><span class="line"><span class="language-css">	<span class="attribute">perspective</span>:<span class="number">5000px</span>;</span></span><br><span class="line"><span class="language-css">	-webkit-<span class="attribute">transform</span>:<span class="built_in">rotateX</span>(-<span class="number">45deg</span>);</span></span><br><span class="line"><span class="language-css">	-moz-<span class="attribute">transform</span>:<span class="built_in">rotateX</span>(-<span class="number">45deg</span>);</span></span><br><span class="line"><span class="language-css">	<span class="attribute">transform</span>:<span class="built_in">rotateX</span>(-<span class="number">45deg</span>);</span></span><br><span class="line"><span class="language-css">	<span class="attribute">transform-style</span>:preserve-<span class="number">3</span>d;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">	<span class="attribute">position</span>:relative;</span></span><br><span class="line"><span class="language-css">	<span class="attribute">width</span>:<span class="number">150px</span>;</span></span><br><span class="line"><span class="language-css">	<span class="attribute">height</span>:<span class="number">250px</span>;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">	<span class="attribute">margin</span>:<span class="number">300px</span> auto;</span></span><br><span class="line"><span class="language-css">	<span class="attribute">transform-style</span>:preserve-<span class="number">3</span>d;</span></span><br><span class="line"><span class="language-css">	-webkit-<span class="attribute">animation</span>:rotate1 <span class="number">10s</span> linear infinite;</span></span><br><span class="line"><span class="language-css">	-moz-<span class="attribute">animation</span>:rotate1 <span class="number">10s</span> linear infinite;</span></span><br><span class="line"><span class="language-css">	<span class="attribute">animation</span>:rotate1 <span class="number">10s</span> linear infinite;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;img/IMG_E1640.JPG&quot;</span>);</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-size</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.box</span> <span class="selector-tag">img</span> &#123;</span></span><br><span class="line"><span class="language-css">	<span class="attribute">width</span>:<span class="number">150px</span>;</span></span><br><span class="line"><span class="language-css">	<span class="attribute">height</span>:<span class="number">250px</span>;</span></span><br><span class="line"><span class="language-css">	<span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#ccc</span>;</span></span><br><span class="line"><span class="language-css">	<span class="attribute">position</span>:absolute;</span></span><br><span class="line"><span class="language-css">	<span class="attribute">left</span>:<span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">	<span class="attribute">top</span>:<span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">	-webkit-box-reflect:below <span class="number">20px</span> <span class="built_in">-webkit-linear-gradient</span>(top,<span class="built_in">rgba</span>(<span class="number">250</span>,<span class="number">250</span>,<span class="number">250</span>,<span class="number">0</span>),<span class="built_in">rgba</span>(<span class="number">250</span>,<span class="number">250</span>,<span class="number">250</span>,<span class="number">0</span>) <span class="number">30%</span>,<span class="built_in">rgba</span>(<span class="number">250</span>,<span class="number">250</span>,<span class="number">250</span>,<span class="number">0.5</span>));</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.img1</span> &#123;</span></span><br><span class="line"><span class="language-css">	-webkit-<span class="attribute">transform</span>:<span class="built_in">translateZ</span>(<span class="number">300px</span>);</span></span><br><span class="line"><span class="language-css">	-moz-<span class="attribute">transform</span>:<span class="built_in">translateZ</span>(<span class="number">300px</span>);</span></span><br><span class="line"><span class="language-css">	<span class="attribute">transform</span>:<span class="built_in">translateZ</span>(<span class="number">300px</span>);</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.img2</span> &#123;</span></span><br><span class="line"><span class="language-css">	-webkit-<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">36deg</span>) <span class="built_in">translateZ</span>(<span class="number">300px</span>);</span></span><br><span class="line"><span class="language-css">	-moz-<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">36deg</span>) <span class="built_in">translateZ</span>(<span class="number">300px</span>);</span></span><br><span class="line"><span class="language-css">	<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">36deg</span>) <span class="built_in">translateZ</span>(<span class="number">300px</span>);</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.img3</span> &#123;</span></span><br><span class="line"><span class="language-css">	-webkit-<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">72deg</span>) <span class="built_in">translateZ</span>(<span class="number">300px</span>);</span></span><br><span class="line"><span class="language-css">	-moz-<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">72deg</span>) <span class="built_in">translateZ</span>(<span class="number">300px</span>);</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.img4</span> &#123;</span></span><br><span class="line"><span class="language-css">	-webkit-<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">108deg</span>) <span class="built_in">translateZ</span>(<span class="number">300px</span>);</span></span><br><span class="line"><span class="language-css">	-moz-<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">108deg</span>) <span class="built_in">translateZ</span>(<span class="number">300px</span>);</span></span><br><span class="line"><span class="language-css">	<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">108deg</span>) <span class="built_in">translateZ</span>(<span class="number">300px</span>);</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.img5</span> &#123;</span></span><br><span class="line"><span class="language-css">	-webkit-<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">144deg</span>) <span class="built_in">translateZ</span>(<span class="number">300px</span>);</span></span><br><span class="line"><span class="language-css">	-moz-<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">144deg</span>) <span class="built_in">translateZ</span>(<span class="number">300px</span>);</span></span><br><span class="line"><span class="language-css">	<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">144deg</span>) <span class="built_in">translateZ</span>(<span class="number">300px</span>);</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.img6</span> &#123;</span></span><br><span class="line"><span class="language-css">	-webkit-<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">180deg</span>) <span class="built_in">translateZ</span>(<span class="number">300px</span>);</span></span><br><span class="line"><span class="language-css">	-moz-<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">180deg</span>) <span class="built_in">translateZ</span>(<span class="number">300px</span>);</span></span><br><span class="line"><span class="language-css">	<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">180deg</span>) <span class="built_in">translateZ</span>(<span class="number">300px</span>);</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.img7</span> &#123;</span></span><br><span class="line"><span class="language-css">	-webkit-<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">216deg</span>) <span class="built_in">translateZ</span>(<span class="number">300px</span>);</span></span><br><span class="line"><span class="language-css">	-moz-<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">216deg</span>) <span class="built_in">translateZ</span>(<span class="number">300px</span>);</span></span><br><span class="line"><span class="language-css">	<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">216deg</span>) <span class="built_in">translateZ</span>(<span class="number">300px</span>);</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.img8</span> &#123;</span></span><br><span class="line"><span class="language-css">	-webkit-<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">252deg</span>) <span class="built_in">translateZ</span>(<span class="number">300px</span>);</span></span><br><span class="line"><span class="language-css">	-moz-<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">252deg</span>) <span class="built_in">translateZ</span>(<span class="number">300px</span>);</span></span><br><span class="line"><span class="language-css">	<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">252deg</span>) <span class="built_in">translateZ</span>(<span class="number">300px</span>);</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.img9</span> &#123;</span></span><br><span class="line"><span class="language-css">	-webkit-<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">288deg</span>) <span class="built_in">translateZ</span>(<span class="number">300px</span>);</span></span><br><span class="line"><span class="language-css">	-moz-<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">288deg</span>) <span class="built_in">translateZ</span>(<span class="number">300px</span>);</span></span><br><span class="line"><span class="language-css">	<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">288deg</span>) <span class="built_in">translateZ</span>(<span class="number">300px</span>);</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.img10</span> &#123;</span></span><br><span class="line"><span class="language-css">	-webkit-<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">324deg</span>) <span class="built_in">translateZ</span>(<span class="number">300px</span>);</span></span><br><span class="line"><span class="language-css">	-moz-<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">324deg</span>) <span class="built_in">translateZ</span>(<span class="number">300px</span>);</span></span><br><span class="line"><span class="language-css">	<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">324deg</span>) <span class="built_in">translateZ</span>(<span class="number">300px</span>);</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="keyword">@-moz-keyframes</span> rotate1 &#123;</span></span><br><span class="line"><span class="language-css">	<span class="number">0%</span> &#123;</span></span><br><span class="line"><span class="language-css">	-webkit-<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">0deg</span>);</span></span><br><span class="line"><span class="language-css">	-moz-<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">0deg</span>);</span></span><br><span class="line"><span class="language-css">	<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">0deg</span>);</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="number">100%</span> &#123;</span></span><br><span class="line"><span class="language-css">	-webkit-<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">360deg</span>);</span></span><br><span class="line"><span class="language-css">	-moz-<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">360deg</span>);</span></span><br><span class="line"><span class="language-css">	<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">360deg</span>);</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css">&#125;<span class="keyword">@-webkit-keyframes</span> rotate1 &#123;</span></span><br><span class="line"><span class="language-css">	<span class="number">0%</span> &#123;</span></span><br><span class="line"><span class="language-css">	-webkit-<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">0deg</span>);</span></span><br><span class="line"><span class="language-css">	-moz-<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">0deg</span>);</span></span><br><span class="line"><span class="language-css">	<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">0deg</span>);</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="number">100%</span> &#123;</span></span><br><span class="line"><span class="language-css">	-webkit-<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">360deg</span>);</span></span><br><span class="line"><span class="language-css">	-moz-<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">360deg</span>);</span></span><br><span class="line"><span class="language-css">	<span class="attribute">transform</span>:<span class="built_in">rotateY</span>(<span class="number">360deg</span>);</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css">&#125;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;show&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/IMG_E1642.JPG&quot;</span> <span class="attr">class</span>=<span class="string">&quot;img1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/IMG_E1644.JPG&quot;</span> <span class="attr">class</span>=<span class="string">&quot;img2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/IMG_E1640.JPG&quot;</span> <span class="attr">class</span>=<span class="string">&quot;img3&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/IMG_1444.JPG&quot;</span> <span class="attr">class</span>=<span class="string">&quot;img4&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/IMG_1440.JPG&quot;</span> <span class="attr">class</span>=<span class="string">&quot;img5&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/IMG_1439.JPG&quot;</span> <span class="attr">class</span>=<span class="string">&quot;img6&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/IMG_1430.JPG&quot;</span> <span class="attr">class</span>=<span class="string">&quot;img7&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/IMG_1427.JPG&quot;</span> <span class="attr">class</span>=<span class="string">&quot;img8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/IMG_1429.JPG&quot;</span> <span class="attr">class</span>=<span class="string">&quot;img9&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/IMG_1443.JPG&quot;</span> <span class="attr">class</span>=<span class="string">&quot;img10&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>定位(position)</p>
</li>
<li><ul>
<li>属性</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>absolute：绝对定位   会让元素脱离文档流，会参照第一个父元素进行定位</li>
<li>fiexd：规定位置，将元素固定在某个位置不动，不管网页怎么拖动，该元素始终不动</li>
<li>relative：相对定位，相对于正常位置进行定位</li>
<li>inherit：继承，规定添加了该属性的元素继承它父元素的定位属性</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>注：添加了定位后，对于标签位置移动时不使用margin，而使用left,right,top,bottom</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.rows</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.cols</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.c1</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#ee3fb3</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.c2</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#50eecd</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.lb</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#17ff0a</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">top</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">left</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;rows&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cols c1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cols c2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;rows&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cols c2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cols c1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;lb&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.b1</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">1000px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#50eecd</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.b2</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">1000px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#41ee4e</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.b3</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">1000px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#edee4f</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.b4</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">1000px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#ee3b13</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.b5</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">1000px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#c25eee</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.fixedDemo</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: fixed;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">right</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">top</span>: <span class="number">30%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#17ff0a</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;b1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;b2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;b3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;b4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;b5&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;fixedDemo&quot;</span>&gt;</span>若干国粹<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Java语言概述</title>
    <url>/2022/07/16/Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h1 id="Java语言概述"><a href="#Java语言概述" class="headerlink" title="Java语言概述"></a>Java语言概述</h1><h2 id="Java简介"><a href="#Java简介" class="headerlink" title="Java简介"></a>Java简介</h2><h3 id="Java发展简史"><a href="#Java发展简史" class="headerlink" title="Java发展简史"></a>Java发展简史</h3><p>Java是由Sun公司于1995年5月推出的)ava程序设计语言和)ava平台的总称，Java语言是可以编写跨平台，分布式应用软件的面向对象的程序设计语言。</p>
<p>1998年12月Sun公司发布了Java历史上最重要的一个JDK版本：JDK1.2,JSP&#x2F;Servlet等规范，并且将Java一分为三。      J2ME:主要用于移动设备和信息家电等设备的编程      J2SE:Java技术的核心和技术      J2EE:Java技术中应用最广泛的部分</p>
<h3 id="Java程序运行的机制"><a href="#Java程序运行的机制" class="headerlink" title="Java程序运行的机制"></a>Java程序运行的机制</h3><p>C语言在编写完程序后要经过编译以后才能运行，Java也是如此，Java程序要想运行，也需要经过编译的阶段，但是和C语言不同的是Java编译过后，并不会生成特定的平台机器码，而是一种与平台无关的字节码（.class件），然而这种文件并不能直接执行，而是运行在Java虚拟机中，由Java虚拟机来解释执行。也就是说如果要运行一个Java程序，必须经历以下3个阶段。</p>
<p><img src="https://files.catbox.moe/cf44z5.png" alt="img"></p>
<p>其中Java源代码编译成字节码的过程由Java编译器完成，生成的是平台无关的字节码。这些字节码并不依赖于特定的平台，只面向Java虚拟机(Java Virtual Mechine,简称JVM,不同平台的JVM是不同的，但是他们都遵循共同的JVM规范。这也是Java跨平台的核心部分，只要为对应平台实现了对应的虚拟机，编译后的字节码就可以在不同的平台上运行。总结起来Java跨平台实现的核心原理包括以下两点：</p>
<p>1.Java源代码在运行之前会先根据JVM规范生成平台无关的字节码文件，也就是class文件，字节码文件不依赖于任何平台。</p>
<p>2.Java为不同平台实现了对应的虚拟机，JVM在加载字节码文件后由WM生成对应平台的计算机指令。</p>
<h3 id="Java语言的特点"><a href="#Java语言的特点" class="headerlink" title="Java语言的特点"></a>Java语言的特点</h3><p>1.简单性：Java在开发时借鉴了C语言的许多语法，并目屏弃了C中不好的设计，如头文件、指针、结构体、多继到等等，并目新增了垃极回收机制使得程序员无需关注内存的分配与释放，把更多的精力放在业务本身。</p>
<p>2.面向对象：面向对象是一种编程思想，相对于面向过程来说，具备一定的优越性，简单来说这种思想将重点放在数据和对象的接口上。打个比方，一个建筑师关注的应该是建筑本身，而不是这栋建筑使用的是什么工具和流程制造的。</p>
<p>3.分布式：Java提供了JSP&#x2F;Servleti规范以后，使得Java应用程序能够通过URL打开和访问网络上的对象。</p>
<p>4.安全性：由于Java具有分布式的特点，Java在安全方面投入了很大的精力，够防范各种攻击。</p>
<p>5.多线程：随着互联网的发展，开发者越来越关注并发性，例如天猫双十一活动每秒的请求量数以百万计算，这不但考验服务器硬件，也考验看服务器编程语言的性能，Java提供的多线程以及并发偏程，很大程度上解决了局并发存在的问题。</p>
<p>6.可移植：正是因为Java提出的跨平台策略使得Java的可移植性具备了操作空间，我们知道Java对于不同的平台开发了对应的JVM,而程序运行前由Java编译器将源代码编译成了平台无关的字节码文件，因此不管是在什么平台开发的源程序，编译后都可以运行在不同平台上的JVM中。</p>
<h2 id="Java下载与安装"><a href="#Java下载与安装" class="headerlink" title="Java下载与安装"></a>Java下载与安装</h2><p>JDK下载地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></p>
<h3 id="Java安装目录简介"><a href="#Java安装目录简介" class="headerlink" title="Java安装目录简介"></a>Java安装目录简介</h3><p>·bin:该目录下主要存放DK的各种工具命令.</p>
<p>·conf:该目录下主要存放JDK的相关配置文件。</p>
<p>·include:该目录下主要存放了一些平台的头文件，</p>
<p>·jmods:该目录下主要存放了JDK的各种模块。</p>
<p>·Iega:该目录下主要存放了JDK各模块的授权文档。</p>
<p>·lib:该目录下主要存放了JDK工具的一些补充jar包和源代码。</p>
<h3 id="Java环境变量配置"><a href="#Java环境变量配置" class="headerlink" title="Java环境变量配置"></a>Java环境变量配置</h3><p>开发一个应用需要经历两个步骤：</p>
<p>1.编写源代码</p>
<p>2.将编写好的源代码进行编译，编译成平台无关的class文件这两个命令对应的就是JDK安装目录中bin目录下的两个应用程序：java.exe,javac.exe,现在如果要去开发一个应用程序，并使得其能正常运行，我们还需要配置环境变量。</p>
<p>配置环境变量的步骤如下：</p>
<p>1.配置JAVA_HOME</p>
<p>在系统环境变量中新建变量名：JAVA_HOME(不区分大小写)，变量值便是jDK的安装路径</p>
<p>2.配置Path</p>
<p>和配置JAVA_HOME一样，新建环境变量PTAH，变量值是JDK安装目录下得bin目录。如果系统变量中已经存在PATH，不要删除PATH中的值，在已有内容的后面添加“；”继续配置Java即可.</p>
<p>3.配置CLASSPATH</p>
<p>在配置好JAVA_HOME和PATH以后，继续配置CLASSPATH，变量值为JDK安装路面下得lib目录。需要注意的是，从JDK 1.5以后，CLASSPATH是可以不配置的。</p>
<h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><h3 id="记事本编写HelloWorld"><a href="#记事本编写HelloWorld" class="headerlink" title="记事本编写HelloWorld"></a>记事本编写HelloWorld</h3><ol>
<li>在D盘根目录新建一个记事本，命名为hello</li>
<li>在记事本输入以下代码</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>保存后关闭文件，并修改文件的拓展名为.java</li>
<li>打开cmd，进入D盘，hello所在位置</li>
<li>输入命令对源文件进行编译：javac Hello.java</li>
<li>输入命令运行Java：java Hello</li>
</ol>
<p><strong>注意：此处的命令并不区分大小写，当使用javac编译完程序后使用java命令运行程序，此时我们只写文件名即可，并不需要写扩展名</strong>按照以上步骤操作以后你会看到窗口中打印了Hello World,自此，我们已经开发了自己的第一个Java程序，下面我们对上述代码进行简单的解释：</p>
<p>1.class:是java中的关键字，用于声明一个类，Hello表示是类名</p>
<p>2.public static是修饰符</p>
<p>3.void表示方法没有返回值</p>
<p>4.main表示方法名，main方法也是程序的入口</p>
<p>5.System.out.println表示在控制台打印，其中System首字母大写</p>
<h3 id="Java源文件命名规则"><a href="#Java源文件命名规则" class="headerlink" title="Java源文件命名规则"></a>Java源文件命名规则</h3><p>Java源文件的命名需要遵守以下规则:</p>
<p>1.文件的扩展名或后缀名必须是java</p>
<p>2.文件名必须和类中pulic修饰的类名称相同</p>
<h3 id="对Java的认识"><a href="#对Java的认识" class="headerlink" title="对Java的认识"></a>对Java的认识</h3><p>Java是一门面向对象的编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点 。Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等。</p>
<h3 id="Java的平台无关性是怎么实现的"><a href="#Java的平台无关性是怎么实现的" class="headerlink" title="Java的平台无关性是怎么实现的"></a>Java的平台无关性是怎么实现的</h3><p>1.什么是平台无关性</p>
<p>平台无关性就是一种语言在计算机上的运行不受平台的约束，一次编译，到处执行（Write Once ,Run Anywhere）。</p>
<p>也就是说，用Java创建的可执行二进制程序，能够不加改变的运行于多个平台。</p>
<p>平台无关性好处</p>
<p>作为一门平台无关性语言，无论是在自身发展，还是对开发者的友好度上都是很突出的。</p>
<p>因为其平台无关性，所以Java程序可以运行在各种各样的设备上，尤其是一些嵌入式设备，如打印机、扫描仪、传真机等。随着5G时代的来临，也会有更多的终端接入网络，相信平台无关性的Java也能做出一些贡献。</p>
<p>对于Java开发者来说，Java减少了开发和部署到多个平台的成本和时间。真正的做到一次编译，到处运行。2.平台无关性的实现</p>
<p>对于Java的平台无关性的支持，就像对安全性和网络移动性的支持一样，是分布在整个Java体系结构中的。其中扮演者重要的角色的有Java语言规范、Class文件、Java虚拟机（JVM）等。</p>
<p><strong>Java到底是是如何运行起来的</strong></p>
<p>在计算机世界中，计算机只认识0和1，所以，真正被计算机执行的其实是由0和1组成的二进制文件。日常开发使用的C、C++、Java、Python等都属于高级语言，而非二进制语言。所以，想要让计算机认识我们写出来的Java代码，那就需要把他”翻译”成由0和1组成的二进制文件。这个过程就叫做编译。负责这一过程的处理的工具叫做编译器。</p>
<p>在Java平台中，想要把Java文件，编译成二进制文件，需要经过两步编译，前端编译和后端编译：</p>
<p>前端编译主要指与源语言有关但与目标机无关的部分。Java中，我们所熟知的javac的编译就是前端编译。除了这种以外，我们使用的很多IDE，如eclipse，idea等，都内置了前端编译器。主要功能就是把.java代码转换成.class代码。这里提到的.class代码，其实就是Class文件。</p>
<p>后端编译主要是将中间代码再翻译成机器语言。Java中，这一步骤就是Java虚拟机来执行的。</p>
<p><strong>Java虚拟机</strong></p>
<p>所谓平台无关性，就是说要能够做到可以在多个平台上都能无缝对接。但是，对于不同的平台，硬件和操作系统肯定都是不一样的。</p>
<p>对于不同的硬件和操作系统，最主要的区别就是指令不同。比如同样执行a+b，A操作系统对应的二进制指令可能是10001000，而B操作系统对应的指令可能是11101110。那么，想要做到跨平台，最重要的就是可以根据对应的硬件和操作系统生成对应的二进制指令。</p>
<p>而这一工作，主要由我们的Java虚拟机完成。虽然Java语言是平台无关的，但是JVM确实平台有关的，不同的操作系统上面要安装对应的JVM。Java之所以可以做到跨平台，是因为Java虚拟机充当了桥梁。他扮演了运行时Java程序与其下的硬件和操作系统之间的缓冲角色。</p>
<p><strong>字节码</strong></p>
<p>各种不同的平台的虚拟机都使用统一的程序存储格式——字节码（ByteCode）是构成平台无关性的另一个基石。Java虚拟机只与由自己码组成的Class文件进行交互。</p>
<p>我们说Java语言可以Write Once ,Run Anywhere。这里的Write其实指的就是生成Class文件的过程。</p>
<p>因为Java Class文件可以在任何平台创建，也可以被任何平台的Java虚拟机装载并执行，所以才有了Java的平台无关性。</p>
<p><strong>Java语言规范</strong></p>
<p>已经有了统一的Class文件，以及可以在不同平台上将Class文件翻译成对应的二进制文件的Java虚拟机，Java就可以彻底实现跨平台了吗？</p>
<p>其实并不是的，Java语言在跨平台方面也是做了一些努力的，这些努力被定义在Java语言规范中。</p>
<p>比如，Java中基本数据类型的值域和行为都是由其自己定义的。而C&#x2F;C++中，基本数据类型是由它的占位宽度决定的，占位宽度则是由所在平台决定的。所以，在不同的平台中，对于同一个C++程序的编译结果会出现不同的行为。</p>
<p>举一个简单的例子，对于int类型，在Java中，int占4个字节，这是固定的。</p>
<p>但是在C++中却不是固定的了。在16位计算机上，int类型的长度可能为两字节；在32位计算机上，可能为4字节；当64位计算机流行起来后，int类型的长度可能会达到8字节。</p>
<p>通过保证基本数据类型在所有平台的一致性，Java语言为平台无关性提供强了有力的支持。</p>
<p><strong>Java语言规范</strong></p>
<p>通过规定Java语言中基本数据类型的取值范围和行为</p>
<p><strong>Class文件</strong></p>
<p>所有Java文件要编译成统一的Class文件</p>
<p><strong>Java虚拟机</strong></p>
<p>通过Java虚拟机将Class文件转成对应平台的二进制文件等</p>
<p>Java的平台无关性是建立在Java虚拟机的平台有关性基础之上的，是因为Java虚拟机屏蔽了底层操作系统和硬件的差异。</p>
]]></content>
  </entry>
  <entry>
    <title>Java控制流程和数组</title>
    <url>/2022/07/19/Java%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B%E5%92%8C%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h1 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h1><p>三类程序结构：顺序结构、分支结构、循环结构</p>
<p>分支结构：用于实现根据条件来选择性执行某一段代码，因此分支结构也被叫做选择结构。<br>循环结构：则是用于实现根据循环条件重复执行某段代码。<br>Java提供了if和switch两种分支语句，还有while,do while和for三种盾环语句。</p>
<p>JDK5还提供了增强for盾环，foreach循环。以更简洁的书写方式遍历集合、数组。</p>
<h2 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h2><p>顺序结构：代码都是自上而下，依次执行，不会出现跳行执行、逆向执行等情况。</p>
<h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><p>java提供了两种常见的分支结构：if语句和switch语句，其中if语句使用布尔表达式或者布尔值作为分支结构条件来进行分支控制。</p>
<h3 id="if条件语句"><a href="#if条件语句" class="headerlink" title="if条件语句"></a>if条件语句</h3><p>if语句使用布尔表达式或者布尔值作为分支条件来进行分支控制，语句有以下三种形式。<br>单分支结构(一个if)、双分支结构（if..else）、多分支结构（if、else if）</p>
<h3 id="switch条件语句"><a href="#switch条件语句" class="headerlink" title="switch条件语句"></a>switch条件语句</h3><p>switch语句有一个控制表达式和多个case标签组成，和if语句不同的是，switch语句后面的控制表达式的数据类型只能是byte、short、char、int四种类型，从Java7以后添加了枚举类型和String类型<br>switch语句通常需要在case标签后紧跟一个代码块，case标签作为这个代码块的标识，switch语句的语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression)&#123;</span><br><span class="line">    <span class="keyword">case</span> condition1:</span><br><span class="line">        &#123;</span><br><span class="line">        	statement(s)    </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="keyword">case</span> condition2:</span><br><span class="line">        &#123;</span><br><span class="line">        	statement(s)    </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">     <span class="keyword">case</span> condition2:</span><br><span class="line">        &#123;</span><br><span class="line">        	statement(s)    </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     ....</span><br><span class="line">      <span class="keyword">case</span> condition N:</span><br><span class="line">        &#123;</span><br><span class="line">        	statement(s)    </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">default</span>:&#123;</span><br><span class="line">        statement (s)</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch分支语句的执行是先对expression求值，然后依次匹配case，如果没有与之匹配的，则执行default</p>
<h3 id="分支嵌套"><a href="#分支嵌套" class="headerlink" title="分支嵌套"></a>分支嵌套</h3><p>如果把一个分支结构放进另一个分支结构中，这种情况叫做分支嵌套，分支嵌套可以是if中嵌套switch,switch中嵌套if,也可以是if互相嵌套或者switch自身嵌套。例如，计算一个年份是否是闰年。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入年份：&quot;</span>);</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(year%<span class="number">4</span>==<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(year%<span class="number">100</span>==<span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(year%<span class="number">400</span>==<span class="number">0</span>) &#123;</span><br><span class="line">					System.out.println(year+<span class="string">&quot;是闰年&quot;</span>);</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					System.out.println(year+<span class="string">&quot;不是闰年&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(year+<span class="string">&quot;是闰年&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(year+<span class="string">&quot;不是闰年&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>循环结构是指在满足某个循环条件的情况下，反复执行同一段代码，直到不满足循环条件为止。被循环执行的代码叫做循环体。当反复执行循环体时，要在适当的时机修改循环条件，从而结束循环，否则循环会一直进行下去，形成死盾环。一个恰当的盾坏结构应该包含以下4个组成部分：<br>1.初始化语句：一个或多个语句，这些语句用来完成一些初始化工作，在循环开始之前执行<br>2.循环条件：循环条件是一个布尔表达式，该表达式决定是否执行循环体<br>3.循环体：这部分是循环的主题，如果循环条件允许，该代码块将被反复执行，如果这个代码块只有一条语句，则代码块的花括号可以管略。<br>4.迭代语句：这部分在一次循环体执行结束后执行，在循环条件求值前执行，通常用于控制循环条件中的变量，使得循环在合适的时候结束。</p>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>([init_statment];[test_exression];[iteration_statement])&#123;</span><br><span class="line">    statement;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化语句只在循环条件开始前执行依次，对于for循环而言，循环条件总比循环体要多执行一次，因为最后一次执行循环条件返回false，将不再执行循环体。</p>
<p><strong>注意：除非特殊情况尽量不要在循环体内修改循环变量的值。</strong></p>
<p>for循环圆括号中只有两个分号是必须的，初始化语句、循环条件、迭代语句部分都是可以省略的，如果省略了循环条件，则这个循环条件默认为true，将产生死循环。例如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EndlessForLoop</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;-----endless-----&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[init_statement]</span><br><span class="line"><span class="keyword">while</span>(test_expression)&#123;</span><br><span class="line">	statement;</span><br><span class="line">    [iteration_statment]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>while循环每次执，行循环体，之前，先对test_expression循环条件求值，如果循环条件为true,则执行循环体部分。从上述伪代码中来看，iteration_statment位于循环体的最后，因此只有当循环体成功执行完成时，while循环才会执行iteration_statmenti语句。</p>
<h3 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do while循环"></a>do while循环</h3><p>do while循环与while循环的区别在于：while循环是先判断循环条件，如果条件为真则执行循环体；而do while循环则新执行循环体，然后才判断循环条件，如果循环条件为真，则执行下一次循环，否则终止循环。do while循环语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[init_statement]</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	statement;</span><br><span class="line">    [iteration_statment]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(test_expression);</span><br></pre></td></tr></table></figure>

<p><strong>注意：do while循环的循环条件必须有一个分号，该分号代表该循环结构结束。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (++i&gt;<span class="number">1</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;循环条件至少执行1次&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(i);</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			k++;</span><br><span class="line">		&#125;<span class="keyword">while</span>(<span class="literal">false</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(k);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>++i&#x3D;1执行后的值为1，此时该表达式结果为false,不执行循环体，而do while循环中循环条件直接是false,但是此时仍l旧执行了循环体，k的值成为了1。</p>
<h2 id="控制循环结构"><a href="#控制循环结构" class="headerlink" title="控制循环结构"></a>控制循环结构</h2><p>Java提供了continue和break控制循环结构</p>
<h2 id="使用break结束循环"><a href="#使用break结束循环" class="headerlink" title="使用break结束循环"></a>使用break结束循环</h2><p>break：用于完全结束一个循环，跳出循环体，不管哪种循环，一旦循环体遇到break，系统将完全结束该循环，开始执行循环结构以后的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">7</span>) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>当i&#x3D;7时，直接跳出循环</p>
<h2 id="使用continue跳过此次循环"><a href="#使用continue跳过此次循环" class="headerlink" title="使用continue跳过此次循环"></a>使用continue跳过此次循环</h2><p>continue的功和break有点类似，区别是continue只是跳出此次循环，继续执行剩下的循环，并不是完全终止循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">7</span>) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h3><p>如果把一个循环放进另一个循环体内，那么就可以形成循环嵌套，循环嵌套可以是上述3种循环的任意嵌套，例如：for循环和while循环的相互嵌套，while循环和do while循环的相互嵌套，也可以是while循环和do while循环的相互嵌套。</p>
<p>当程序遇到循环嵌套是，如果外层循环的循环条件允许，则开始执行外层循环的循环体，而内层循环将被外层循环的循环体来执行，只是内层循环需要反复执行自己的循环体而已。当内层循环执行结束，且完成循环的循环体执行结束时，在再次计算外层循环的循环条件，决定是否再次执行外层循环的循环体。</p>
<p>示例：打印等腰三角形</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">5</span>-i; k &gt; <span class="number">0</span>; k-- ) &#123;</span><br><span class="line">				System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; (<span class="number">2</span>*i) - <span class="number">1</span>; j++) &#123;</span><br><span class="line">				System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>示例：冒泡排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;趟比较:&quot;</span>);</span><br><span class="line">        	</span><br><span class="line">        	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> -i; j++) &#123;</span><br><span class="line">        		<span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">        			<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        			temp = arr[j];</span><br><span class="line">        			arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">        			arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">        		&#125;</span><br><span class="line">        		System.out.print(<span class="string">&quot;第&quot;</span>+(j+<span class="number">1</span>)+<span class="string">&quot;次比较:&quot;</span>);</span><br><span class="line">        		System.out.println(Arrays.toString(arr));</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>示例：二分查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>&#125;;</span><br><span class="line">		<span class="type">int</span> <span class="variable">cc</span> <span class="operator">=</span> Demo11.binarySearch(a, <span class="number">3</span>);</span><br><span class="line">		System.out.println(cc);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] srcArray, <span class="type">int</span> des)</span> &#123;</span><br><span class="line">	    <span class="comment">//定义初始最小、最大索引</span></span><br><span class="line">	    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> srcArray.length - <span class="number">1</span>;<span class="comment">//5</span></span><br><span class="line">	    <span class="comment">//确保不会出现重复查找，越界</span></span><br><span class="line">	    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">	        <span class="comment">//计算出中间索引值</span></span><br><span class="line">	        <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (end + start)&gt;&gt;&gt;<span class="number">1</span> ;<span class="comment">//防止溢出//3</span></span><br><span class="line">	        <span class="keyword">if</span> (des == srcArray[middle]) &#123;</span><br><span class="line">	            <span class="keyword">return</span> middle;</span><br><span class="line">	        <span class="comment">//判断下限</span></span><br><span class="line">	        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (des &lt; srcArray[middle]) &#123;</span><br><span class="line">	            end = middle - <span class="number">1</span>;</span><br><span class="line">	        <span class="comment">//判断上限</span></span><br><span class="line">	        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	            start = middle + <span class="number">1</span>;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="comment">//若没有，则返回-1</span></span><br><span class="line">	    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//类是对象的模板，对象是类的实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环嵌套中的break"><a href="#循环嵌套中的break" class="headerlink" title="循环嵌套中的break"></a>循环嵌套中的break</h3><p>break语句仅结束其所在的循环，例如在双层循环嵌套中，只结束内层循环，而不能结束外层盾环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(j==<span class="number">2</span>) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(<span class="string">&quot;内存循环：&quot;</span>+j);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;外存循环：&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>运行上述代码，我们可以发现break只是结束了内层自己所在的循环，外层循环并没有被结束，仍旧在继续循环。那么，如何让break结束外层循环呢，此时就要在break后面紧跟一个标签了，这个标签用于表示一个外层盾环。Java中的标签就是一个紧跟着冒号的标识符，与其他语言不同的是，Java中的标签只有放在循环语句前才有作用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		outer:</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">			<span class="comment">//内层循环</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(j==<span class="number">1</span>) &#123;</span><br><span class="line">					<span class="comment">//跳出outer所标识的循环</span></span><br><span class="line">					<span class="keyword">break</span> outer;</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(<span class="string">&quot;i的值为：&quot;</span>+i+<span class="string">&quot;,j的值为：&quot;</span>+j);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>程序从外层循环进入内层循环，当j等于1时，程序遇到一个break outer语言，该语句将会导致结束outer标签指定的循环，不是break所在的循环，而是结束break循环的外层循环。</p>
<p>需要注意的是，break后的标签必须是一个有效的标签，这个标签必须在break语句所在的循环之前定义，或者在所在循环的外层循环之前定义。当然，如果把这个标签放在break语句所在的循环之前定义，也就失去了标签的意义，因为break默认就是结束其所在的循环。</p>
<h3 id="循环嵌套中使用continue"><a href="#循环嵌套中使用continue" class="headerlink" title="循环嵌套中使用continue"></a>循环嵌套中使用continue</h3><p>将上例中break换成continue，此处continue的作用不变，只是在多层循环中，continue会忽略当前循环，直接到外层循环继续进行循环</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p><strong>数组就是：具有相同数据类型且按照一定次序排列的一组数据的集合。</strong></p>
<p>在数组的概念中需要注意以下几点：<br>1.具有相同的数据类型，也就是说存放在一个数组的元素必须数据类型相同，不能把不同类型的元素放进同一个数组。<br>2.按照一定次序排列，数组中的元素是有序的，这句话包含两层含义，第一：元素是有顺序的。也可以理解为每个数组元素都有一个编号，这个编号是连续的（我们通常把这个编号叫做数组的下标或者索引）；第二：元素存放的顺序<br>和取出的顺序是一致的，也就是说存放元素的顺序是10,20,30,40。那么取出的顺序也是10,20,30,40。<br>3.一组数据，一组数据是指元素的个数可以是0个，也可以是1个，也可以是多个，Java中允许数组中有0个元素，也就是我们所说的空数组。</p>
<h2 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h2><p>Java的数据类型可以分为两大类：基本类型和引用类型，其中基本类型有8个，引用类型则包括：对象，数组，接口。因此数组也是一种数据类型。数组的定义方式有两种语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">type[] arrayName;</span><br><span class="line">type arrayName[];</span><br></pre></td></tr></table></figure>

<p>int类型是一个基本类型，而int[]则是一个引用类型。</p>
<p>数组初始化一旦完成，数组在内存中所占的空间将被固定下来，长度就不会改变，若长度改变，则一定</p>
<p>数组是一种引用类型的变量，当仅仅是定义了数组后，仅仅是定义了一个引用变量，这个变量还未指向任何有效内存，此时整个数组还不能使用，只有对数组初始化后才能使用。</p>
<h3 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h3><p>Java中数组必须先初始化，然后才可以使用。所谓初始化，就是为数组的元素分配内存空间，并为每个元素赋初始值。<br>数组的初始化有两种方式：<br>1.静态初始化：初始化时由程序员指定每个元素的初始值。由系统觉定数组的长度<br>2.动态初始化：初始化是程序员指定数组长度，由系统为元素分配初始值。<br>静态初始化语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">arrayName = <span class="keyword">new</span> <span class="title class_">type</span>[]&#123;e1,e2,e3&#125;</span><br><span class="line">arrayName = &#123;e1,e2,e3&#125;</span><br></pre></td></tr></table></figure>

<p>动态初始化只指定数组的长度，由系统为每个元素指定初始值。动态初始化的语法格式如下：<br>arrayName new type[length];<br>在上面的语法中，需要指定一个int类型的length参数，该参数指定了数组的长度，也就是可以容纳数组元素的个数，与静态初始化类型，此处的<br>type必须与定义数组时使用的type类型相同。动态初始化语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] ary  = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>]; </span><br></pre></td></tr></table></figure>

<p>执行动态初始化时，开发者只需指定数组的长度，即为每个元素指定所需的内存空间，系统将负责为这些数组元素分配初始值。指定初始值时，系统按如下规则分配初始值：<br>·数组元素的类型是基本类型中的整型(byte,short,int,Iong),则数组元素的初始值为0；<br>·数组元素的类型是基本类型中的浮点型(float,double),则数组元素的值是0.0；<br>·数组元素的类型是基本类型中的字符型(char),则数组元素的值是’\u0000’:<br>·数组元素的类型是基本类型中的布尔型(boolean),则数组元素的默认值是false。<br>·数组元素的类型是基本类型中的引用类型，则数组元素的默认值是null。</p>
<h2 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个整型数组，并对其动态初始化，此时数组中的元素都是默认值</span></span><br><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">5</span>];</span><br><span class="line"><span class="comment">//对数组的第二个元素进行赋值</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>遇到数组索引时，需要考虑java.lang.ArraryIndexOutOfBoundsException(数组越界异常)。</p>
<h3 id="for循环遍历数组"><a href="#for循环遍历数组" class="headerlink" title="for循环遍历数组"></a>for循环遍历数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">			a[i] = i+<span class="number">100</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">			System.out.println(a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="foreach遍历数组"><a href="#foreach遍历数组" class="headerlink" title="foreach遍历数组"></a>foreach遍历数组</h3><p>Java5以后，Java提供了更简洁遍历数组的方式：foreach循环。使用foreach遍历数组和集合元素时，无需获得数组和集合长度，无需根据索引来访问数组元素。</p>
<p>foreach我们可以理解为增强for循环，不需要开发者根据索引去数组中取值，系统会自动从数组a中取到每一个元素，并赋值给i，只需要打印i即可，这种方式也有效的避免了数组下标越界异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//定义一个整型数组，并对其静态初始化</span></span><br><span class="line">		<span class="type">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">		<span class="comment">//使用foreach遍历</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i : a) &#123;</span><br><span class="line">			System.out.println(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="深入数组"><a href="#深入数组" class="headerlink" title="深入数组"></a>深入数组</h2><h3 id="内存中的数组"><a href="#内存中的数组" class="headerlink" title="内存中的数组"></a>内存中的数组</h3><p>数组引用变量只是一个引用，这个引用变量可以指向任何有效内存，只有当该引用指向有效内存后，才可以通过该数组变量访问数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> [] a;</span><br></pre></td></tr></table></figure>

<p>此时只是定义了一个数组类型的变量，该变量没有指向任何有效内存，如果此时访问数组元素时，将会引发空指针异常。</p>
<p>与所有引用变量相同的是，引用变量是访问真实对象的根本方式，也就是说，如果希望在程序中访问数组对象本身，只能通过数组的引用变量来访问。</p>
<p>实际的数组对象被存储在堆内存中，如果引用该数组对象的数组引用变量是一个局部变量，那么它将被存储在栈内存中。数组在内存中的示意图如下图所示：</p>
<p><img src="https://files.catbox.moe/inscuk.png"></p>
<h3 id="数组的长度不能被改变"><a href="#数组的长度不能被改变" class="headerlink" title="数组的长度不能被改变"></a>数组的长度不能被改变</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line">		<span class="type">int</span>[] b = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">		a = b;</span><br><span class="line">		System.out.println(a.length);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>运行上述代码，发现数组a的长度发生了变化</p>
<p>当代码执行完第10行时，此时数组a和数组b的内存示意图如下：</p>
<p><img src="https://files.catbox.moe/4tv5yo.png"></p>
<p>当代码执行第11行时，此时内存中发生如下变化：</p>
<p><img src="https://files.catbox.moe/pm1dc7.png"></p>
<p>从图示中可以看出，此时a并不指向原来的内存空间，而是和b一样指向了相同的内存空间，而原来a指向的内存还在内存中，也就是说变的仅仅是变量a指向的内存空间，而不是数组长度，a原来指向的数组长度还是4，并没有发生变化</p>
<p><strong>数组一旦被初始化后长度不可变，如果发生了变化，一定是指向了新的数组。</strong></p>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>Java语言里提供了多维数组的支持，但是实际上并不存在多维数组，例如二维数组，完全可以认为是数组类型的数组：因为Java语言里的数组类型是引用类型，因此数组变量其实是一个引用，这个引用指向真实数组的内存。数组元素的类型也可以是引用，如果数组元素的引用再次指向真实的数组内存，此时就产生了多维数组，换句话说，多维数组本质都是一维数组。我们可以把数组当成一种数据类型，可以理解为数组类型的数组，二维数组的语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">type[] [] a = <span class="keyword">new</span> <span class="title class_">type</span>[length1][length2]</span><br></pre></td></tr></table></figure>

<p>下面通过实例来定义二维数组，并对其进行遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//此处可以理解为定义了一个3行4列的矩阵</span></span><br><span class="line">		<span class="comment">//也可以理解为外层的数组长度为3，即包含了3个数组</span></span><br><span class="line">		<span class="comment">//内存数组中每个数组有4个元素</span></span><br><span class="line">		<span class="type">int</span>[] [] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; a[i].length; j++) &#123;</span><br><span class="line">				a[i][j] = i*j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(Arrays.deepToString(a));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>通过上述代码我们可以理解为数组a是一个二维数组，也就是说数组a是长度为3的数组，而数组a中又存放了3个长度为4的数组，为每个元素赋值，<strong>deepToString</strong>则是Arrays工具类为我们提供了打印多维数组的方法。Arrays工具类会在下一小节讲解。</p>
<h2 id="Arrays工具类"><a href="#Arrays工具类" class="headerlink" title="Arrays工具类"></a>Arrays工具类</h2><p>Java提供了Arrays.工具类，里面包，含了一些方法，可以直接操作数组。<br>·int binarySearch(long[] a,long key):使用二分查找法查询key元素值在数组a中出现的索引，如果a数组不包含key元素，则返回负数，调用此方法时要求数组中的元素已经按升序排列。<br>T[] copyOf(T[] original,int newLength):该方法会把original数组复制成一个新数组，其中length:是新数组的长度，如果length.小于original数组的长度，则新数组就是原数组的前面length个元素，如果lenght大于original数组的长度，则新数组的前面元素就是原数组的所有元素，后面补充默认值，根据数组类型确定<br>·copyOfRange(T[] original,int from,int to):这个方法与前面的类以，但是这个方法只复制原数组form索引到to索引l的元素。<br>·boolean equals(type[] a,tyte[] a2):如果数组a和a2长度相等，并且a和a2每个元素也相等则返回true,否则返回false.。<br>·void fill((long[]a,I):该方法会把a数组的所有元素都赋值为val<br>·void sort(type[] a):该方法对a数组进行排序<br>·String toString(type[] a):该方法将一个数组转换成字符串，该方法按顺序吧多个元素连接在一起，元素之间用逗号隔开。<br><strong>实例一：复制数组1</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] a = &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">		<span class="comment">//如果length小于a数组长度，则只复制前n个元素</span></span><br><span class="line">		<span class="type">int</span>[] b = Arrays.copyOf(a, <span class="number">2</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i : b) &#123;</span><br><span class="line">			System.out.println(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果length大于数组a的长度，多余元素则以默认值填充</span></span><br><span class="line">		<span class="type">int</span>[] c = Arrays.copyOf(a, <span class="number">5</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i : c) &#123;</span><br><span class="line">			System.out.println(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实例二：复制数组2</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] a = &#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">6</span>&#125;;</span><br><span class="line">		<span class="type">int</span>[] b = Arrays.copyOfRange(a, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i : b) &#123;</span><br><span class="line">			System.out.println(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>复制的元素时包含了form和to索引处的元素。需要注意的是，如果该方法的第三个参数超出了原数组长度，此时并不会抛出异常，会将原数组中所有的元素进行复制，空余的位置以默认值。</p>
]]></content>
  </entry>
  <entry>
    <title>Java数据类型和运算符</title>
    <url>/2022/07/19/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h1 id="Java数据类型和运算符"><a href="#Java数据类型和运算符" class="headerlink" title="Java数据类型和运算符"></a>Java数据类型和运算符</h1><p>Java是一门强类型语言，所谓的强类型语言，可以理解为包含以下2层含义：<br>1.所有的变量都必须先声明，后使用<br>2.变量的类型一旦确定，那么变量的值必须和数据类型相匹配<br>变量:可以理解为程序运行时内存中用于保存数据的一个存储区域，该存储区域有自己的名称、类型、和值。强类型语言可以在编译过程中发现源代码的错误，从而保证程序更加健壮。</p>
<h2 id="标识符和关键字"><a href="#标识符和关键字" class="headerlink" title="标识符和关键字"></a>标识符和关键字</h2><p>Java中将变量名和方法名以及类名统称为标识符，标识符命名规则如下：</p>
<p>1.标识符只由字母、数字、下划线(_)、和美元符号($)组成，但是不能以数字开头<br>2.标识符不能是Java的关键字和保留字、但是可以包含关键字和保留字<br>3.标识符不能包含空格以及其他特殊符号</p>
<h2 id="标识符命名方式"><a href="#标识符命名方式" class="headerlink" title="标识符命名方式"></a>标识符命名方式</h2><p>在Java中标识符的命名一般遵循以下两种命名方式：<br>1.Pascal命名法：所有单词的首字母均大写，例如StudentName,TeacherAge,这种命名法通常用于类名。<br>2.Camel命名法：第一个单词的首字母小写，其余单词首字母均大写。例如：productName,produceCount。这种命名法通常用于变量名及方法名。</p>
<h2 id="数据类型分类"><a href="#数据类型分类" class="headerlink" title="数据类型分类"></a>数据类型分类</h2><p>Java中数据类型可以分为两大类：基本类型和引用类型。其中基本类型又可以分为4类，分别是：整型、浮点型、布尔型和字符型</p>
<h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p><strong>整型通常包含以下4种：</strong><br>  byte: 一个byte类型整数在内存中占8位(bit)即1个字节，可以表示的数值范围为：-128一127<br>  short: 一个short类型整数在内存中占16位即2个字节，可以表示的数值范围为-2^15一一2^15-1<br>  int: 一个int类型整数在内存中占32位4字节，可以表示的数值范围为-2^31一2^31-1<br>  long: 一个long类型整数在内存中占64位8字节，可以表示的数值范围-2^63一一2^63-1</p>
<p>如果直接将一个较小的整数值(byte或者short类型的表示范围内)赋值给一个byte类型或者short变量，系统会自动把这个整数值当成byte或者short类型处理，因为在Java中定义一个整型变量。编译器会默认是int类型</p>
<p>如果使用一个巨大的整数值（超出了int类型能表示的范围），Java不会自动把这个整数当成long类型处理，如果希望编译器把这个正式当做long类型处理，应该在数值后添加”l”或者”L”.</p>
<h4 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h4><p>在Java中声明一个变量必须先指定数据类型（Java11之前），并对其进行初始化</p>
<h4 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h4><p>声明一个变量时，目的就是为了在变量中保存数据，并使用该数据。因此，当变量定义完毕后，需要对其进行初始化，所谓初始化，就是在为变量开辟的内容空间中保存一份数据。</p>
<p><img src="https://files.catbox.moe/tta4pz.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个byte类型的变量</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="comment">//变量值超出了byte表示范围，编译器会报错</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="comment">//定义一个short类型变量</span></span><br><span class="line"><span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="comment">//定义一个整型的变量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="comment">//定义一个long类型的变量</span></span><br><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">2000L</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">2000l</span>;</span><br></pre></td></tr></table></figure>

<p>Java中整数值有4种表示方式：十进制、二进制、十六进制、八进制，其中二进制的整数以0b或者0B开头；八进制的整数以0开头；十六进制的整数以0X或者0x开头，其中10-15分别以a-表示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二进制</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0b1011</span>;</span><br><span class="line"><span class="comment">//八进制</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0111</span>;</span><br><span class="line"><span class="comment">//十六进制</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0x111</span></span><br></pre></td></tr></table></figure>

<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>Java中浮点型有两类：float和double.。Java的浮点型有固定的表示范围，Java的浮点数遵循1EEE754标准，采用二进制数据的科学计数法来表示浮点数，对于float类型，第1位是符号位，接下来的8位表示指数，在接下来的23位表示尾数；对于double类型的值，第1位也是符号位，接下来的11位表示指数，再接下来的52位表示尾数。</p>
<p>Java中浮点型有两种表示形式：<br>十进制：这种形式就是简单的浮点数，如：3.14,7.1等浮点型必须包含一个小数点，否则会被当成int类型处理<br>科学计数法：例如5.12e2(即5.12x102)<br>Java语言中浮点型默认的都是double类型的，如果要让Java把一个浮点数当故float类型处理，应该在这个浮点型后面添加后缀f或者F</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个浮点型</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">5.12</span>;</span><br><span class="line"><span class="comment">//定义一个float类型,此时编译器会报错，因为Java默认将浮点型都当做double类型，</span></span><br><span class="line"><span class="comment">//因此如果要声明一个float类型,应该添加F后缀</span></span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">5.12</span>;<span class="comment">//编译错误</span></span><br><span class="line"><span class="type">float</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="number">5.12F</span>;</span><br></pre></td></tr></table></figure>

<p>Java还提供了三个特殊的浮点数：正无穷大、负无穷大和非数，用于表示益出和出错。正无穷大用POSITIVE _INFINITY表示；负无穷大用NEGATIVE_INFINITY表示，非数通过NAN表示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="number">0.1</span>;</span><br><span class="line"><span class="comment">//用正浮点数除以0得到正无穷大</span></span><br><span class="line">System.out.print(d1/<span class="number">0</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> -<span class="number">0.1</span>;</span><br><span class="line"><span class="comment">//用负浮点数除以0得到负无穷大</span></span><br><span class="line">System.out.print(d2/<span class="number">0</span>);</span><br><span class="line"><span class="comment">//对负数开方得到NAN</span></span><br><span class="line">System.out.println(Math.sqrt(-<span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<p><strong>注意：所有的正无穷大都是相等的，所有的负无穷大都是相等的，但是NAN与任何数值都不相等，甚至和NAN都不相等。另外，只有浮点数除以0才可以得到正无穷大或者负无穷大，如果一个整数除以0,则会抛出一个异常(算数异常：ArithmeticException: &#x2F; by zero)</strong></p>
<h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><p>字符型通常用于表示单个字符，字符型值必须要用单引号括起来，Java语言使用16位的Unicode字符集作为编码方式，而Unicode字符集支特世界上所有书面语言的字符，包括中文字符因此Java程序支持各种语言的字符。</p>
<p>字符型值有3种表示形式<br>·通过单个字符来指定字符型值：例如A’,’9等<br>·通过转义字符表示特殊字符型值，如’\n’，”\t’等：<br>·直接使用Unicode值来表示字符型格式为’\uxxxx’,其中xxxx表示一个十六进制的整数<br>Java中常用转义字符如下表：</p>
<p><img src="https://files.catbox.moe/jnhlb2.png"></p>
<p>字符型值也可以使用十六进制的编码方式表示，范围是u0000一一\uFFFF,一共可以表示65535个字符，其中前256个字符和ASCII码中字符一致。并且char类型也可以作为整型值使用</p>
<h3 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h3><p>布尔型只有boolean类型，用于表示逻辑真和假，在Java中布尔型的值只有true或者false,且不能用0或者非0表示。和其他数据类型也不能相互转换.<br>Java规范中并没有强制指定布尔型变量所占用的内存，即使布尔型变量只要1位就可保存，但是大部分计算机在分配内存时所允许的最小内存单元是字节，因此布尔类型实际上占用了8位</p>
<h2 id="基本类型转换"><a href="#基本类型转换" class="headerlink" title="基本类型转换"></a>基本类型转换</h2><p>在java应用中，经常需要不同数据类型之间进行相互转换，布尔型和其他类型不能相互转换，但是在剩余7种类型之间可以相互转换，转换方式有两种：自动类型转换和强制类型转换</p>
<h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>Java中当把一个表示范围小的数值或变量赋值给另一个表示范围大的变量时，系统将自动进行转换，反之则需要强制转换。</p>
<p><img src="https://files.catbox.moe/hqqiet.png"></p>
<p>箭头左边的数值类型可以自动转换为箭头右边的数值类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TypeCast1</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">		<span class="comment">//将byte类型变量a的值赋值给int类型变量b</span></span><br><span class="line">		<span class="comment">//此时将自动转换类型</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br><span class="line">		<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">		<span class="comment">//将int类型变量c的值赋值给float类型变量d</span></span><br><span class="line">		<span class="type">float</span> <span class="variable">d</span> <span class="operator">=</span> c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>表示范围大的值或变量赋值给表示范围小的变量时，需要进行强制转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TypeCast2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//double类中转int类型</span></span><br><span class="line">		<span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5.12</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">int</span>)a;</span><br><span class="line">		<span class="comment">//int类型转short类型</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">		<span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> (<span class="type">short</span>) c;</span><br><span class="line">		System.out.println(b);</span><br><span class="line">		<span class="comment">//int类型转char类型</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">97</span>;</span><br><span class="line">		<span class="type">char</span> <span class="variable">f</span> <span class="operator">=</span> (<span class="type">char</span>) e;</span><br><span class="line">		System.out.println(f);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例中我们发现当我们把浮点型转成整型时，发生了精度丢失，只保留了整数位，舍弃了小数位，因此当操作此种类型转换时一定要注意精度丢失的问题。并且当我们把int类型转成char类型打印时发现打印了a,因为java使用了Unicode:字符集，并且前256位兼容了ASCII码，而97正是字符a。</p>
<h3 id="自动类型提升"><a href="#自动类型提升" class="headerlink" title="自动类型提升"></a>自动类型提升</h3><p>当一个算术表达式中包含多个基本类型的值时，整个算术表达式的数据类型将发生自动提升，java自动提升规则如下：<br>所有的byte、short、和char类型将被提升到int类型<br>整个算术表达式的数据类型自动提升到表达式中最高等级操作数相同的类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个byte类型变量并+2</span></span><br><span class="line"><span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">1</span>；</span><br><span class="line">s = s+<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>编译上述代码时会发现编译无法通过，这是因为变量s是short类型，2则是int类型，此时表达式中包含了多个数据类型，那么该表达式结果的数据类型则会发生自动提升，提升为最高等级操作数数据类型，也就是int,此时将一个int类型的值赋值给short类型的变量，需要进行类型强制转换，上述代码中并未强制转换，因此会编译错误，如果对s+2强制转换为int类型，则会编译通过并正常运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义double类型变量</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">5.02</span>;</span><br><span class="line"><span class="comment">//定义整型变量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">//定义byte类型变量</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">s</span> <span class="operator">=</span> d+i+b;</span><br></pre></td></tr></table></figure>

<p>在上例代码表达式中包含double类型、int类型、byte类型，根据Java类型自动提升的规则，我们知道表达最终的运算结果为等级最高的数据类型，也就是double类型，因此我们最后保存结果时定义了double类型的变量。</p>
<p>Java中的基本数据类型以及每种类型所占用的字节数和取值范围：</p>
<p><img src="https://files.catbox.moe/dmtwd1.png"></p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>编程语言主要的功能之一就是进行或简单或复杂的运算，在运算过程中有操作数，同样也需要运算符的参与，运算符其实就是一种特殊的符号，用于表述数据的运算，赋值和比较等。<br>Java中运算符可以分为以下几类：<br>·算术运算符（加、减、乘、除、取余、自增自减）</p>
<p>·%：取余运算符，求余是指使用第一个操作数除以第二个操作数，得到一个整除的结果后剩下的就是余数。需要注意的是求余运算，本质上也是一个除法运算，如果求余运算的两个操作数都是整型，则第二个操作数不能为0，<br>否则会引发程序异常。如果求余运算的两个操作数中有1个或者2个都是浮点数，则第二个操作数可以是0或者0.0，结果是NAN。0或者0.0对零以外的任何数求余都会得到0或者0.0.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ModDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">5</span>%<span class="number">3</span>;</span><br><span class="line">		System.out.println(c);</span><br><span class="line">		System.out.println(<span class="string">&quot;5对0.0取余：&quot;</span>+<span class="number">5.0</span>%<span class="number">0.0</span>);<span class="comment">//NAN</span></span><br><span class="line">		System.out.println(<span class="string">&quot;0对5.0取余：&quot;</span>+<span class="number">0</span>%<span class="number">5.0</span>);<span class="comment">//0.0</span></span><br><span class="line">		System.out.println(<span class="string">&quot;0对0.0求余：&quot;</span>+<span class="number">0</span>%<span class="number">0.0</span>);<span class="comment">//NAN</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>·赋值运算符 （&#x3D;）<br>·比较运算符（&gt;、 &lt;、 &gt;&#x3D;、 &lt;&#x3D;、&#x3D;&#x3D;）<br>·逻辑运算符<br>·位运算符<br>·类型相关运算符</p>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>Java中位运算符有7个：<br>&amp;:按位与。当两位同时为1时才返回1（同1为1）。<br>|:按位或。只要有一位为1时即返回1（有1则1）。<br>~:按位非。单目运算符，将操作数每一位（包括符号位）1变0,0变1（符号位一起取反加一）<br>^:按位异或。当两位相同时返回0，不同时返回1。（相同为0，不同为1）<br>&lt;&lt;:左移运算符(左移为乘)</p>
<p>·&gt;&gt;:右移运算符</p>
<p>·&gt;&gt;&gt;:无符号右移运算符<br>一般来说，位运算只操作整数类型的变量或值。</p>
<p><img src="https://files.catbox.moe/vskyk4.png"></p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p><strong>逻辑运算符用于操作两个布尔型的变量或者常量，主要有以下6个。</strong></p>
<p>·&amp;&amp;:与，左右两个操作数都是true才会返回true,否则返回false,需要注意的是如果左右两边是表达式，如果第一个表达式就返回false,则第二个表达式并不进行运算。</p>
<p>·&amp;:不短路与，作用于&amp;&amp;相同，但是无论第一个表达式的结果是true还是false,第二个表达式都会进行运算。</p>
<p>·||:或，两个操作数只要有一个为true,就可以返回true,否则返回false,同样，如果第一个表达式返回值为true,则第二个表达式不进行运算</p>
<p>·|:不短路或，作用于相同，但是无论第一个表达式结果如何，第二个表达式都会进行运算。</p>
<p>·!:非，只需要一个操作数，如果操作数为true,则返回false,如果操作数为false,则返回true。</p>
<p>·^:异或，当两个操作数不同时返回为true,如果两个操作数相同的返回false。</p>
<h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4><p>三目运算符只有一个：？：，三目运算符语法格式如下：<br>(expression) ? if-true-statement ： if-false-statement;<br>运算规则如下：<br>1.计算表达式expression的值<br>2.如果表达式返回true,则返回if-true-statement的值<br>3.如果表达式返回false,则返回if-false-statement的值</p>
<h4 id="赋值扩展运算符"><a href="#赋值扩展运算符" class="headerlink" title="赋值扩展运算符"></a>赋值扩展运算符</h4><p>赋值运算符可以同算术运算符、位移运算符结合，对赋值运算符进行扩展，扩展后的赋值运算符如下：<br>·+&#x3D;:对于x+&#x3D;y,等价于x&#x3D;x+y。<br>·-&#x3D;:对于x-&#x3D;y,等价于x&#x3D;x-y。<br>·*&#x3D;:对于x*&#x3D;y,等价于x&#x3D;x*y。</p>
<p>&#x2F;&#x3D;、%&#x3D;、&amp;&#x3D;、|&#x3D;、^&#x3D;、&lt;&lt;&#x3D;、&gt;&gt;&#x3D;、&gt;&gt;&gt;&#x3D;（无符号右移赋值操作）</p>
<h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>运算符有不同的优先级，所谓优先级就是在表达式中运算的先后顺序，Java语言中大部分运算符都是从左向右结合的，只有个别运算符从右向走结合，例如：单目运算符、赋值运算符、三目运算符，下表将列出所有运算符的优先级：</p>
<p><img src="https://files.catbox.moe/xv3qg6.png"></p>
]]></content>
  </entry>
  <entry>
    <title>Java面向对象(基础)</title>
    <url>/2022/07/20/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E5%9F%BA%E7%A1%80)/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h1 id="面向对象（基础篇）"><a href="#面向对象（基础篇）" class="headerlink" title="面向对象（基础篇）"></a>面向对象（基础篇）</h1><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>类：可以被理解为一种自定义的数据类型，可以使用类定义变量，所有使用类定义的变量都是引用类型。类是一系列具有相同行为和属性的对象的集合，用于描述客观世界中一类对象的共同特征。</p>
<p>对象：是具体的，是类的实例，类是对象的模板，对象是类的实例</p>
<h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><p>面向对象的程序设计中有两个重要的概念：类（class）和对象（Object，也叫做实例）。其中类是对一批对象的抽象，可以把类理解成某个群体，对象则是具体的存在。</p>
<p><strong>Java中定义类的简单语法如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] class 类名&#123;</span><br><span class="line"> 	<span class="number">0</span>个或者多个构造器</span><br><span class="line">    <span class="number">0</span>个或者多个成员变量</span><br><span class="line">    <span class="number">0</span>个或者多个方法</span><br><span class="line">    <span class="comment">//另外，类中还可以包含内部类，内部枚举等等    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于一个类来说，最常见的可以包含：构造器、成员变量和方法，并且这个组成部分都可以包含0个或者多个。一般来说这3个组成部分至少会包含1个组成部分，如果3部分都不包含实际上定义了一个空类，这样做没有任何意义。</p>
<p><strong>定义成员变量语法如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] 数据类型 成员变量 [=默认值]</span><br></pre></td></tr></table></figure>

<p><strong>修饰符：</strong>修饰符可以省略，也可以是public、protected、private、static、.final、transient,其中public、protected、private.只能选一个，可以与final、static组合来修饰成员变量<br><strong>类型：</strong>类型可以是Java允许的任意类型，可以是基本类型、也可以是引用类型<br><strong>成员变量名：</strong>成员变量名只要是一个合法的标识符即可，成员变量的命名一般使用camel命名法，第一个单词首字母小写，其余单词的首字母均大写，单词间不用任何分隔符，并且要做到见名知意，尽量避免用单个字母命名<br><strong>默认值：</strong>成员变量可以指定默认值，也可以不指定，当不指定时在创建对象时，Java会提供默认值，其中整型默认值为0，浮点型默认值为0.0,布尔型默认值为false,字符型默认值为’\u0000’。</p>
<p><strong>定义成员方法语法如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] 方法返回值类型 方法名(形参列表)&#123;</span><br><span class="line"> 	<span class="comment">//方法体   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法返回值类型：</strong>返回值类型可以是v允许的任意数据类型、包括基本类型和引用类型；如果声明了返回值类型、则方法体中必须有一个有效的return语句，该语句返回一个变量或者表达式，这个变量或表达式的类型必须与声明的类型匹配，此外，如果一个方法没有返回值，则返回值类型用void代替，表明该方法没有返回值。<br><strong>方法名：</strong>方法名的命名规则同成员变量的命名规则基本一致。<br><strong>形参列表：</strong>形参用于定义该方法可以接受的参数，形参列表可以由0个或者多个参数组成，参数之间用逗号隔开。一旦方法定义时定义了形参列表，则调用该方法时必须传入对应类型的参数值。即谁调用，谁传参。</p>
<p><strong>构造体(构造方法)的定义</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] 方法名(形参列表)&#123;</span><br><span class="line"> 	方法体   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造器则是一种特殊的方法，其作用是用于创建对象，Java语言通过new关键字来调用构造方法，从而返回该类的实例。构造器是一个类创建对象的基本方法，如果一个类没有构造器，这个类也就无法创建实例了。因此Java语言提供了一个功能：<strong>如果开发者没有为类编写构造器，编译器会为该类提供一个默认无参数的构造器，一旦开发者提供了构造器，则编译器不在提供构造器。</strong></p>
<p><strong>需要注意的是构造器是一种特殊的方法，其方法名和类名相同，但没有方法返回值，也不用void修饰。</strong></p>
<p><strong>修饰符：</strong>修饰符可以省略，也可以是public、protected、private其中之一，如果构造器的修饰符为private,则不能通过new调用，也就是说当一个类的构造器被private修饰，该类则不能通过new来创建对象<br><strong>方法名：</strong>必须与类名相同<br><strong>形参列表：</strong>和方法中的形参格式完全相同</p>
<p><strong>陷阱:给定一个方法名称和类名相同，但是有返回值或者使用了void修饰，要求你判断是否是构造方法。有void的方法就不是构造方法！！！</strong></p>
<h2 id="创建对象和使用对象"><a href="#创建对象和使用对象" class="headerlink" title="创建对象和使用对象"></a>创建对象和使用对象</h2><p>创建对象最根本的途径是调用构造器，Java中通过new关键字来调用构造器创建对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个Student类型的对象，也可以说是定义了一个Student类型的变量</span></span><br><span class="line">Student s;</span><br><span class="line"><span class="comment">//通过new关键字调用构造方法，返回Student对象</span></span><br><span class="line"><span class="comment">//将返回的对象赋值给变量s</span></span><br><span class="line">s = <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="comment">//简写为</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br></pre></td></tr></table></figure>

<p>创建好对象后，可以对对象进行如下操作：</p>
<p>1、访问对象的实例变量</p>
<p>2、调用对象的方法</p>
<h2 id="基本类型和引用类型"><a href="#基本类型和引用类型" class="headerlink" title="基本类型和引用类型"></a>基本类型和引用类型</h2><p>基本类型：int i &#x3D; 10; 执行该代码时，其在内存中的结构如下图所示：</p>
<p><img src="https://files.catbox.moe/1biox2.png"></p>
<p>引用类型：Student s &#x3D; new Student(); 执行该代码时，其在内存的示意图如下所示：</p>
<p><img src="https://files.catbox.moe/3eo9gj.png"></p>
<p>从上图中我们可以看出，Studenty对象包含两个实例变量，而变量是需要内存来存储的，当创建Student对象时，必然要有对应的内存来存储对象的实例变量，Student对象由多块内存组成，不同的内存分别存储着Student对象的不同成员变量，当把Student对象赋值给一个引用变量时，<br>Java会将对象的地址保存在变量中，也就是保存在栈中，也就是说<strong>变量中仅仅保存的是一个引用或者说地址，而不是真实的对象</strong>，由该变量中的引用指向该对象。对象的成员变量数据实际存放在堆中，<br>当访问对象的成员变量和方法时，实际上访问的是变量所指向的对象的成员变量和方法。<br>综上所述，可以简单的理解为基本类型在栈中保存的是变量真实的值，而引用类型保存的并不是对象而是一个地址或者说引用，这就是基本类型和引用类型的根本区别，这也就是说我们通常判断基本类型相等时，用双等号即可，而判断引用类型则不能用双等号。</p>
<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>Java提供了一个this关键字，this关建字可以指代当前对象，根据this出现的位置不同，this作为当前对象的默认引用有两种使用方式<br>1.构造器中使用this可以调用其他构造器<br>2.方法中使用this可以方问其他方法或者实例变量，通常this可以省咯。<br>this关键字最大的作用就是让类中一个方法，访问该类里的另一个方法或实例变量<br>this关键字最大的作用就是上类中的方法访问类中的另一个方法或者实例变量，假设定义了一个Animal类，这个Animal对象的run()方法需要调用它的jump方法，就可以使用this关键字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">	String name;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">//在run方法中调用jump</span></span><br><span class="line">		<span class="built_in">this</span>.jump();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jump</span><span class="params">()</span> &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>在Java中一个成员直接调用另一个成员时，this可以省略。也就是说上述的代码可以修改为如下形式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">//在run方法中调用jump</span></span><br><span class="line">		jump();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jump</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>这是Java中规定，当在构造方法中调用其它构造方法时，不需要些构造方法的名字，因为所有构造方法的名称都是一样的，唯一不同的就是参数列表，JVM会通过this后传入的参数列表来确定究竟调用哪一个构造方法.<strong>需要注意的是，this调用构造方法只能在构造方法中使用，不能写在实例方法中，并且要放在构造方法中代码的第一行。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">	<span class="comment">//实例变量</span></span><br><span class="line">	String name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="comment">//提供无参的构造方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>(<span class="string">&quot;猫咪&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//提供有参的构造方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>(<span class="string">&quot;猫咪&quot;</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：this不能出现在类方法中，因为类方法在类加载后，创建对象前就已经准备完毕，此时还没有对象，也就不存在this</strong></p>
<h2 id="方法详解"><a href="#方法详解" class="headerlink" title="方法详解"></a>方法详解</h2><p>方法是类或对象的行为特征的抽象，方法是类或对象最重要的组成部分。但从功能上来看，方法完全类似于传统结构化程序设计里的函数。值得指出的是，Java 里的方法不能独立存在，所有的方法都必须定义在类里。方法在逻辑上要么属于类，要么属于对象。</p>
<h3 id="实例方法和类方法"><a href="#实例方法和类方法" class="headerlink" title="实例方法和类方法"></a>实例方法和类方法</h3><p>·被static修饰的方法叫做类方法，方法属于类，调用时不依赖于对象，通过类名.方法名即可调用。<br>·不被static修饰的方法叫做实例方法，方法属于对象，调用时依赖对象，必须先创建对象才能调用，因此其调用方式是对象名.方法名</p>
<p>**这里可能产生一个问题;同一个类里不同方法之间相互调用时，不就可以直接调用吗?**这里需要指出; 同一个类的一个方法调用另外一个方法时，如果被调方法是普通方法，则默认使用 this 作为调用者;如果被调方法是静态方法，则默认使用类作为调用者。也就是说，表面上看起来某些方法可以被独立执行，但实际上还是使用 this 或者类来作为调用者。</p>
<p>·永远不要把方法当成独立存在的实体，正如现实世界由类和对象组成，而方法只能作为类和对象的附属，Java语言里的方法也是一样。Java语言里方法的所属性主要体现在如下几个方面。方法不独立定义，方法只能在类体里定义。<br>·从逻辑意义上来看，方法要么属于该类本身，要么属于该类的一个对象。<br>·永远不能独立执行方法，执行方法必须使用类或对象作为调用者。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="comment">//定义一个类方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">makeMoney</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//定义一个实例方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法的参数传递"><a href="#方法的参数传递" class="headerlink" title="方法的参数传递"></a>方法的参数传递</h3><p>前面已经介绍了Java里的方法是不能独立存在的，调用方法也必须使用类或对象作为主调者。如果声明方法时包含了形参声明，则调用方法时必须给这些形参指定参数值，调用方法时实际传给形参的参数值也被称为实参。那么，Java的实参值是如何传入方法的呢？这是由java方法的参数传递机制来控制的，Java方法的参数传递方式只有一种值传递。所谓值传递，就是将实际参数值的副本（复制品）传入方法内，而参数本身不会受到任何影响。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwapDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">		swap(a, b);</span><br><span class="line">		System.out.println(<span class="string">&quot;main=====a:&quot;</span>+a);<span class="comment">//5</span></span><br><span class="line">		System.out.println(<span class="string">&quot;main=====b:&quot;</span>+b);<span class="comment">//3</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 定义方法交换两个变量</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> b</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">		a = a^b;</span><br><span class="line">		b = a^b;</span><br><span class="line">		a = a^b;</span><br><span class="line">		System.out.println(<span class="string">&quot;swap=====a:&quot;</span>+a);<span class="comment">//3</span></span><br><span class="line">		System.out.println(<span class="string">&quot;swap=====b:&quot;</span>+b);<span class="comment">//5</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>从结果可以看出在swap方法中交换了变量a和变量b的值，但是在main方法中变量a和变量b的值并没有发生变化，这是因为在方法传递参数时传递的是实参的副本，也就是说在main方法中调用swap方法传递参数时，会将变量保存在钱内存中的真实值复制一份传递给swap方法，这样并不影响原来变量的值。</p>
<p><strong>以上情况是基本类型的，那么引用类型的又是怎样的呢，现在我们定义一个Teacher类，类中只包含一个int类型的age变量。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Teacher</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">		t1.age = <span class="number">18</span>;</span><br><span class="line">		change(t1);</span><br><span class="line">		System.out.println(<span class="string">&quot;main=====t:&quot;</span>+t1.age);<span class="comment">//20</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(Teacher t2)</span> &#123;</span><br><span class="line">		t2.age = <span class="number">20</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;change=====t:&quot;</span>+t2.age);<span class="comment">//20</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当代码执行到12行时，此时调用了change()方法，并传入了t1对象，此时并不是将对象直接传递，传递的是t1中保存的引用或地址。</p>
<p><img src="https://files.catbox.moe/lbzdgw.png"></p>
<p>在change方法中修改了对象的年龄，也就是说在change方法中修改的也是t1指向的对象，所以当在main方法中打印对象的年龄时，t1的年龄也变成了20。所以在Java中不存在引用传递，<strong>所谓的引用传递本质上都是值传递</strong></p>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>JDK 1.5 以后Java允许定义形参个数可变的参数，从而允许为方法指定数量不确定的参数，如果在定义方法时，最后一个参数的类型后添加三点，则表明该形参可以接收多个参数指，多个参数值被当做数组传入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Varargs</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//可变参数可以单独传递</span></span><br><span class="line">		test(<span class="number">100</span>, <span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">		String[] strs = &#123;<span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;赵敏&quot;</span>,<span class="string">&quot;张三丰&quot;</span>&#125;;</span><br><span class="line">		<span class="comment">//可变参数可以传入数组</span></span><br><span class="line">		test(<span class="number">200</span>, strs);</span><br><span class="line">		<span class="comment">//也可以不传递</span></span><br><span class="line">		test(<span class="number">300</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a,String...names)</span> &#123;</span><br><span class="line">		System.out.println(a);</span><br><span class="line">		<span class="keyword">if</span>(names!=<span class="literal">null</span>&amp;&amp;names.length&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">				System.out.println(name);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>null和空的区别，int[] a;不初始化数组，则它为null；int[] a &#x3D; {};初始化数组,但不为它赋值，则为空。</p>
<p>例如有一张白纸，上面不写东西则为空；没有白纸，则为null</p>
<p>从上面的示例可以看出，当一个方法中有可变参数时，参数可以分开传递，也可以放入数组，然后将数组传递给可变参数，也可以不传递，因此，我们在使用可变参数时，首先要判断可变参数是否为null，其次因为可变参数的本质是数组，因此还需要判断数组中是否存在元素。<br>注意的是：可<strong>变参数只能处于参数列表的最后一个参数，一个方法中只能包含一个可变参数，可变参数的本质就是一个数组。</strong></p>
<h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>在Java中允许同一个类中定义多个同名的方法，但是要保证参数列表不同，也就是说同一个类中包含了两个或者两个以上方法名相同，但是参数列表不同，则被称为方法重载。这里需要注意的是方法重载与访问修饰符无关、方法返回值无关、方法抛出异常无关，只与方法的参数列表有关。<br>那么什么叫做参数列表不同呢，参数列表不同需要注意以下几点：<br>1.个数不同<br>2.数据类型不同<br>例如下面的两个方法就不构成方法重载，因为两个方法方法名相同，但是参数数据类型相同，都是一个double类型和一个int类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalcArea</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">area</span><span class="params">(<span class="type">int</span> width,<span class="type">double</span> height)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> width*height;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">area</span><span class="params">(<span class="type">double</span> width)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="type">int</span>)width*height;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，当我们调用方法时，如果区分究竟调用的是哪个方法呢，如果你还记得我们使用this调用构造方法时，这个问题就会迎刃而解，当我们调用重载的方法时，也是通过传入的参数由JVM决定调用哪个方法。这个过程叫做<strong>重载解析</strong>。</p>
<h2 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h2><p>在 Java 语言中，根据定义变量位置的不同，可以将变量分成两大类; 成员变量和局部变量。成员变量和局部变量的运行机制存在较大差异</p>
<h3 id="成员变量和局部变量是什么"><a href="#成员变量和局部变量是什么" class="headerlink" title="成员变量和局部变量是什么"></a>成员变量和局部变量是什么</h3><p>成员变量指的是在类里定义的变量，也就是前面所介绍的filed;局部变量指的是在方法里定义的变量。</p>
<p><img src="https://files.catbox.moe/rsluwt.png"></p>
<p>成员变量被分为类变量和实例变量两种，定义成员变量设有static修饰的就是实例变量，有static修饰的就是类变量。其中类变量从该类的准备阶段起开始存在，直到系统完全销毁这个类，类变量的作用域与这个类的生存范围相同：而实例变量则从该类的实例被创建起开始存在，直到系统完全销毁这个实例，实例变量的作用域与对应实例的生存范围相同。</p>
<p><strong>一个类在使用之前要经过类加载、类验证、类准备、类解析、类初始化等几个阶段。</strong></p>
<p>正是基于这个原因，可以把类变量和实例变量统称为成员变量，其中类变量可以里解为类成员变量，它作为类本身的一个成员，与类本身共存亡实例变量侧可理解为实例成员变量，它作为实例的一个成员，与实例共存亡。只要类存在，程序就可以访问该类的类变量。在程序中访问类<br><strong>变量通过如下语法：类.类变量、实例.实例变量、实例.类变量</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//创建两个对象</span></span><br><span class="line">		<span class="type">School</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">School</span>();</span><br><span class="line">		<span class="type">School</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">School</span>();</span><br><span class="line">		<span class="comment">//修改s1对象的number</span></span><br><span class="line">		s1.number = <span class="number">1000</span>;</span><br><span class="line">		<span class="comment">//因为static修饰的是所有对象共有的</span></span><br><span class="line">		<span class="comment">//所以s1的number也是1000</span></span><br><span class="line">		System.out.println(s2.number);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>从上例的实例可以看出当修改s1的number属性时，s2的number属性也发生了变化，这是因为，static修饰的变量属于对象所属的类，被所有对象所共享。但是我们并不推荐使用对象来访问类变量，类变量应该通过类名访问。</p>
<p>局部变量根据定义形左式的不同，又可以被分为如下三种。<br><strong>形参：</strong>在定义方法签名时定义的变量，形参的作用域在整个方法内有效。<br><strong>方法局部变量：</strong>在方法体内定义的局部变量，它的作用域是从定义该变量的地方生效，到该方法结束时失效。<br><strong>代码块局部变量：</strong>在代码块中定义的局部变量，这个局部变量的作用域从定义该变量的地方生效，到该代码块结束时失效。与成员变量不同的是，局部变量除形参之外，都必须显式初始化。也就是说，必须先给方法局部变量和代码块局部变量指定初始值，否则不可以访问它们。</p>
<p>在同一个类里，成员变量的作用范围是整个类内有效。一个类里不能定义两个同名的成员变量，即使一个是类变量，一个是实例变量也不行；一个方法里不能定义两个同名的方法局部变量，方法局部变量与形参也不同名：同一个方法中不同代码块内的代码块局部变量可以同名：如果先定义代码块局部变量，后定义方法局部变量，前面定义的代码块局部变量与后面定义的方法局部变量也可以同名。Java允许局部变量和成员变量同名，如果方法里的局部变量和成员变量同名，局部变量会覆盖成员变量，如果需要在这个方法里引用被覆盖的成员变量，则可使用this(对于实例变量)或类名（对于类变量）作为调用者来限定问成员变量</p>
<h3 id="成员变量初始化机制"><a href="#成员变量初始化机制" class="headerlink" title="成员变量初始化机制"></a>成员变量初始化机制</h3><p>当系统加载类或创建该类的实例时，系统自动为成员变量分配内存空间，并在分配内存空间后，自动为成员变量指定初始值，下面我们通过图示来学习。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"> 	<span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    System.out.print(s.age);</span><br><span class="line">    s.age = <span class="number">18</span>;</span><br><span class="line">    System.out.print(s.age);       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当代码执行到第3行，我们发现打印了0<br>当代码执行到第2行时，JVM在堆中分配了一块内存区域，这块内存区域中保存这实例变量āge,并为其赋默认值。此时内存结构如下：</p>
<p><img src="https://files.catbox.moe/52mn1j.png"></p>
<p>当执行第4行代码时，JVM将堆内存中age的值修改为18.</p>
<h3 id="局部变量的初始化机制"><a href="#局部变量的初始化机制" class="headerlink" title="局部变量的初始化机制"></a>局部变量的初始化机制</h3><p>局部变量定义后，必须经过显式初始化后才能使用，系统不会为局部变量执行初始化。这意味着定义局部变量后，系统并未为这个变量分配内存空间，直到等到程序为这个变量赋初始值时，系统才会为局部变量分配内存，并将初始值保存到这块内存中。<br>与成员变量不同，局部变量不属于任何类或实例，因此它总是保存在其所在方法的浅内存中。如果局部变量是基本类型的变量，则直接把这个变量的值保存在该变量对应的内存中，如果局部变量是一个引用类型的变量，则这个变量里存放的是地址，通过该地址引用到该变量实际引用的对<br>象或数组。栈内存中的变量无需系统垃圾回收，往往随方法或代码块的运行结束而结束。因此，局部变量的作用域是从初始化该变量开始，直到该方法或该代码块运行完成而结束。因为局部变量只保存基本类型的值或者对象的引用，因此局部变量所占的内存区通常比较小。</p>
<h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>在前面的内容中我们可以总结出static用于修饰方法和示例变量，使用static修饰的方法叫做类方法，使用static修饰的变量叫放类变量,static还可以修饰代码块，无论是类变量还是类方法，都属于类，而不属于对象，是所有对象共享的。<br>类变量属于整个类，当系统第一次准备使用该类时，系统会为该类变量分配内存空间，类变量开始生效，直到该类被卸载，该类的类变量所占有的内存才被系统的垃圾回收机制回收。类变量生存范围几乎等同于该类的生存范围。当类初始化完成后，类变量也被初始化完成。类变量既可通<br>过类来访问，也可通过类的对象来访问。但通过类的对象来访问类变量时，实际上并不是访问该对象所拥有的变量，因为当系统创建该类的对象时，系统不会再为类变量分配内存，也不会再次对类变量进行初始化，也就是说，对象根本不拥有对应类的类变量。通过对象访问类变量只是一<br>种假象，通过对象访问的依然是该类的类变量，可以这样理解：当通过对象来访问类变量时，系统会在底层转换为通过该类来访问类变量。<br>由于对象实际上并不特有类变量，类变量是由该类持有的，同一个类的所有对象问类变量时，实际上方间的都是孩类所特有的变量。因此，从程序运行表面来看，即可看到同一类的所有实例的类变量共享同一块内存区。<br>类方法也是类成员的一种，类方法也是属于类的，通常直接使用类作为调用者来调用类方法，但也可以使用对象来调用类方法。与类变量类似，使使用对象来调用类方法，其效果也与用类来调用类方法完全一样。</p>
]]></content>
  </entry>
  <entry>
    <title>Java面向对象(高级)</title>
    <url>/2022/07/21/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E9%AB%98%E7%BA%A7/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h1 id="Java面向对象"><a href="#Java面向对象" class="headerlink" title="Java面向对象"></a>Java面向对象</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>Java 也支持面向对象的三大特征∶封装、继承和多态，Java 提供了 private、protected 和 public 三个访问控制修饰符来实现良好的封装，提供了extends 关键字来让子类继承父类，子类继承父类就可以继承到父类的成员变量和方法，如果访问控制允许，子类实例可以直接调用父类里定义的方法。继承是实现类复用的重要手段，除此之外，也可通过组合关系来实现这种复用，从某种程度上来看，继承和组合具有相同的功能。使用继承关系来实现复用时，子类对象可以直接赋给父类变量，这个变量具有多态性，编程更加灵活;而利用组合关系来实现复用时，则不具备这种灵活性。<br> 构造器用于对类实例进行初始化操作，构造器支持重载，如果多个重载的构造器里包含了相同的初始化代码，则可以把这些初始化代码放置在普通初始化块里完成。初始化块总在构造器执行之前被调用。除此之外，Java 还提供了一种静态初始化块，静态初始化块用于初始化类，在类初始化阶段被执行。如果继承树里的某一个类需要被初始化时，系统将会同时初始化该类的所有父类。</p>
<h3 id="理解封装"><a href="#理解封装" class="headerlink" title="理解封装"></a>理解封装</h3><p>封装（encapsulation)是面向对象的三大特征之一，它的含义是指将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，而是通过该类提供的方法来实现对内部信息的操作和访问。</p>
<p>对一个类或者对象实现良好的封装，可以实现以下目的：</p>
<ol>
<li>隐藏类的实现细节，例如我们定义一个学生类，并创建了对象，对象的年龄是不能随意修改和访问的。例如我们使用的Arrays工具类中的sort()方法，我们并不需要关注方法内实现的细节，我们只需要知道该方法可以对数组进行排序即可</li>
<li>让使用者只能通过预定的方法来访问数据，从而可以在该方法中加入控制逻辑，限制对成员变量的不合理访问。</li>
<li>便于修改，提高代码的可维护性</li>
</ol>
<p><strong>为实现良好的封装，需要从两个方面考虑：</strong></p>
<ul>
<li><p>将对象的成员变量和实现细节隐藏在对象内部，不允许外部直接访问</p>
</li>
<li><p>把方法暴露出来，让方法来控制对这些成员变量进行安全的访问和操作</p>
<p>​</p>
</li>
</ul>
<h3 id="使用访问控制符"><a href="#使用访问控制符" class="headerlink" title="使用访问控制符"></a>使用访问控制符</h3><p>ava提供了3个访问控制符，private，protected和public，分别代表了3种级别的访问控制权限，另外有一个缺省的访问修饰符，因此Java提供了4个访问控制级别。Java的访问控制级别有小到大，如下图所示：</p>
<p><img src="https://files.catbox.moe/lmknma.png"></p>
<p><strong>当不使用任何访问控制符来修饰类或者类成员是，系统默认使用该访问控制级别</strong></p>
<ul>
<li>private（当前类访问权限）∶ 如果类里的一个成员（包括成员变量、方法和构造器等）使用 private 访问控制符来修饰，则这个成员只能在当前类的内部被访问。很显然，这个访问控制符用于修饰成员变量最合适，使用它来修饰成员变量就可以把成员变量隐藏在该类的内部。</li>
<li>default（包访问权限）∶如果类里的一个成员（包括成员变量、方法和构造器等）或者一个外部 类不使用任何访问控制符修饰，就称它是包访问权限的，default 访问控制的成员或外部类可以被相同包下的其他类访问。</li>
<li>protected（子类访问权限）∶如果一个成员（包括成员变量、方法和构造器等）使用protected 访 问控制符修饰，那么这个成员既可以被同一个包中的其他类访问，也可以被不同包中的子类访问。在通常情况下，如果使用 protected 来修饰一个方法，通常是希望其子类来重写这个方法。</li>
<li>public （公共访问权限）∶ 这是一个最宽松的访问控制级别，如果一个成员（包括成员变量、方 法和构造器等）或者一个外部类使用 public 访问控制符修饰，那么这个成员或外部类就可以被所有类访问，不管访问类和被访问类是否处于同一个包中，是否具有父子继承关系。</li>
</ul>
<p>可以用下表来概括上述内容：</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>公共的</td>
</tr>
<tr>
<td>protected</td>
<td>同包，子类</td>
</tr>
<tr>
<td>default</td>
<td>同包</td>
</tr>
<tr>
<td>private</td>
<td>类内</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>修饰符&#x2F;范围</th>
<th>类内</th>
<th>同包子类</th>
<th>同包非子类</th>
<th>非同包子类</th>
<th>非同包非子类</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>default</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p>对于外部类而言，它也可以使用访问控制符修饰，但外部类只能有两种访问控制级别;public 和默认，外部类不能使用 private 和 protected 修饰，因为外部类没有处于任何类的内部，<strong>也就没有其所在类的内部、所在类的子类两个范围</strong>，因此 private 和 protected 访问控制符对外部类没有意义。 外部类可以使用 public 和包访问控制权限，使用 public 修饰的外部类可以被所有类使用，如声明变量、创建实例; 不使用任何访问控制符修饰的外部类只能被同一个包中的其他类使用。 </p>
<p><strong>1.不能用private:</strong><br>对于一个外部类，用private修饰是没有意义的。因为如果使用private修饰外部类，其它类就不能访问的这个类，那么这个类就不能创建实<br>例，这个类的属性和方法就不能被外界访问，所以没有意义。</p>
<p><strong>2.不能用protected:</strong><br>protected;是用来修饰类中的属性和方法的，不是用来修饰类的。假如定义一个A类用protected修饰，再在与A类不可包的另一个保重定义一个B类，B类如果要继承A类，前提是B类能够访问到A类。仔细想想就会发现这是冲突的。（你要成为A类的子类，你的先访问到A类，但你要访问到A类，那你先得成为A类的子类。因为protected修饰的类就是给子类访问的)这个逻辑明显是冲突的。<br>所以不仅是外部类，普通类也不能用protected修饰。<br>这时肯定有人会说：把B类放在A类同一个包下，那B类不就可以访问到A类了呜？<br>但是：如果你把B类放在和A类同一个包下，那和用default修饰A类有什么区别，既然和default没有区别，那干麻还要用protected修饰A类，<br>而且protected本身可以跳出同一个包访问的意义也不存在了，所以用protected修饰类是没有意义的。</p>
<p><strong>关于访问控制符的使用，存在如下几条基本原则。</strong></p>
<ul>
<li>类里的绝大部分成员变量都应该使用 private 修饰，只有一些 static 修饰的、类似全局变量的成 员变量，才可能考虑使用public 修饰。除此之外，有些方法只用于辅助实现该类的其他方法，这些方法被称为工具方法，工具方法也应该使用private 修饰。</li>
<li>如果某个类主要用做其他类的父类，该类里包含的大部分方法可能仅希望被其子类重写，而不 想被外界直接调用，则应该使用protected 修饰这些方法。</li>
<li>希望暴露出来给其他类自由调用的方法应该使用public 修饰。因此，类的构造器通过使用 public 修饰，从而允许在其他地方创建该类的实例。因为外部类通常都希望被其他类自由使用，所以大部分外部类都使用 public 修饰。</li>
</ul>
<h3 id="package、import和import-static"><a href="#package、import和import-static" class="headerlink" title="package、import和import static"></a>package、import和import static</h3><p>所谓的包从操作系统层面来看就是一个文件夹，如果从项目开发的角度来看，就是用于管理代码的目录，一个项目可能会由多个人进行开发，那么类名相同也就不可避免，那么如何确保我们写的类不被其他开发者覆盖呢，那么我们就可以用包加以区分。</p>
<p>简而言之，Java中的包就是为了管理Java类，以及控制权限的目录。<br>如果需要使用不同包中的其他类是，我们需要在类名前加包名。例如如下写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cn.bytecollege.<span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">cn</span>.bytecollege.Student();</span><br></pre></td></tr></table></figure>

<p>这种写法在语法上是完全合法的。但是这是一件很麻烦的事情。为了简化编程，Java引入了import关键字，import可以导入指定包层次下某个类或者全部类，import语句应该出现在package语句后、类定义之前，一个Java源文件只能包含一个package语句，但可以包含多个import语句，多个import语句用于导入多个包层次下的类。</p>
<h3 id="深入构造器"><a href="#深入构造器" class="headerlink" title="深入构造器"></a>深入构造器</h3><p>构造器是一个特殊的方法，所以也叫构造方法，这个特殊的方法用于创建对象时执行初始化。构造方法是创建对象的基本方式，因此，Java类必须包含一个或者以上的构造器。</p>
<h4 id="构造器的作用"><a href="#构造器的作用" class="headerlink" title="构造器的作用"></a>构造器的作用</h4><p>构造器最大的用处就是在创建对象时执行初始化。</p>
<p>当创建一个对象时，系统为这个对象的实例变量进行默认初始化，这种默认的初始化把所有基本类型的实例变量设为 0（对数值型实例变量）或 false（对布尔型实例变量），把所有引用类型的实例变量设为 null。 如果想改变这种默认的初始化，想让系统创建对象时就为该对象的实例变量显式指定初始值，就可以通过构造器来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 提供一个自定义构造方法用于初始化实例变量</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;周芷若&quot;</span>,<span class="number">18</span>);</span><br><span class="line">		System.out.println(s.name);</span><br><span class="line">		System.out.println(s.age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的程序，可以看到输出的name值是周芷若，年龄是18，这就是构造方法的作用——为实例变量初始化值</p>
<p>构造器是创建 Java 对象的重要途径，通过 new 关键字调用构造器时，构造器也确实返回了该类的对象，<strong>但这个对象并不是完全由构造器负责创建的</strong>。<strong>实际上，当程序员调用构造器时，系统会先为该对象分配内存空间，并为这个对象执行默认初始化，这个对象已经产生了</strong>——这些操作在构造器执行之前就都完成了。也就是说，<strong>当系统开始执行构造器的执行体之前，系统已经创建了一个对象，只是这个对象还不能被外部程序访问，只能在该构造器中通过 this 来引用</strong>。当构造器的执行体执行结束来后，这个对象作为构造器的返回值被返回，通常还会赋给另一个引用类型的变量，从而让外部程序可以访问该对象。</p>
<p>因为构造器主要用于被其他方法调用，用以返回该类的实例，因而通常把构造器设置成public 访问权限，从而允许系统中任何位置的类来创建该类的对象。除非在一些极端的情况下，业务需要限制创建该类的对象，可以把构造器设置成其他访问权限，例如设置为 protected，主要用于被其子类调用;把其设置为private，阻止其他类创建该类的实例。</p>
<h4 id="构造器重载"><a href="#构造器重载" class="headerlink" title="构造器重载"></a>构造器重载</h4><p>同一个类里具有多个构造器，多个构造器的形参列表不同，即被称为构造器重载。</p>
<p>因为构造器必须与类名相同，所以同一个类的所有构造器名肯定相同。为了让系统能区分不同的构造器，多个构造器的参数列表必须不同。构造方法名称相同，参数列表不同，系统通过new调用构造方法时，根据传入的参数列表来决定调用哪个构造方法。</p>
<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>继承也是面向对象的三大特征之一，是实现代码复用的重要手段之一，<strong>Java的继承具有单继承的特点，也就是所每个类有且只能有一个父类。</strong></p>
<h3 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h3><p>所谓继承就是在已有类的基础上构建一个新类，使用extends关键字来实现，从而达到代码复用的目的，其中已有类也叫做父类、基类或者超类，新扩展的的类叫做子类或者派生类。</p>
<p>Java使用extends作为继承的关键字，其实extends翻译为扩展更为合适，而不是继承，因为翻译做继承的话，很容易和我们理解意义上的继承混淆。并且子类更多的是作为父类的扩展，也就是说父类中更多的描述的是共性，也就是大家都具有的特性，而子类中不但有共性，也可能有特性。</p>
<p>定义父类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printInfo</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;=====&quot;</span>+age);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>定义子类，该子类继承Father，并且类本身中不定义任何内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">		son.age = <span class="number">18</span>;</span><br><span class="line">		son.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">		son.printInfo();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试类，我们发现打印了张三&#x3D;&#x3D;&#x3D;18岁，我们发现Son中没有定义任何内容，但是我们依然可以访问到实例变量name和age，这说明子类Son从父类继承了这两个属性，并且我们调用了son对象的printInfo()方法，这说明子类不但继承了父类的实例变量，也继承了父类的实例方法。</p>
<p>Java中采用了单继承，也就是说一个类有且只能有一个直接父类，多个间接父类，例如：类A继承了类B，类B又继承了类C，类C又继承了类D，那么类A的直接的直接父类是类B，间接父类则有类C和类D。</p>
<p>此外，需要注意的是，如果一个Java类没有显式的指定直接父类，那么这个类默认隐式的extends了java.lang.Object类。</p>
<h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><p>子类扩展了父类，那么就获得了父类中定义的可访问的成员变量和方法。并且子类在父类的基础上可以对父类进行扩展，增加自己的状态或者行为。子类扩展了父类，当父类方法不能满足子类需要时，子类就可以重写父类方法，也叫做方法覆盖。</p>
<p>所谓方法重写就是，子类扩展父类以后，为满足自身需要，对父类行为或者方法进行覆盖，<br>子类包含与父类同名方法的现象叫做方法重写。这里需要注意以下几点：</p>
<ol>
<li>方法重写只存在于继承关系中</li>
<li>方法重写子类方法名和父类方法名相同，并且参数列表和父类方法参数列表完全相同</li>
<li>子类方法返回值类型与父类方法返回值类型一致，或者子类方法返回值类型是父类方法返回值类型的子类</li>
<li>子类方法抛出的异常要小于父类方法抛出的异常。</li>
<li>子类方法的访问权限要大于等于父类方法访问权限</li>
</ol>
<p>简单归纳为方法重写中的注意事项为“两小一大两相同”，其中两小指的是子类方法返回值和抛出异常小于父类方法返回值和抛出异常。一大则是指子类方法访问权限大于等于父类访问权限。两相同则是指方法名和参数列表相同。<br>此外，需要注意的是，如果父类方法具有 private 访问权限，则该方法对其子类是隐藏的，因此其子类无法访问该方法，也就是无法重写该方法。如果子类中定义了一个与父类 private 方法具有相同的方法名、相同的形参列表、相同的返回值类型的方法，依然不是重写，只是在子类中重新定义了一个新方法。</p>
<p><strong>方法重写和方法重载的区别：</strong><br>（1）方法重载（Overload）方法重写（Override）<br>（2）方法重载发生在同一个类里面，方法重写只发生在继承里面。<br>（3）方法重载和返回值类型无关，方法重写子类方法的返回值类型要和父类方法返回值的类型一致，或者是父类返回值的子类。<br>（4）方法重载和抛出异常无关，方法重写子类方法抛出异常小于等于父类方法抛出异常<br>（5）方法重载和修饰符的权限无关，方法重写子类方法的访问权限大于等于父类方法的访问权限<br>（6）方法重载参数列表要参数个数不同或类型顺序不同，方法重写的参数列表要与父类的参数列表一致。</p>
<p>首先我们定义一个父类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;====run&quot;</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>定义子类，并重写父类方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sparrow</span> <span class="keyword">extends</span> <span class="title class_">Bird</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;是一只麻雀，不能快速的跑，但是我可以跳&quot;</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义了Bird类，并在类中定义了run方法，因为鸟类都具有跑这个行为，但是麻雀准确意义上不能称之为跑，所以重写了父类的方法，并且严格遵循了重写方法的规则。需要注意的是在代码第8行，有一行@Override，这叫做注解，当发生方法重写时，添加在方法上方。<br><strong>注意：父类构造方法不能被继承，因此也不能被重写。可以重写的一定是从父类继承的可访问的方法。</strong></p>
<h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>super可以指代父类对象，用于访问从父类继承得到的实例变量或者方法，同时也可以访问父类的构造方法。super和this一样，都不出现在类方法中，如果出现在构造方法中，必须放在第一行，因此super()和this()调用构造方法时，不能同时出现。</p>
<ul>
<li>super访问父类属性</li>
</ul>
<p>首先，我们定义父类，父类中包含了name和age两个属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们定义子类，在子类中不定义任何实例变量，定义个print()方法，方法中使用super访问限定父类实例变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 定义实例方法使用super访问父类实例变量</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="built_in">super</span>.age);</span><br><span class="line">		System.out.println(<span class="built_in">super</span>.name);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>定义测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">		son.age = <span class="number">18</span>;</span><br><span class="line">		son.name =<span class="string">&quot;张三&quot;</span>;</span><br><span class="line">		son.print();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>测试类中我们创建了Son对象，并为其从父类继承来的属性赋值，代码12行调用son对象print方法后，在方法内部，我们使用super访问了父类的属性，并成功打印。<br>在上面的示例中，Son中没有定义任何实例变量，Son中所有的实例变量实际上都是从父类继承过来的，那么如果Son中如果定义了实例变量，并且和父类中实例变量同名，那么又会发生什么呢？那么，下面我们修改上述示例：<br>定义父类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;====&quot;</span>+age);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>在父类中定义实例变量name和age，并定义inof，打印自身的name和age。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;打印name:&quot;</span>+name);</span><br><span class="line">		System.out.println(<span class="string">&quot;访问父类name:&quot;</span>+<span class="built_in">super</span>.name);</span><br><span class="line">		System.out.println(<span class="string">&quot;访问父类age:&quot;</span>+<span class="built_in">super</span>.age);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>定义子类，并在子类中定义和父类相同的name实例变量，在print()方法中分别打印自身定义的name实例变量和父类的两个实例变量。<br>编写测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">		son.age = <span class="number">18</span>;</span><br><span class="line">		son.name =<span class="string">&quot;张三&quot;</span>;</span><br><span class="line">		son.print();</span><br><span class="line">		son.info();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试类，结果如下：</p>
<p><img src="https://files.catbox.moe/uclhit.png"></p>
<p>根据结果我们可以看出，如果子类和父类具有同名的实例变量，那么在子类实例方法中访问该成员变量时，无需显式的添加super，访问的就是自身的实例变量。也就是说如果在某个方法中访问某个成员变量，但是没有显式的指定调用者，则编译器查找顺序如下：</p>
<ol>
<li><p>查找该方法中是否含有该局部变量</p>
</li>
<li><p>查找当前类中是否包含该实例变量</p>
</li>
<li><p>查找直接父类中是否包含该变量，依次向上追溯所有父类，如果直到Object类还是没有找到，则编译错误</p>
<p>​</p>
</li>
</ol>
<p>我们在子类中定义了和父类同名的实例变量，当我们创建对象后，为name属性赋值，此时JVM查找到类本身中具有name属性，因此直接为子类对象name属性赋值，而age值此时子类对象中并不存在，因此只能为从父类继承的属性赋值，当调用print()时，print()方法是在Son中定义的，在该方法中第一行因为没有使用super，所有访问的是自身的name属性，因此打印张三，第二行访问父类属性时，因为将张三赋值给了子类的name属性，父类的属性并没有赋值，因此只有默认值，所以为null。紧接着我们访问了父类的age属性，因为age属性子类自身没有定义，所以只能访问父类的，并且明确限定了super，如果不加super，那么打印的也是18，在父类中访问自身的属性时，就会打印null和18，其实当上述代码运行时，实际上会为Son对象分配两块内存，一块用于存储在子类中定义的变量，一块用于存在从父类继承过来得到的实例变量。</p>
<ul>
<li>super访问父类实例方法</li>
</ul>
<p>访问父类的实例方法和访问实例变量类似，下面通过示例来学习，使用super调用父类实例方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;执行了Father2的info&quot;</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son2</span> <span class="keyword">extends</span> <span class="title class_">Father2</span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 子类实例方法中调用父类方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;调用Son2 test方法&quot;</span>);</span><br><span class="line">		<span class="built_in">super</span>.info();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>定义测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Son2</span> <span class="variable">son2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son2</span>();</span><br><span class="line">		son2.test();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>运行上述代码我们发现当我们调用test方法时，test方法中使用super调用了父类对象的info方法，并成功执行</p>
<ul>
<li>super访问父类构造方法</li>
</ul>
<p>我们知道子类不能继承父类的构造器，但是子类的构造方法中可以调用父类的构造方法。下面我们定义Base类和Sub类，并在Sub类中调用父类Base的构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义父类，并提供无参构造</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MR.W</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> <span class="keyword">extends</span> <span class="title class_">Object</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Base</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;执行了Base的构造方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> cn.bytecollege.extend;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义子类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MR.W</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Sub</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;执行了Sub()构造方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Sub</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="https://files.catbox.moe/rw3hei.png"></p>
<p>从代码中可以看出使用super()调用了父类构造方法，和this一样super调用构造方法，也必须放在代码的第一行。需要注意的是子类不管是否显示的使用super调用父类构造方法，JVM总会在创建子类对象时调用父类构造器，即使把上述代码中Sub类中第9行代码删了，仍旧会出现上述效果。子类调用父类构造方法分以下几种情况。</p>
<ul>
<li>子类构造器执行体的第一行使用 super 显式调用父类构造器，系统将根据 super 调用里传入的实 参列表调用父类对应的构造器。</li>
<li>子类构造器执行体的第一行代码使用 this 显式调用本类中重载的构造器，系统将根据 this 调用 传入的实参列表调用本类中的另一个构造器。执行本类中另一个构造器时即会调用父类构造器。</li>
<li>子类构造器执行体中既没有 super 调用，也没有 this 调用，系统将会在执行子类构造器之前，隐 式调用父类无参数的构造器。</li>
</ul>
<p>换句话说就是<strong>创建子类对象时会先创建父类对象</strong></p>
<p>下面，我们通过示例来学习，我们定义3个类，A继承B，B继承C</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;创建了A对象&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">C</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;创建了B对象&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">C</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;创建了C对象&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如图：</p>
<p><img src="https://files.catbox.moe/famycf.png"></p>
<p>通过上例中的代码我们可以看出两点：</p>
<ol>
<li>即使不显式的使用super，程序在创建对象时，也会先调用父类构造方法，这是因为编译器会为我们在每个构造方法内第一行添加super();</li>
<li>创建子类对象时一定会先创建父类对象。创建任何对象总是从该类所在继承树最顶项层类的构造器开始执行，然后依次向下执行，最后才执行本类的构造器。如果某个父类通过 this 调用了同类中重载的构造器，就会依次执行此父类的多个构造器。</li>
</ol>
<h3 id="super关键字和this关键字的区别"><a href="#super关键字和this关键字的区别" class="headerlink" title="super关键字和this关键字的区别"></a>super关键字和this关键字的区别</h3><p>1.属性的区别：<br>this访问本类中的属性，如果本类没有此属性则从父类中续继查找。super访问父类中的属性。</p>
<p>2.方法的以别：<br>tihs访问本类中的方法，如果本类没有此方法则从父类中继续查找。super访问父类中的方法。</p>
<p>3.构造的区别：<br>this调用本类构造，必须放在构造方法的首行。super调用父类构造，必须放在子类构造方法首行。</p>
<p>4.其他区别：<br>this表示当前对象。sper不能表示当前对象<br>A、this.变量和super.变量<br>this.变量 调 用的当前对象的变量；<br>super.变量 直接调用的是父类中的变量。<br>B、this(参数)和super(参数)方法<br>this（参数)调用（转发）的是当前类中的构造器；<br>super(参数)用于确认要使用父类中的哪一个构造器。</p>
<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><h4 id="Object类的方法"><a href="#Object类的方法" class="headerlink" title="Object类的方法"></a>Object类的方法</h4><p>Object是所有类的父类，当一个类没有使用extends关键字显式的指定父类，则该类继承Object类，因为所有类都是Object的子类，任何Java对象都可以调用Object类的方法。Object提供了以下几个方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>getClass()</td>
<td>获得当前对象的类对象</td>
</tr>
<tr>
<td>hashCode()</td>
<td>返回当前对象的hashCode()</td>
</tr>
<tr>
<td>equals()</td>
<td>判断两个对象是否相等</td>
</tr>
<tr>
<td>clone()</td>
<td>克隆并返回当前对象副本</td>
</tr>
<tr>
<td>toString()</td>
<td>打印该对象</td>
</tr>
<tr>
<td>notify()</td>
<td>线程唤醒</td>
</tr>
<tr>
<td>notifyAll()</td>
<td>线程唤醒</td>
</tr>
<tr>
<td>wait()</td>
<td>线程等待</td>
</tr>
<tr>
<td>finalize()</td>
<td>通知垃圾回收器回收，该方法不确实实际执行时间，不推荐使用</td>
</tr>
</tbody></table>
<h4 id="重写equals-方法"><a href="#重写equals-方法" class="headerlink" title="重写equals()方法"></a>重写equals()方法</h4><p>在上一小节我们知道Object类是所有Java类的父类，也就是说所有Java类都继承了Object类的可访问的方法，这其中就包括equals()方法，equals方法是用于判断两个对象是否相等。首先我们来看一下Object中equals方法的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>从源码中我们可以看到Object中equals()，方法代码很简单，其中this表示当前对象，也就是说谁调用equals方法，this就是谁，obj则是指要和当前对象比对的对象，源码中只是简单的判断this是否等于obj，也就是说判断当前对象和传入对象是否是同一引用，那么这里又产生了新的概念，“同一引用”，下面我们通过示例来学习同一引用<br>定义Student类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> s1;</span><br><span class="line">		System.out.println(s1.equals(s2));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时运行程序会发现打印true，在代码16行，我们创建了Student对象并将对象的引用赋值给了变量s1，在代码17行，我们又将s1中的引用赋值给了s2，此时变量s1和s2中都保存的是同一引用或者地址，调用equals方法时返回了true，那么我们现在再从内存的角度理解同一引用：<br>当代码执行到16行是，此时内存中示意图如下：</p>
<p><img src="https://files.catbox.moe/20a187.png"></p>
<p>当代码执行到底17行是，定义了变量s2，并将s1的值赋值给了s2，也就是说将栈内存中的s1中保存的值复制了一份放到了s2中，此时内存示意图如下：</p>
<p><img src="https://files.catbox.moe/ff8th8.png"></p>
<p>时s1和s2就是同一引用，因为他们指向了堆内存中的同一块内存区域，那么调用equals方法后，判断栈内存中值是否相等，换句话说就是判断自己是否和自己相等的，结果是肯定的。<br>但是在实际情况中只有在少数情况下才会出现两个对象指向同一引用的情况，那么该怎么判断两个对象相等呢，例如s1和s2所有的属性都相等，我们就认为这两个对象相等，此时Object类提供的equals()方法是不能满足我们的需要的，这就需要重写equals()方法。<br>通常重写equals()方法需要满足以下几个条件：</p>
<ul>
<li>自反性∶ 对任意 x，x.equals（x）一定返回 true。</li>
<li>对称性∶ 对任意x和 y，如果 y.equals（x）返回 true，则x.equals（y）也返回 true。</li>
<li>传递性∶ 对任意x，y，z，如果x.equals（y）返回 ture，y.equals（z）返回 true，则x.equals（z）一定返回 true。</li>
<li>一致性∶ 对任意x和 y，如果对象中用于等价比较的信息没有改变，那么无论调用 x.equals（y） 多少次，返回的结果应该保持一致，要么一直是 true，要么一直是 false。</li>
<li>对任何不是 null 的x，x.equals（null）一定返回 false。</li>
</ul>
<p>下面，我们根据上述规则重写Student的equals()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">		<span class="comment">//1.判断是否是同一引用，如果是则直接返回true</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">this</span> == obj) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//2.判断obj是否为null，如果是则返回false</span></span><br><span class="line">		<span class="keyword">if</span>(obj == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//3.判断是否是同一类型</span></span><br><span class="line">		<span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> Student) ) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//4.转换为同一类型对象</span></span><br><span class="line">		<span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student) obj;</span><br><span class="line">		<span class="comment">//5.判断所有实例变量是否相等</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">this</span>.name.equals(s.name)&amp;&amp;<span class="built_in">this</span>.age==s.age) &#123;<span class="comment">//这里的equals是比较String对象的</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据重写的步骤，我们可以将重写 equals()方法归纳为以下5：</p>
<ol>
<li>判断是否是同一引用，如果是则直接返回true</li>
<li>判断obj是否为null，如果是则返回false</li>
<li>判断是否是同一类型</li>
<li>转换为同一类型对象</li>
<li>判断所有实例变量是否相等</li>
</ol>
<p>下面，我们编写测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EuqalsTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">19</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(s1.equals(s2));</span><br><span class="line">		System.out.println(s1.equals(s3));</span><br><span class="line">		System.out.println(s2.equals(s3));<span class="comment">//这里的equals是比较Object对象的</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="x3D-x3D-和equals的区别"><a href="#x3D-x3D-和equals的区别" class="headerlink" title="&#x3D;&#x3D;和equals的区别"></a>&#x3D;&#x3D;和equals的区别</h4><p>我们在判断两个基本类型是否相等时，通常使用双等号，但是判断两个对象相等，使用&#x3D;&#x3D;就比较有局限性了，因为使用双等号只能判断两个变量指向同一引用的情况，而我们在日常开发中通常两个对象的所有实例变量相等，即可认为两个对象相等。从内存的角度来说，&#x3D;&#x3D;用于判断变量栈内存中保存的内容是否相等，而equals则是判断对象在堆内存中的内容是否相等。简而言之，基本类型相等的判断使用&#x3D;&#x3D;，而判断两个对象是否相等，则需要重写equals方法来判断。</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="什么是多态"><a href="#什么是多态" class="headerlink" title="什么是多态"></a>什么是多态</h3><p>继承、方法重写、父类引用指向子类对象，对象调用同一个方法时，展现出不同的行为特性</p>
<p>Java引用变量有两个类型：编译时类型和运行时类型。编译时类型有声明该变量时使用的类型决定，运行时类型由实际赋值给该变量的对象决定。如果两种类型不一致，就会出现多态性（也就是父类引用指向了子类对象）。</p>
<p>定义父类，父类中定义了实例变量和两个实例方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.poly;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">base</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;父类的普通方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;父类被子类覆盖的方法&quot;</span>);</span><br><span class="line">	&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>定义子类，子类中定义了实例变量，两个实例方法，其中一个方法重写了父类方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.poly;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sub</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;子类中的普通方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;子类覆盖了父类中的方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>定义测试类，在测试类创建3个对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.poly;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//创建父类对象，编译时类型和运行时类型一致</span></span><br><span class="line">		<span class="type">Base</span> <span class="variable">base</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Base</span>();</span><br><span class="line">		System.out.println(base.a);</span><br><span class="line">		base.base();</span><br><span class="line">		base.test();</span><br><span class="line">		<span class="comment">//创建子类对象，编译时类型和运行时类型一致</span></span><br><span class="line">		<span class="type">Sub</span> <span class="variable">sub</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">		System.out.println(sub.a);</span><br><span class="line">		sub.sub();</span><br><span class="line">		sub.test();</span><br><span class="line">		<span class="comment">//编译时类型和运行时类型不一致，多态发生</span></span><br><span class="line">		<span class="type">Base</span> <span class="variable">ploy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">		System.out.println(ploy.a);</span><br><span class="line">		ploy.base();</span><br><span class="line">		ploy.test();</span><br><span class="line">	&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的程序中，显示创建了3个对象，前面两个对象base和sub，编译时类型和运行时类型完全相同，因此不会出现多态，他们调用成员变量和成员方法是结果正常，第三个poly比较特殊，他的编译时类型是Base，运行时类型则是Sub，当调用改对象的test()方法时，实际上执行的是子类中覆盖后的test()方法，这就可能出现多态了。</p>
<p>当把一个子类对象直接赋值给父类引用变量时，就同上面的代码一样，当运行时调用该变量的方法时，其方法行为总是表现出子类方法的行为特征，而不是父类方法的行为特征，这就是相同类型的变量、调用同一个方法是呈现出多种不同的行为特征，这就是多态。</p>
<p>与方法不同的是，<strong>对象的实例变量不具备多态性</strong>。比如上面的ploy引用变量，程序中输出实例变量时，输出的了父类的实例变量。</p>
<h3 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h3><p>instanceof 运算符的作用是判断对象是否是某个类型，第一个操作数通常是一个引用类型的变量，后面的操作数通常是一个类，或者是其子类等等，如果是则返回true，如果不是则返回false。</p>
<p>在使用 instanceof 运算符时需要注意; instanceof 运算符前面操作数的编译时类型要么与后面的类相同，要么与后面的类具有父子继承关系，否则会引起编译错误。下面程序示范了instanceof运算符的用法。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.instance;<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义Person类型</span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">&#125;<span class="keyword">package</span> cn.bytecollege.instance;<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义Student类</span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;&#125;<span class="keyword">package</span> cn.bytecollege.instance;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//定义Student类型对象</span></span><br><span class="line">		<span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">		<span class="comment">//s 是Student类型的对象，因此返回true</span></span><br><span class="line">		System.out.println(s <span class="keyword">instanceof</span> Student);</span><br><span class="line">		<span class="comment">//父类引用指向子类对象</span></span><br><span class="line">		<span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">		<span class="comment">//因为Student和Person存在继承关系，所以p可以看做是Person类型</span></span><br><span class="line">		<span class="comment">//返回true</span></span><br><span class="line">		System.out.println(p <span class="keyword">instanceof</span> Person);</span><br><span class="line">		<span class="comment">//因为运行时类型就是Student类型，所以返回true</span></span><br><span class="line">		System.out.println(p <span class="keyword">instanceof</span> Student);</span><br><span class="line">        <span class="comment">//p不是String类型，编译出错</span></span><br><span class="line">        System.out.println(p <span class="keyword">instanceof</span> String);</span><br><span class="line">	&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="向上转型和向下转型"><a href="#向上转型和向下转型" class="headerlink" title="向上转型和向下转型"></a>向上转型和向下转型</h3><p>在前面重写equals方法时，我们在第4步做了一个转型操作，从代码中我们可以看出，我们将Object类型的对象转成了Student类型的对象，我们知道Object是所有Java类的父类，也就是说Student是Object的子类，这种将父类对象转型成子类的操作就叫做向下转型，类似我们在基本类型的表示大范围的数据类型转成表示小范围的数据类型，需要强制转换。反之，我们也可以将子类对象转换成父类型，这种操作在Java中我们称之为向下转型。需要注意的是：引用类型之间的转换只能在具有继承关系的两个类型之间进行，如果是两个没有任何继承关系的类型，则无法进行类型转换，否则编译时就会出现错误。如果试图把一个父类实例转换成子类类型，则这个对象必须实际上是子类实例才行（即编译时类型为父类类却，而运行时类型是子类类型），否则将在运行时引发 ClassCastException 异常。 </p>
<p>下面，我们通过示例来学习向上转型和向下转型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.instance;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CastDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">		<span class="comment">//子类对象转成父类，向上转型，自动转换</span></span><br><span class="line">		<span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> s;</span><br><span class="line">		<span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">		<span class="comment">//父类对象转子类，向下转型，强制转换</span></span><br><span class="line">		<span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> (Student) p;</span><br><span class="line">		<span class="comment">//String和Person没有任何关系，转换时会编译出错</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> p2;</span><br><span class="line">	&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h2><p>我们知道构造方法可以对对象进行状态的初始化，和构造方法具有相同功能的是初始化块。</p>
<h3 id="初始化块-1"><a href="#初始化块-1" class="headerlink" title="初始化块"></a>初始化块</h3><p>一个类中可以存在多个初始化块，相同类型的初始化块按照书写的先后顺序执行，其语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符]&#123;</span><br><span class="line"> 	<span class="comment">//代码块   &#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.init;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="comment">//定义初始化块</span></span><br><span class="line">	&#123;	</span><br><span class="line">		System.out.println(<span class="string">&quot;执行了第1个初始化块&quot;</span>);</span><br><span class="line">		<span class="comment">//初始化中也可以对实例变量初始化</span></span><br><span class="line">		name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;执行了构造方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//定义初始化块</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;执行了第2个初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;main方法中访问name属性：&quot;</span>+student.name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="https://files.catbox.moe/iva301.png"></p>
<p>从上面的结果可以看出，当创建Java对象时，系统总是先调用类中定义的初始化块，如果一个类中定义了2个普通的初始化块，前面定义的初始化块先执行，后面定义的初始化块后执行。</p>
<p>虽然 Java 允许一个类里定义 2个普通初始化块，但这没有任何意义。因为初始化块是在创建 Java对象时隐式执行的，而且它们总是全部执行，因此完全可以把多个普通初始化块合并成一个初始化块，从而可以让程序更加简洁，可读性更强。</p>
<p>从上面的示例中我们可以看出，实例变量也可以在初始化块中进行初始化，也就是说从某种程度上来说，初始化块是构造器的补充，但是初始化块不能替代构造方法。因为初始化块是一段固定执行的代码，他不能接受任何参数。如果有一段初始化处理代码对所有对象完全相同，且无需接受任何参数，就可以把这段初始化代码提取到初始化块中。如果从反编译的角度来看，初始化块中的代码在运行时会合并进构造器中。</p>
<p>从结果中我们可以看出在构造方法中多了几行指令，因此我们可以得出结论，初始化块中的代码最终也会合并进构造方法中执行。</p>
<h3 id="静态初始化块"><a href="#静态初始化块" class="headerlink" title="静态初始化块"></a>静态初始化块</h3><p>如果定义初始化块使用了static修饰，则这个初始化块就变成了静态初始化块，也被称为类初始化块（普通初始化块负责对对象进行初始化，类初始化块则负责对类进行初始化）。静态初始化块是类相关的，系统将在类初始化阶段执行静态初始化块，而不是在创建对象时才执行，因此静态初始化块比普通初始化块先执行。并且类初始化块通常用于对类变量进行初始化处理，静态初始化块不能对实例变量进行初始化。<br>与普通初始化块类似的是，系统在类初始化阶段执行静态初始化块时，不仅会执行本类的静态初始化块，而且还会一直上溯到 java.lang.Object 类（如果它包含静态初始化块），先执行java.lang.Object 类的静态初始化块（如果有），然后执行其父类的静态初始化块，最后才执行该类的静态初始化块，经过这个过程，才完成了该类的初始化过程。只有当类初始化完成后，才可以在系统中使用这个类，包括访问这个类的类方法、类变量或者用这个类来创建实例。<br><strong>注意：静态初始化块也被称为类初始化块，同样静态成员不能访问非静态成员，因此静态初始化块不能访问实例变量和实例方法。</strong></p>
<p>下面，我们通过示例来学习静态初始化块：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.init;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">	<span class="comment">//静态初始化块</span></span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Base静态块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Base初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Base</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Base构造方法&quot;</span>);</span><br><span class="line">	&#125;&#125;<span class="keyword">package</span> cn.bytecollege.init;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Sub静态块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Sub初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Sub</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Sub构造方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;<span class="keyword">package</span> cn.bytecollege.init;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Sub</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">	&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://files.catbox.moe/4fff8x.png"></p>
<p>从结果我们可以看出，我们创建Sub对象时，先追溯到父类，执行了父类的静态块代码，然后执行了子类的静态块代码，然后执行了父类的初始化块中的代码和构造方法，最后才到子类中执行了子类的初始化代码块和构造方法。</p>
<p>总结一下，我们可以归纳出静态代码块和初始化块的顺序</p>
<p><img src="https://files.catbox.moe/vibzie.png"></p>
<h3 id="初始化块中的陷阱"><a href="#初始化块中的陷阱" class="headerlink" title="初始化块中的陷阱"></a>初始化块中的陷阱</h3><p>需要注意的是在类运行过程中，一定是类成员先初始化，查看下面的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.init;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">Sub</span> <span class="variable">sub</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">	<span class="comment">//静态初始化块</span></span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Base静态块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Base初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Base</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Base构造方法&quot;</span>);</span><br><span class="line">	&#125;&#125;<span class="keyword">package</span> cn.bytecollege.init;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Sub静态块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Sub初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Sub</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Sub构造方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;<span class="keyword">package</span> cn.bytecollege.init;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Sub</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">	&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://files.catbox.moe/k94i5w.png"></p>
<p>这个结果你可能会有疑惑，但是你始终记得static修饰的成员先初始化就能得到答案，当程序运行时，我们创建了sub对象，此时，因为static修饰的会先运行，代码第4行我们创建了sub对象，创建子类对象时会先创建父类对象，因此会先创建父类对象，创建完父类对象后再创建子类对象，然后继续根据我们上一小节总结的顺序进行执行。</p>
<h2 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h2><p>final关键字可以用于修饰类，变量和方法，用于表示不可变的意思。</p>
<p>final修饰变量时，表示该变量一旦获得初始值以后，就不能被不能被重新赋值，final既可以修饰成员变量，也可以修饰局部变量、形参。</p>
<h3 id="final-修饰成员变量"><a href="#final-修饰成员变量" class="headerlink" title="final 修饰成员变量"></a>final 修饰成员变量</h3><p>成员变量是随类初始化或对象初始化而初始化的。当类初始化时，系统会为该类的类变量分配内存，并分配默认值∶当创建对象时，系统会为该对象的实例变量分配内存，并分配默认值。也就是说，当执行静态初始化块时可以对类变量赋初始值; <strong>当执行普通初始化块、构造器时可对实例变量赋初始值</strong>。因此，成员变量的初始值可以在定义该变量时指定默认值，也可以在初始化块、构造器中指定初始值。 对于 final 修饰的成员变量而言，一旦有了初始值，就不能被重新赋值，如果既没有在定义成员变量时指定初始值，也没有在初始化块、构造器中为成员变量指定初始值，那么这些成员变量的值将一直是系统默认分配的 0、”\u0000’、false 或 null，这些成员变量也就完全失去了存在的意义。因此 Java 语法规定∶ final 修饰的成员变量必须由程序员显式地指定初始值。 归纳起来，final 修饰的类变量、实例变量能指定初始值的地方如下。</p>
<ul>
<li>类变量:必须在静态初始化块中指定初始值或声明该类变量时指定初始值，而且只能在两个地 方的其中之一指定。</li>
<li>实例变量∶ 必须在非静态初始化块、声明该实例变量或构造器中指定初始值，而且只能在三个 地方的其中之一指定。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecolleg.fin;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Final1</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> age;</span><br><span class="line">	String gender;</span><br><span class="line">	<span class="keyword">final</span> String name;</span><br><span class="line">	<span class="comment">//静态块中初始化类变量</span></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		age = <span class="number">18</span>;</span><br><span class="line">		<span class="comment">//静态块中不能初始化实例变量//		gender = &quot;男&quot;;</span></span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//初始化块中可以初始化final修饰的变量</span></span><br><span class="line">		gender = <span class="string">&quot;女&quot;</span>;</span><br><span class="line">		name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">	&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>与普通成员变量不同的是，****final</strong> <strong>成员变量（包括实例变量和类变量）必须由程序员显式初始化</strong></p>
<h3 id="final-修饰局部变量"><a href="#final-修饰局部变量" class="headerlink" title="final 修饰局部变量"></a>final 修饰局部变量</h3><p>系统不会对局部变量进行初始化，局部变量必须由程序员显式初始化。因此使用 final 修饰局部变量时，既可以在定义时指定默认值，也可以不指定默认值。 如果 final 修饰的局部变量在定义时没有指定默认值，则可以在后面代码中对该 final 变量赋初始值，但只能一次，不能重复赋值;如果 final 修饰的局部变量在定义时已经指定默认值，则后面代码中不能再对该变量赋值。下面程序示范了 final 修饰局部变量、形参的情形。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecolleg.fin;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Final2</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> a)</span> &#123;</span><br><span class="line">		<span class="comment">//方法中不能对final修饰的形参赋值//		a = 100;</span></span><br><span class="line">		System.out.println(a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		test(<span class="number">300</span>);</span><br><span class="line">	&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="final修饰方法"><a href="#final修饰方法" class="headerlink" title="final修饰方法"></a>final修饰方法</h3><p>final 修饰的方法不可被重写，如果出于某些原因，不希望子类重写父类的某个方法，则可以使用 final 修饰该方法。 Java 提供的 Object 类里就有一个 final方法∶ getClassO），因为 Java不希望任何类重写这个方法，所以使用 final把这个方法密封起来。但对于该类提供的 toString()和 equals()方法，都允许子类重写，因此没有使用 final 修饰它们。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.init;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;&#125;<span class="keyword">package</span> cn.bytecollege.init;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">	<span class="comment">//编译出错，final修饰的方法不能被重写</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="final-修饰类"><a href="#final-修饰类" class="headerlink" title="final 修饰类"></a>final 修饰类</h3><p>inal修饰的类不能有子类，也就是说final修饰的类不能被继承，当子类继承父类时，父类的有些方法可能被重写，属性可以被访问，如果不希望出现上述情况，可以使用final修饰类，这样讲阻止子类继承。</p>
<h3 id="不可变类"><a href="#不可变类" class="headerlink" title="不可变类"></a>不可变类</h3><p>不可变（immutable）类的意思是创建该类的实例后，该实例的实例变量是不可改变的。Java 提供的 8 个包装类和 java.lang.String 类都是不可变类，当创建它们的实例后，其实例的实例变量不可改变。<br>如果需要创建自定义的不可变类，可遵守如下规则。</p>
<ul>
<li>使用 private 和 final 修饰符来修饰该类的成员变量。</li>
<li>提供带参数构造器，用于根据传入参数来初始化类里的成员变量。</li>
<li>仅为该类的成员变量提供getter 方法，不要为该类的成员变量提供 setter 方法，因为普通方法无 法修改 final 修饰的成员变量。</li>
</ul>
<h2 id="软件设计原则"><a href="#软件设计原则" class="headerlink" title="软件设计原则"></a>软件设计原则</h2><p>在软件开发中，软件的可维护性和代码的可复用性是一个开发者必须所思考的内容，为了增加软件的可扩展性和灵活性，开发者应该尽可能的根据以下这6条原则开发程序。</p>
<h3 id="单一职责原则-Single-Responsibility-Principle"><a href="#单一职责原则-Single-Responsibility-Principle" class="headerlink" title="单一职责原则(Single Responsibility Principle)"></a>单一职责原则(Single Responsibility Principle)</h3><p>单一职责简要来说就是对于一个类而言，应该只专注做一件事情。单一职责元素是一种对对象的理想期望，对象不应该承担太多的职责。这样就可以保证对象的高内聚，以及细粒度，方便对对象的重用。如果一个对象承担了太多的职责，当客户端需要该对象的某个职责时，就不得不把所有的职责都包含进来，从而造成代码冗余。</p>
<h3 id="里式替换原则-Liskov-Substitution-Principle"><a href="#里式替换原则-Liskov-Substitution-Principle" class="headerlink" title="里式替换原则(Liskov Substitution Principle)"></a>里式替换原则(Liskov Substitution Principle)</h3><p>在面向对象的语言中，继承是一种非常优秀的机制，继承主要有2下几个优点：</p>
<ul>
<li>代码复用，减少子类的工作量，每个子类都拥有父类的方法和属性</li>
<li>提高代码的可重用性及可扩展性</li>
</ul>
<p>同样，继承也存在若干缺点，主要体现在以下几个方面：</p>
<ul>
<li>继承是入侵式的，只要继承就必须拥有父类的方法和属性</li>
<li>增强了耦合性，当父类的常量、变量、方法修改时，必须考虑子类的修改，这有可能造成大量的代码需要重构</li>
</ul>
<p>里式替换原则可以简单的概况为所有引用基类的地方必须能透明的使用其子类，换句话说，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或者异常。但是反过来则不行，子类能出现的地方，父类一不定能出现，这一点要尤为注意。</p>
<h3 id="依赖倒置原则-Dependence-Inversion-Principle"><a href="#依赖倒置原则-Dependence-Inversion-Principle" class="headerlink" title="依赖倒置原则(Dependence Inversion Principle)"></a>依赖倒置原则(Dependence Inversion Principle)</h3><p>依赖倒置原则是指：高层模块不应该依赖底层模块，两者都依赖其抽象，并且抽象不应该依赖细节，而应该是细节依赖于抽象。<br>在Java语言中，抽象就是指接口或抽象类，两者都是不能直接被实例化的；细节就是具体的实现类，实现类实现了接口或继承了抽象类，其特点是可以直接被实例化。依赖倒置原则在Java语言中的表现是：</p>
<ul>
<li>模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生；</li>
<li>接口或抽象类不依赖于实现类；</li>
<li>实现类依赖于接口或抽象类。</li>
</ul>
<p>依赖倒置原则更加精确的定义就是“面向接口编程”——OOD（Object-OrientedDesign）的精髓之一。依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。依赖倒置原则是JavaBean、EJB等组件设计模型背后的基本原则。</p>
<h3 id="接口隔离原则-Interface-Segregation-Principle"><a href="#接口隔离原则-Interface-Segregation-Principle" class="headerlink" title="接口隔离原则(Interface Segregation Principle)"></a>接口隔离原则(Interface Segregation Principle)</h3><p>接口隔离原则的具体含义如下。</p>
<ul>
<li>一个类对另外一个类的依赖性应当是建立在最小的接口上的。</li>
<li>一个接口代表一个角色，不应当将不同的角色都交给一个接口。没有关系的接口合并在一起，形成一个臃肿的大接口，这是对角色和接口的污染。因此使用多个专门的接口比使用单一的总接口要好。</li>
<li>不应该强迫客户依赖于它们不用的方法。接口属于客户，不属于它所在的类层次结构，即不要强迫客户使用它们不用的方法，否则这些客户就会面临由于这些不使用的方法的改变所带来的改变。</li>
</ul>
<h3 id="迪米特法则-Law-of-Demeter"><a href="#迪米特法则-Law-of-Demeter" class="headerlink" title="迪米特法则(Law of Demeter)"></a>迪米特法则(Law of Demeter)</h3><p>迪米特法则又叫最少知识原则（Least Knowledge Principle，LKP），意思是一个对象应当对其他对象尽可能少的了解。迪米特法则最初是用来作为面向对象的系统设计风格的一种法则，在1987年由Ian Holland在美国东北大学为一个叫迪米特的项目设计提出的，因此叫做迪米特法则。<br>按照迪米特法则，如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用；如果一个类需要调用另一个类的某一个方法，可以通过第三者转发这个调用。</p>
<h3 id="开闭原则-Open-Closed-Principle"><a href="#开闭原则-Open-Closed-Principle" class="headerlink" title="开闭原则(Open-Closed Principle)"></a>开闭原则(Open-Closed Principle)</h3><p>开闭原则是指一个软件实体应当对扩展开放，对修改关闭。<br>这个原则说的是，在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展，即应当可以在不必修改源代码的情况下改变这个模块的行为。在面向对象的编程中，开闭原则是最基础的原则，起到总的指导作用，其他原则（单一职责、里氏替换、依赖倒置、接口隔离、迪米特法则）都是开闭原则的具体形态，即其他原则都是开闭原则的手段和工具。开闭原则的重要性可以通过以下几个方面来体现。</p>
<ul>
<li><p><strong>开闭原则提高复用性</strong>。在面向对象的设计中，所有的逻辑都是从原子逻辑组合而来的，而不是在一个类中独立实现一个业务逻辑，代码粒度越小，被复用的可能性就越大，避免相同的逻辑重复增加。开闭原则的设计保证系统是一个在高层次上实现了复用的系统。</p>
</li>
<li><p><strong>开闭原则提高可维护性</strong>。一个软件投产后，维护人员的工作不仅仅是对数据进行维护，还可能对程序进行扩展，就是扩展一个类，而不是修改一个类。开闭原则对已有软件模块，特别是最重要的抽象层模块要求不能再修改，这就使变化中的软件系统有一定的稳定性和延续性，便于系统的维护。</p>
</li>
<li><p><strong>开闭原则提高灵活性</strong>。所有的软件系统都有一个共同的性质，即对系统的需求都会随时间的推移而发生变化。在软件系统面临新的需求时，系统的设计必须是稳定的。开闭原则可以通过扩展已有的软件系统，提供新的行为，能快速应对变化，以满足对软件新的需求，使变化中的软件系统有一定的适应性和灵活性。</p>
</li>
<li><p><strong>开闭原则易于测试</strong>。测试是软件开发过程中必不可少的一个环节。测试代码不仅要保证逻辑的正确性，还要保证苛刻条件（高压力、异常、错误）下不产生“有毒代码”（Poisonous Code），因此当有变化提出时，原有健壮的代码要尽量不修改，而是通过扩展来实现。否则，就需要把原有的测试过程回笼一遍，需要进行单元测试、功能测试、集成测试，甚至是验收测试。开闭原则的使用，保证软件是通过扩展来实现业务逻辑的变化，而不是修改。因此，对于新增加的类，只需新增相应的测试类，编写对应的测试方法，只要保证新增的类是正确的就可以了。</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Java抽象类和接口</title>
    <url>/2022/07/26/Java%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>我们学习了面向对象以及面向对象的特征，我们知道父类一般描述的是一类事物的共性，也就是说父类就是对基类的初步抽象，但是有的时候我们可能只知道子类具有行为，但是不能确切的知道这些子类如何实现这些方法，例如，我们都知道绝大多数鸟都会飞，但是每种鸟飞的高度和速度都不同，这样父类也就不能准确的描述子类飞行这个行为。即便是父类定义了方法，不同的鸟根据实际情况也会重写这个方法，那么这个方法的定义也就显得多余。<br>你可能会想到，能不能只定义方法头，而不提供方法的具体实现，让这个类的子类去自己实现呢？在Java中，这种行为是允许的，这就是我们我们本章节学习的抽象类和接口。</p>
<h2 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h2><p>抽象类就是使用abstract修饰的类。抽象方法就是使用abstract修饰的方法。抽象类中可以包含抽象方法，也可以不包含。<br>抽象类和抽象方法的规则如下：</p>
<ul>
<li>抽象类必须使用 abstract 修饰符来修饰，抽象方法也必须使用 abstract 修饰符来修饰，抽象方法 不能有方法体。</li>
<li>抽象类不能被实例化，无法使用 new 关键字来调用抽象类的构造器创建抽象类的实例。即使抽 象类里不包含抽象方法，这个抽象类也不能创建实例。</li>
<li>抽象类可以包含成员变量、方法（普通方法和抽象方法都可以）、构造器、初始化块、内部类（接 口、枚举）5种成分。抽象类的构造器不能用于创建实例，主要是用于被其子类调用。</li>
<li>含有抽象方法的类（包括直接定义了一个抽象方法;或继承了一个抽象父类，但没有完全实现 父类包含的抽象方法;或实现了一个接口，但没有完全实现接口包含的抽象方法三种情况）只能被定义成抽象类。</li>
</ul>
<p>定义抽象类只需在普通类上增加 abstract 修饰符即可。甚至一个普通类（没有包含抽象方法的类）增加 abstract 修饰符后也将变成抽象类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter07;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个抽象类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MR.W</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractCalc</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 普通类中可以定义的内容，抽象类中都可以定义</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> String type;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 定义抽象方法，具体实现由子类实现</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">area</span><span class="params">(<span class="type">double</span>...args)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，定义了一个抽象类，抽象类的命名一般用Abstract作为前缀，在非抽象类中定义的内容在抽象类中同样可以定义，并且抽象类中还可以定义抽象方法，在代码16行，定义了一个抽象方法，从示例中可以看出，抽象方法使用了abstract修饰，并且抽象方法只有方法头，没有方法体。参数列表后直接以“;”结束。<br>下面定义子类并重写父类的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter07;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AreaCalc</span> <span class="keyword">extends</span> <span class="title class_">AbstractCalc</span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 计算圆面积</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">area</span><span class="params">(<span class="type">double</span>... args)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(args!=<span class="literal">null</span>&amp;&amp;args.length&gt;<span class="number">0</span>&amp;&amp;args.length==<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> Math.PI*Math.pow(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例中继承了抽象类AbstractCalc，并重写了父类的抽象方法，因为父类方法使用了可变参数，而计算圆面积时，只需要传入半径即可，因此先判断可变参数是否为null以及长度是否为0，并且只有1个参数时，就可以确定是在计算圆面积。需要注意的是：</p>
<ul>
<li>子类继承抽象类必须重写父类的抽象方法（普通实例方法可以不重写），如果不重写父类的抽象方法，那么自己也必须是一个抽象类。</li>
<li>abstract只能修饰类和方法，不能修饰成员变量和局部变量、构造器等，没有抽象变量和抽象构造方法。</li>
<li>抽象类也是单继承的，不管是普通类继承抽象类还是抽象类继承抽象类，都是单继承的。</li>
</ul>
<p>除此之外，当使用 static 修饰一个方法时，表明这个方法属于该类本身，即通过类就可调用该方法，但如果该方法被定义成抽象方法，则将导致通过该类来调用该方法时出现错误（调用了一个没有方法体的方法肯定会引起错误）。因此static 和 abstract 不能同时修饰某个方法，即没有所谓的类抽象方法。</p>
<p>abstract 关键字修饰的方法必须被其子类重写才有意义，否则这个方法将永远不会有方法体，因此 abstract 方法不能定义为 private 访问权限，即 private和abstract 不能同时修饰方法。</p>
<p>从前面的示例程序可以看出，抽象类不能创建实例，只能当成父类来被继承。从语义的角度来看，抽象类是从多个具体类中抽象出来的父类，它具有更高层次的抽象。·从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为其子类的模板，从而避免了子类设计的随意性。 抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会大致保留抽象类的行为方式。 如果编写一个抽象父类，父类提供了多个子类的通用方法，并把一个或多个方法留给其子类实现，这就是一种模板模式，模板模式也是十分常见且简单的设计模式之一。例如前面介绍的 Shape、Circle和Triangle 三个类，已经使用了模板模式。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>抽象类是从多个类中抽象出来的模板，如果将这种抽象更彻底一些，可以抽象出更加简洁和精炼的类——接口。<br>在日常生活中，我们经常可以听到某某接口，例如：USB接口、打印机接口等，你可能会将Java中的接口和上述的这些接口等同，其实这是不准确的，在Java中的接口更倾向于描述行为规范，也就等价于描述的一些规定。例如经常听到一句话叫做一流公司做标准，这里的标准就可以理解为Java中的接口，不同的工厂生产的产品遵守这个标准和规范产品才能在市场上流通。因此，Java中的接口可以理解为定义了一种规范，接口定义了某一批类所要遵守的规范，接口并不关心类的内部状态数据，也不关注这些方法里的实现细节，它只规定子类里必须提供某些方法。<br>由此可见，接口是从多个相似的类<strong>中抽象出来的规范</strong>，接口不提供任何实现。</p>
<h3 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h3><p>定义接口使用关键字interface，接口的定义语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] interface 接口名 extends 父接口<span class="number">1</span>,父接口<span class="number">2</span>,父接口<span class="number">3.</span>..&#123;</span><br><span class="line"> 	  <span class="number">0</span>个或者多个常量定义...</span><br><span class="line">      <span class="number">0</span>个或者多个抽象方法定义...</span><br><span class="line">      <span class="number">0</span>个或者多个内部类、接口、枚举</span><br><span class="line">      <span class="number">0</span>个多个私有的方法、默认方法或者类方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面语法说明如下：</p>
<ul>
<li>修饰符可以是 public 或者省略，如果省略了public 访问控制符，则默认采用包权限访问控制符， 即只有在相同包结构下才可以访问该接口。</li>
<li>接口名应与类名采用相同的命名规则，即如果仅从语法角度来看，接口名只要是合法的标识符 即可;如果要遵守 Java 可读性规范，则接口名应由多个有意义的单词连缀而成，每个单词首字母大写，单词与单词之间无须任何分隔符。接口名通常能够使用形容词。</li>
<li>一个接口可以有多个直接父接口，但接口只能继承接口，不能继承类。</li>
</ul>
<p>由于接口定义的是一种规范，因此接口里不能包含构造器和初始化块定义。接口里可以包含成员变量（只能是静态常量）、方法（只能是抽象实例方法、类方法、默认方法或私有方法）、内部类（包括内部接口、枚举）定义。<br> 对比接口和类的定义方式，不难发现接口的成员比类里的成员少了两种（构造器和初始化块）而且接口里的成员变量只能是静态常量，接口里的方法只能是抽象方法、类方法、默认方法或私有方法。<br> 前面已经说过了，接口里定义的是多个类共同的公共行为规范，因此接口里的常量、方法、内部类和内部枚举都是 public 访问权限。定义接口成员时，可以省略访问控制修饰符，如果指定访问控制修饰符，则只能使用 public 访问控制修饰符。<br> Java9为接口增加了一种新的私有方法，其实私有方法的主要作用就是作为工具方法，为接口中的默认方法或类方法提供支持。私有方法可以拥有方法体，但私有方法不能使用 default 修饰。私有方法可以使用 static 修饰，也就是说，私有方法既可是类方法，也可是实例方法。 <br>对于接口里定义的静态常量而言，它们是接口相关的，因此系统会自动为这些成员变量增加 static和 final 两个修饰符。也就是说，在接口中定义成员变量时，不管是否使用 public static final修饰符，接口里的成员变量总是使用这三个修饰符来修饰。而且接口里没有构造器和初始化块，因此接口里定义的成员变量只能在定义时指定默认值。<br>接口中定义的变量都是常量，默认的修饰符就是public static final ,因此即使不加，在编译时编译器也会自动添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">MAX_VALUE</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SIZE</span> <span class="operator">=</span> <span class="number">50</span></span><br></pre></td></tr></table></figure>

<p>接口里定义的方法只能是抽象方法、类方法、默认方法或私有方法，因此如果不是定义默认方法、类方法或私有方法，系统将自动为普通方法增加 abstract 修饰符;定义接口里的普通方法时不管是否使用 public abstract 修饰符，接口里的普通方法总是使用public abstract 来修饰。接口里的普通方法不能有方法实现（方法体）; 但类方法、默认方法、私有方法都必须有方法实现（方法体）。<br>下面，通过示例来学习接口的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter07;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MR.W</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IBird</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 常量的命名一般使用大写，多个单词</span></span><br><span class="line"><span class="comment">	 * 用_连接</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">MAX_AGE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 定义抽象方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 定义类方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;鸟类吃食物&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 定义默认方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;鸟类睡觉&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">alive</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;鸟类存活了100年&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是子类继承了接口只有抽象方法是需要强制重写的，否则子类就需要使用abstract修饰。<br>Java 8 允许在接口中定义默认方法，默认方法必须使用 default 修饰，该方法不能使用 static 修饰，无论程序是否指定，默认方法总是使用 public 修饰——如果开发者没有指定 public，系统会自动为默认方法添加 public 修饰符。由于默认方法并没有 static 修饰，因此不能直接使用接口来调用默认方法，需要使用接口的实现类的实例来调用这些默认方法。<br>Java8允许在接口中定义类方法，类方法必须使用 static 修饰，该方法不能使用 default 修饰，无论程序是否指定，类方法总是使用 public 修饰——如果开发者没有指定 public，系统会自动为类方法添加 public 修饰符。类方法可以直接使用接口来调用。<br> Java9增加了带方法体的私有方法。<br>下面定义一个接口的实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter07;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sparrow</span> <span class="keyword">implements</span> <span class="title class_">IBird</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//默认方法可以不重写</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		IBird.<span class="built_in">super</span>.sleep();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上例中我们可以得出接口中的抽象方法子类必须重写，否则就需要用abstract修饰，默认方法则可以选择性重写，而私有方法则不需要重写。</p>
<p>静态方法可以被继承，但是，不能被覆盖，即重写。如果父类中定义的静态方法在子类中被重新定义，那么在父类中定义的静态方法将被隐藏。可以使用语法：父类名.静态方法调用隐藏的静态方法。 如果父类中含有一个静态方法，且在子类中也含有一个返回类型、方法名、参数列表均与之相同的静态方法，那么该子类实际上只是将父类中的该同名方法进行了隐藏，而非重写。换句话说，父类和子类中含有的其实是两个没有关系的方法，它们的行为也并不具有多态性 因此，通过一个指向子类对象的父类引用变量来调用父子同名的静态方法时，只会调用父类的静态方法。</p>
<p>Java中的静态方法不能被子类重写</p>
<p>特点：静态方法属于类的方法，也属于对象的方法，但是静态方法随类的存在。</p>
<p>结论：Java中的静态方法不能被子类重写，实际上，子类的静态方法隐藏了父类的静态方法，因此父类的子类的静态方法同时存在，只不过父类通过类名（或对象名）调用的是父类的静态方法，子类通过类名（或对象名）调用的是子类的</p>
<p>结论：</p>
<p>（1）静态方法不支持多态。（final，private 方法也如此）</p>
<p>（2）静态方法可通过类名直接调用，也可通过类的实例化对象调用，因此Father 的实例化对象f1调用的是父类（不是子类）的静态方法。</p>
<p>（3）静态方法的绑定时期为代码的编译器期，也叫前期绑定。非静态的方法属于程序的执行期绑定，也就运行期绑定。</p>
<h3 id="接口和抽象类的区别1"><a href="#接口和抽象类的区别1" class="headerlink" title="接口和抽象类的区别1"></a>接口和抽象类的区别1</h3><p>（还要说接口、抽象类都包含什么）</p>
<p>抽象类：抽象类可以包含成员变量、方法（普通方法（其它方法）和抽象方法都可以）、构造器、初始化块、内部类（接 口、枚举）5种成分。抽象类的构造器不能用于创建实例，主要是用于被其子类调用。</p>
<p>接口：接口里可以包含成员变量（只能是静态常量）、方法（只能是抽象实例方法、类方法、默认方法或私有方法）、内部类（包括内部接口、枚举）定义。</p>
<p>从某种程度上来看，接口类似于整个系统的”总纲”，它制定了系统各模块应该遵循的标准，因此一个系统中的接口不应该经常改变。一旦接口被改变，对整个系统甚至其他系统的影响将是辐射式的，导致系统中大部分类都需要改写。 <br>抽象类则不一样，抽象类作为系统中多个子类的共同父类，它所体现的是一种模板式设计。抽象类作为多个子类的抽象父类，可以被当成系统实现过程中的中间产品，这个中间产品已经实现了系统的部分功能（那些已经提供实现的方法），但这个产品依然不能当成最终产品，必须有更进一步的完善，这种完善可能有几种不同方式。<br> 除此之外，接口和抽象类在用法上也存在如下差别。</p>
<p>接口和抽象类很像，它们都具有如下特征。</p>
<ul>
<li><p>接口和抽象类都不能被实例化，它们都位于继承树的顶端，用于被其他类实现和继承。</p>
</li>
<li><p>接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。</p>
</li>
<li><p>接口里只能包含抽象方法、静态方法、默认方法和私有方法，不能为普通方法提供方法实现; 抽象类则完全可以包含普通方法。</p>
</li>
<li><p>接口里只能定义静态常量，不能定义普通成员变量;抽象类里则既可以定义普通成员变量，也 可以定义静态常量。</p>
</li>
<li><p>接口里不包含构造器; 抽象类里可以包含构造器，抽象类里的构造器并不是用于创建对象，而 是让其子类调用这些构造器来完成属于抽象类的初始化操作。</p>
</li>
<li><p>接口里不能包含初始化块; 但抽象类则完全可以包含初始化块。</p>
</li>
<li><p>一个类最多只能有一个直接父类，包括抽象类;但一个类可以直接实现多个接口，通过实现多 个接口可以弥补Java 单继承的不足。</p>
</li>
</ul>
<h3 id="接口和抽象类的区别2"><a href="#接口和抽象类的区别2" class="headerlink" title="接口和抽象类的区别2"></a>接口和抽象类的区别2</h3><p>编译时类型由声明该变量时的类型决定，运行时类型由赋值给该变量的对象类型决定，在继承关系中，当编译时类型和运行时类型不一致时，子类重写父类方法，编译时类型调用相同方法时，总是表现出子类方法的特性，此时就产生了多态（父类引用指向子类对象）<br><strong>注意</strong><br>多态发生在继承关系当中<br>对象的实例变量不具备多态性<br>抽象类和接口的区别：<br>相同：<br>（1）抽象类和接口都不能被实例化，他们位于继承树的顶端。<br>（2）抽象类和接口都可以包含抽象方法，实现接口或继承抽象类的普通类必须实现这些抽象方法。<br>不同：</p>
<p>（1）抽象类包含类变量，实例变量，方法( 普通方法，抽象方法，默认方法，静态方法，私有方法 )，构造方法，初始化块、内部类（接口，枚举）。接口只能包含静态常量，抽象方法，默认方法(JAVA 8)，私有方法(JAVA 9)，类方法，内部类（接口，枚举）。<br>（2）接口不含初始化块和构造方法，抽象类包含，但是抽象类的构造器不是用来创建对象的，而是用来被普通子类调用来初始化抽象类。<br>（3）在Java中，抽象类本质上也是一个类，所以抽象类是单继承的，一个类只能有一个直接父类，为了弥补java单继承的不足，接口与接口之间可以进行多继承，一个类可以实现多个接口，一个接口可以继承多个接口,接口只能继承接口。</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>在类内部定义的类就叫做内部类，包含内部类的类也被叫做外部类或者宿主类，Java从JDK1.1 开始引入了内部类，目的是为Java提供了更好的封装。内部类具有以下作用：</p>
<ul>
<li>内部类隐藏在外部类中，不允许同一个包中的其他类访问</li>
<li>内部类成员可以直接访问外部类的私有数据，内部类被当成其外部类成员，同一个类的成员之间可以相互访问。但外部类不能访问内部类的实现细节，例如内部类的成员变量。</li>
</ul>
<p>从语法角度来看，定义内部类与定义外部类的语法大致相同，内部类除了需要定义在外部类内之外，还有以下两点区别：</p>
<ol>
<li>内部类比外部类多三个修饰符：private、protected、static</li>
<li>非静态内部不能拥有静态成员</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span>&#123;  </span><br><span class="line">     <span class="keyword">class</span> <span class="title class_">InnerClass</span>&#123;  </span><br><span class="line">         <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> i;  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>对于java类加载顺序我们知道，首先加载类，执行static变量初始化，接下来执行对象的创建，如果我们要执行代码中的变量i初始化，</p>
<p>那么必须先执行加载OuterClass，再加载Innerclass，最后初始化静态变量i，问题就出在加载Innerclass上面，我们可以把InnerClass看成OuterClass的非静态成员，<strong>它的初始化必须在外部类对象创建后以后进行，要加载InnerClass必须在实例化OuterClass之后完成</strong> ，java虚拟机要求所有的静态变量必须在对象创建之前完成，这样便产生了矛盾。</p>
<p>非静态内部类的创建、访问都需要有一个外部类的实例，通过外部类的实例才能访问到内部类。从底层的角度来说，外部类的实例持有指向内部类的指针，只有通过外部类实例才能访问到内部类的数据。 那么，为什么非静态内部类不能有静态的成员呢！ 首先从内存分配角度来说，众所周知，静态成员是在类加载时候分配内存空间的；但对于内部类来说，要访问它的成员，就要有一个外部类实例，但是在加载类的时候不可能实例化一个外部类给内部类的，因此，没有任何外部类的实例持有这个静态成员的指针，内部类的静态成员是无法访问到的，所以Java不允许有非静态内部类的静态成员。</p>
<h3 id="非静态内部类"><a href="#非静态内部类" class="headerlink" title="非静态内部类"></a>非静态内部类</h3><p>定义内部类并没有什么特殊之处，只需要把一个类定义在另一个类内部即可。下面通过示例来定义内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.inner;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MR.W</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的示例可以看出，内部类位于外部类的大括号中，如果位于外部类的大括号以外，则不能叫做内部类，只是源文件中定义了两个Java类而已（一个源文件中只能有一个public修饰的类，并且类名要和文件名相同）。<br>内部类可以看做类的成员，成员内部类又分为静态内部类和非静态内部类，成员内部类和成员变量、成员方法、初始化块等一样，都是类的成员。下面，通过示例继续学习非静态内部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.inner;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MR.W</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Outer</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.number = number;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 定义非静态内部类</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> MR.W</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">		<span class="keyword">private</span> String name;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">Inner</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">			<span class="built_in">super</span>();</span><br><span class="line">			<span class="built_in">this</span>.name = name;</span><br><span class="line">			<span class="built_in">this</span>.age = age;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="comment">//内部类中可访问外部类的私有成员</span></span><br><span class="line">			System.out.println(<span class="string">&quot;Outer number:&quot;</span>+number);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> cn.bytecollege.inner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.bytecollege.inner.Outer.Inner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//创建内部类对象</span></span><br><span class="line">		<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>(<span class="number">100</span>).<span class="keyword">new</span> <span class="title class_">Inner</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">		</span><br><span class="line">		inner.test();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上例38行创建了内部类对象，因为非静态内部类和实例变量一样，都依赖于对象存在，因此必须先创建外部类以后才能继续创建内部类。并且我们在内部类实例方法中访问了外部类的私有成员变量。创建完内部类对象后调用方法和普通类的对象调用方法并没有什么区别。<br>需要注意的是：非静态内部类的成员可以访问外部类的 private 成员，但反过来就不成立了。非静态内部类的成员在非静态内部类范围内是可知的，并不能被外部类直接使用。如果外部类需要访问内部类的成员，则必须显式创建非静态内部类对象来调用访问其实例成员。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.inner;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MR.W</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer2</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Outer2</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.number = number;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//外部类中访问内部类成员</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">//编译出错，因为外部类不能直接访问内部类成员</span></span><br><span class="line"><span class="comment">//		System.out.println(name);</span></span><br><span class="line">		<span class="comment">//外部类访问内部类成员时需要先创建对象</span></span><br><span class="line">		<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">		System.out.println(inner.age);</span><br><span class="line">		System.out.println(inner.name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 定义非静态内部类</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> MR.W</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">		<span class="keyword">private</span> String name;</span><br><span class="line">		<span class="type">int</span> age;</span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">Inner</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">			<span class="built_in">super</span>();</span><br><span class="line">			<span class="built_in">this</span>.name = name;</span><br><span class="line">			<span class="built_in">this</span>.age = age;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="comment">//内部类中可访问外部类的私有成员</span></span><br><span class="line">			System.out.println(<span class="string">&quot;Outer number:&quot;</span>+number);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例中，代码15行在外部类成员方法中访问了内部类的成员，发现编译出错，因为外部类不能直接访问内部类的属性。<br>另外需要注意的是：非静态内部类里不能有静态方法、静态成员变量、静态初始化块，但是可以包含初始化块。</p>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>当内部类被static修饰后，就成为了静态内部类，和类变量、类方法、静态代码块一样具有同等的地位。static 关键字的作用是把类的成员变成类相关，而不是实例相关，即 static 修饰的成员属于整个类，而不属于单个对象。</p>
<p>静态内部类可以包含静态成员，也可以包含非静态成员。根据静态成员不能访问非静态成员的规则，静态内部类不能访问外部类的实例成员，只能访问外部类的类成员。即使是静态内部类的实例方法也不能访问外部类的实例成员，只能访问外部类的静态成员。下面我们通过示例来验证这条结论</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.inner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer3</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="comment">//访问外部类类成员</span></span><br><span class="line">			System.out.println(number);</span><br><span class="line">			<span class="comment">//编译出错，静态内部类不能访问外部类的实例变量</span></span><br><span class="line"><span class="comment">//			System.out.println(count);</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上例14行可以看出静态内部类只能访问外部类的静态成员，不能访问实例成员。<br>那么静态内部类又该如何创建对象呢，下面通过示例来学习：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.inner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.bytecollege.inner.Outer3.Inner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer3</span>.Inner();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>如果把一个内部类放在方法里定义，则这个内部类就是一个局部内部类，局部内部类仅在该方法里有效。由于局部内部类不能在外部类的方法以外的地方使用，因此局部内部类也不能使用访问控制符和 static 修饰符修饰。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.inner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PartInner</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 定义局部内部类</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@author</span> MR.W</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类在Java web开发中使用的比较少，但是在Android开发中经常使用，匿名内部类的定义语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 实现接口() | 父类构造器(参数列表)&#123;</span><br><span class="line"> <span class="comment">//内部类实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面定义可以看出，匿名内部类必须继承一个父类，或实现一个接口，但最多只能继承一个父类，或实现一个接口。 关于匿名内部类还有如下两条规则。</p>
<ul>
<li>匿名内部类不能是抽象类，因为系统在创建匿名内部类时，会立即创建匿名内部类的对象。因 此不允许将匿名内部类定义成抽象类。</li>
<li>匿名内部类不能定义构造器。由于匿名内部类没有类名，所以无法定义构造器，但匿名内部类 可以定义初始化块，可以通过实例初始化块来完成构造器需要完成的事情。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.inner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(IStandard standard)</span> &#123;</span><br><span class="line">		System.out.println(standard.getCount());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">AnonDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnonDemo</span>();</span><br><span class="line">		<span class="comment">//调用test方法时，需要传入一个IStandard的子类对象</span></span><br><span class="line">		<span class="comment">//传入一个匿名内部类</span></span><br><span class="line">		demo.test(<span class="keyword">new</span> <span class="title class_">IStandard</span>() &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，AnonDemo中定义了方法test()，这个方法的参数是一个接口。因为接口不能被实例化，所以不能直接创建对象，因此创建了一个实现类的对象传入了方法。并且从示例中可以发现定义匿名内部类不需要关键字class，在定义匿名内部类时直接生成该匿名内部类的对象。<br>如果把接口更换成抽象类，定义匿名内部类的方法和上例相同，只是创建的类变成了抽象类的子类对象，并且内部类也要重新抽象类中定义的抽象方法。</p>
<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>在特定情况下，一个类的对象是有限且固定的，例如季节、星期、性别等，这种实例有限且固定的类，Java中称为枚举类。<br>在引入枚举之前，这种情况一般使用常量代替。但是这么做有一定的缺陷，例如输入性别时，一般只输出1或者2很难去猜测其代表的含义，因此也降低了代码的可读性。<br>Java5新增了一个enum关键字，用于定义枚举类（枚举也可以看做是一个特殊的类）。枚举同样可以拥有自己的成员变量和方法，也可是实现一个或者多个接口，也可以定义自己的构造方法。和定义类一样，一个枚举源文件中最多只能定义一个public访问权限的枚举类，并且该源文件名称也必须和枚举类相同。<br>枚举类和普通类存在以下差异：</p>
<ol>
<li>枚举类可以实现一个或多个接口，使用 enum 定义的枚举类默认继承了java.lang.Enum 类，而不是默认继承 Object 类，因此枚举类不能显式继承其他父类。其中 java.lang.Enum 类实现. java.lang.Serializable 和 java.lang. Comparable 两个接口。</li>
<li>使用 enum 定义、非抽象的枚举类默认会使用 final 修饰，因此枚举类不能派生子类。</li>
<li>枚举类的构造器只能使用 private 访问控制符， 如果省略了构造器的访问控制符。则默认使用 private 修饰; 如果强制指定访问控制符，则只能指定 private 修饰符。</li>
<li>枚举类的所有实例必须在枚举类的第一行显式列出，否则这个枚举类永远都不能产生实例。列出这些实例时，系统会自动添加 public static final 修饰，无须程序员显式添加。</li>
</ol>
<h3 id="定义枚举类"><a href="#定义枚举类" class="headerlink" title="定义枚举类"></a>定义枚举类</h3><p>下面，我们定义一个简单的性别枚举</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义性别枚举</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MR.W</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Gender</span> &#123;</span><br><span class="line">	MALE,FEMALE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义枚举类时，需要显式列出所有的枚举值。所有的枚举值之间用“,”隔开。枚举值结束后用英文分号作为结束。<br>在第3章switch一节中知道switch支持了枚举类型，下面通过示例学习枚举在switch中的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwitchDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> (Gender.FEMALE) &#123;</span><br><span class="line">		<span class="keyword">case</span> FEMALE:</span><br><span class="line">			System.out.println(<span class="string">&quot;女性&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> MALE:</span><br><span class="line">			System.out.println(<span class="string">&quot;男性&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的示例测试了枚举的的基本用法以及在switch分支结构中的使用。<br>因为枚举都继承了java.lang.Enum类，所以枚举类可以使用Enum类中的方法，下面介绍3个重要的方法：</p>
<ul>
<li>String name()∶ 返回此枚举实例的名称，这个名称就是定义枚举类时列出的所有枚举值之一。与 此方法相比，大多数程序员应该优先考虑使用 toString（O方法，因为 toStringO）方法返回更加用户友好的名称。</li>
<li>int ordinal()∶返回枚举值在枚举类中的索引值（就是枚举值在枚举声明中的位置，第一个枚举 值的索引值为零）。</li>
<li>String toString()∶返回枚举常量的名称，与name 方法相似，但 toStringO方法更常用。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package cn.bytecollege;</span><br><span class="line"></span><br><span class="line">public class EnumDemo &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//枚举类的Values()方法返回该枚举的所有实例</span><br><span class="line">		for (Gender g : Gender.values()) &#123;</span><br><span class="line">			System.out.println(g);</span><br><span class="line">			System.out.println(g.toString());</span><br><span class="line">			System.out.println(g.ordinal());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当程序打印枚举值时，实际上输出的是该枚举值的 toString()方法，也就是输出该枚举值的名字。</p>
<h3 id="枚举类的构造方法"><a href="#枚举类的构造方法" class="headerlink" title="枚举类的构造方法"></a>枚举类的构造方法</h3><p>枚举类也是一种类，只是它是一种比较特殊的类，因此它一样可以定义成员变量、方法和构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义性别枚举</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MR.W</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Gender</span> &#123;</span><br><span class="line">	MALE,FEMALE;</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，在枚举中定义构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义性别枚举</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MR.W</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Gender</span> &#123;</span><br><span class="line">	MALE(<span class="string">&quot;男&quot;</span>),FEMALE(<span class="string">&quot;女&quot;</span>);</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Gender</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面程序中可以看出，当为Gender 枚举类创建了一个Gender（String name）构造器之后，列出枚举值就应该采用粗体字代码来完成。也就是说，在枚举类中列出枚举值时，实际上就是调用构造器创建枚举类对象，只是这里无须使用 new 关键字，也无需显式调用构造器。前面列出枚举值时无需传入参数，甚至无需使用括号，仅仅是因为前面的枚举类包含无参数的构造器。</p>
<h3 id="枚举中的抽象方法"><a href="#枚举中的抽象方法" class="headerlink" title="枚举中的抽象方法"></a>枚举中的抽象方法</h3><p>假设有一个 Operation 枚举类，它的 4个枚举值 PLUS，MINUS，TIMES，DIVIDE 分别代表加、减、乘、除 4 种运算，该枚举类需要定义一个eval（）方法来完成计算。 从上面描述可以看出，Operation 需要让PLUS、MINUS、TIMES、DIVIDE 四个值对 evalO方法各有不同的实现。此时可考虑为 Operation 枚举类定义一个eval()抽象方法，然后让4个枚举值分别为eval()提供不同的实现。例如如下代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">	PLUS</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">eval</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> a+b;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	MINUS</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">eval</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> a-b;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	TIMES</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">eval</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> a*b;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	DIVDE&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">eval</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> a/b;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">//定义抽象方法，为不同的枚举值提供实现</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">eval</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		System.out.println(Operation.PLUS.eval(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">		System.out.println(Operation.MINUS.eval(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">		System.out.println(Operation.TIMES.eval(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">		System.out.println(Operation.DIVDE.eval(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：枚举类里定义抽象方法时不能使用 abstract 关键字将枚举类定义成抽象类（因为系统自动会为它添加 abstract 关铰字），但因为枚举类需要显式创建枚举值，而不是作为父类，所以定义每个枚举值时必须为抽象方法提供实现，否则将出现编译错误。</p>
]]></content>
  </entry>
  <entry>
    <title>Java-String和常用类</title>
    <url>/2022/07/27/Java-String%E5%92%8C%E5%B8%B8%E7%94%A8%E7%B1%BB/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h1 id="String和常用类"><a href="#String和常用类" class="headerlink" title="String和常用类"></a>String和常用类</h1><p>Java为开发者提供了丰富的类库，例如字符串、数学计算、日期处理等等，完全可以满足日常开发的需要</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>在Java中字符串就是连续的字符序列，Java提供了String，StringBuilder、StringBuffer 3个类来封装字符串，在日常开发时，有很大一部分操作就是在操作字符串。例如：在web开发中对前端页面提交的数据进行验证、过滤特殊字符、检测敏感字符等等。因此Java为开发者提供了大量的API，并且也出现了一系列帮助开发者操作数据库的第三方工具库，如国内开发者开发的hutool、和Google提供的Guava。</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String类是一个不可变类，不可变类即类中的成员变量都使用final修饰，这也就说明一个String对象被创建以后，包含在这里对象中的字符序列是不可改变的，直到整个对象被销毁。并且在Java中所有字符串相关的类都是Charsquence接口的子类。<br>String类提供了大量的构造方法来创建String对象，先来看以下几个：</p>
<ul>
<li>String()：创建一个包含0个字符的String对象</li>
<li>String(byte[] bytes,Charset charset)：使用指定的字符集将指定的byte[]解码成一个新的String对象</li>
<li>String(String original)：根据字符串字面量来创建String对象。</li>
<li>String(StringBuffer buffer)：根据StringBuffer对象来创建String</li>
<li>String(StringBuilder builder)：根据StringBuilder来创建对应的String对象。</li>
</ul>
<p>下面，通过示例来学习以上构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//创建一个字符序列为空的字符串</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line">		<span class="comment">//使用指定的字符集将指定的byte[]解码成一个新的String对象</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;天苍苍，野茫茫&quot;</span>;</span><br><span class="line">		System.out.println(Charset.defaultCharset());</span><br><span class="line">		<span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(s.getBytes(),Charset.defaultCharset());</span><br><span class="line">		System.out.println(str2);</span><br><span class="line">		<span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">		System.out.println(str3);</span><br><span class="line">		<span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;张三丰&quot;</span>));</span><br><span class="line">		System.out.println(str4);</span><br><span class="line">		<span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;张无忌&quot;</span>));</span><br><span class="line">		System.out.println(str5);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了以上创建字符串的方式，还可以通过字面量的方式创建字符串对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s = &quot;金毛狮王&quot;;</span><br></pre></td></tr></table></figure>

<p>除此之外，String还提供了诸多API用来操作字符串。</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>equals(String string)</td>
<td>判断两个字符串是否相等</td>
</tr>
<tr>
<td>equalsIgnoreCase(String string)</td>
<td>忽略大小写判断两个字符串是否相等</td>
</tr>
<tr>
<td>length()</td>
<td>获取字符串长度</td>
</tr>
<tr>
<td>charAt(int index)</td>
<td>获取某个索引处的字符</td>
</tr>
<tr>
<td>indexOf(String string)</td>
<td>获取字符串第一次出现的位置</td>
</tr>
<tr>
<td>indexOf(String string,int startIndex)</td>
<td>从startIndex处查找第一次出现的位置</td>
</tr>
<tr>
<td>lastIndexOf(String string)</td>
<td>字符串最后一次出现的位置</td>
</tr>
<tr>
<td>startsWith(String string)</td>
<td>判断是否以string开始</td>
</tr>
<tr>
<td>endsWith(String string)</td>
<td>判断是否以string结尾</td>
</tr>
<tr>
<td>compareTo(String string)</td>
<td>比较字符串大小</td>
</tr>
<tr>
<td>toLowerCase()</td>
<td>字符串转小写</td>
</tr>
<tr>
<td>toUpperCase()</td>
<td>字符串转大写</td>
</tr>
<tr>
<td>subString(int index)</td>
<td>从index位置处截取到字符串末尾</td>
</tr>
<tr>
<td>subString(int startIndex,int endIndex)</td>
<td>从startIndex位置开始，到endIndex结束，前闭后开</td>
</tr>
<tr>
<td>trim()</td>
<td>去除字符串首尾空格</td>
</tr>
<tr>
<td>split(String string)</td>
<td>以string对字符串进行分割，此方法会省略末尾空字符</td>
</tr>
<tr>
<td>split(String string,int limit)</td>
<td>对字符串进行分割，此方法不会省略末尾空字符</td>
</tr>
<tr>
<td>join(String s,String…str)</td>
<td>以s为连接符，连接str内字符串</td>
</tr>
<tr>
<td>concat(String str)</td>
<td>连接字符串</td>
</tr>
<tr>
<td>valueOf()</td>
<td>基本类型转字符串</td>
</tr>
<tr>
<td>contains(String str)</td>
<td>判断是否包含str</td>
</tr>
<tr>
<td>toCharArray()</td>
<td>将字符串转换成字符数组</td>
</tr>
<tr>
<td>intern()</td>
<td>判断字符串在常量池中是否存在，如果不存在，则复制，1.6是将实例复制，1.7及以后是将引用复制。</td>
</tr>
<tr>
<td>isEmpty()</td>
<td>判断字符串是否为空</td>
</tr>
<tr>
<td>stripLeading()</td>
<td>去除字符串首部的空格（since11）</td>
</tr>
<tr>
<td>stripTrailing()</td>
<td>去除字符串尾部的空格（since11）</td>
</tr>
<tr>
<td>isBlank()</td>
<td>判断字符串是否为空及是否全是空格</td>
</tr>
<tr>
<td>repeate(int count)</td>
<td>重复字符串若干次（since11）</td>
</tr>
</tbody></table>
<p>下面，通过示例学习String的常用API</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本例将演示String常用API</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MR.W</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringDemo2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//判断两个字符串相等</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;ABC&quot;</span>;</span><br><span class="line">		System.out.println(a.equals(b));</span><br><span class="line">		<span class="comment">//忽略大小写判断两个字符串是否相等</span></span><br><span class="line">		System.out.println(a.equalsIgnoreCase(c));</span><br><span class="line">		<span class="comment">//获取字符串长度</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line">		System.out.println(d.length());</span><br><span class="line">		<span class="comment">//获取索引处的字符,方法参数在0-字符串长度-1之间</span></span><br><span class="line">		System.out.println(d.charAt(<span class="number">0</span>));	</span><br><span class="line">		<span class="comment">//从头开始查找获取字符串第一次出现的位置</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> d.indexOf(<span class="string">&quot;lo&quot;</span>);</span><br><span class="line">		System.out.println(index);</span><br><span class="line">		<span class="comment">//从某个位置处查找获取字符串第一次出现的位置</span></span><br><span class="line">		System.out.println(d.indexOf(<span class="string">&quot;o&quot;</span>,<span class="number">7</span>));</span><br><span class="line">		<span class="comment">//查找字符串最后一次出现的位置</span></span><br><span class="line">		System.out.println(d.lastIndexOf(<span class="string">&quot;o&quot;</span>));</span><br><span class="line">		<span class="comment">//判断字符串是否是以某个字符串开始</span></span><br><span class="line">		System.out.println(d.startsWith(<span class="string">&quot;He&quot;</span>));</span><br><span class="line">		<span class="comment">//判断字符串是否以某个字符串结束</span></span><br><span class="line">		System.out.println(d.endsWith(<span class="string">&quot;lo&quot;</span>));</span><br><span class="line">		<span class="comment">//比较两个字符串大小,如果两个字符串相等则返回0</span></span><br><span class="line">		<span class="comment">//如果字符串中的字符相等，但是长度不相等则返回长度差值</span></span><br><span class="line">		<span class="comment">//如果字符不相等则返回字符差值</span></span><br><span class="line">		System.out.println(a.compareTo(b));</span><br><span class="line">		<span class="comment">//字符串转大小</span></span><br><span class="line">		System.out.println(a.toUpperCase());</span><br><span class="line">		<span class="comment">//字符串转小写</span></span><br><span class="line">		System.out.println(a.toLowerCase());</span><br><span class="line">		<span class="comment">//截取字符串，从传入位置截取到字符串末尾</span></span><br><span class="line"><span class="comment">//		System.out.println(a.substring(2));</span></span><br><span class="line">		<span class="comment">//截取字符串，从传入位置截取到第二个参数处，前闭后开</span></span><br><span class="line"><span class="comment">//		System.out.println(a.substring(1,2));</span></span><br><span class="line">		<span class="comment">//去除字符串首尾空格</span></span><br><span class="line">		System.out.println(<span class="string">&quot;   Hello   &quot;</span>.trim());</span><br><span class="line">		<span class="comment">//分割字符串,默认会省略末尾的空</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello,World&quot;</span>;</span><br><span class="line">		String[] strs = s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//分割字符串，第二个参数传入负值，则不省略末尾的空</span></span><br><span class="line">		strs = s.split(<span class="string">&quot;,&quot;</span>,-<span class="number">1</span>);</span><br><span class="line">		<span class="comment">//连接字符串</span></span><br><span class="line">		System.out.println(a.concat(b));</span><br><span class="line">		<span class="comment">//将基本类型转成字符串</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">		System.out.println(String.valueOf(k));</span><br><span class="line">		<span class="comment">//判断是否包含某个字符串</span></span><br><span class="line">		System.out.println(a.contains(<span class="string">&quot;@&quot;</span>));</span><br><span class="line">		<span class="comment">//将字符串转换成数组</span></span><br><span class="line">		<span class="type">char</span>[] cs = a.toCharArray();</span><br><span class="line">		<span class="comment">//判断字符串是否为空</span></span><br><span class="line">		System.out.println(a.isEmpty());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的实例中演示了字符串的常用API，因为String是一个不可变类，因此要大量操作字符串时，并不建议使用String对象，而应该使用下一小节中的StringBuilder和StringBuffer</p>
<h3 id="StringBuilder和StringBuffer"><a href="#StringBuilder和StringBuffer" class="headerlink" title="StringBuilder和StringBuffer"></a>StringBuilder和StringBuffer</h3><p>StringBuffer和StringBuilder通常也用于操作字符串，但是StringBuffer和StringBuilder中的字符数组不是用final修饰的，所有字符数组可以指向新的数组，也就是说用这两个类创建的字符串对象是可变的，StringBuffer和StringBuilder为开发者提供了以下几个方法。用于操作字符串：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>append(String str)</td>
<td>字符串末尾追加字符串</td>
</tr>
<tr>
<td>delete(int start, int end)</td>
<td>删除区间内字符</td>
</tr>
<tr>
<td>deleteCharAt(int index)</td>
<td>删除索引处字符</td>
</tr>
<tr>
<td>replace(int start, int end, String str)</td>
<td>替换区间内的字符</td>
</tr>
<tr>
<td>substring(int start)</td>
<td>从start处截取到末尾</td>
</tr>
<tr>
<td>substring(int start, int end)</td>
<td>从start处截取到end</td>
</tr>
<tr>
<td>insert(int offset, String str)</td>
<td>索引处插入字符串</td>
</tr>
<tr>
<td>indexOf(String str)</td>
<td>字符串str第一次出现的位置</td>
</tr>
<tr>
<td>reverse()</td>
<td>字符序列反转</td>
</tr>
<tr>
<td>toString()</td>
<td>对象转成字符串</td>
</tr>
</tbody></table>
<p>因为StringBuffer和StringBuilder提供的方法都一样，所以方法都是通用的，下面通过示例学习<br>首先，StringBuilder提供了一下几个构造方法：</p>
<ul>
<li>StringBuilder StringBuilder()：创建一个空的StringBuilder对象，一个空的字符序列</li>
<li>StringBuilder StringBuilder(StringBuilder builder)：传入StringBuilder对象创建字符序列</li>
<li>StringBuilder StringBuilder(String str)：根据字符串创建字符序列</li>
<li>StringBuilder(int capcity)：指定容量的StringBuilder对象</li>
</ul>
<p>下面通过示例学习StringBuilder的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本例将演示StringBuilder常用API</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MR.W</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(a);</span><br><span class="line">		<span class="comment">//字符序列后追加字符串</span></span><br><span class="line">		System.out.println(sb.append(<span class="string">&quot;World&quot;</span>).toString());</span><br><span class="line">		<span class="comment">//删除区间内的字符</span></span><br><span class="line">		System.out.println(sb.delete(<span class="number">0</span>, <span class="number">3</span>));</span><br><span class="line">		<span class="comment">//删除某个索引处的字符</span></span><br><span class="line">		System.out.println(sb.deleteCharAt(<span class="number">5</span>));</span><br><span class="line">		<span class="comment">//替换区间内的字符</span></span><br><span class="line">		System.out.println(sb.replace(<span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;W&quot;</span>));</span><br><span class="line">		<span class="comment">//索引处插入字符串</span></span><br><span class="line">		System.out.println(sb.insert(<span class="number">0</span>, <span class="string">&quot;false&quot;</span>));</span><br><span class="line">		<span class="comment">//反转字符串</span></span><br><span class="line">		System.out.println(sb.reverse());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Java对String的优化"><a href="#Java对String的优化" class="headerlink" title="Java对String的优化"></a>Java对String的优化</h3><p>Java在底层对String进行了优化，节省了一定的内存空间，在前面的章节中可以看到，通过字面量的形式创建String对象，所谓字面量（也叫做直接量），就是在定义变量后直接给定的值。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//下面的代码中10就是一个字面量</span><br><span class="line">int a = 10;</span><br><span class="line">//下面的代码中5.2就是字面量</span><br><span class="line">double b = 5.2;</span><br><span class="line">//字符串对象直接给的值也是字面量</span><br><span class="line">String s = &quot;张三&quot;;</span><br></pre></td></tr></table></figure>

<p>因为String是一个不可变类，也就是说一旦定义好一个字符串后，字符串的值是不能被改变了，如果发生了改变一定是指向了一个新的对象。那么这样的话无疑会占用大量的内存空间。因此Java对String进行了一定的优化，在JVM中有一块区域叫做常量池，常量池里放着字符串的字面量和常量。当字面量出现一个字符串后，Java会将该字面量放入常量池，如果再有变量引用该字符串时，直接返回常量池中字符串的引用，而不创建对象。通过下面的示例可以验证以上结论：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String a = &quot;张三&quot;;</span><br><span class="line">String b = &quot;张三&quot;;</span><br><span class="line">//返回结果为true</span><br><span class="line">System.out.print(a==b);</span><br></pre></td></tr></table></figure>

<p>在前面的章节中知道，两个对象用“&#x3D;&#x3D;”判断相等时，如果返回true，则这两个变量一定指向了相同的对象。从上面的结果可以看出变量a和变量b指向了同一个对象。总结一下就是<strong>常量池中的字符串有且只有一个，一旦创建后如果出现相同的字符串则直接返回字符串对象的引用，而不创建新的字符串。</strong><br>下面深入学习Java对字符串的优化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String a = &quot;张三&quot;;</span><br><span class="line">String b = new String(&quot;张三&quot;);</span><br><span class="line">//返回结果为false</span><br><span class="line">System.out.print(a==b);</span><br><span class="line">//返回结果为true</span><br><span class="line">System.out.print(a.equals(b));</span><br></pre></td></tr></table></figure>

<p>上面的结果可能会很疑惑，我们对上例中的代码逐行分析：当代码执行到第1行时，此时出现了字面量“张三”。因为已经将该对象放入常量池，因此，运行时直接该对象的引用保存在a中。<br>代码第2行，又出现了“张三”，此时常量池已经有了这个对象，此时就不再创建，此时先返回该对象的引用，返回该引用后，又new了一个String对象，此时在堆中分配了一块内存区域，这块内存中保存这刚才返回的引用。然后将堆中的引用保存在b中，因为a指向了常量池，变量b指向了堆中，所以a和b中保存的引用不同，所以用&#x3D;&#x3D;判断时返回false，但是两个对象的内容相等。所以使用equals时两个变量的内容相等。<br>继续看下面的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String a = &quot;HelloWorld&quot;;</span><br><span class="line">String d = &quot;Hello&quot;+&quot;World&quot;;</span><br><span class="line">//返回true</span><br><span class="line">System.out.print(a==d);</span><br><span class="line">//返回true</span><br><span class="line">System.out.print(a.equals(d));</span><br></pre></td></tr></table></figure>

<p>运行上面的示例，可以看到结果都为true，这又是为什么呢？这也是Java对字符串的一项优化，也就是说在编译期间就可以确定变量d的结果为“HelloWorld”,而在确定变量d的结果之前，变量a的值已经放入了常量池，此时不再创建对象，直接返回引用，因此就有了上例中的结果。<br>上面的示例可以看出字面量和字面量拼接结果是确定的，那么字面量和变量拼接，变量和变量拼接又会出现什么结果呢，针对上述的问题，JVM还对String做了优化，看下面的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String a = &quot;HelloWorld&quot;;</span><br><span class="line">String b = new String(&quot;Hello&quot;);</span><br><span class="line">String c = new String(&quot;World&quot;);</span><br><span class="line">String d = b+c;</span><br><span class="line">//返回false</span><br><span class="line">System.out.print(a==d);</span><br><span class="line">//返回true</span><br><span class="line">System.out.print(a.equals(d));</span><br><span class="line">String e = &quot;Hello&quot;;</span><br><span class="line">String f = e + c;</span><br><span class="line">//返回false</span><br><span class="line">System.out.print(a==f);</span><br><span class="line">//返回true</span><br><span class="line">System.out.print(a.equals(f));</span><br></pre></td></tr></table></figure>

<p>因为变量d是两个堆中的对象拼接，此时java会用StringBuilder对两个对象拼接，也就是说在堆中新创建一个对象，保存拼接后的字符串，并将引用返回给d保存，因为不是执行同一块内存，所有a中的地址和d中的地址不相同，所以返回false，两个对象的内容相同，所以使用equals方法时返回true，下面的代码也是一样，java会使用StringBuilder对两个对象进行拼接，所以返回的地址不同。</p>
<h3 id="String和StringBuffer以及StringBuilder的区别"><a href="#String和StringBuffer以及StringBuilder的区别" class="headerlink" title="String和StringBuffer以及StringBuilder的区别"></a>String和StringBuffer以及StringBuilder的区别</h3><p>根据本小节的内容，三者的区别可以归纳如下：</p>
<ol>
<li>String、StringBuffer、StringBuilder都是Charsquence接口的子类</li>
<li>String、StringBuffer、StringBuilder都是final修饰的，不能被继承，也就是说三者都没有子类</li>
<li>String是不可变类，创建的字符串序列不能被修改，StringBuffer和StringBuilder是可以修改的</li>
<li>StringBuffer是线程安全的，StringBuilder是非线程安全的，因此StringBuilder效率更高，在不考虑线程安全或者单线程情况下优先考虑使用StringBuilder。</li>
</ol>
<h2 id="Scanner获取键盘输入"><a href="#Scanner获取键盘输入" class="headerlink" title="Scanner获取键盘输入"></a>Scanner获取键盘输入</h2><p>在前面的章节中，我们反复遇到Scanner对象，并使用其方法接受从键盘输入的数据。Scanner可以从文件、输入流、字符串中解析处基本类型和字符串值，Scanner提供了多个构造器，可以分别接收文件、输入流、字符串作为数据源，并从中解析数据。Scanner主要提供以下方法来扫描输入。</p>
<ul>
<li>hasNextXXX()：是否还有下个输入项，其中XXX可以是Int，Long等代表基本类型的字符串。如果判断是否有 下一个字符串则直接使用hasNext()。</li>
<li>nextXxx()：获取下个输入项，输入项可以是基本类型数据，如果是字符串则直接使用next()</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScannerDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入：&quot;</span>);</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="keyword">while</span>(scanner.hasNext()) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">			System.out.println(k);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h2><p>Java提供了System类和Runtime类来获取平台相关属性和运行平台进行交互。</p>
<h3 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h3><p>System类代表当前运行Java程序的平台。System为开发者提供了获取系统环境变量，系统属性等方法。下面通过示例来使用System类访问操作系统的环境变量和系统属性。</p>
<ul>
<li>Map&lt;String,String&gt; getenv()：获取系统所有的环境变量，保存在map集合中。</li>
<li>String getenv(String name)：获取指定的环境变量</li>
<li>Properties getProperties()：获取系统的属性。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//获取所有的环境变量</span></span><br><span class="line">		Map&lt;String,String&gt; map = System.getenv();</span><br><span class="line">		<span class="comment">//遍历map</span></span><br><span class="line">		<span class="keyword">for</span>(String s : map.keySet()) &#123;</span><br><span class="line">			System.out.println(s+<span class="string">&quot;======&quot;</span>+map.get(s));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取指定名称的环境变量值,如果环境变量的名称不存在则返回null</span></span><br><span class="line">		System.out.println(System.getenv(<span class="string">&quot;JAVA_HOME&quot;</span>));</span><br><span class="line">		<span class="comment">//获取系统参数</span></span><br><span class="line">		<span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> System.getProperties();</span><br><span class="line">		</span><br><span class="line">		Set&lt;Entry&lt;Object, Object&gt;&gt; entry =  properties.entrySet();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (Entry&lt;Object, Object&gt; e : entry) &#123;</span><br><span class="line">			System.out.println(e.getKey()+<span class="string">&quot;=============&quot;</span>+e.getValue());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例中使用了Map和Properties容器，在此处只为获取保存在其中的数据，详细内容讲在后续章节学习，此处不做深究。<br>除此以外，System还提供了两个使用频率比较高的方法：</p>
<ul>
<li>long currentTimeMillis()：获取当前时间的毫秒数，返回当前时间与UTC 1970年1月1日 00:00:00的时间差，以毫秒为单位</li>
<li>int identityHashCode(Object x)：获取指定对象的精确hashCode值，关于hashCode会在Set集合中详细讲解，此处先做了解</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemDemo2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//获取当前时间的毫秒数</span></span><br><span class="line">		System.out.println(System.currentTimeMillis());</span><br><span class="line">		System.out.print(System.identityHashCode(<span class="string">&quot;Hello&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>System还提供了一个复制数组的方法：</p>
<ul>
<li>void arraycopy(Object src,  int  srcPos,  int destPos, int length)：该方法的作用是复制数组，第一个src是指被复制的数组，srcPos是指定复制的起始位置，dest则是指将元素粘贴到哪个数组，destPos是指目标数组粘贴的起始位置，length则可以理解为复制元素的个数。</li>
<li>void exit(int status)：退出虚拟机。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyArray</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] a = &#123;<span class="number">5</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>&#125;;</span><br><span class="line">		<span class="type">int</span>[] b = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">		<span class="comment">//复制数组a元素粘贴的b数组</span></span><br><span class="line">		System.arraycopy(a, <span class="number">0</span>, b, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">		System.out.println(Arrays.toString(b));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Runtime类"><a href="#Runtime类" class="headerlink" title="Runtime类"></a>Runtime类</h3><p>Runtime类代表Java程序的运行时环境，每个Java程序都有一个与之对应Runtime实例。可以访问JVM相关信息，处理器数量，内存信息等</p>
<ul>
<li>int availableProcessors()：获取处理器数量</li>
<li>long freeMemory()：获取jvm空闲内存</li>
<li>long totalMemory()：获取最大内存</li>
<li>long maxMemory()：获取虚拟机可以用最大内存</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuntimeDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">		System.out.println(<span class="string">&quot;处理器数量：&quot;</span>+runtime.availableProcessors());</span><br><span class="line">		System.out.println(<span class="string">&quot;总内寸数：&quot;</span>+runtime.totalMemory()/Math.pow(<span class="number">1024</span>,<span class="number">2</span>)+<span class="string">&quot;MB&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;JVM空闲内存：&quot;</span>+runtime.freeMemory()/Math.pow(<span class="number">1024</span>, <span class="number">2</span>)+<span class="string">&quot;MB&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;可用最大内存：&quot;</span>+runtime.maxMemory()/Math.pow(<span class="number">1024</span>, <span class="number">3</span>)+<span class="string">&quot;GB&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同的电脑可能会出现不同的结果：</p>
<p><img src="https://files.catbox.moe/hken2g.png"></p>
<p>Runtime还提供了exec()方法，用于启动一个进程来运行操作系统的命令。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">runtime.exec(<span class="string">&quot;notepad.exe&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>运行示例中的代码可以打开记事本，其他命令可以自行查找。</p>
<h2 id="数学相关"><a href="#数学相关" class="headerlink" title="数学相关"></a>数学相关</h2><h3 id="Math工具类"><a href="#Math工具类" class="headerlink" title="Math工具类"></a>Math工具类</h3><p>Math提供了基本的加减乘除以为，还提供了一些复杂的数学运行，三角函数，对数运算等，Math类还提供了两个常量PI和E<br>Math的主要方法如下表：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Math.sqrt()</td>
<td>求平方根，参数为负数时返回NAN</td>
</tr>
<tr>
<td>Math.pow(x,a)</td>
<td>幂运算，x的a次方</td>
</tr>
<tr>
<td>Math.floor(a)</td>
<td>向下取整</td>
</tr>
<tr>
<td>Math.ceil(a)</td>
<td>向上取整</td>
</tr>
<tr>
<td>Math.floorMod(x,y)</td>
<td>求余，x%y</td>
</tr>
<tr>
<td>Math.toDegree()</td>
<td>弧度转换成角度</td>
</tr>
<tr>
<td>Math.toRadians()</td>
<td>角度转换成弧度</td>
</tr>
<tr>
<td>Math.sin()</td>
<td>求正弦</td>
</tr>
<tr>
<td>Math.cos()</td>
<td>求余弦</td>
</tr>
<tr>
<td>Math.tan()</td>
<td>求正切</td>
</tr>
<tr>
<td>Math.abs()</td>
<td>求绝对值</td>
</tr>
<tr>
<td>Math.max()</td>
<td>两个数的最大值</td>
</tr>
<tr>
<td>Math.min()</td>
<td>两个数最小值</td>
</tr>
<tr>
<td>Math.random()</td>
<td>0.0到1.0的随机数</td>
</tr>
</tbody></table>
<p>下面通过示例学习Math的 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//求平方根</span></span><br><span class="line">        System.out.println(Math.sqrt(<span class="number">4</span>));</span><br><span class="line">        <span class="comment">//幂运算，x的a次方</span></span><br><span class="line">        System.out.println(Math.pow(<span class="number">3</span>,<span class="number">3</span>));</span><br><span class="line">        <span class="comment">//求余，x%y</span></span><br><span class="line">        System.out.println(Math.floorMod(<span class="number">10</span>,<span class="number">3</span>));</span><br><span class="line">        <span class="comment">//求正弦</span></span><br><span class="line">        System.out.println(Math.sin(Math.PI/<span class="number">2</span>));</span><br><span class="line">        <span class="comment">//求余弦</span></span><br><span class="line">        System.out.println(Math.cos(Math.PI));</span><br><span class="line">        <span class="comment">//求正切</span></span><br><span class="line">        System.out.println(Math.tan(<span class="number">0</span>));</span><br><span class="line">        <span class="comment">//求绝对值</span></span><br><span class="line">        System.out.println(Math.abs(-<span class="number">101</span>));</span><br><span class="line">        <span class="comment">//求两个数的最大值</span></span><br><span class="line">        System.out.println(Math.max(-<span class="number">2</span>,<span class="number">2</span>));</span><br><span class="line">        <span class="comment">//求两个数的最小值</span></span><br><span class="line">        System.out.println(Math.min(-<span class="number">2</span>,<span class="number">2</span>));</span><br><span class="line">        <span class="comment">//0.0到1.0的随机数</span></span><br><span class="line">        System.out.println(Math.random());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Random生成随机数"><a href="#Random生成随机数" class="headerlink" title="Random生成随机数"></a>Random生成随机数</h3><p>Random类用于生成一个伪随机数，Random类包含两个构造方法：</p>
<ul>
<li>Random()：以当前时间作为种子</li>
<li>Random(long seed)：需要开发者显式传入long型的种子</li>
</ul>
<p>Random有以下几个生成伪随机数的方法：</p>
<ul>
<li>nextDouble()：生成0.0—1.0之间的伪随机double数。</li>
<li>nextFloat()：生成0.0—1.0之间的伪随机float数。</li>
<li>nextInt()：生成一个 int类型取值范围内的伪随机整数</li>
<li>nextInt(int a)：生成0-a之间的伪随机整数。</li>
<li>nextLong()：生成处于long整数取值范围的伪随机整数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本例将演示随机数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MR.W</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="type">Random</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">		System.out.println(r1.nextBoolean());</span><br><span class="line">		System.out.println(r1.nextDouble());</span><br><span class="line">		System.out.println(r1.nextFloat());</span><br><span class="line">		System.out.println(r1.nextInt());</span><br><span class="line">		System.out.println(r1.nextLong());</span><br><span class="line">		System.out.println(r1.nextInt(<span class="number">100</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="type">Random</span> <span class="variable">r2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">100</span>);</span><br><span class="line">		<span class="type">Random</span> <span class="variable">r3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">100</span>);</span><br><span class="line">		System.out.println(r2.nextInt());</span><br><span class="line">		System.out.println(r2.nextInt());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上例的示例，产生了不同的随机数，需要注意的当种子相同时，产生的随机数是相同的。</p>
<h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>在学习数据类型时，其中浮点型有float和double两种，同时也了解到float和double在计算时很容易出现精度问题：<br>例如，如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0.05</span>+<span class="number">0.01</span>;</span><br><span class="line">System.out.print(s);</span><br></pre></td></tr></table></figure>

<p><img src="https://files.catbox.moe/ozsins.png"><br>如果程序对运算精度要求不高，double和float完全可以满足需要，但是有些时候对浮点型精度要求比较高，例如金融项目、电商项目等。这就需要使用BigDecimal类的方法了。<br>首先，查看BigDecimal的构造方法：</p>
<ul>
<li>BigDecimal(String val)：通过字符串创建BigDecimal对象，Java推荐使用该构造方法创建对象，因为如果传入浮点型的值时，因为本身该值就不精确，因此创建的BigDecimal也会不精确，所以推荐使用字符串的形式创建对象。</li>
</ul>
<p>如果必须使用 double 浮点数作为 BigDecimal 构造器的参数时，不要直接将该 double 浮点数作为构造器参数创建 BigDecimal 对象，而是应该通过 BigDecimal.valueOf（double value）静态方法来创建 BigDecimal 对象。<br>BigDecimal类提供了add()、subtract()、multiply()、divide()、pow()等方法对精确浮点数进行常规算术运算。下面程序示范了 BigDecimal 的基本运算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigDecimalDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">BigDecimal</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.05&quot;</span>);</span><br><span class="line">		<span class="type">BigDecimal</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.01&quot;</span>);</span><br><span class="line">		<span class="comment">//加法</span></span><br><span class="line">		System.out.println(d1.add(d2));</span><br><span class="line">		<span class="comment">//减法</span></span><br><span class="line">		System.out.println(d1.subtract(d2));</span><br><span class="line">		<span class="comment">//乘法</span></span><br><span class="line">		System.out.println(d1.multiply(d2));</span><br><span class="line">		<span class="comment">//除法</span></span><br><span class="line">		System.out.println(d1.divide(d2));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：<br><img src="https://files.catbox.moe/w3yvec.png"></p>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>Java是一门面向对象的语言，但是在前面的章节中的了解到，定义基本类型变量时，并没有new对象，也就是说8种基本数据类型并不支持面向对象，基本类型数据也就不具备对象的特性，没有成员变量和成员方法可以被调用。Java提供这8种基本数据类型其一是为了节省内存开支，开发者没必要为了定义一个整型变量而去创建一个对象，这样对内存也是一种浪费，另外也是为了使得开发者更好的在语言之间迁移。<br>Java针对每个基本类提供了对应的包装类，如下表：</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<p>有时候需要将基本类型转换成包装类，例如，将一个十进制数转换成二进制时，基本类型的变量没有方法可以调用，此时就需要进行转换，Java中有如下规定：</p>
<ol>
<li>基本类型转换成包装类叫做自动装箱</li>
<li>包装类转换成基本类型时叫做自动拆箱</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="comment">//自动装箱</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> Integer.valueOf(a);</span><br><span class="line"><span class="comment">//自动拆箱</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">100</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> c;</span><br></pre></td></tr></table></figure>

<h3 id="Integer类中的缓存"><a href="#Integer类中的缓存" class="headerlink" title="Integer类中的缓存"></a>Integer类中的缓存</h3><p>Integer类提供了缓存，将-128到127之间的Integer对象创建好放置在内存中，使用是直接返回对象的引用，通过下面示例来学习Integer中的缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java会自动进行装箱</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">System.out.print(a==b);</span><br></pre></td></tr></table></figure>

<p>引用类型的判断使用equals()方法，但是上面的示例运行结果是true，这就是缓存的作用，因为对象a和对象b的值相等，且在-128-127之间，此时100这个对象已经创建好了，当创建a、b两个对象时，直接从缓存中获取对象，也就是说a和b都指向了相同的内存区域。如果变量的值超出了缓存范围，则会创建新的对象。如下示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">129</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">129</span>;</span><br><span class="line">System.out.print(a==b);</span><br></pre></td></tr></table></figure>

<p>因为对象a和b的值超出了缓存范围，因此是两个不同的对象，指向了不同的内存区域，因此返回false。<br>此外，当包装类和基本类型的值进行比较时，会进行自动拆箱</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">129</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">129</span>;</span><br><span class="line">System.out.print(a==b);</span><br></pre></td></tr></table></figure>

<p>上例的代码会返回true，这是因为当基本类型和包装类型比较时，会将包装类拆箱成基本类型，而基本类型则不存在缓存，就是两个真实的值在比较，因此返回true。<br>当 JDK 提供了自动装箱和自动拆箱功能后，大大简化了基本类型变量和包装类对象之间的转换过程。值得指出的是，进行自动装箱和自动拆箱时必须注意类型匹配，例如 Integer 只能自动拆箱成 int类型变量，不要试图拆箱成 boolean 类型变量; 与之类似的是，int 类型变量只能自动装箱成 Integer 对象（即使赋给 Obiect 类型变量，那也只是利用了Java 的向上自动转型特性），不要试图装箱成 Boolean对象。<br>除此之外，包装类还可实现基本类型变量和字符串之间的转换。把字符串类型的值转换为基本类型的值有两种方式。 利用包装类提供的 parseXxx（String s）静态方法（除了 Character 之外的所有包装类都提供了该方法。<br><strong>另外需要注意的是，Byte、Short、Integer、Long这4个包装类，都具有-128到127之间的缓存，Float和Double类型则不具有。Boolean类型中表示true和false的对象则是两个常量</strong>。</p>
<h3 id="Integer类常用方法"><a href="#Integer类常用方法" class="headerlink" title="Integer类常用方法"></a>Integer类常用方法</h3><p><img src="https://files.catbox.moe/ge891f.png"></p>
<h2 id="日期时间类"><a href="#日期时间类" class="headerlink" title="日期时间类"></a>日期时间类</h2><p>Java提供了Date类和Calendar类用于处理日期，包括创建日期，获取当前日期等。</p>
<h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h3><p>Date类为开发者提供了6个构造方法，但是有4个已经标记为Deprecated(过时的方法，不推荐使用，可能会在未来的某个版本彻底废弃)。因此我们查看剩余两个：</p>
<ul>
<li>Date()：创建一个代表当前时间的Date对象。</li>
<li>Date(long date)：根据指定的long型整数生成一个Date对象。其中参数表示创建Date对象和GMT 1970年1月1日 08:00:00之间的时间差。单位是毫秒</li>
</ul>
<p>下面通过示例学习两个构造方法的使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//当前时间</span><br><span class="line">Date date = new Date();</span><br><span class="line">//指定时间</span><br><span class="line">Date date2 = new Date(1000000);</span><br></pre></td></tr></table></figure>

<p>Date类还为开发者提供了一下4个方法：</p>
<ul>
<li>boolean after(Date when)∶ 测试该日期是否在指定日期 when 之后。</li>
<li>boolean before(Date when)∶ 测试该日期是否在指定日期 when 之前。</li>
<li>long getTime()∶ 返回该时间对应的 long型整数，即从GMT1970-01-01 00∶00∶00 到该Date 对象 之间的时间差，以毫秒作为计时单位。</li>
<li>void setTime(long time):设置该Date对象的时间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2020</span>,<span class="number">10</span>,<span class="number">01</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">newdate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2021</span>,<span class="number">10</span>,<span class="number">02</span>);</span><br><span class="line">        <span class="comment">//测试该日期是否在指定日期 when 之后</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">a</span> <span class="operator">=</span> date.after(newdate);</span><br><span class="line">        <span class="comment">//测试该日期是否在指定日期 when 之前</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> date.before(newdate);</span><br><span class="line">        <span class="comment">//返回该时间对应的 long型整数</span></span><br><span class="line">        date.setTime(<span class="number">86400</span>);</span><br><span class="line">        <span class="comment">//设置该Date对象的时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">c</span> <span class="operator">=</span> date.getTime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><p>因为Date类的设计缺陷，Java提供了Calendar类处理日期和时间。Calendar是一个抽象类。它用了几个静态方法用来获取Calendar对象。<br>Calendar 类提供了大量访问、修改日期时间的方法，常用方法如下。</p>
<ul>
<li>void add（int field， int amount）∶ 根据日历的规则，为给定的日历字段添加或减去指定的时间量。</li>
<li>int get（int field）∶ 返回指定日历字段的值。</li>
<li>int getActualMaximum（int field）∶ 返回指定日历字段可能拥有的最大值。例如月，最大值为 11。</li>
<li>int getActualMinimum（int field）∶ 返回指定日历字段可能拥有的最小值。例如月，最小值为 0。</li>
<li>void roll（int field， int amount）∶与 add()方法类似，区别在于加上 amount 后超过了该字段所能表 示的最大范围时，也不会向上一个字段进位。</li>
<li>void set（int field， int value）∶将给定的日历字段设置为给定值。</li>
<li>void set（int year， int month， int date）∶ 设置 Calendar 对象的年、月、日三个字段的值。</li>
<li>void set（int year， int month，int date，int hourOfDay， int minute，int second）∶设置 Calendar 对象的年、 月、日、时、分、秒6个字段的值。 上面的很多方法都需要一个int类型的 field参数，field是 Calendar类的类变量，如 Calendar，YEAR、 CalendarMONTH等分别代表了年、月、日、小时、分钟、秒等时间字段。需要指出的是，Calendar.MONTH字段代表月份，月份的起始值不是1，而是0，所以要设置8 月时，用7 而不是8。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalenderDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="comment">//设置 Calendar 对象的年、月、日、时、分、秒6个字段的值</span></span><br><span class="line">        calendar.set(<span class="number">2020</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">20</span>,<span class="number">23</span>,<span class="number">59</span>,<span class="number">59</span>);</span><br><span class="line">        <span class="comment">//返回指定日历字段的值</span></span><br><span class="line">        System.out.println(calendar.get(Calendar.HOUR_OF_DAY));</span><br><span class="line">        <span class="comment">//返回指定日历字段可能拥有的最小值</span></span><br><span class="line">        System.out.println(calendar.getActualMinimum(Calendar.DAY_OF_MONTH));</span><br><span class="line">        <span class="comment">//返回指定日历字段可能拥有的最大值</span></span><br><span class="line">        calendar.add(Calendar.MONTH,<span class="number">3</span>);</span><br><span class="line"><span class="comment">//        calendar.roll(Calendar.MONTH,-10);</span></span><br><span class="line">        System.out.println(calendar.getTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>add（int field，int amount）的功能非常强大，add 主要用于改变 Calendar 的特定字段的值。如果需要增加某字段的值，则让 amount 为正数;如果需要减少某字段的值，则让 amount 为负数即可。 add（int field， int amount）有如下两条规则：</p>
<ul>
<li>当被修改的字段超出它允许的范围时，会发生进位，即上一级字段也会增大。</li>
<li>如果下一级字段也需要改变，那么该字段会修正到变化最小的值</li>
</ul>
<p>roll()的规则与 add()的处理规则不同∶当被修改的字段超出它允许的范围时，上一级字段不会增大。</p>
<h3 id="Java8-新增的日期时间类"><a href="#Java8-新增的日期时间类" class="headerlink" title="Java8 新增的日期时间类"></a>Java8 新增的日期时间类</h3><p>Java 8专门新增了一个 java.time 包，该包下包含了如下常用的类。</p>
<ul>
<li>LocalDate∶该类代表不带时区的日期，例如 2007-12-03。该类提供了静态的 now()方法来获取 当前日期，它还提供了 minusXxx()方法在当前年份基础上减去几年、几月、几周或几日等，也提供了 plusXxx()方法在当前年份基础上加上几年、几月、几周或几日等。</li>
<li>LocalTime∶ 该类代表不带时区的时间，例如 10∶15∶30。该类提供了静态的 now()方法来获取当 前时间，除此之外，它还提供了minusXxx()方法在当前年份基础上减去几小时、几分、几秒等，也提供了plusXxx()方法在当前年份基础上加上几小时、几分、几秒等。</li>
<li>LocalDateTime∶该类代表不带时区的日期、时间，例如 2007-12-03T10∶15∶30。该类提供了静态 的 now()方法来获取当前日期、时间，它还提供了 minusXxx()方法在当前年份基础上减去几年、几月、几日、几小时、几分、几秒等，也提供了plusXxx()方法在当前年份基础上加上几年、几月、几日、几小时、几分、几秒等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">LocalDate</span> <span class="variable">ld</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">		System.out.println(ld);</span><br><span class="line">		<span class="type">LocalTime</span> <span class="variable">lt</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">		System.out.println(lt);</span><br><span class="line">		<span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">		System.out.println(ldt);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><p>在日常的开发中，开发者经常会遇到按照一定格式显示数据的情况，例如，文本、数字、日期等等，在本小节，我们将学习Java中常用的格式化类。</p>
<h3 id="数字格式化"><a href="#数字格式化" class="headerlink" title="数字格式化"></a>数字格式化</h3><p>NumberFormat 是所有数值格式的抽象基类。此类提供格式化和解析数值的接口。NumberFormat提供了以下方法用于格式化。</p>
<ul>
<li>getInstance()、getNumberInstance()。返回当前默认语言环境的通用数值格式。</li>
<li>getInstance(Locale)、getNumberInstance(Locale)。返回指定语言环境的通用数值格式。</li>
<li>NumberFormat.setMinimumIntegerDigits(int)。设置数的整数部分所允许的最小位数。</li>
<li>NumberFormat.setMaximumIntegerDigits(int)。设置数的整数部分所允许的最大位数。</li>
<li>NumberFormat.setMinimumFractionDigits(int)。设置最少小数点位数，不足的位数以0补位，超出的话按实际位数输出。</li>
<li>NumberFormat.setMaximumFractionDigits(int)。设置最多保留小数位数，不足不补0。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.NumberFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumberFormatDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">12345.676688000</span>;</span><br><span class="line">        <span class="type">NumberFormat</span> <span class="variable">nf</span> <span class="operator">=</span> NumberFormat.getNumberInstance();</span><br><span class="line">        System.out.println(nf.format(d));<span class="comment">//12,345.677 默认只保留到小数点后三位</span></span><br><span class="line">        nf.setMinimumIntegerDigits(<span class="number">2</span>);</span><br><span class="line">        System.out.println(nf.format(d));<span class="comment">//12,345.677 整数部分大于2位按默认最小数位数3位输出</span></span><br><span class="line">        d = <span class="number">1234.0</span>;</span><br><span class="line">        nf.setMaximumIntegerDigits(<span class="number">3</span>);</span><br><span class="line">        System.out.println(nf.format(d));<span class="comment">//234</span></span><br><span class="line">        nf = NumberFormat.getInstance();</span><br><span class="line">        d = <span class="number">12345.6766</span>;</span><br><span class="line">        nf.setMinimumFractionDigits(<span class="number">1</span>);</span><br><span class="line">        System.out.println(nf.format(d));<span class="comment">//12,345.677 小数部分大于1位，按默认最大小数位数3位输出</span></span><br><span class="line">        nf.setMinimumFractionDigits(<span class="number">5</span>);</span><br><span class="line">        System.out.println(nf.format(d));<span class="comment">//12,345.67660 不够位数补0</span></span><br><span class="line">        nf.setMaximumFractionDigits(<span class="number">1</span>);</span><br><span class="line">        System.out.println(nf.format(d));<span class="comment">//12,345.7</span></span><br><span class="line">        nf = NumberFormat.getNumberInstance(Locale.CHINA);</span><br><span class="line">        d = <span class="number">12345.6789</span>;</span><br><span class="line">        System.out.println(nf.format(d));<span class="comment">//12,345.679</span></span><br><span class="line">        nf = NumberFormat.getNumberInstance(Locale.US);</span><br><span class="line">        System.out.println(nf.format(d));<span class="comment">//12 345,679</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h3><p>在前面的日期类当中当打印Date对象时发现，打印的格式并不是我们日常生活中看到的格式，因此，需要对日期进行格式化，Java为开发者提供了SimpleDateFormat对象格式化日期，当创建SimpleDateFormat对象时需要传入一个格式字符串。下面通过示例来学习。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateFormatDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">		<span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">158764354</span>);</span><br><span class="line">		<span class="type">SimpleDateFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> format.format(date);</span><br><span class="line">		System.out.println(str);</span><br><span class="line">		<span class="comment">//将字符串转换成Date类型，字符串格式也要符合构造方法中的参数格式</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;1990-08-18 12:00:00&quot;</span>;</span><br><span class="line">		<span class="comment">//parse方法用于解析</span></span><br><span class="line">		<span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> format.parse(s);</span><br><span class="line">		System.out.println(d);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 8位开发者提供了更强大的格式化工具DateFormatter，格式化之前需要先获取DateFormatter对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateFormatterDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> formatter.format(LocalDateTime.now());</span><br><span class="line">		System.out.println(str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。</p>
<h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><p>构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。<br>正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为”元字符”）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。<br>在学习正则表达之前，首先需要了解一下元字符，也就是正则表达式的组成部分，每个元字符都有其特定的表示含义及范围。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td>将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\‘ 匹配 “&quot; 而 “(“ 则匹配 “(“。</td>
</tr>
<tr>
<td>^</td>
<td>匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。</td>
</tr>
<tr>
<td>*</td>
<td>匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。</td>
</tr>
<tr>
<td>{n}</td>
<td>n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>
</tr>
<tr>
<td>{n,}</td>
<td>n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td>
</tr>
<tr>
<td>{n,m}</td>
<td>m 和 n 均为非负整数，其中n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td>
</tr>
<tr>
<td>?</td>
<td>当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。</td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用像”<strong>(.|\n)</strong>“的模式。</td>
</tr>
<tr>
<td>(pattern)</td>
<td>匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。</td>
</tr>
<tr>
<td>(?:pattern)</td>
<td>匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。</td>
</tr>
<tr>
<td>(?&#x3D;pattern)</td>
<td>正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，”Windows(?&#x3D;95|98|NT|2000)”能匹配”Windows2000”中的”Windows”，但不能匹配”Windows3.1”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td>
</tr>
<tr>
<td>(?!pattern)</td>
<td>正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如”Windows(?!95|98|NT|2000)”能匹配”Windows3.1”中的”Windows”，但不能匹配”Windows2000”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td>
</tr>
<tr>
<td>(?&lt;&#x3D;pattern)</td>
<td>反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，”<code>(?&lt;=95&amp;#124;98&amp;#124;NT&amp;#124;2000)Windows</code>“能匹配”<code>2000Windows</code>“中的”<code>Windows</code>“，但不能匹配”<code>3.1Windows</code>“中的”<code>Windows</code>“。</td>
</tr>
<tr>
<td>(?&lt;!pattern)</td>
<td>反向否定预查，与正向否定预查类似，只是方向相反。例如”<code>(?&lt;!95&amp;#124;98&amp;#124;NT&amp;#124;2000)Windows</code>“能匹配”<code>3.1Windows</code>“中的”<code>Windows</code>“，但不能匹配”<code>2000Windows</code>“中的”<code>Windows</code>“。</td>
</tr>
<tr>
<td>x|y</td>
<td>匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。</td>
</tr>
<tr>
<td>[xyz]</td>
<td>字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</td>
</tr>
<tr>
<td>[^xyz]</td>
<td>负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。</td>
</tr>
<tr>
<td>[a-z]</td>
<td>字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。</td>
</tr>
<tr>
<td>[^a-z]</td>
<td>负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td>
</tr>
<tr>
<td>\B</td>
<td>匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td>
</tr>
<tr>
<td>\cx</td>
<td>匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td>
</tr>
<tr>
<td>\d</td>
<td>匹配一个数字字符。等价于 [0-9]。</td>
</tr>
<tr>
<td>\D</td>
<td>匹配一个非数字字符。等价于 [^0-9]。</td>
</tr>
<tr>
<td>\f</td>
<td>匹配一个换页符。等价于 \x0c 和 \cL。</td>
</tr>
<tr>
<td>\n</td>
<td>匹配一个换行符。等价于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td>\r</td>
<td>匹配一个回车符。等价于 \x0d 和 \cM。</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td>
</tr>
<tr>
<td>\t</td>
<td>匹配一个制表符。等价于 \x09 和 \cI。</td>
</tr>
<tr>
<td>\v</td>
<td>匹配一个垂直制表符。等价于 \x0b 和 \cK。</td>
</tr>
<tr>
<td>\w</td>
<td>匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。</td>
</tr>
<tr>
<td>\W</td>
<td>匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。</td>
</tr>
<tr>
<td>\xn</td>
<td>匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\x41’ 匹配 “A”。’\x041’ 则等价于 ‘\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。</td>
</tr>
<tr>
<td>\num</td>
<td>匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\1’ 匹配两个连续的相同字符。</td>
</tr>
<tr>
<td>\n</td>
<td>标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。</td>
</tr>
<tr>
<td>\nm</td>
<td>标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。</td>
</tr>
<tr>
<td>\nml</td>
<td>如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。</td>
</tr>
<tr>
<td>\un</td>
<td>匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。</td>
</tr>
</tbody></table>
<p>Java中为开发提供了2个类用于正则表达式：</p>
<ul>
<li><strong>Pattern 类：</strong>pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。</li>
<li><strong>Matcher 类：</strong>Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。</li>
</ul>
<p>下面我们通过一个简单的示例，来了解正则表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RexDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;884105019@qq.com&quot;</span>;</span><br><span class="line">		<span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$&quot;</span>);</span><br><span class="line">		<span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(content);</span><br><span class="line">		System.out.println(m.matches());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Java常用的正则表达式</title>
    <url>/2022/08/01/Java%E5%B8%B8%E7%94%A8%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h1 id="校验数字的表达式"><a href="#校验数字的表达式" class="headerlink" title="校验数字的表达式"></a>校验数字的表达式</h1><ul>
<li><img src="https://files.catbox.moe/c4h179.png"></li>
</ul>
<h1 id="校验字符的表达式"><a href="#校验字符的表达式" class="headerlink" title="校验字符的表达式"></a>校验字符的表达式</h1><ul>
<li><img src="https://files.catbox.moe/6j7046.png"></li>
</ul>
<h1 id="特殊需求的表达式"><a href="#特殊需求的表达式" class="headerlink" title="特殊需求的表达式"></a>特殊需求的表达式</h1><ul>
<li><img src="https://files.catbox.moe/tj1pu1.png"></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Java集合框架--List和Queue</title>
    <url>/2022/08/01/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-List%E5%92%8CQueue/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h1 id="Java集合框架–List和Queue"><a href="#Java集合框架–List和Queue" class="headerlink" title="Java集合框架–List和Queue"></a>Java集合框架–List和Queue</h1><p>在前面的章节我们存储数据一般有两种方式：</p>
<ol>
<li>保存在变量中，优点是简单方便，缺点是只能保存一个数据</li>
<li>保存在数组中，优点是可以批量保存数据，缺点是数组的长度不可变，一旦数据个数发生变化时，就得重新创建数组然后复制数组元素，并且数组只能存储相同数据类型的数据。</li>
</ol>
<p>基于以上两点，Java为我们提供了集合类，用于存储数量不等的<strong>对象</strong>，除此以外，Java还可以用于保存具有映射关系的关联数组。</p>
<h2 id="Java集合体系概述"><a href="#Java集合体系概述" class="headerlink" title="Java集合体系概述"></a>Java集合体系概述</h2><p>Java集合大致可以分为List、Set、Map和Queue，其中List代表有序、可重复的集合，Set代表无序、不可重复的集合，而Map则代表具有映射关系的集合。<br>Java集合就像是一个容器，只不过容器里装的都是对象，在JAVA 5之前，Java集合对丢失容器中对象的数据类型，把所有对象都当做Object类型处理，从容器取出元素后，还面临着对象向下转型的问题，Java5以后新增了泛型（关于泛型，会在Java高级中讲解，此处不做深究）。Java集合可以记住容器中对象的数据类型。首先，来查看Java集合体系的全貌。</p>
<p><img src="https://files.catbox.moe/omijxq.png"></p>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>List集合代表一个元素有序、有索引、可重复的集合。List允许存放相同的元素，并且每个元素都有对应的索引，可以通过索引访问指定位置的集合元素。结合ArrayList的特点以及前面章节的内容很容易联想到学习过的数组， 通过查看ArrayList源码可以看到ArrayList的底层就是用数组保存数据以及对数据操作的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 存储ArrayList元素的数组缓冲区。</span></span><br><span class="line"><span class="comment">* ArrayList的容量是此数组缓冲区的长度。任何</span></span><br><span class="line"><span class="comment">* 空的 ArrayList 等价于 elementData==DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment">* 当添加第一个元素时，将扩展到默认容量。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br></pre></td></tr></table></figure>

<p>那么我们就可以先尝试手动实习自己的ArrayList。在实现ArrayList之前，先来查看ArrayList继承关系图以及主要方法：</p>
<p><img src="https://files.catbox.moe/n0q81w.png"></p>
<p>通过继承关系图可以看出ArrayList的继承关系，下面先对各个接口进行解释：<br><strong>RandomAccess</strong>:随机访问接口，因为ArrayList底层使用数组实现，所以支持在允许范围内随机访问。<br><strong>Cloneable</strong>：克隆接口，说明ArrayList支持克隆<br><strong>Serializable</strong>：序列化接口，说明ArrayList支持序列化（关于序列化的内容，将会在Java高级中讲解)。<br><strong>List</strong>:接口提供数组的添加、删除、修改、迭代遍历等操作。<br><strong>AbstractList</strong>:AbstractList 提供了 List 接口的骨架实现，大幅度的减少了实现迭代遍历相关操作的代码<br>了解完继承关系以后，接下来熟悉ArrayList的常用API，了解完ArrayList的基本操作以后，可以更方便的理解ArrayList的源码以及结构。</p>
<h2 id="ArrayList常用API"><a href="#ArrayList常用API" class="headerlink" title="ArrayList常用API"></a>ArrayList常用API</h2><p>前面的内容可以知道ArrayList在Java中通常当做容器使用，当做容器使用就需要具备基本的增删改查方法。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>首先，需要了解ArrayList常用的构造方法：</p>
<ul>
<li>public ArrayList(int initialCapacity) ：创建给定容量的ArrayList，initialCapacity的值不能小于0，不能大于Integer能表示的最大值</li>
<li>public ArrayList()：创建ArrayList对象，默认创建一个空数组。</li>
<li>public ArrayList(Collection&lt;? extends E&gt; c)：传入一个集合，以集合中元素为初始元素创建对象</li>
</ul>
<p>在上述3个构造方法中，前两个使用频率较高，当知道ArrayList中保存对象的个数时，通常使用第一个构造方法，这样在ArrayList创建对象时已经初始化好数组的长度了，这样也就避免了扩容的内存开销。<br>同理，当不确定元素个数时，通常使用第二个构造方法。<br>如果需要把一个集合中的元素放入ArrayList，就可以使用第三个构造方法。<br>下面，通过示例来学习这3个构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//创建固定容量的集合</span></span><br><span class="line">		<span class="type">List</span> <span class="variable">list1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(<span class="number">10</span>);</span><br><span class="line">		<span class="comment">//创建不固定容量的集合</span></span><br><span class="line">		<span class="type">List</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">		<span class="comment">//传入一个集合</span></span><br><span class="line">		<span class="type">List</span> <span class="variable">list3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list2);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>add(Object o)</strong></td>
<td>添加数据</td>
</tr>
<tr>
<td><strong>add(int index,Object o)</strong></td>
<td>在制定索引处添加元素</td>
</tr>
<tr>
<td><strong>size()</strong></td>
<td>获取元素个数</td>
</tr>
<tr>
<td><strong>get(int index)</strong></td>
<td>获取索引处的元素</td>
</tr>
<tr>
<td><strong>isEmpty()</strong></td>
<td>判断集合是否为空</td>
</tr>
<tr>
<td><strong>indexOf(Object o)</strong></td>
<td>判断某个元素第一次出现的位置</td>
</tr>
<tr>
<td><strong>E remove(int index)</strong></td>
<td>移除索引处元素，并返回该元素</td>
</tr>
<tr>
<td><strong>boolean remove(Object o)</strong></td>
<td>移除元素</td>
</tr>
<tr>
<td><strong>clear()</strong></td>
<td>清空元素</td>
</tr>
<tr>
<td><strong>set(int index ,E e)</strong></td>
<td>修改索引处的元素</td>
</tr>
<tr>
<td><strong>iterator()</strong></td>
<td>获取迭代器</td>
</tr>
<tr>
<td>trimToSize()</td>
<td>减少容量至当前元素个数</td>
</tr>
<tr>
<td>contains(Object o)</td>
<td>判断是否包含某个元素</td>
</tr>
<tr>
<td>lastIndexOf(Object o)</td>
<td>判断某个元素最后一次出现的位置</td>
</tr>
<tr>
<td>toArray()</td>
<td>将集合转换为数组</td>
</tr>
<tr>
<td>addAll(Collection&lt;? extends E&gt; c)</td>
<td>集合中添加集合</td>
</tr>
<tr>
<td>addAll(int index, Collection&lt;? extends E&gt; c)</td>
<td>索引处添加集合</td>
</tr>
<tr>
<td>retainAll(Collection c)</td>
<td>求两个集合的交集</td>
</tr>
<tr>
<td>removeAll(Collection&lt;?&gt; c)</td>
<td>移除传入集合内的元素</td>
</tr>
<tr>
<td>subList(int fromIndex, int toIndex)</td>
<td>获取子集合</td>
</tr>
</tbody></table>
<p>下面，通过示例代码来学习ArrayList的常用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//集合当中添加元素</span></span><br><span class="line">		<span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">		list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;小昭&quot;</span>);</span><br><span class="line">		<span class="comment">//将list转成数组</span></span><br><span class="line">		Object[] objects = list.toArray();</span><br><span class="line">		System.out.println(Arrays.toString(objects));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        list.add(<span class="number">10</span>);</span><br><span class="line">        list.add(<span class="number">20</span>);</span><br><span class="line">        list.add(<span class="number">30</span>);</span><br><span class="line">        list.add(<span class="number">40</span>);</span><br><span class="line">        list.add(<span class="number">50</span>);</span><br><span class="line">        list.add(<span class="number">30</span>);</span><br><span class="line">        <span class="comment">//在索引处，添加元素</span></span><br><span class="line">        list.add(<span class="number">3</span>,<span class="number">100</span>);</span><br><span class="line">        <span class="comment">//获取元素的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> list.size();</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        <span class="comment">//判断集合是否为空</span></span><br><span class="line">        System.out.println(list.isEmpty());</span><br><span class="line">        <span class="comment">//判断某个元素第一次出现的位置</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="number">30</span>));</span><br><span class="line">        <span class="comment">//移除索引处的元素</span></span><br><span class="line">        System.out.println(list.remove(<span class="number">1</span>));</span><br><span class="line">        list.set(<span class="number">5</span>,<span class="number">60</span>);</span><br><span class="line">        <span class="comment">// 迭代器</span></span><br><span class="line">        Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line">        System.out.println(it.next());</span><br><span class="line">        <span class="comment">//清空元素</span></span><br><span class="line">        list.clear();</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">        list.trimToSize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayListDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">15</span>);</span><br><span class="line">        list.add(<span class="number">20</span>);</span><br><span class="line">        list.add(<span class="number">25</span>);</span><br><span class="line">        list.add(<span class="number">30</span>);</span><br><span class="line">        list.add(<span class="number">15</span>);</span><br><span class="line">        <span class="comment">//判断是否包含某个元素</span></span><br><span class="line">        System.out.println(list.contains(<span class="number">10</span>));</span><br><span class="line">        <span class="comment">//判断某个元素最后一次出现的位置</span></span><br><span class="line">        System.out.println(list.lastIndexOf(<span class="number">15</span>));</span><br><span class="line">        <span class="comment">//将集合转换为数组</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        arr.add(<span class="number">1</span>);</span><br><span class="line">        arr.add(<span class="number">2</span>);</span><br><span class="line">        arr.add(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//集合中添加集合</span></span><br><span class="line"><span class="comment">//        list.addAll(arr);</span></span><br><span class="line">        <span class="comment">//求两个集合的交集</span></span><br><span class="line">        list.retainAll(arr);</span><br><span class="line"><span class="comment">//        集合处添加集合</span></span><br><span class="line">        list.addAll(<span class="number">3</span>,arr);</span><br><span class="line">        list.toArray();</span><br><span class="line">        System.out.println(list.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="手动实现ArrayList"><a href="#手动实现ArrayList" class="headerlink" title="手动实现ArrayList"></a>手动实现ArrayList</h3><p>通过上一小节的学习可以发现ArrayList中主要的方法就是增、删、改、查，接下来根据ArrayList的方法，手动实现自己的ArrayList。<br>第一步：需要定义一个数组保存元素，其次需要定义一个变量保存数组中元素的个数。以及当前数组的长度和默认初始化的长度</p>
<p>第一步：需要定义一个数组保存元素，其次需要定义一个变量保存数组中元素的个数。以及当前数组的长度和默认初始化的长度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于保存元素个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"><span class="comment">//保存元素</span></span><br><span class="line"><span class="keyword">private</span> Object[] objects;</span><br><span class="line"><span class="comment">//保存数组的当前长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> length;</span><br><span class="line"><span class="comment">//保存数组的默认长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_LEGTH</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>第二步：定义构造方法，构造方法的目的主要是为了初始化数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyArray</span> &#123;	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 定义数组，保存数据</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> Object[] objects = <span class="literal">null</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 默认数组长度</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_LENGTH</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 数组长度</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> length;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 数组元素个数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> size= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 默认构造函数，创建数组</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LOAD</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyArray</span><span class="params">()</span> &#123;</span><br><span class="line">		length = DEFAULT_LENGTH;</span><br><span class="line">		objects = <span class="keyword">new</span> <span class="title class_">Object</span>[length];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 构造函数，根据用户传入长度创建数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyArray</span><span class="params">(<span class="type">int</span> length)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.length = length;</span><br><span class="line">		objects = <span class="keyword">new</span> <span class="title class_">Object</span>[length];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步：定义add()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyArray</span> &#123;	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 向数组中添加元素</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">		<span class="comment">//判断是否需要扩容</span></span><br><span class="line">		<span class="keyword">if</span>(size==length) &#123;</span><br><span class="line">			<span class="comment">//元素个数等于了数组长度，需要扩容</span></span><br><span class="line">			length = length*LOAD;</span><br><span class="line">			objects = Arrays.copyOf(objects,length);</span><br><span class="line">		&#125;</span><br><span class="line">		objects[size]=o;</span><br><span class="line">		size++;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index,Object o)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(index&lt;<span class="number">0</span>||index&gt;size-<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(<span class="string">&quot;访问越界&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//判断是否需要扩容</span></span><br><span class="line">			<span class="keyword">if</span>(size==length) &#123;</span><br><span class="line">				<span class="comment">//元素个数等于了数组长度，需要扩容</span></span><br><span class="line">				length = length*LOAD;</span><br><span class="line">				objects = Arrays.copyOf(objects,length );</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//先将index位置处的元素已近后面元素向右移动</span></span><br><span class="line">			System.arraycopy(objects, index, objects, index+<span class="number">1</span>, size-index);</span><br><span class="line">			objects[index] = o;</span><br><span class="line">			size++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中重载了两个add()方法，第一个方法默认添加到数组元素尾部，从代码中可以看出添加元素时先判断元素个数是否等于数组长度，当元素个数等于数组长度时意味着数组已经满了，此时，需要扩容，我们获取到数组原长度并乘以2，然后创建新的数组长度为原数组长度的2倍，并将原数组中的元素复制到新数组，最后将新数组的引用保存在原数组，扩容完毕后将新添加的元素放置在新数组元素末尾，然后元素个数增加一。如果不需要扩容，则直接将元素添加在数组元素末尾，然后元素个数增加一。<br>在add(int index,Object o)方法中，因为此时涉及到数组的索引，所以先判断传入的索引是否越界，如果越界则抛出异常，没有越界则继续执行，当添加元素时也需要先判数组是否已经放满，如果已经放满则扩容，扩容以后先将原数组的元素全部复制到新数组，复制完成以后，先将索引处元素到最后一个元素依次向后移动，然后将新元素放入索引位置处，最后将元素个数加一，如果不需要扩容，则直接将索引处元素向后移动，然后将新增的元素放入索引位置处。<br>第二步：定义删除方法<br>为了保证数组中所有的元素连续，那么当删除一个元素需要对被删除元素以后的元素全部向前移动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组移除操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(index&lt;<span class="number">0</span>||index&gt;size-<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(<span class="string">&quot;访问越界&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		objects[index]= <span class="literal">null</span>;</span><br><span class="line">		System.arraycopy(objects, index+<span class="number">1</span>, objects,index , size-index);</span><br><span class="line">		size--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于是要根据数组索引删除元素，因此删除之前要先判断索引是否越界，如果越界则抛出异常。<br>删除元素时只需将索引处的元素置为null，然后将索引处后面的元素全部往前移动1位，最后将元素个数减一即可。<br>第三步：修改元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 更新数组元素</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> index,Object o)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(index&lt;<span class="number">0</span>||index&gt;size-<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(<span class="string">&quot;访问越界&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	objects[index] = o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改元素时，一般是修改某个索引处的元素，因此也要判断传入索引是否越界。如果索引没有越界，则将索引处的元素修改为新元素即可。<br>第四步：查看元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 查找某个索引处的元素</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(index&lt;<span class="number">0</span>||index&gt;size-<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(<span class="string">&quot;访问越界&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> objects[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取索引处元素时，也需要先判断索引是否越界，如果没有越界则直接从数组中获取数组元素即可。</p>
<h3 id="ArrayList添加元素过程"><a href="#ArrayList添加元素过程" class="headerlink" title="ArrayList添加元素过程"></a>ArrayList添加元素过程</h3><p>在前面的章节中可以知道ArrayList的底层实现是一个数组，在ArrayList中添加元素的过程本质上就是在ArrayList底层数组添加元素的过程。<br>下面我们通过分析ArrayList源码来了解这个过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">//记录ArrayList的修改次数</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//调用重载的add()方法</span></span><br><span class="line">    add(e, elementData, size);</span><br><span class="line">    <span class="comment">//从这里看出不管元素是否添加成功都返回了true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从add()方法中可以看出，add方法内调用了重载的私有add(E e, Object[] elementData, int s)方法，并且返回了true，在这里需要注意的是根据此方法的返回值判断元素是否添加成功并没有任何意义，因为add()方法返回值恒为true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e, Object[] elementData, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="comment">//判断元素个数是否和长度相等</span></span><br><span class="line">    <span class="keyword">if</span> (s == elementData.length)</span><br><span class="line">        <span class="comment">//扩容</span></span><br><span class="line">        elementData = grow();</span><br><span class="line">    <span class="comment">//将元素放置在扩容后数组的已有元素的末尾</span></span><br><span class="line">    elementData[s] = e;</span><br><span class="line">    <span class="comment">//元素个数增加</span></span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法中首先判断元素的个数是否等于数组长度，也就是说判断数组是否已经满了，如果满了则进行扩容。不管是否扩容，都将新增的元素放在已有元素的后面，然后元素的个数加一。<br>那么ArrayList又是如何扩容的呢？继续查看grow()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object[] grow() &#123;</span><br><span class="line">    <span class="keyword">return</span> grow(size + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>grow()方法比较简单，只是调用了私有的重载grow(intminCapacity)方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object[] grow(<span class="type">int</span> minCapacity) &#123;</span><br><span class="line">    <span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> Arrays.copyOf(elementData,</span><br><span class="line">                                           newCapacity(minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源代码可以看出，在这个grow()方法内部使用了数组复制，并且在数组复制前调用了newCapacity()方法。继续查看newCapacity()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">newCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">//获取数组当前长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">//计算新长度，可以看出新长度是原长度的1.5倍</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//判断新容量和最小容量大小，如果新容量小于等于最小容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果当前数组是默认容量长度为0的数组</span></span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="comment">//返回数组初始长度10</span></span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        <span class="comment">//如果最小容量小于0则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果新容量大于最小容量，判断新容量是否比数组长度的最大值小</span></span><br><span class="line">    <span class="comment">//如果新容量小于数组长度最大值则返回新容量</span></span><br><span class="line">    <span class="keyword">return</span> (newCapacity - MAX_ARRAY_SIZE &lt;= <span class="number">0</span>)</span><br><span class="line">        ? newCapacity</span><br><span class="line">        : hugeCapacity(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>newCapacity()方法即ArrayList计算扩容后数组长度的核心方法，在这个方法中主要做了以下工作：</p>
<ol>
<li>获取数组原长度并根据元长度计算新长度</li>
<li>判断新长度是否比原长度小，如果新长度比原长度小，判断数组是否是初始的空数组，如果是则返回默认长度10。</li>
<li>如果新长度大于原长度，判断新长度是否大于等于数组长度的最大值（Integer.MAX_VALUE-8）,如果不大于则返回新长度。</li>
<li>如果大于则调用hugeCapacity()方法。</li>
</ol>
<p>继续查看hugeCapacity()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE)</span><br><span class="line">            ? Integer.MAX_VALUE</span><br><span class="line">            : MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>hugeCapacity()方法较为简单，判断最小容量是否大于数组的最大长度，如果大于则返回Integer的最大值，否则返回数组最大值。</p>
<h3 id="ArrayList和Vector"><a href="#ArrayList和Vector" class="headerlink" title="ArrayList和Vector"></a>ArrayList和Vector</h3><p>和ArrayList具有相同功能的类是Vector，Vector是Java早期提供的一个集合类，Vector和ArrayList的方法以及底层的实现基本相似，唯一不同的是Vector的方法都是线程安全的，打开Vector源码可以发现Vector的方法都是用synchronized修饰的（关于synchronized修饰符，会在多线程中讲解），因此Vector效率低于ArrayList。除此之外ArrayList和Vector的区别还体现在以下几个方面：</p>
<ol>
<li>ArrayList扩容后的长度是原长度的1.5倍，而Vector扩容后的长度是原长度的2倍</li>
<li>ArrayList调用无参构造方法创建对象时，会创建一个空的Object数组，当添加第一个元素时进行扩容，初始容量为10，当Vector调用无参构造创建对象时，则会直接初始化保存数据的数组，长度为10。</li>
</ol>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>LinkedList同样实现了List，也就是说LinkedList和ArrayList的方法基本一致。除此以外，LinkedList还实现了Deque接口。Deque接口则继承了Queue接口，因为Queue是指队列这种数据结构，换句话说就是LinkedList不但可以当做List使用，也可以当做队列使用（FIFO），并且是双端队列，根据队列的规定，队列只能从一端进入数据，另一端出数据，但是双端队列任意一端都可以进出数据。下面先来查看LinkedList继承关系图：</p>
<p><img src="https://files.catbox.moe/ybf7v4.png"></p>
<h3 id="手动实现LinkedList"><a href="#手动实现LinkedList" class="headerlink" title="手动实现LinkedList"></a>手动实现LinkedList</h3><p>LinkedList底层结构实现和ArrayList底层数据结构实现有着本质上的区别，通过上一小节的内容可以看出ArrayList底层实现主要依赖数组，而LinkedList底层实现则是依赖链表。并且LinkedList底层数据结构是双向链表，因此，需要先定义链表数据节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">	Node pre;</span><br><span class="line">	Object data;</span><br><span class="line">	Node next;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Node pre, E data, Node next)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.pre = pre;</span><br><span class="line">		<span class="built_in">this</span>.data = data;</span><br><span class="line">		<span class="built_in">this</span>.next = next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一步：LinkedList的实现是双向链表，因此需要定义首节点和尾结点。并且需要保存链表中元素的个数。此外，还需要提供无参构造方法，在构造方法内初始化一个空链表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLinkedList</span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 链表元素个数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 链表首节点</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> Node first;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 链表尾结点</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> Node last;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 默认构造创建一个空链表</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">		first = <span class="literal">null</span>;</span><br><span class="line">		last = <span class="literal">null</span>;</span><br><span class="line">		size = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>第二步：添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 链表中添加节点，默认添加在尾部</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> Object</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Object e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(first==<span class="literal">null</span>||last==<span class="literal">null</span>||size==<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//说明链表为空链表</span></span><br><span class="line">		<span class="comment">//1.创建新节点</span></span><br><span class="line">		<span class="comment">//2.新节点指为first</span></span><br><span class="line">		<span class="comment">//3.新节点指为last</span></span><br><span class="line">		<span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>,e,<span class="literal">null</span>);</span><br><span class="line">		first = newNode;</span><br><span class="line">		last = newNode;</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//1.创建新节点</span></span><br><span class="line">		<span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(last,e,<span class="literal">null</span>);</span><br><span class="line">		<span class="comment">//2.将last节点指向新节点</span></span><br><span class="line">		last.next = newNode;</span><br><span class="line">			<span class="comment">//3.将新节点改为last</span></span><br><span class="line">		last = newNode;</span><br><span class="line">	&#125;</span><br><span class="line">	size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当直接添加元素时，默认添加在链表末尾。添加元素时首先判断链表是否为空链表，如果为空链表，则新增加的节点既是首节点，也是尾结点，并且没有前置节点也没有后置节点，因此，新增的节点前置节点和后置节点都为null，当创建好新增的节点后，将首节点和为节点都指向该节点，然后元素个数加一。<br>当链表不为空链表时，只需要将创建的新节点的前置节点指向尾结点，然后将尾结点指向新创建的节点，然后将元素个数加一。<br>第二步：定义删除元素方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 删除索引处节点</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(index&lt;<span class="number">0</span>||index&gt;size-<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;访问越界&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(index==<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(size==<span class="number">1</span>)&#123;</span><br><span class="line">                first = <span class="literal">null</span>;</span><br><span class="line">                last = <span class="literal">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">removeNode</span> <span class="operator">=</span> first;</span><br><span class="line">				first = first.next;</span><br><span class="line">				first.pre = <span class="literal">null</span>;</span><br><span class="line">				removeNode.next=<span class="literal">null</span>;   </span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(index==size-<span class="number">1</span>) &#123;</span><br><span class="line">        	<span class="keyword">if</span>(size==<span class="number">1</span>)&#123;</span><br><span class="line">                first = <span class="literal">null</span>;</span><br><span class="line">                last = <span class="literal">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">removeNode</span> <span class="operator">=</span> last;</span><br><span class="line">                last = last.pre;</span><br><span class="line">                last.next = <span class="literal">null</span>;</span><br><span class="line">                removeNode.pre = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;  	</span><br><span class="line">            <span class="comment">//1.找到索引处的节点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">indexNode</span> <span class="operator">=</span> getNodeByIndex(index);</span><br><span class="line">            <span class="comment">//2.找到索引处的后置节点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> indexNode.next;</span><br><span class="line">            <span class="comment">//3.找到索引处的前置节点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> indexNode.pre;</span><br><span class="line">            <span class="comment">//4.将索引处前置节点的next指向索引处后置节点</span></span><br><span class="line">            pre.next = next;</span><br><span class="line">            <span class="comment">//5.将索引处后置节点的pre指向索引处前置节点</span></span><br><span class="line">            next.pre = pre;</span><br><span class="line">		&#125;</span><br><span class="line">		size--;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>移除元素时，根据元素索引移除，所以要先判断索引是否越界，索引越界时抛出异常，如果没有越界。则判断删除元素的位置：<br>当删除的是首节点时，首先判断元素个数是否是1，如果只有一个元素，则直接将首节点和尾结点置为null即可。<br>如果有多个元素时，则先获取首节点，然后获取首节点的后置节点并将获取到节点的pre属性置为null以及将原来首节点的next属性置为null，并将获取到的节点置为新的首结点，最后将元素个数减一即可。<br>当删除的节点是尾结点时，先判断元素个数是否为1，如果只有一个元素，则直接将首节点和尾结点置为null即可。<br>如果有多个元素时，则先获取尾结点的前置节点，将获取到的节点的next属性和原来尾结点的pre属性置为null，并将获取到的节点置为新的尾结点。最后将元素个数减一即可。<br>当删除的节点是中间节点时，首先需要获取删除索引处节点的前置节点和后置节点，即获取n-1处的节点和n+1处的节点，然后将n-1处节点的next指向n+1处节点，并将n+1处的节点pre属性指向n-1处节点。最后将元素个数减一。<br>第三步：定义查找方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 根据传入的索引找到节点</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">private</span> Node&lt;E&gt; <span class="title function_">getNodeByIndex</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">	<span class="comment">//判断索引越界</span></span><br><span class="line">	<span class="keyword">if</span>(index&lt;<span class="number">0</span>||index&gt;size) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;访问越界&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(index==<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> first;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(index==size-<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> last;</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		Node&lt;E&gt; current = first;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size&amp;&amp;current!=<span class="literal">null</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i==index) &#123;</span><br><span class="line">				<span class="keyword">return</span> current;</span><br><span class="line">			&#125;</span><br><span class="line">			current = current.next;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据索引获取元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">	Node&lt;E&gt; node = getNodeByIndex(index);</span><br><span class="line">	<span class="keyword">return</span> node.data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据索引获取元素，需要判断索引是否越界，如果没有越界则根据传入索引判断获取的是哪个节点的元素。<br>当索引值为0时，直接返回首节点中保存的数据。<br>当索引的值为size-1时，直接返回尾结点中保存的数据。<br>当索引的值在0到size-1之间时，从首节点开始遍历，当遍历的节点索引等于index时，返回该节点中保存的数据。<br>第四步：定义修改方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改索引处的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> index,E e)</span> &#123;</span><br><span class="line">	chcekRange(index);</span><br><span class="line">	Node&lt;E&gt; current  = first;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size&amp;&amp;current!=<span class="literal">null</span>;i++,current = current.next) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i==index) &#123;</span><br><span class="line">			current.data = e;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改元素时，检查索引是否越界，从首节点开始遍历，直到找到索引处元素并修改值即可</p>
<h3 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h3><p>ArrayList和LinkedList虽然都是List接口的子类，但是在底层实现以及效率上存在以下区别</p>
<ol>
<li>ArrayList和LinkedList都实现了List接口</li>
<li>ArrayList和LinkedList都是非线程安全的，因此在多线程环境下可能会出现出现不同步的情况</li>
<li>ArrayList底层实现是数组，LinkedList底层实现是双向链表</li>
<li>ArrayList因为底层实现是数组，并且支持随机访问因此查找效率高，但是ArrayList在新增元素时会扩容以及复制数组元素，并且删除时也会进行数组复制，所以增删效率低。而LinkedList不支持随机访问，获取元素时必须从首节点开始从前往后遍历查找，因此查找效率低。但是增加和删除时最多涉及到两个节点的操作，因此增删效率高。</li>
</ol>
<h2 id="ArrayList和LinkedList的遍历"><a href="#ArrayList和LinkedList的遍历" class="headerlink" title="ArrayList和LinkedList的遍历"></a>ArrayList和LinkedList的遍历</h2><ol>
<li>ArrayList和LinkedList都支持使用for循环遍历</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本例将演示使用for循环遍历ArrayList和LinkedList</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MR.W</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		List&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		arrayList.add(<span class="string">&quot;宋远桥&quot;</span>);</span><br><span class="line">		arrayList.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">		arrayList.add(<span class="string">&quot;张翠山&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arrayList.size(); i++) &#123;</span><br><span class="line">			System.out.println(arrayList.get(i));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		List&lt;String&gt; linkedList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">		linkedList.add(<span class="string">&quot;白眉鹰王&quot;</span>);</span><br><span class="line">		linkedList.add(<span class="string">&quot;金毛狮王&quot;</span>);</span><br><span class="line">		linkedList.add(<span class="string">&quot;青翼蝠王&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; linkedList.size(); i++) &#123;</span><br><span class="line">			System.out.println(arrayList.get(i));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.使用foreach遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本例将演示使用foreach遍历ArrayList和LinkedList</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MR.W</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForeachDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		List&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		arrayList.add(<span class="string">&quot;宋远桥&quot;</span>);</span><br><span class="line">		arrayList.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">		arrayList.add(<span class="string">&quot;张翠山&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (String s : arrayList) &#123;</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		List&lt;String&gt; linkedList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">		linkedList.add(<span class="string">&quot;白眉鹰王&quot;</span>);</span><br><span class="line">		linkedList.add(<span class="string">&quot;金毛狮王&quot;</span>);</span><br><span class="line">		linkedList.add(<span class="string">&quot;青翼蝠王&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (String s : linkedList) &#123;</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.因为ArrayList和LinkedList都继承了Iterable接口，因此ArrayList和LinkedList都可以使用迭代器进行遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteratorDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		List&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		arrayList.add(<span class="string">&quot;宋远桥&quot;</span>);</span><br><span class="line">		arrayList.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">		arrayList.add(<span class="string">&quot;张翠山&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		Iterator&lt;String&gt; it1 = arrayList.iterator();</span><br><span class="line">		<span class="keyword">while</span>(it1.hasNext()) &#123;</span><br><span class="line">			System.out.println(it1.next());</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		List&lt;String&gt; linkedList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">		linkedList.add(<span class="string">&quot;白眉鹰王&quot;</span>);</span><br><span class="line">		linkedList.add(<span class="string">&quot;金毛狮王&quot;</span>);</span><br><span class="line">		linkedList.add(<span class="string">&quot;青翼蝠王&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		Iterator&lt;String&gt; it2 = linkedList.iterator();</span><br><span class="line">		<span class="keyword">while</span>(it2.hasNext()) &#123;</span><br><span class="line">			System.out.println(it2.next());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了Iterator以外，List还提供了ListIterator用于遍历List，方法基本和Iterator类似。</p>
<p>4.Lambda表达式遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Lambda遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MR.W</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		List&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		arrayList.add(<span class="string">&quot;宋远桥&quot;</span>);</span><br><span class="line">		arrayList.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">		arrayList.add(<span class="string">&quot;张翠山&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		arrayList.forEach(str-&gt;&#123;</span><br><span class="line">			System.out.println(str);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>Queue 用于模拟队列这种数据结构，队列通常是指”先进先出”（FIFO）的容器。队列的头部保存在队列中存放时间最长的元素，队列的尾部保存在队列中存放时间最短的元素。新元素插入（offer）到队列的尾部，访问元素（poll）操作会返回队列头部的元素。通常，队列不允许随机访问队列中的元素。<br>Queue 接口中定义了如下几个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Queue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">//队列末尾添加元素</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">    <span class="comment">//将指定的元素添加到队列尾部</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span>;</span><br><span class="line">    <span class="comment">//移除队列头部的元素</span></span><br><span class="line">    E <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//获取队列头部的元素，并删除该元素</span></span><br><span class="line">    E <span class="title function_">poll</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//获取队列头部的元素</span></span><br><span class="line">    E <span class="title function_">element</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//获取队列头部的元素，但是不删除</span></span><br><span class="line">    E <span class="title function_">peek</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>boolean add(Object e)∶将指定元素加入此队列的尾部。</li>
<li>Object element()∶获取队列头部的元素，但是不删除该元素。</li>
<li>boolean offer(Object e)∶将指定元素加入此队列的尾部。当使用有容量限制的队列时，当使用有容量限制的队列时使用offer方法，比使用 add(Object e)方法更好。</li>
<li>Object peek()∶获取队列头部的元素，但是不删除该元素。如果此队列为空，则返回 null。</li>
<li>Object poll()∶获取队列头部的元素，并删除该元素。如果此队列为空，则返回 null。</li>
<li>Object remove()∶获取队列头部的元素，并删除该元素。</li>
</ul>
<p>Queue 接口有一个PriorityQueue 实现类。除此之外，Queue 还有一个 Deque 接口，Deque 代表一个”双端队列”，双端队列可以同时从两端来添加、删除元素，因此 Deque 的实现类既可当成队列使用，也可当成栈使用。Java 为 Deque提供了ArrayDeque 和 LinkedList 两个实现类。</p>
<p><strong>add()和offer()区别:</strong></p>
<p>add()和offer()都是向<a href="https://so.csdn.net/so/search?q=%E9%98%9F%E5%88%97&spm=1001.2101.3001.7020">队列</a>中添加一个元素。一些队列有大小限制，因此如果想在一个满的队列中加入一个新项，调用 add() 方法就会抛出一个 unchecked 异常，而调用 offer() 方法会返回 false。因此就可以在程序中进行有效的判断！</p>
<p><strong>poll()和remove()区别：</strong></p>
<p>remove() 和 poll() 方法都是从队列中删除第一个元素。如果队列元素为空，调用remove() 的行为与 Collection 接口的版本相似会抛出异常，但是新的 poll() 方法在用空集合调用时只是返回 null。因此新的方法更适合容易出现异常条件的情况。</p>
<p><strong>element() 和 peek() 区别：</strong></p>
<p>element() 和 peek() 用于在队列的头部查询元素。与 remove() 方法类似，在队列为空时， element() 抛出一个异常，而 peek() 返回 null。</p>
<p>下面是Java中Queue的一些常用方法：</p>
<p>add 增加一个元索 如果队列已满，则抛出一个IIIegaISlabEepeplian异常<br>remove 移除并返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常<br>element 返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常<br>offer 添加一个元素并返回true 如果队列已满，则返回false<br>poll 移除并返问队列头部的元素 如果队列为空，则返回null<br>peek 返回队列头部的元素 如果队列为空，则返回null<br>put 添加一个元素 如果队列满，则阻塞<br>take 移除并返回队列头部的元素</p>
<h3 id="PriorityQueue实现类"><a href="#PriorityQueue实现类" class="headerlink" title="PriorityQueue实现类"></a>PriorityQueue实现类</h3><p>PriorityQueue是一个标准的队列实现，需要注意的是PriorityQueue并不是绝对标准的队列实现，这是因为PriorityQueue保存队列元素的顺序并不是按照加入的顺序，在PriorityQueue内部会对元素的大小进行重新排序。因此，当调用peek()方法或者poll()方法取出队列中的元素时。并不是取出最先进入队列的元素，而是取出队列中最小的元素，从这个意义上来看，PriorityQueue已经违反了队列先进先出的规则。下面，通过示例来查看PriorityQueue的用法.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityQueueDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Integer&gt;();</span><br><span class="line">		queue.offer(<span class="number">5</span>);</span><br><span class="line">		queue.offer(-<span class="number">1</span>);</span><br><span class="line">		queue.offer(<span class="number">10</span>);</span><br><span class="line">		queue.offer(<span class="number">30</span>);</span><br><span class="line">		<span class="comment">//①打印queue</span></span><br><span class="line">		System.out.println(queue);</span><br><span class="line">		<span class="comment">//获取队列头部的元素并删除</span></span><br><span class="line">		System.out.println(queue.poll());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上述程序打印PriorityQueue队列时，发现队列中的元素顺序并不是按照存放的顺序排列的，而是从小到大排列。<br>PriorityQueue不允许插入null元素，它还需要对队列元素进行排序，PriorityQueue的元素有两种排序方式：</p>
<ol>
<li>自然排序：采用自然顺序的PriorityQueue队列中的元素必须实现Comparable接口，并且应该是同一个类的多个示例，否则可能导致转型异常</li>
<li>定制排序：创建PriorityQueue队列是，传入一个Comparator对象，该对象负责对队列中的所有元素进行排序。采用定制排序时不要求队列元素实现Comparator接口。</li>
</ol>
<h3 id="Deque接口与ArrayDeque"><a href="#Deque接口与ArrayDeque" class="headerlink" title="Deque接口与ArrayDeque"></a>Deque接口与ArrayDeque</h3><p>在上一小节学习的PriorityQueue是一个单向队列，也就是入口和出口是由明显划分的，不能从入口取出元素，反之也不能在出口放入元素。<br>Deque是Queue的子接口，它代表的了一个双端队列，Deque接口中定义了一些双端队列的方法，这些方法允许从队列两端来操作队列中的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Deque&lt;E&gt; extends Queue&lt;E&gt; &#123;</span><br><span class="line">    void addFirst(E e);</span><br><span class="line">    void addLast(E e);</span><br><span class="line">    boolean offerFirst(E e);</span><br><span class="line">    boolean offerLast(E e);</span><br><span class="line">    E removeFirst();</span><br><span class="line">    E removeLast();</span><br><span class="line">    E pollFirst();</span><br><span class="line">    E pollLast();</span><br><span class="line">    E getFirst();</span><br><span class="line">    E getLast();</span><br><span class="line">    E peekFirst();</span><br><span class="line">    E peekLast();</span><br><span class="line">    boolean removeFirstOccurrence(Object o);</span><br><span class="line">    boolean removeLastOccurrence(Object o);</span><br><span class="line">    boolean add(E e);</span><br><span class="line">    boolean offer(E e);</span><br><span class="line">    E remove();</span><br><span class="line">    E poll();</span><br><span class="line">    E element();</span><br><span class="line">    E peek();</span><br><span class="line">    boolean addAll(Collection&lt;? extends E&gt; c);</span><br><span class="line">    void push(E e);</span><br><span class="line">    E pop();</span><br><span class="line">    boolean remove(Object o);</span><br><span class="line">    boolean contains(Object o);</span><br><span class="line">    int size();</span><br><span class="line">    Iterator&lt;E&gt; iterator();</span><br><span class="line">    Iterator&lt;E&gt; descendingIterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面对接口中的方法进行简要介绍：</p>
<ul>
<li>void addFirst(Object e)：将指定元素插入该双端队列的开头。</li>
<li>void addLast(Object e)：将指定元素插入该双端队列的末尾。</li>
<li>Iterator descendinglterator()：返回该双端队列对应的迭代器，该迭代器将以逆向顺序来迭代队列中的元素。</li>
<li>Object getFirst()：获取但不删除双端队列的第一个元素。</li>
<li>Object getLast()：获取但不删除双端队列的最后一个元素。</li>
<li>boolean offerFirst(Object e)：将指定元素插入该双端队列的开头。</li>
<li>boolean offerLast(Object e)：将指定元素插入该双端队列的末尾。</li>
<li>Object peekFirst()：获取但不删除该双端队列的第一个元素;如果此双端队列为空，则返回 null。</li>
<li>Object peekLast()：获取但不删除该双端队列的最后一个元素;如果此双端队列为空，则返回 null。</li>
<li>Object pollFirst()：获取并删除该双端队列的第一个元素;如果此双端队列为空，则返回 null。</li>
<li>Object pollLast()：获取并删除该双端队列的最后一个元素;如果此双端队列为空，则返回 null。</li>
<li>Object pop()(栈方法)：pop 出该双端队列所表示的栈的栈顶元素。相当于removeFirstO。</li>
<li>void push(Object e)(栈方法)：将一个元素 push 进该双端队列所表示的栈的栈顶。相当于addFirst(e)。</li>
<li>Object removeFirst()：获取并删除该双端队列的第一个元素。</li>
<li>Object removeFirstOccurrence(Object o)：删除该双端队列的第一次出现的元素 o。</li>
<li>Object removeLast()：获取并删除该双端队列的最后一个元素。</li>
<li>boolean removeLastOccurrence(Object o)：删除该双端队列的最后一次出现的元素o。</li>
</ul>
<p>从上面方法中可以看出，Deque 不仅可以当成双端队列使用，而且可以被当成栈来使用，因为该类里还包含了pop（出栈）、push（入栈）两个方法。<br>Deque接口提供了一个典型的实现类：ArrayDeque，从类名就可以看出，这个队列是基于数组实现的双端队列，创建Deque时可以指定一个numElement参数，该参数用于指定Object[]数组的长度，如果不指定该参数，则ArrayDeque底层数组的默认长度为16。<br>由于ArrayDeque既可以当做队列使用，又可以当做栈使用，下面的示例首先示范将ArrayDeque使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ArrayDequeDemo &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		ArrayDeque&lt;String&gt; stack = new ArrayDeque&lt;String&gt;();</span><br><span class="line">		stack.push(&quot;Java&quot;);</span><br><span class="line">		stack.push(&quot;HTML&quot;);</span><br><span class="line">		stack.push(&quot;Spring&quot;);</span><br><span class="line">		//输出stack:[Spring, HTML, Java]</span><br><span class="line">		System.out.println(stack);</span><br><span class="line">		//peek第一个元素，但是并不出栈,输出Spring</span><br><span class="line">		System.out.println(stack.peek());</span><br><span class="line">		//pop第一个元素，出栈并删除</span><br><span class="line">		System.out.println(stack.pop());</span><br><span class="line">		//再次打印stack,输出[HTML, Java]</span><br><span class="line">		System.out.println(stack);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的示例演示了ArrayDeque作为栈使用，当程序中需要使用栈这种数据结构时，推荐使用ArrayDeque，尽量避免使用Stack，这是因为Stack是一个比较古老的集合，并且性能方面也不尽人意。<br>当然ArrayDeque也可以当做队列使用，ArrayDeque会按照“先进先出”的方式操作集合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDequeDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		ArrayDeque&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;String&gt;();</span><br><span class="line">		queue.offer(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">		queue.offer(<span class="string">&quot;HTML&quot;</span>);</span><br><span class="line">		queue.offer(<span class="string">&quot;Spring&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//打印queue，输出[Java, HTML, Spring]</span></span><br><span class="line">		System.out.println(queue);</span><br><span class="line">		<span class="comment">//访问队列头部元素，但不出队列输出Java</span></span><br><span class="line">		System.out.println(queue.peek());</span><br><span class="line">		<span class="comment">//poll出第一个元素，输出Java</span></span><br><span class="line">		System.out.println(queue.poll());</span><br><span class="line">		<span class="comment">//再次打印队列，输出[HTML, Spring]</span></span><br><span class="line">		System.out.println(queue);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LinkedList实现类"><a href="#LinkedList实现类" class="headerlink" title="LinkedList实现类"></a>LinkedList实现类</h3><p>LinkedList类时List接口的实现类，也就是说LinkedList可以根据索引来随机访问放入其中的元素，除此以外LinkedList也可以被当做栈和队列使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		LinkedList&lt;String&gt; linkedList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line">		<span class="comment">//将字符串加入队列末尾</span></span><br><span class="line">		linkedList.offer(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">		<span class="comment">//将一个字符串加入栈的顶部</span></span><br><span class="line">		linkedList.push(<span class="string">&quot;Spring&quot;</span>);</span><br><span class="line">		<span class="comment">//将字符串添加到队列头部（相当于栈的顶部）</span></span><br><span class="line">		linkedList.offerFirst(<span class="string">&quot;HTML&quot;</span>);</span><br><span class="line">		<span class="comment">//当做list遍历</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; linkedList.size(); i++) &#123;</span><br><span class="line">			System.out.println(linkedList.get(i));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//访问并不删除栈顶的元素</span></span><br><span class="line">		System.out.println(linkedList.peekFirst());</span><br><span class="line">		<span class="comment">//访问并不删除队列的最后一个元素</span></span><br><span class="line">		System.out.println(linkedList.peekLast());</span><br><span class="line">		<span class="comment">//将栈顶的元素弹出栈</span></span><br><span class="line">		System.out.println(linkedList.pop());</span><br><span class="line">		<span class="comment">//输出[Spring, Java]</span></span><br><span class="line">		System.out.println(linkedList);</span><br><span class="line">		<span class="comment">//访问并删除队列中的最后一个元素</span></span><br><span class="line">		System.out.println(linkedList.pollLast());</span><br><span class="line">		<span class="comment">//输出[[Spring]]</span></span><br><span class="line">		System.out.println(linkedList);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码分别演示了LinkedList作为List，双端队列及栈的使用，所以LinkedList是一个功能非常强大的类，但是需要注意的是，虽然LinkedList功能强大，开发中如果要当做队列使用，就不要调用栈和list相关的方法，这样做会引起不必要的麻烦以及代码难以维护。</p>
]]></content>
  </entry>
  <entry>
    <title>Java集合框架--Map</title>
    <url>/2022/08/01/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-Map/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h1 id="Java集合框架–Map集合"><a href="#Java集合框架–Map集合" class="headerlink" title="Java集合框架–Map集合"></a>Java集合框架–Map集合</h1><h2 id="Map概述"><a href="#Map概述" class="headerlink" title="Map概述"></a>Map概述</h2><p>Map用于保存具有映射关系的数据，因此Map集合里保存着两组值，一组用于保存Map里的key，另外一组用于保存Map里的value，key和value都可以是任何引用类型的数据。Map的key不允许重复，即同一个Map对象的任何两个key通过equals方法比较总是返回false。<br>key和value之间存在单向一对一的关系，即通过指定的key，总能找到唯一的、确定的value。从Map中取出数据时，只要给出指定的key，就可以取出对应的value.<br>Map的实现类有HashMap、Hashtable、Properties、SortedMap等等。</p>
<p><img src="https://files.catbox.moe/0dfod3.png"></p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="HashMap常用API"><a href="#HashMap常用API" class="headerlink" title="HashMap常用API"></a>HashMap常用API</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>put(K key,V value)</td>
<td>添加键值对</td>
</tr>
<tr>
<td>get(Object key)</td>
<td>根据键获取值</td>
</tr>
<tr>
<td>keySet()</td>
<td>获取keySet</td>
</tr>
<tr>
<td>entrySet()</td>
<td>获取entrySet</td>
</tr>
<tr>
<td>clear()</td>
<td>清空</td>
</tr>
<tr>
<td>containsKey(Object key)</td>
<td>判断是否存在key</td>
</tr>
<tr>
<td>remove(Object key)</td>
<td>根据key删除键值对</td>
</tr>
<tr>
<td>remover(Object key,Object value)</td>
<td>根据key和value删除键值对</td>
</tr>
<tr>
<td>size()</td>
<td>获取元素个数</td>
</tr>
<tr>
<td>isEmpty()</td>
<td>判断map是否为空</td>
</tr>
</tbody></table>
<p>下面，通过示例学习HashMap的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,String&gt;();</span><br><span class="line">        <span class="comment">//添加键值对</span></span><br><span class="line">        map.put(<span class="number">1</span>,<span class="string">&quot;妲己&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>,<span class="string">&quot;亚瑟&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>,<span class="string">&quot;虞姬&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>,<span class="string">&quot;韩信&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>,<span class="string">&quot;蔡文姬&quot;</span>);</span><br><span class="line">        <span class="comment">//根据键获取值</span></span><br><span class="line">        System.out.println(map.get(<span class="number">3</span>));</span><br><span class="line">        <span class="comment">//获取keySet</span></span><br><span class="line">        <span class="keyword">for</span> (Integer i : map.keySet())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;key: &quot;</span> + i + <span class="string">&quot; value: &quot;</span> + map.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取entrySet</span></span><br><span class="line">        System.out.println(map.entrySet());</span><br><span class="line">        <span class="comment">//获取元素个数</span></span><br><span class="line">        System.out.println(map.size());</span><br><span class="line">        <span class="comment">//判断是否存在key</span></span><br><span class="line">        System.out.println(map.containsKey(<span class="number">5</span>));</span><br><span class="line">        <span class="comment">//判断是否存在value</span></span><br><span class="line">        System.out.println(map.containsValue(<span class="string">&quot;程咬金&quot;</span>));</span><br><span class="line">        <span class="comment">//判断map是否为空</span></span><br><span class="line">        System.out.println(map.isEmpty());</span><br><span class="line">        <span class="comment">//根据key删除键值对</span></span><br><span class="line">        map.remove(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//根据key和value删除键值对</span></span><br><span class="line">        map.remove(<span class="number">4</span>,<span class="string">&quot;韩信&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">//清空map</span></span><br><span class="line">        map.clear();</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashMap存放元素流程"><a href="#HashMap存放元素流程" class="headerlink" title="HashMap存放元素流程"></a>HashMap存放元素流程</h3><p>HashMap元素存放是一个相对是复杂的过程，整个过程涉及到的有哈希表扩容，红黑树和链表的相互转换等过程，在本小节从源码查看整个过程。<br>在学习HashMap存放元素之前需要对HashMap中的几个关键成员变量进行了解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HashMap默认容量16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"><span class="comment">//HashMap最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//HashMap负载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;;</span><br><span class="line"><span class="comment">//链表转换为红黑树的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"><span class="comment">//红黑树转换为链表的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"><span class="comment">//链表转换为红黑树时Hash表的容量阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"><span class="comment">//保存HashMap的Hash表</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">//HashMap中元素个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure>

<p>HashMap添加元素会调用put(K key,V value)方法，从源码可以看出在put()方法内部调用了putVal()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">//调用putVal方法</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续查看putVal()方法，这个方法即HashMap存放元素的核心流程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">//判断哈希表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//扩容</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)<span class="comment">//判断tab[i]是否有元素</span></span><br><span class="line">        <span class="comment">//如果没有元素则直接存放</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">         Node&lt;K,V&gt; e; K k;</span><br><span class="line">         <span class="comment">//判断和已有节点的key是否相等</span></span><br><span class="line">         <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                 ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">             <span class="comment">//如果key相等则替换</span></span><br><span class="line">             e = p;</span><br><span class="line">         <span class="comment">//如果key不相等，判断哈希表已有的节点是不是红黑树</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">             <span class="comment">//如果是红黑树则以树的方式插入元素</span></span><br><span class="line">             e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//如果不是红黑树则说明这里链表，遍历链表</span></span><br><span class="line">             <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                 <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                     p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                     <span class="comment">//如果链表长度大于等于7，则进制红黑树转换相关工作</span></span><br><span class="line">                     <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                         treeifyBin(tab, hash);</span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                 	 <span class="comment">//如果key相等则在链表中替换</span></span><br><span class="line">                     <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                         ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line">                     </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">    	<span class="comment">//如果元素个数大于临界值则扩容</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法内整个过程可以描述如下：</p>
<ol>
<li>判断底层hash表是否为空，如果为空则先扩容</li>
<li>如果不为空，根据存放元素的key计算在hash表中的位置</li>
<li>判断在计算出位置处是否有元素，如果没有元素则直接放入hash表，并直接跳转到第9步</li>
<li>如果计算出位置有元素判断key是否相等，如果相等则直接赋值</li>
<li>如果计算出位置有元素并且判断key不相等，判断此处的节点是否是红黑树，如果是红黑树则以树的方式插入</li>
<li>如果计算处位置有元素并且判断key不相等，并且此处节点不是红黑树，那么这个节点处的数据结构一定是链表，则遍历链表准备插入。</li>
<li>遍历链表如果新增元素和链表中元素key相等则替换，如果新增元素和链表中已有元素key都不相等，则在已有元素末尾链表插入。</li>
<li>如果链表长度大于8，判断hash表容量是否大于64，如果大于64则转换成红黑树，并以红黑树的方式插入元素。</li>
<li>添加元素后判断元素个数是否大于扩容阈值，如果大于则扩容。</li>
</ol>
<p>这9步完整的描述了HashMap添加元素的流程，描述如图：</p>
<p><img src="https://files.catbox.moe/zcfozq.png"></p>
<p><img src="https://files.catbox.moe/gqygu3.jpg"></p>
<h3 id="HashMap扩容流程"><a href="#HashMap扩容流程" class="headerlink" title="HashMap扩容流程"></a>HashMap扩容流程</h3><p>在上一小节中我们了解了HashMap添加元素的详细流程，在HashMap添加元素的过程中涉及到一个很重要的操作，那就是扩容。因为如果在HashMap内添加元素，当HashMap内部数组无法装载更多元素时，就需要扩大数组长度，以便放入更多元素，由于Java中数组是无法自动扩容的，这就需要创建一个新的数组替代已有的数组，在本小节内将详细了解HashMap的扩容机制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">//获取原有hash表</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//获取原容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">//获取原阈值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果原容量大于0</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果原容量已经大于最大容量则不再扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果原容量的2倍小于最大容量，并且原容量小于默认容量10，就将扩容阈值修改为原阈值的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//如果当前hash表没有数据，则使用初始化的值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">//如果是第一次添加元素则使用默认容量16，扩容阈值为16*0.75=12</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    <span class="comment">//创建新的hash表</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历hash表开始扩容</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">//如果原数据不为空，则将原数据复制到新数组</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">//如果链表只有一个节点，则直接复制</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//如果元数据是红黑树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">//进行红黑树相关操作</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">//链表复制操作</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>纵观整个代码HashMap扩容时会存在以下几种情况：</p>
<ol>
<li>调用无参构造器时，实例化的HashMap底层数组是null，当第一次调用put()方法时进行扩容，初始容量为16。</li>
<li>调用有参构造指定了容量和负载因子时，会根据指定的正整数找到不小于指定容量的2的次幂，将这个数赋值给扩容阈值（threshold），当第一次put()方法时，会将阈值赋值给容量，并计算新的阈值&#x3D;容量x负载因子。</li>
<li>如果不是第一次扩容，则容量变为原容量的2倍，阈值也变为原来的2倍。</li>
</ol>
<p><strong>Java 7 和Java 8中HashMap的区别</strong><br>Java8中对HashMap进行了相关的调整，主要体现在以下几个方面：</p>
<ol>
<li>Java7中HashMap数据结构采用了数组+链表，而Java8中采用了数组+链表+红黑树，当链表长度大于8并且容量大于64时，会将链表转换成红黑树（注意，如果此时如果链表长度已经是8，但是数组长度并没有到64时会先进行扩容）。当红黑树节点个数小于等于6时会退化成链表。</li>
<li>Java7中链表使用的是头插法，但是使用头插法在多线程环境下有概率出现环形链表死循环的问题，在Java8中链表采用了尾插法以及使用了红黑树，避免了出现链表死循环的问题。</li>
</ol>
<h3 id="HashMap的遍历方式"><a href="#HashMap的遍历方式" class="headerlink" title="HashMap的遍历方式"></a>HashMap的遍历方式</h3><p>HashMap的遍历在开发中属于必备技能，HashMap的遍历方式有很多种，但是总的来说只有三种：</p>
<ol>
<li>获取keySet()后遍历keySet()获取到key然后通过key获取value</li>
<li>获取entrySet()后遍历entrySet()，相比于第一种写法稍显复杂，但是能更好的体现Map中的数据结构</li>
<li>使用Lambda表达式遍历，相比前两种是最简洁的方式，但是代码可读性略差在HashMap的遍历中，应该综合考虑性能、效率等因素做出合适的选择。下面通过实例学习HashMap的遍历。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本例将演示HashMap遍历的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MR.W</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForeachHashMap</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		map.put(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;计算机科学与技术&quot;</span>);</span><br><span class="line">		map.put(<span class="string">&quot;李四&quot;</span>, <span class="string">&quot;软件工程&quot;</span>);</span><br><span class="line">		map.put(<span class="string">&quot;王五&quot;</span>, <span class="string">&quot;网络工程&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//第一种：获取keySet()并遍历</span></span><br><span class="line">		Set&lt;String&gt; set = map.keySet();</span><br><span class="line">		<span class="comment">//获取迭代器</span></span><br><span class="line">		Iterator&lt;String&gt; it = set.iterator();</span><br><span class="line">		<span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> it.next();</span><br><span class="line">			<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">			System.out.println(key+<span class="string">&quot;===================&quot;</span>+value);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (; it.hasNext();) &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> it.next();</span><br><span class="line">			<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">			System.out.println(key+<span class="string">&quot;===================&quot;</span>+value);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (String key : set) &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">			System.out.println(key+<span class="string">&quot;===================&quot;</span>+value);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//第二种：获取Entry</span></span><br><span class="line">		Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">		<span class="comment">//使用迭代器</span></span><br><span class="line">		Iterator&lt;Map.Entry&lt;String, String&gt;&gt; entryIt = entrySet.iterator();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span> (entryIt.hasNext()) &#123;</span><br><span class="line">			Map.Entry&lt;String, String&gt; entry = entryIt.next();</span><br><span class="line">			<span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">			<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">			System.out.println(key+<span class="string">&quot;===================&quot;</span>+value);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (; entryIt.hasNext();) &#123;</span><br><span class="line">			Map.Entry&lt;String, String&gt; entry = entryIt.next();</span><br><span class="line">			<span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">			<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">			System.out.println(key+<span class="string">&quot;===================&quot;</span>+value);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (Entry&lt;String, String&gt; entry : entrySet) &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">			<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">			System.out.println(key+<span class="string">&quot;===================&quot;</span>+value);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//第三种：Lambda表达式</span></span><br><span class="line">		map.forEach((key,value)-&gt;System.out.println(key+<span class="string">&quot;===================&quot;</span>+value));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下图所示：</p>
<p><img src="https://files.catbox.moe/og1pmr.png"></p>
<h3 id="HashMap和Hashtable"><a href="#HashMap和Hashtable" class="headerlink" title="HashMap和Hashtable"></a>HashMap和Hashtable</h3><p>HashMap 和 Hashtable 都是 Map 接口的典型实现类，它们之间的关系完全类似于 ArrayList 和 Vector的关系∶ Hashtable 是一个古老的 Map 实现类，它从 JDK 1.0起就已经出现了，当它出现时，Java还没有提供Map 接口，所以它包含了两个烦琐的方法，即 elements() 类似于 Map接口定义的 values()方法）和 keys() 类似于 Map 接口定义的 keySet()方法。<br>除此之外，Hashtable 和 HashMap 存在三点典型区别。</p>
<ul>
<li>Hashtable 是一个线程安全的 Map接口实现，但 HashMap 是线程不安全的实现，所以 HashMap 比 Hashtable 的性能高一点;但如果有多个线程访问同一个 Map 对象时，使用 Hashtable 实现类会更好。</li>
<li>Hashtable 不允许使用 null 作为 key 和 value，如果试图把 null 值放进 Hashtable 中，将会引发 NullPointerException 异常; 但 HashMap 可以使用 null 作为 key 或 value。</li>
<li>HashMap数组初始长度为16，扩容后长度是原长度的2倍，Hashtable初始长度为11，扩容后的长度是原长度的2n+1</li>
</ul>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>HashMap也有一个LinkedHashMap子类;LinkedHashMap 也使用双向链表来维护 key-value 对的次序（其实只需要考虑 key 的次序），该链表负责维护 Map 的迭代顺序，迭代顺序与 key-value 对的插入顺序保持一致。 <br>LinkedHashMap 可以避免对 HashMap、Hashtable 里的 key-value 对进行排序（只要插入 key-value对时保持顺序即可），同时又可避免使用 TreeMap 所增加的成本（TreeMap的内容将会在下一小节学习）。 LinkedHashMap 需要维护元素的插入顺序，因此性能略低于 HashMap 的性能;但因为它以链表来维护内部顺序，所以在迭代访问 Map 里的全部元素时将有较好的性能，下面通过示例学习LinkedHashMap。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本例将演示LinkedHashMap</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MR.W</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashMapDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		LinkedHashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">		map.put(<span class="string">&quot;语文&quot;</span>, <span class="number">90</span>);</span><br><span class="line">		map.put(<span class="string">&quot;数学&quot;</span>, <span class="number">100</span>);</span><br><span class="line">		map.put(<span class="string">&quot;英文&quot;</span>, <span class="number">82</span>);</span><br><span class="line">		</span><br><span class="line">		Set&lt;String&gt; set = map.keySet();</span><br><span class="line">		<span class="keyword">for</span> (String key : set) &#123;</span><br><span class="line">			System.out.println(key+<span class="string">&quot;================&quot;</span>+map.get(key));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用Properties读写文件"><a href="#使用Properties读写文件" class="headerlink" title="使用Properties读写文件"></a>使用Properties读写文件</h2><p>Properties 类是 Hashtable 类的子类，该对象在处理属性文件时特别方便（Windows 操作平台上的 ini 文件就是一种属性文件）。Properties 类可以把 Map 对象和属性文件关联起来，从而可以把Map 对象中的 key-value 对写入属性文件中，也可以把属性文件中的”属性名&#x3D;属性值”加载到 Map 对象中。由于属性文件里的属性名、属性值只能是字符串类型，所以 Properties 里的 key、 value 都是字符串类型。该类提供了如下三个方法来修改 Properties 里的 key、value 值。</p>
<ul>
<li>String getProperty(String key)∶获取 Properties 中指定属性名对应的属性值，类似于 Map 的 get（Object key）方法。</li>
<li>String getProperty(String key，String defaultValue)∶该方法与前一个方法基本相似。该方法多一个功能，如果 Properties 中不存在指定的 key 时，则该方法指定默认值。</li>
<li>Object setProperty(String key， String value)∶设置属性值，类似于Hashtable 的 put() 方法。除此之外，它还提供了两个读写属性文件的方法。</li>
<li>void load(InputStream inStream)∶ 从属性文件（以输入流表示）中加载 key-value 对，把加载到的 key-value 对追加到 Properties 里（Properties 是 Hashtable 的子类，它不保证 key-value 对之间的次序）。</li>
<li>void store(OutputStream out， String comments)∶将 Properties 中的 key-value 对输出到指定的属性 文件（以输出流表示）中。 上面两个方法中使用了InputStream 类和 OutputStream 类，它们是 Java IO 体系中的两个基类，关于流的内容在后续章节讲解。下面通过示例先演示基本用法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本例将演示Properties类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MR.W</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException, IOException &#123;</span><br><span class="line">		<span class="comment">//--------------------读取数据--------------------------//</span></span><br><span class="line">		<span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">		properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;data.properties&quot;</span>)));</span><br><span class="line">		</span><br><span class="line">		<span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(username);</span><br><span class="line">		System.out.println(password);</span><br><span class="line">		<span class="comment">//--------------------写数据--------------------------//</span></span><br><span class="line">		<span class="type">Properties</span> <span class="variable">properties2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">		properties2.setProperty(<span class="string">&quot;token&quot;</span>, <span class="string">&quot;123431&quot;</span>);</span><br><span class="line">		properties2.store(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;data.properties&quot;</span>)), <span class="string">&quot;token&quot;</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的示例分别演示了Properties读写配置文件，在JDBC中将会使用配置文件配置数据库连接信息。</p>
<h2 id="SortedMap和TreeMap"><a href="#SortedMap和TreeMap" class="headerlink" title="SortedMap和TreeMap"></a>SortedMap和TreeMap</h2><p>Map 接口也派生出一个 SortedMap 子接口，SortedMap 接口也有一个 TreeMap 实现类。 TreeMap 就是一个红黑树数据结构，每个 key-value 对即作为红黑树的一个节点。TreeMap 存储 key-value 对（节点）时，需要根据 key 对节点进行排序。TreeMap 可以保证所有的 key-value 对处于有序状态。TreeMap 也有两种排序方式。</p>
<ul>
<li>自然排序∶TreeMap的所有key 必须实现 Comparable 接口，而且所有的 key 应该是同一个类的 对象，否则将会抛出 ClassCastException 异常。</li>
<li>定制排序∶ 创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有key进行排序。采用定制排序时不要求 Map 的 key 实现 Comparable 接口。 类似于 TreeSet 中判断两个元素相等的标准，TreeMap 中判断两个 key 相等的标准是∶ 两个 key 通过 compareTo()方法返回 0，TreeMap 即认为这两个 key 是相等的。</li>
</ul>
<p>如果使用自定义类作为 TreeMap 的 key，且想让 TreeMap 良好地工作，则重写该类的 equals()方法和 compareTo（方法时应保持一致的返回结果∶ 两个 key 通过 equals()方法比较返回 true 时，它们通过 compareTo()方法比较应该返回 0。如果 equals()方法与 compareTo()方法的返回结果不一致， TreeMap与 Map 接口的规则就会冲突。<br>TreeMap 中也提供了一系列根据 key 顺序访问 key-value 对的方法。</p>
<ul>
<li>Map.Entry firstEntry()∶ 返回该 Map 中最小 key 所对应的 key-value 对，如果该Map为空，则返回 null。</li>
<li>Object firstKey()∶返回该 Map 中的最小 key值，如果该 Map为空，则返回 null。</li>
<li>Map.Entry lastEntry()∶ 返回该 Map 中最大 key 所对应的 key-value 对，如果该 Map为空或不存 在这样的 key-value 对，则都返回 null。</li>
<li>Object lastKey()∶ 返回该 Map 中的最大 key 值，如果该 Map 为空或不存在这样的 key，则都返回nulI。</li>
<li>Map.Entry higherEntry(Object key)∶ 返回该 Map 中位于key 后一位的 key-value 对（即大于指定 key 的最小 key 所对应的 key-value 对）。如果该 Map 为空，则返回 null。</li>
<li>Object higherKey(Object key)∶返回该 Map 中位于key 后一位的 key 值（即大于指定 key 的最小 key 值）。如果该 Map 为空或不存在这样的 key-value 对，则都返回 null。</li>
<li>Map.Entry lowerEntry(Object key)∶ 返回该 Map 中位于key 前一位的 key-value 对（即小于指定 key 的最大 key 所对应的 key-value 对）。如果该 Map 为空或不存在这样的 key-value 对，则都返回 null。</li>
<li>Object lowerKey(Object key)∶返回该Map 中位于key前一位的 key 值（即小于指定 key 的最大 key 值）。如果该 Map 为空或不存在这样的 key，则都返回 null。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TreeMap&lt;Integer,String&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;Integer,String&gt;();</span><br><span class="line">        map.put(<span class="number">1</span>,<span class="string">&quot;刘能&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>,<span class="string">&quot;谢广坤&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>,<span class="string">&quot;赵四&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>,<span class="string">&quot;王大拿&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>,<span class="string">&quot;宋晓峰&quot;</span>);</span><br><span class="line">        <span class="comment">//返回该 Map 中最小 key 所对应的 key-value 对，如果该Map为空，则返回 null。</span></span><br><span class="line">        System.out.println(map.firstEntry());</span><br><span class="line">        <span class="comment">//返回该 Map 中的最小 key值，如果该 Map为空，则返回 null。&gt; Map.Entry lastEntry（）∶ 返回该 Map 中最大 key 所对应的 key-value 对，如果该 Map为空或不存在这样的 key-value 对，则都返回 null。</span></span><br><span class="line">        System.out.println(map.firstKey());</span><br><span class="line">        <span class="comment">//返回该 Map 中的最大 key 值，如果该 Map 为空或不存在这样的 key，则都返回nulI。</span></span><br><span class="line">        System.out.println(map.lastKey());</span><br><span class="line">        <span class="comment">//返回该 Map 中位于key 后一位的 key 值（即大于指定 key 的最小key 值）。如果该 Map 为空或不存在这样的 key-value 对，则都返回 nul 。</span></span><br><span class="line">        System.out.println(map.higherKey(<span class="number">3</span>));</span><br><span class="line">        <span class="comment">//返回该 Map 中位于key 后一位的 key-value 对（即大于指定key 的最小 key 所对应的 key-value 对）。如果该 Map 为空，则返回 null。</span></span><br><span class="line">        System.out.println(map.higherEntry(<span class="number">3</span>));</span><br><span class="line">        <span class="comment">//返回该Map 中位于key前一位的 key 值（即小于指定 key 的最大key 值）。如果该 Map 为空或不存在这样的 key，则都返回 null。</span></span><br><span class="line">        System.out.println(map.lowerKey(<span class="number">2</span>));</span><br><span class="line">        <span class="comment">//返回该 Map 中位于key 前一位的 key-value 对（即小于指定key 的最大 key 所对应的 key-value 对）。如果该 Map 为空或不存在这样的 key-value 对，则都返回 null。</span></span><br><span class="line">        System.out.println(map.lowerEntry(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="各Map性能分析"><a href="#各Map性能分析" class="headerlink" title="各Map性能分析"></a>各Map性能分析</h2><p>对于 Map 的常用实现类而言，虽然 HashMap 和 Hashtable 的实现机制几乎一样，但由于Hashtable是一个古老的、线程安全的集合，因此 HashMap 通常比 Hashtable 要快。<br> TreeMap 通常比 HashMap、Hashtable 要慢（尤其在插入、删除 key-value 对时更慢），因为 TreeMap底层采用红黑树来管理 key-value 对（红黑树的每个节点就是一个 key-value 对）。 使用 TreeMap 有一个好处∶ TreeMap 中的 key-value 对总是处于有序状态，无须专门进行排序操作。当 TreeMap 被填充之后，就可以调用 keySet() ，取得由key 组成的 Set，然后使用 toArray()方法生成 key的数组，接下来使用 Arrays 的 binarySearch() 方法在已排序的数组中快速地查询对象。<br> 对于一般的应用场景，程序应该多考虑使用 HashMap，因为 HashMap 正是为快速查询设计的（HashMap 底层其实也是采用数组来存储 key-value 对）。但如果程序需要一个总是排好序的 Map 时，则可以考虑使用TreeMap。 LinkedHashMap 比 HashMap 慢一点，因为它需要维护链表来保持 Map中 key-value 时的添加顺序。</p>
]]></content>
  </entry>
  <entry>
    <title>Java常见排序算法</title>
    <url>/2022/08/03/Java%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<p><img src="https://files.catbox.moe/6jqfd2.gif"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] a = &#123;<span class="number">6</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; a.length-i-<span class="number">1</span>; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>]) &#123;</span><br><span class="line">					<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span>a[j];</span><br><span class="line">					a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">					a[j+<span class="number">1</span>] =temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(Arrays.toString(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><ol>
<li>在长度为N的无序数组中，第一次遍历n-1个数，找到最小的数与第一个元素交换</li>
<li>第二次遍历n-2个数，找到最小的数值与第二个元素交换</li>
<li>重复以上步骤</li>
<li>第n-1词遍历，找到最小的数值与第n-1的元素交换，排序完成<img src="https://files.catbox.moe/6jqfd2.gif"></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] a = &#123;<span class="number">8</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">17</span>,<span class="number">23</span>,<span class="number">85</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="comment">//定义此轮循环最小数放置的位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">//从第2个数依次和后面的数进行对比</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">                <span class="comment">//如果minIndex的数比j大则记录j</span></span><br><span class="line">				<span class="keyword">if</span>(a[minIndex]&gt;a[j]) &#123;</span><br><span class="line">					minIndex=j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="keyword">if</span>(minIndex!=i)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[minIndex];</span><br><span class="line">                a[minIndex] = a[i];</span><br><span class="line">                a[i] = temp;</span><br><span class="line">                System.out.println(<span class="string">&quot;每次结果&gt;&gt;&gt;&quot;</span>+Arrays.toString(a));</span><br><span class="line">            &#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;每轮结果===&quot;</span>+Arrays.toString(a));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><ol>
<li>在要排序的无序数组中，假定n-1个数已经排好序，现在将第n个数插入到前面的有序数列中，使得这个n个数也是拍好序的，反复循环，直到全部排好顺序。插入排序也可以理解为从第二个数开始，前面的相邻的数依次两两对比，如果后面的数比前面的数小，则交换位置。（如果实在理解不了，可以类比冒泡排序，把插入排序理解为一种特殊的冒泡排序）</li>
</ol>
<p><img src="https://files.catbox.moe/hzemg8.gif"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] a = &#123;<span class="number">87</span>,<span class="number">86</span>,<span class="number">82</span>,<span class="number">10</span>,<span class="number">30</span>&#125;;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &gt;<span class="number">0</span>; j--) &#123;</span><br><span class="line">				<span class="keyword">if</span>(a[j]&lt;a[j-<span class="number">1</span>]) &#123;</span><br><span class="line">					<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[j];</span><br><span class="line">					a[j] = a[j-<span class="number">1</span>];</span><br><span class="line">					a[j-<span class="number">1</span>] = temp;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                	<span class="keyword">break</span>;   </span><br><span class="line">                &#125;</span><br><span class="line">				System.out.println(<span class="string">&quot;每次结果===&quot;</span>+Arrays.toString(a));</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;轮结果&gt;&gt;&gt;&quot;</span>+Arrays.toString(a));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序有两种实现方式：双边循环法和挖坑法，思路如下：<br><strong>快速排序</strong></p>
<ol>
<li>定义左右指针，并选取一个数作为基准（通常选择数组第一个）</li>
<li>移动右指针，如果右指针的数小于基准数，则停止移动，反之则继续移动</li>
<li>移动左指针，如果左指针的数大于基准数，则停止移动，反之则继续移动</li>
<li>当左右指针都停止移动时交换左右指针处的数</li>
<li>当左右两个指针停在相同位置时，交换指针处的数和基准数的位置</li>
<li>将数组以左右指针位置处一分为二重复上述步骤。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 双边循环</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">pivotIndex</span><span class="params">(<span class="type">int</span>[]ary,<span class="type">int</span> startIndex,<span class="type">int</span> endIndex)</span> &#123;</span><br><span class="line">		<span class="comment">//保存左右两个指针，从第一个元素和最后一个元素开始</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> startIndex;</span><br><span class="line">		<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> endIndex;</span><br><span class="line">		<span class="comment">//获取基准，一般选择数组第一个数</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> ary[startIndex];</span><br><span class="line">		<span class="comment">//大循环，当左右两个指针不相等时，左指针右移，右指针左移</span></span><br><span class="line">		<span class="keyword">while</span> (left!=right) &#123;</span><br><span class="line">			<span class="comment">//右边指针向左移动，当对应元素大于基准数时继续移动，小于基准数时停止移动</span></span><br><span class="line">			<span class="keyword">while</span>(right&gt;left&amp;&amp;ary[right]&gt;=pivot) &#123;</span><br><span class="line">				right--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//左边指针向右移动，当小于基准数时继续移动，大于基准数时停止移动</span></span><br><span class="line">			<span class="keyword">while</span> (right&gt;left&amp;&amp;ary[left]&lt;=pivot) &#123;</span><br><span class="line">				left++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//此时如果左边指针小于右边指针时；左右指针交换元素</span></span><br><span class="line">			<span class="keyword">if</span>(left&lt;right) &#123;</span><br><span class="line">				<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> ary[right];</span><br><span class="line">				ary[right] = ary[left];</span><br><span class="line">				ary[left] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> left;</span><br><span class="line">		<span class="comment">//如果两个指针相等时,交换基准元素和当前位置的数</span></span><br><span class="line">		ary[startIndex] = ary[index];</span><br><span class="line">		ary[index] = pivot;</span><br><span class="line">		<span class="keyword">return</span> index;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">qucikSort</span><span class="params">(<span class="type">int</span>[] ary,<span class="type">int</span> startIndex,<span class="type">int</span> endIndex)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(startIndex&gt;endIndex) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> pivotIndex(ary,startIndex,endIndex);</span><br><span class="line">		qucikSort(ary, startIndex, index-<span class="number">1</span>);</span><br><span class="line">		qucikSort(ary, index+<span class="number">1</span>, endIndex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] a= &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">3</span>&#125;;</span><br><span class="line">		qucikSort(a, <span class="number">0</span>, a.length-<span class="number">1</span>);</span><br><span class="line">		System.out.println(Arrays.toString(a));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>挖坑法</strong></p>
<ol>
<li>选取起始位置作为标记位（也就是坑），选取一个数作为基准，通常是数组第一个</li>
<li>从数组第二数开始依次和基准数对比，如果比基准数小，则扩大小于基准数的区间，也就是mark++，并将该数与标mark处的数交换</li>
<li>循环结束后，将mark处的数和基准数进行交换</li>
<li>以mark为界，将数组一分为二重复上述步骤</li>
</ol>
<p><img src="https://files.catbox.moe/dcwsxe.gif"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单边循环</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MR.W</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QucikSort2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">pivotIndex</span><span class="params">(<span class="type">int</span>[] ary,<span class="type">int</span> startIndex,<span class="type">int</span> endIndex)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">mark</span> <span class="operator">=</span> startIndex;</span><br><span class="line">		<span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> ary[startIndex];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex+<span class="number">1</span>; i &lt;= endIndex; i++) &#123;</span><br><span class="line">			<span class="comment">//如果指针指向的元素小于基准元素，干两件事情</span></span><br><span class="line">			<span class="comment">//1.mark+1,扩大小于基准数的区间</span></span><br><span class="line">			<span class="comment">//2.将指针所指向的数和mark位置处的数进行交换</span></span><br><span class="line">			<span class="keyword">if</span>(ary[i]&lt;pivot) &#123;</span><br><span class="line">				mark++;</span><br><span class="line">				<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> ary[i];</span><br><span class="line">				ary[i] = ary[mark];</span><br><span class="line">				ary[mark] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//当循环结束时将mark位置的数和基准数进行交换</span></span><br><span class="line">		ary[startIndex]= ary[mark]; </span><br><span class="line">		ary[mark] = pivot;</span><br><span class="line">		<span class="keyword">return</span> mark;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] ary,<span class="type">int</span> startIndex,<span class="type">int</span> endIndex)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(startIndex&gt;endIndex) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> pivotIndex(ary, startIndex, endIndex);</span><br><span class="line">		quickSort(ary, startIndex, index-<span class="number">1</span>);</span><br><span class="line">		quickSort(ary, index+<span class="number">1</span>, endIndex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span> [] a = &#123;<span class="number">7</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">8</span>&#125;;</span><br><span class="line">		quickSort(a, <span class="number">0</span>, a.length-<span class="number">1</span>);</span><br><span class="line">		System.out.println(Arrays.toString(a));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> [] a = &#123;<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; a.length-<span class="number">1</span>; j++) &#123;</span><br><span class="line">				<span class="type">int</span> temp;</span><br><span class="line">				<span class="keyword">if</span>(a[i]&lt;a[j]) &#123;</span><br><span class="line">					temp = a[j];</span><br><span class="line">					a[j] = a[i];</span><br><span class="line">					a[i] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(<span class="string">&quot;每次&quot;</span>+Arrays.toString(a));</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;每轮&quot;</span>+Arrays.toString(a));</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;最后&quot;</span>+Arrays.toString(a));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
<p><img src="https://files.catbox.moe/yk7q42.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> &#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] shellSort(<span class="type">int</span> ary[],<span class="type">int</span> length)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> length;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            gap = gap/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//根据增量将数组分为若干子序列</span></span><br><span class="line">            <span class="comment">//K表示第几个子序列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;k&lt;gap;k++)&#123;</span><br><span class="line">                <span class="comment">//对子序列插入排序</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k+gap;i&lt;length;i+=gap)&#123;</span><br><span class="line">                    <span class="comment">//因为是相隔gap的元素插入排序，所以j-=jap</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=i;j&gt;k;j-=gap)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(ary[j]&lt;ary[j-gap])&#123;</span><br><span class="line">                             temp = ary[j-gap];</span><br><span class="line">                             ary[j-gap] = ary[j];</span><br><span class="line">                             ary[j] = temp;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(<span class="string">&quot;每次结果：&gt;&gt;&gt;&quot;</span>+Arrays.toString(ary)); </span><br><span class="line">                    &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;每轮结果：---&quot;</span>+Arrays.toString(ary));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(gap==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ary = &#123;<span class="number">3</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(shellSort(ary, ary.length)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>基数排序的思路非常简单，首先创建数组，然后将每个数放到相应的位置（例如6放在下标为6的数组位置）；最后遍历数组，即为排序后的结果。</p>
<ol>
<li><p>基数排序先排好个位，然后排好在排好个位的基础上排十位，以此类推，直到遍历最高位次，排序结束。</p>
</li>
<li><p>基数排序不是比较排序，而是通过分配和收集的过程来实现排序。</p>
</li>
<li><p>初始化10个桶，桶下标为0-9</p>
</li>
<li><p>通过得到待排序数字的个十百等位的数字，把这个数字对应的item放到对应的桶中</p>
</li>
<li><p>基数排序有两种排序方式：LSD和MSD，最小位有限（从右边开始）和最大位优先（从左边开始）。</p>
<p>​</p>
</li>
</ol>
<p><img src="https://files.catbox.moe/1woylv.gif"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RadixSort</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> d)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">1</span>;<span class="comment">//代表位数对应的数：1,10,100...</span></span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>;<span class="comment">//保存每一位排序后的结果用于下一位的排序输入</span></span><br><span class="line">    <span class="type">int</span> length=array.length;</span><br><span class="line">    <span class="type">int</span>[][] bucket=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][length];<span class="comment">//排序桶用于保存每次排序后的结果，这一位上排序结果相同的数字放在同一个桶里</span></span><br><span class="line">    <span class="type">int</span>[] order=<span class="keyword">new</span> <span class="title class_">int</span>[length];<span class="comment">//用于保存每个桶里有多少个数字</span></span><br><span class="line">    <span class="keyword">while</span>(n&lt;d)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:array) <span class="comment">//将数组array里的每个数字放在相应的桶里</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> digit=(num/n)%<span class="number">10</span>;</span><br><span class="line">            bucket[digit][order[digit]]=num;</span><br><span class="line">            order[digit]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)<span class="comment">//将前一个循环生成的桶里的数据覆盖到原数组中用于保存这一位的排序结果</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(order[i]!=<span class="number">0</span>)<span class="comment">//这个桶里有数据，从上到下遍历这个桶并将数据保存到原数组中</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;order[i];j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    array[k]=bucket[i][j];</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            order[i]=<span class="number">0</span>;<span class="comment">//将桶里计数器置0，用于下一次位排序</span></span><br><span class="line">        &#125;</span><br><span class="line">        n*=<span class="number">10</span>;</span><br><span class="line">        k=<span class="number">0</span>;<span class="comment">//将k置0，用于下一轮保存位排序结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序（MERGE-SORT）是利用<strong>归并</strong>的思想实现的排序方法，该算法采用经典的<strong>分治</strong>（divide-and-conquer）策略（分治法将问题<strong>分</strong>(divide)成一些小的问题然后递归求解，而**治(conquer)**的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。</p>
<ol>
<li>把长度为n的数组分成两个长度为n&#x2F;2的子序列</li>
<li>对这两个子数组分别采用归并排序</li>
<li>将两个排序号的子数组合并成一个最终的排序数组</li>
</ol>
<p>首先考虑下如何将2个有序数列合并。这个非常简单，只要从比较2个数列的第一个数，谁小就先取谁。</p>
<p><img src="https://files.catbox.moe/nczkjt.png"></p>
<p><img src="https://files.catbox.moe/ufmir0.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> ary[])</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[ary.length];</span><br><span class="line">        sort(ary,<span class="number">0</span>,ary.length-<span class="number">1</span>,temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] ary,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span>[] temp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//左侧子数组归并排序</span></span><br><span class="line">            sort(ary,left,mid,temp);</span><br><span class="line">            <span class="comment">//右侧子数组归并排序</span></span><br><span class="line">            sort(ary,mid+<span class="number">1</span>,right,temp);</span><br><span class="line">            <span class="comment">//合并子数组</span></span><br><span class="line">            merge(ary, left, mid, right, temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] ary,<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right,<span class="type">int</span>[]temp)</span>&#123;</span><br><span class="line">        <span class="comment">//左指针序列</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="comment">//右指针序列</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//临时指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ary[i]&lt;=ary[j])&#123;</span><br><span class="line">                temp[t++]=ary[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp[t++]=ary[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将左边剩余的元素填充进temp中</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">            temp[t++]=ary[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将右边剩余元素填充进temp中</span></span><br><span class="line">        <span class="keyword">while</span>(j&lt;=right)&#123;</span><br><span class="line">            temp[t++] = ary[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将temp中的元素全部拷贝到原数组</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            ary[left++] = temp[t++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> []arr = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>堆排序是利用<strong>堆</strong>这种数据结构而设计的一种排序算法，堆排序是一种<strong>选择排序，</strong>它的最坏，最好，平均时间复杂度均为O(nlogn)<br><strong>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：</strong></p>
<p><img src="https://files.catbox.moe/7ktiss.png"></p>
<p>该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：<br>**大顶堆：arr[i] &gt;&#x3D; arr[2i+1] &amp;&amp; arr[i] &gt;&#x3D; arr[2i+2] **<br>**小顶堆：arr[i] &lt;&#x3D; arr[2i+1] &amp;&amp; arr[i] &lt;&#x3D; arr[2i+2] **<br><strong>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> <span class="keyword">implements</span> <span class="title class_">IArraySort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] sourceArray) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对 arr 进行拷贝，不改变参数内容</span></span><br><span class="line">        <span class="type">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line"></span><br><span class="line">        buildMaxHeap(arr, len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            swap(arr, <span class="number">0</span>, i);</span><br><span class="line">            len--;</span><br><span class="line">            heapify(arr, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>) Math.floor(len / <span class="number">2</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            heapify(arr, i, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(arr, i, largest);</span><br><span class="line">            heapify(arr, largest, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<ol>
<li>计数排序的特征<br>  当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。<br>  由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。<br>  通俗地理解，例如有 10 个年龄不同的人，统计出有 8 个人的年龄比 A 小，那 A 的年龄就排在第 9 位,用这个方法可以得到其他每个人的位置,也就排好了序。当然，年龄有重复时需要特殊处理（保证稳定性），这就是为什么最后要反向填充目标数组，以及将每个数字的统计减去 1 的原因。<br>  算法的步骤如下：</li>
</ol>
<p>  <img src="https://files.catbox.moe/iqrgu4.gif"></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountingSort</span> <span class="keyword">implements</span> <span class="title class_">IArraySort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] sourceArray) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对 arr 进行拷贝，不改变参数内容</span></span><br><span class="line">        <span class="type">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> getMaxValue(arr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> countingSort(arr, maxValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] countingSort(<span class="type">int</span>[] arr, <span class="type">int</span> maxValue) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bucketLen</span> <span class="operator">=</span> maxValue + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[bucketLen];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            bucket[value]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sortedIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; bucketLen; j++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (bucket[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                arr[sortedIndex++] = j;</span><br><span class="line">                bucket[j]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMaxValue</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxValue &lt; value) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p>
<ol>
<li>在额外空间充足的情况下，尽量增大桶的数量</li>
<li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li>
</ol>
<p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。<br>元素分配在桶中：</p>
<p><img src="https://files.catbox.moe/paqbk0.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BucketSort</span> <span class="keyword">implements</span> <span class="title class_">IArraySort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">InsertSort</span> <span class="variable">insertSort</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InsertSort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] sourceArray) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对 arr 进行拷贝，不改变参数内容</span></span><br><span class="line">        <span class="type">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bucketSort(arr, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] bucketSort(<span class="type">int</span>[] arr, <span class="type">int</span> bucketSize) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">minValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; minValue) &#123;</span><br><span class="line">                minValue = value;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; maxValue) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">bucketCount</span> <span class="operator">=</span> (<span class="type">int</span>) Math.floor((maxValue - minValue) / bucketSize) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[][] buckets = <span class="keyword">new</span> <span class="title class_">int</span>[bucketCount][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用映射函数将数据分配到各个桶中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (<span class="type">int</span>) Math.floor((arr[i] - minValue) / bucketSize);</span><br><span class="line">            buckets[index] = arrAppend(buckets[index], arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">arrIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] bucket : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对每个桶进行排序，这里使用了插入排序</span></span><br><span class="line">            bucket = insertSort.sort(bucket);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> value : bucket) &#123;</span><br><span class="line">                arr[arrIndex++] = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动扩容，并保存数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arrAppend(<span class="type">int</span>[] arr, <span class="type">int</span> value) &#123;</span><br><span class="line">        arr = Arrays.copyOf(arr, arr.length + <span class="number">1</span>);</span><br><span class="line">        arr[arr.length - <span class="number">1</span>] = value;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="常见排序的复杂度"><a href="#常见排序的复杂度" class="headerlink" title="常见排序的复杂度"></a>常见排序的复杂度</h1><p><img src="https://files.catbox.moe/o07v4f.png"></p>
]]></content>
  </entry>
  <entry>
    <title>Java发展简史</title>
    <url>/2022/08/03/Java%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<p><strong>1991年4月，</strong>由James Gosling博士领导的绿色计划（Green Project)开始启动，此计划的目的是开发一种能够在各种消费型电子产品（如机顶盒、冰箱、收音机等）上运行的程序架构。这个计划的产品就是Java语言的前身——Oak，Oak当时在消费品市场上并不算成功，但随着1995年互联网潮流的兴起， Oak迅速找到了最适合自己发展的市场定位并蜕变成为 Java语言。<br><strong>1992 年3月，</strong>由于Oak已被用作另一种已存在的编程语言名称，因此必须选一个新的名字——Java。 Java 的灵感来源于咖啡，据说James Gosling 研发小组的工程师经常喝的咖啡就产自印度尼西亚的爪哇岛(Java）上所种植的咖啡豆。<br><strong>1993年2月,</strong> Sun Microsystems的子公司 FirstPerson试图从时代华纳获得一个电视机顶盒交互系统的一系列订单。在那时，由于绿色计划不是很成功，随即失去了时代华纳的订单，于是开发的重心从家庭消费电子产品转移到了电视机顶盒的相关平台上。<br><strong>1995年5月23日,</strong> Oak语言更名为Java,并且在 Sun World大会上正式发布Java 1.0版本。Java 语言第一次提出了“Write Once, Run Anywhere”的口号。<br><strong>1996年1月23日，</strong>JDK 1.0发布，Java语言有了第一个正式版本的运行环境，JDK 1.0提供了一个解释执行的Java 虚拟机实现(Sun Classic VM) 。JDK1.0版本的代表技术包括 Java虚拟机、Applet 以及 AWT等。<br><strong>1996年4月，10个最主要的操作系统供应商申明，将在其产品中嵌入Java 技术。同年9月，已有大约8.3万个网页应用了 Java技术来制作。在1996年5月底</strong>，Sun 公司于美国旧金山举行了首届JavaOne大会，从此JavaOne成为全世界数百万Java语言开发者每年一度的技术盛会。<br><strong>1997年2月19日，</strong> Sun公司发布了JDK 1.1, Java 技术的一些最基础的支撑点9（如 JDBC等）都是在JDK1.1版本中发布的 JDK 1.1版的技术代表有JAR文件格式、JDBC、 JavaBeans 和 RMI. Java语法也有了一定的发展，如内部类(Inner Class)和反射（Reflection)都是在这个时候出现的。</p>
<blockquote>
<p>从1.1.47后，每个JDK版本都有一个自己的名字(工程代号)，分别为JDK 1.1.4 - Sparkler （宝石）JDK1.1:5- Pumpkin（南瓜) JDK1.1.6- Abigail(阿比盖尔，女子名)、JDK1.1.7- Brutus(布鲁图，古罗马政治家和将军)和JDK1.1.8- Chelsea(切尔西，城市名)。</p>
</blockquote>
<p><strong>1998年12月4日，</strong>JDK迎来了一个里程碑式的版本JDK1.2, 工程代号为Playground(竞技场)Sun公司在这个版本中把Java 技术体系拆分为3个方向，分别是面向桌面应用开发的J2SE (Java 2 Platform, StandardEdition）、面向企业级开发的J2EE (Java 2 Platform, Enterprise Edition)和面向手机等移动终端开发的J2ME (Java 2 Platform, Micro Edition）。在这个版本中出现的代表性技术非常多，如EJB、Java Plug-in、Java IDL 以及 Swing等，并且这个版本中Java 虚拟机第一次内置了 JIT (Just In Time)编译器（JDK 1.2中曾并存过3个虚拟机， Classic VMs HotSpot VM 和 Exact VM， 其中 Exact VM 只在 Solaris平台出现过:后面两个虚拟机都是内置JIT编译器的，而之前版本所带的 Classic VM只能以外挂的形式使用JIT编译器)。在语言和API级别上，Java 添加了 strictfp关键字与现在 Java编码之中极为常用的一系列 Collections集合类。在1999年3月和7月，分别有JDK 1.2.1和JDK1.2.2两个小版本发布。<br><strong>1999年4月27日,</strong> HotSpot 虚拟机发布。HotSpot 最初由一家名为“Longview Technologies”的小公司开发，因为 HotSpot 的优异表现，这家公司在1997年被Sun公司收购了。HotSpot 虚拟机发布时是作为JDK 1.2的附加程序提供的，后来它成为了JDK1.3及之后所有版本的Sun JDK 的默认虚拟机。<br><strong>2000年5月8日，</strong>工程代号为 Kestrel(美洲红)的JDK 1.3发布，JDK 1.3相对于JDK 1.2的改进主要表现在一些类库上(如数学运算和新的 Timer API等)，JNDI服务从JDK 1.3开始被作为一项平台级服务提供(以前JNDI仅仅是一项扩展)，使用CORBA IIOP来实现RMI的通信协议等。这个版本还对 Java 2D做了很多改进，提供了大量新的 Java 2D API，并且新添加了 JavaSound类库。JDK 1.3有一个修正版本JDK 1.3.1,工程代号为 Ladybird（瓢虫)，于2001年5月17日发布。<br>从MJDK1.3开始, Sun 公司维持了一个习惯:大约每隔两年发布一个JDK的主版本，以动物名作为工程代号，期间发布的各个修正版本则以昆虫名作为工程代号。<br><strong>2002年2月13日，</strong> JDK1.4发布，工程代号为Merlin （灰背)。<br><strong>2002年9月16日，</strong>发布了工程代号为Grasshopper （蚱蜢)的JDK 1.4.1。</p>
<blockquote>
<p>JDK1.4是Java真正走向成熟的一个版本,Compaq、 Fujitsu、 SAS、 Symbian 以及IBM等著名公司都有参与甚至实现自己独立的JDK 1.4。哪怕是在十多年后的今天，仍然有许多主流应用（Spring、 Hibernate 以及 Struts等)能直接运行在JDK 1.4之上，或者继续发布能运行在JDK 1.4上的版本。</p>
</blockquote>
<p><strong>2003年6月26日，</strong>发布了工程代号为Mantis（螳螂)的JDK1.4.2。<br><strong>2004年9月30 日，</strong>JDK1.5发布，工程代号 Tiger（老虎)。从JDK 1.2发布以来，Java在语法层面上的变换一直很小，而JDK1.5在 Java语法易用性上做出了非常大的改进。例如，自动装箱、泛型、动态注解、枚举、可变长参数以及遍历循环(foreach 循环)等语法特性都是在JDK 1.5中加入的。在虚拟机和API层面上，这个版本改进了 Java的内存模型(Java Memory Model, JMM)，提供了 java.util.concurrent 并发包等。另外,JDK 1.5是官方声明可以支持Windows 9x平台的最后一个JDK版本。<br><strong>2006年12月11日，</strong>JDK1.6发布，工程代号 Mustang（野马)。在这个版本中，Sun公司终结了从JDK 1.2开始已经有8年历史的J2EE、J2SE 和 J2ME的命名方式，启用Java SE 6、 Java EE 6和Java ME 6的命名方式。JDK 1.6的改进包括提供动态语言支持(通过内置 Mozilla Java Rhino引擎实现)、提供编译API 和微型HTTP服务器API等。同时，这个版本对Java 虚拟机内部做了大量改进，包括锁与同步、垃收集以及类加载等方面的算法都有相当多的改动。<br>在 <strong>2006年11月13日</strong>的 JavaOne大会上,Sun 公司宣布最终会将Java开源，并在随后的一年多时间内，陆续将JDK的各个部分在GPL v2 (GNU General Public License v2)协议下公开了源码，并建立了OpenJDK组织对这些源码进行独立管理。除了极少量的产权代码外（Encumbered Code，这部分代码大多是Sun公司本身也无权限进行开源处理的），OpenJDK几乎包括了Sun JDK的全部代码外，OpenJDK的质量主管曾经表示，在JDK 1.7中，Sun JDK 和 OpenJDK 除了代码文件头的版权注释之外，代码基本上完全一样，所以OpenJDK7与Sun JDK 1.7本质上就是同套代码库开发的产品。<br>JDK1.6发布以后，由于代码复杂性的增加、JDK开源、开发 JavaFX、经济危机及Sun 公司收购案等原因，SUN公司在JDK发展以外的事情上耗费了很多资源，JDK的更新没有再维持两年发布一个主版本的发展速度。JDK1.6到目前为止一共发布了37个 Update版本，最新的版本为 Java SE 6 Update 37, 于2012年10月16日发布，2009年2月19日，工程代号为Dophin (海豚)的JDK 1.7完成了其第一个里程碑版本。 根据 JDK 1.7 的功能规划，一共设置了 10个里程碑。最后一个里程碑版本原计划于2010年9月9日结束，但由于各种原因JDK1.7最终无法按计划完成。<br>MJDK1.7最开始的功能规划来看，它本应是一个包含许多重要改进的JDK版本，其中的 Lambda 项目 (Lambda表达式、函数式编程)、Jigsaw项目(虚拟机模块化支持)、动态语言支持、GarbageFirst 收集器和 Coin项目(语言细节进化)等子项目对于 Java业界都会产生深远的影响。在JDK1.7开发期间， Sun 公司由于相继在技术竞争和商业竞争中都陷入泥潭，公司的股票市值跌至仅有高峰时期的3%， 已无力推动 JDK1.7的研发工作按正常计划进行。为了尽快结束JDK 1.7长期“跳票”的问题，Oracle公司收购Sun 公司后不久便宣布将实行“B计划”。<br>大幅裁剪了JDK 1.7 预定目标，以便保证JDK 1.7的正式版能够于2011年7月28日准时发布。“B计划”把不能按时完成的 Lambda 项目、Jigsaw项目和Coin项目的部分改进延迟到 JDK 1.8之中。最终，JDK 1.7的主要改进包括提供新的G1收集器(G1 在发布时依然处于 Experimental状态，直至2012年4月的 Update 4 中才正式“转正”)、加强对非 Java语言的调用支持(JSR-292，这项特性到目前为止依然没有完全实现定型）以级类加载架构等。<br>到目前为止, JDK 1.7已经发布了9个 Update版本，最新的 Java SE 7 Update 9于 2012年 10月16日发布。<br>从 Java SE 7 Update 4起, Oracle开始支持Mac OSX操作系统，并在 Update6中达到完全支持的程度，同时在 Update 6中还对ARM指令集架构提供了支持。至此，官方提供的JDK可以运行于 Windows（不含Windows9x） 、 Linux,、Solaris和 Mac OS 平台上，支持ARM、 x86、x64 和 Sparc指令集架构类型。<br>由于此前 Oracle 公司已经收购了另外一家大型的中间件企业BEA公司，在完成对 Sun 公司的收购之后, Oracle  公司分别从BEA公司和Sun 公司中取得了目前三大商业虚拟机的其中两个—JRockit和 HotSpot, Oracle公司宣布在未来1~2年的时间内，将把这两个优秀的虚拟机互相取长补短，最终合二为一。由此可以预见在不久的将来, Java 虚拟机技术将会产生相当巨大的变化。<br><strong>2011年7月28日,</strong> Oracle 公司发布 Java SE 1.7。<br><strong>2014年3月18日,</strong> Oracle 公司发布 Java SE 1.8。<br><strong>2017年9月22日,</strong> Java SE 1.9正式发布。Java 9提供了一个全新的模块系统，它的核心变化就是引入了一种新的 Java编程组件，也就是模块化。Java 9提供了轻量级JSON API;使用G1作为默认的垃圾收集器，替代了之前默认使用的 Paralel GC; 引入了 jshel这个交互性工具，jshel 为Java带来了读入一一求值一一打印一一循环的功能。它的目的在于以即时结果和反馈的形式，简化原型的实现并帮助我们探索语言在编码时的可选项;对os process拥有更好的控制和管理方式； 全面支持Http 2.0，以所谓的孵化器模块交付，并且为Java配备一个全新的 Http客户端来替代 HttpURLConnection，同时还实现 Http 2.0 和 websockets。</p>
]]></content>
  </entry>
  <entry>
    <title>Java集合框架--Set</title>
    <url>/2022/08/03/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-Set/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h1 id="Java集合框架–Set"><a href="#Java集合框架–Set" class="headerlink" title="Java集合框架–Set"></a>Java集合框架–Set</h1><h2 id="Set概述"><a href="#Set概述" class="headerlink" title="Set概述"></a>Set概述</h2><p>Set也是集合中的一个容器，类似于一个罐子，程序可以依次把若干个对象放进Set，但是Set无法保存元素添加的顺序，Set不允许包含相同的元素，如果把两个相同的元素加入同一个Set中，则添加失败，add()方法会返回false，并且新元素不会被添加。Set接口主要有两个实现类HashSet、TreeSet。</p>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时就是使用这个实现类。HashSet 按 Hash算法来存储集合中的元素，因此具有很好的存取和查找性能。 HashSet 具有以下特点。</p>
<ul>
<li>不能保证元素的排列顺序，顺序可能与添加顺序不同，顺序也有可能发生变化。</li>
<li>HashSet 不是同步的，如果多个线程同时访问一个 HashSet，假设有两个或者两个以上线程同时 修改了HashSet集合时，则必须通过代码来保证其同步。</li>
<li>集合元素值可以是 null。 当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode()方法来得到该对象的 hashCode 值，然后根据该hashCode 值决定该对象在 HashSet 中的存储位置。如果有两个元素通过equals()方法比较返回 true，但它们的 hashCode()方法返回值不相等，HashSet 将会把它们存储在不同的位置，依然可以添加成功。</li>
<li>也就是说，HashSet 集合判断两个元素相等的标准是两个对象通过 equals()方法比较相等，并且两个对象的 hashCode()方法返回值也相等。</li>
</ul>
<h3 id="HashSet常用API"><a href="#HashSet常用API" class="headerlink" title="HashSet常用API"></a>HashSet常用API</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>add(Object o)</td>
<td>添加元素</td>
</tr>
<tr>
<td>remove(Object o)</td>
<td>移除元素</td>
</tr>
<tr>
<td>isEmpty()</td>
<td>判断元素是否为空</td>
</tr>
<tr>
<td>size()</td>
<td>获取set中元素个数</td>
</tr>
</tbody></table>
<p>下面通过示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">		<span class="comment">//添加元素</span></span><br><span class="line">		set.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">		<span class="comment">//移除元素</span></span><br><span class="line">		set.remove(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">		<span class="comment">//此时set中没有元素</span></span><br><span class="line">		System.out.println(set.isEmpty());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashSet遍历"><a href="#HashSet遍历" class="headerlink" title="HashSet遍历"></a>HashSet遍历</h3><ol>
<li>因为HashSet中的元素没有索引，所以不支持for循环直接遍历，但是可以使用foreach进行遍历</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本例将演示使用foreach遍历Set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MR.W</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetForDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		set.add(<span class="string">&quot;乔峰&quot;</span>);</span><br><span class="line">		set.add(<span class="string">&quot;虚竹&quot;</span>);</span><br><span class="line">		set.add(<span class="string">&quot;段誉&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (String name : set) &#123;</span><br><span class="line">			System.out.println(name);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>HashSet继承了Iterable接口，因此HashSet还可以使用迭代器遍历。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetIteDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		set.add(<span class="string">&quot;乔峰&quot;</span>);</span><br><span class="line">		set.add(<span class="string">&quot;虚竹&quot;</span>);</span><br><span class="line">		set.add(<span class="string">&quot;段誉&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		Iterator&lt;String&gt; it = set.iterator();</span><br><span class="line">		<span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">			System.out.println(it.next());</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator(); iterator.hasNext();) &#123;</span><br><span class="line">			System.out.println(iterator.next());</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重写hashCode"><a href="#重写hashCode" class="headerlink" title="重写hashCode"></a>重写hashCode</h3><p>HashSet 中每个能存储元素的”槽位”（slot）通常称为”桶”（bucket），如果有多个元素的 hashCode值相同，但它们通过equals()方法比较返回 false，就需要在一个”桶”里放多个元素，这样会导致性能下降。 <br>下面给出重写 hashCode() 方法的基本规则。</p>
<ul>
<li>在程序运行过程中，同一个对象多次调用 hashCode（）方法应该返回相同的值。</li>
<li>当两个对象通过 equals()方法比较返回 true 时，这两个对象的 hashCode()方法应返回相等的值</li>
<li>对象中用作 equals()方法比较标准的实例变量，都应该用于计算 hashCode 值。</li>
</ul>
<p>下面给出重写hashCode() 方法的一般步骤。</p>
<ol>
<li>把对象内每个有意义的实例变量（即每个参与 equals方法比较标准的实例变量）计算出一个 int 类型的 hashCode 值，计算方式如下： | 实例变量类型 | 计算方式 | 实例变量类型 | 计算方式 | | — | — | — | — | | boolean | hashCode&#x3D;(f?1:0); | float | hashCode&#x3D;Float.floatToIntBits(f) | | 整型 | hashCode&#x3D;(int)f; | double | long l &#x3D; Double.doubleToLongBits(f);<br>hashCode &#x3D; (int)(l^l&gt;&gt;&gt;32); | | long | hashCode&#x3D;(int)(f^(f&gt;&gt;&gt;32)) | 引用类型 | hashCode &#x3D; f.hashCode(); |</li>
<li>用第1步计算出来的多个hashCode 值组合计算出一个 hashCode 值返回。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> f1.hashCode() + (<span class="type">int</span>)f2;</span><br></pre></td></tr></table></figure>

<p>为了避免直接相加产生偶然相等 （两个对象的 f、f 实例变量并不相等，但它们的 hashCode 的和恰好相等），可以通过各实例变量的 hashCode 值乘以任意一个质数后再相加。例如如下代码;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> f1.hashCode()*<span class="number">19</span> + (<span class="type">int</span>)f2*<span class="number">31</span>;</span><br></pre></td></tr></table></figure>

<h3 id="HashSet使用场景"><a href="#HashSet使用场景" class="headerlink" title="HashSet使用场景"></a>HashSet使用场景</h3><p>根据HashSet的特点可以知道HashSet中存放的元素不能重复，利用这个特性就可以做一些去重的业务，例如在给定字符串HelloWorld中统计出现的字符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line">		<span class="comment">//将字符串转换成字符数组</span></span><br><span class="line">		<span class="type">char</span>[] ch = str.toCharArray();</span><br><span class="line">		</span><br><span class="line">		Set&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">		<span class="comment">//遍历字符数组将所有元素添加进set去重</span></span><br><span class="line">		<span class="keyword">for</span> (Character c : ch) &#123;</span><br><span class="line">			set.add(c);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//遍历set</span></span><br><span class="line">		<span class="keyword">for</span> (Character c : set) &#123;</span><br><span class="line">			System.out.println(c);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>HashSet有一个子类LinkedHashSet，LinkedHashSet集合同HashSet一样，也是根据元素的hashCode值来确定元素的存储位置，并且通过链表维护元素的顺序，换句话说，遍历LinkedHashSet时，LinkedHashSet将会按照元素的添加顺序来访问集合里的元素。<br>由于LinkedHash需要维护元素插入的顺序，因此性能略低于HashSet。下面通过示例学习LinkedHashSet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本例将演示LinkedHashSet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MR.W</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashSetDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">		set.add(<span class="string">&quot;乔峰&quot;</span>);</span><br><span class="line">		set.add(<span class="string">&quot;虚竹&quot;</span>);</span><br><span class="line">		set.add(<span class="string">&quot;段誉&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (String name : set) &#123;</span><br><span class="line">			System.out.println(name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从示例代码以及HashSet的遍历我们可以看出LinkedHashSet维护了添加顺序，也就是说添加进容器的元素和取出的元素顺序是一致的。<br>如果在某些场景下要使用set容器保存元素，并且需要维护set中的存放元素的顺序，那么就可以使用LinkedHashSet</p>
<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p>TreeSet 是 SortedSet 接口的实现类，TreeSet 可以确保集合元素处干排序状态。</p>
<h3 id="TreeSet常用API"><a href="#TreeSet常用API" class="headerlink" title="TreeSet常用API"></a>TreeSet常用API</h3><p>与 HashSet 集合相比，TreeSet 还提供了如下几个额外的方法。</p>
<ul>
<li>Comparator comparator()∶如果 TreeSet 采用了定制排序，则该方法返回定制排序所使用的 Comparator;如果 TreeSet 采用了自然排序，则返回 null。</li>
<li>Object first()∶返回集合中的第一个元素。</li>
<li>Object last(): 返回集合中的最后一个元素。</li>
<li>Object lower(Object e)∶ 返回集合中位于指定元素之前的元素（即小于指定元素的最大元素，参 考元素不需要是 TreeSet集合里的元素）。</li>
<li>Object higher(Object e)∶返回集合中位于指定元素之后的元素（即大于指定元素的最小元素， 参考元素不需要是 TreeSet 集合里的元素）</li>
<li>SortedSet subSet(Object fromElement，Object toElement)∶返回此Set 的子集合，范围从fromElement （包含）到 toElement （不包含）。</li>
<li>SortedSet headSet(Object toElement)∶ 返回此 Set 的子集，由小于 toElement 的元素组成。</li>
<li>SortedSet tailSet(Object fromElement)∶ 返回此 Set 的子集，由大于或等于 fromElement 的元素组成。</li>
</ul>
<p>下面通过示例学习TreeSet的常用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TreeSet&lt;Integer&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Integer&gt;();</span><br><span class="line">        treeSet.add(<span class="number">10</span>);</span><br><span class="line">        treeSet.add(<span class="number">20</span>);</span><br><span class="line">        treeSet.add(<span class="number">30</span>);</span><br><span class="line">        treeSet.add(<span class="number">40</span>);</span><br><span class="line">        treeSet.add(<span class="number">50</span>);</span><br><span class="line">        <span class="comment">//如果 TreeSet 采用了定制排序，则该方法返回定制排序所使用的Comparator;如果 TreeSet 采用了自然排序，则返回 null。</span></span><br><span class="line">        System.out.println(treeSet.comparator());</span><br><span class="line">        <span class="comment">//返回集合中的第一个元素。</span></span><br><span class="line">        System.out.println(treeSet.first());</span><br><span class="line">        <span class="comment">//返回集合中的最后一个元素。</span></span><br><span class="line">        System.out.println(treeSet.last());</span><br><span class="line">        <span class="comment">//返回集合中位于指定元素之前的元素（即小于指定元素的最大元素，参考元素不需要是 TreeSet集合里的元素）。</span></span><br><span class="line">        System.out.println(treeSet.lower(<span class="number">25</span>));</span><br><span class="line">        <span class="comment">//返回集合中位于指定元素之后的元素（即大于指定元素的最小元素，参考元素不需要是 TreeSet 集合里的元素）</span></span><br><span class="line">        System.out.println(treeSet.higher(<span class="number">25</span>));</span><br><span class="line">        <span class="comment">//返回此Set 的子集合，范围从fromElement（包含）到 toElement （不包含）。</span></span><br><span class="line">        System.out.println(treeSet.subSet(<span class="number">20</span>,<span class="number">50</span>));</span><br><span class="line">        <span class="comment">//返回此 Set 的子集，由小于 toElement 的元素组成</span></span><br><span class="line">        System.out.println(treeSet.headSet(<span class="number">30</span>));</span><br><span class="line">        <span class="comment">//返回此 Set 的子集，由大于或等于 fromElement 的元素组成。</span></span><br><span class="line">        System.out.println(treeSet.tailSet(<span class="number">30</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据 上面程序的运行结果即可看出，TreeSet 并不是根据元素的插入顺序进行排序的。而是根据元素实际值的大小来进行排序的。 <br>与 HashSet 集合采用 hash 算法来决定元素的存储位置不同，TreeSet 采用红黑树的数据结构来存储集合元素。那么 TreeSet 进行排序的规则是怎样的呢? TreeSet 支持两种排序方法∶自然排序和定制排序。在默认情况下，TreeSet 采用自然排序。</p>
<h3 id="自然排序"><a href="#自然排序" class="headerlink" title="自然排序"></a>自然排序</h3><p>TreeSet 会调用集合元素的 compareTo（Object obj）方法来比较元素之间的大小关系，然后将集合元素按升序排列，这种方式就是自然排序。<br> Java 提供了一个 Comparable接口，该接口里定义了一个 compareTo(Object obj)方法，该方法返回一个整数值，实现该接口的类必须实现该方法，实现了该接口的类的对象就可以比较大小。当一个对象调用该方法与另一个对象进行比较时，例如 obj1.compareTo(obj2)，如果该方法返回 0，则表明这两个对象相等;如果该方法返回一个正整数，则表明 obj1 大于 obj2;如果该方法返回一个负整数，则表明 obj1小于obj2。<br>下面通过示例学习该接口，首先定义Student类，类中包含name和age属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Set&lt;Student&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">18</span>);</span><br><span class="line">		</span><br><span class="line">		set.add(s1);</span><br><span class="line">		set.add(s2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当运行以上程序时，发现程序抛出了异常：</p>
<p><img src="https://files.catbox.moe/3z10zq.png"></p>
<p>这是因为Student没有继承Comparable接口，如果把一个对象添加到TreeSet时，则该对象的类必须继承Comparable接口，否则程序将会抛出异常。<br>下面的程序将演示正确的添加方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name,<span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.age-o.age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Set&lt;Student&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">19</span>);</span><br><span class="line">		</span><br><span class="line">		set.add(s1);</span><br><span class="line">		set.add(s2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Student类继承Comparable接口并重写compareTo()方法后再次向TreeSet中添加，可以顺利添加，并且可以按照age属性的大小进行排序。<br>当把一个对象加入 TreeSet 集合中时，TreeSet 调用该对象的 compareTo(Object obj)方法与容器中的其他对象比较大小，然后根据红黑树结构找到它的存储位置。如果两个对象通过 compareTo(Object obj)方法比较相等，新对象将无法添加到 TreeSet 集合中。<br> 对于TreeSet集合而言，它判断两个对象是否相等的唯一标准是∶两个对象通过compareTo(Object obj)方法比较是否返回 0——如果通过 compareTo（Object obi）方法比较返回 0，TreeSet 则会认为它们相等;否则就认为它们不相等。</p>
<h3 id="定制排序"><a href="#定制排序" class="headerlink" title="定制排序"></a>定制排序</h3><p>TreeSet 的自然排序是根据集合元素的大小，TreeSet 将它们以升序排列。如果需要实现定制排序，例如以降序排列，则可以通过 Comparator 接口的帮助。该接口里包含一个int compare(T o1，T o2)方法，该方法用于比较 o1 和 o2 的大小∶ 如果该方法返回正整数，则表明o1 大于o2;如果该方法返回0，则表明 o1等于 o2;如果该方法返回负整数，则表明 o1小于 o2。<br> 如果需要实现定制排序，则需要在创建 TreeSet 集合对象时，提供一个 Comparator 对象与该TreeSet集合关联，由该 Comparator 对象负责集合元素的排序逻辑。<br>下面通过示例学习Comparator的用法，继续使用上例中的Student类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name,<span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComparatorDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Set&lt;Student&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Student&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> o1.age-o2.age;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">19</span>);</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">20</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="各个Set性能分析"><a href="#各个Set性能分析" class="headerlink" title="各个Set性能分析"></a>各个Set性能分析</h2><p>HashSet 和 TreeSet 是 Set 的两个典型实现，到底如何选择 HashSet 和 TreeSet 呢?HashSet 的性能总是比 TreeSet 好（特别是最常用的添加、查询元素等操作），因为 TreeSet 需要额外的红黑树算法来维护集合元素的次序。只有当需要一个保持排序的 Set 时，才应该使用 TreeSet，否则都应该使用 HashSet。<br> HashSet 还有一个子类∶LinkedHashSet，对于普通的插入、删除操作，LinkedHashSet 比 HashSet要略微慢一点，这是由维护链表所带来的额外开销造成的，但由于有了链表，遍历 LinkedHashSet 会更快。</p>
]]></content>
  </entry>
  <entry>
    <title>Java异常</title>
    <url>/2022/08/04/Java%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h1 id="Java异常概述"><a href="#Java异常概述" class="headerlink" title="Java异常概述"></a>Java异常概述</h1><p>如果看一门编程语言是否健壮，那么是否提供异常处理机制就是很重要的判断标准之一，除了传统的C语言以外，目前主流的编程语言都提供了成熟的异常机制，例如C#，Python等。异常机制可以使程序中的异常处理代码和业务代码分离，保证程序更加的优雅，提高程序的健壮性。<br>Java 的异常机制主要依赖干 try、catch、finally、throw 和 throws 五个关键字，其中 try 关键字后紧跟一个花括号扩起来的代码块（花括号不可省略），简称 try 块，它里面放置可能引发异常的代码。catch后对应异常类型和一个代码块，用于表明该 catch 块用于处理这种类型的代码块。多个 catch 块后还可以跟一个 finally 块，finally 块用于回收在 try 块里打开的物理资源，异常机制会保证 finally 块总被执行。 <strong>throws 关键字主要在方法签名中使用，用于声明该方法可能抛出的异常；而 throw 用于抛出—个实际的异常，throw 可以单独作为语句使用，抛出一个具体的异常对象</strong> 。<br>Java 7 进一步增强了异常处理机制的功能，包括带资源的 try 语句、捕获多异常的 catch 两个新功能，这两个功能可以极好地简化异常处理。 开发者希望所有的错误都能在编译阶段被发现，就是在试图运行程序之前排除所有错误，但这是不现实的，余下的问题必须在运行期间得到解决。Java将异常分为两种，Checked 异常和 Runtime 异常， Java 认为 Checked 异常都是可以在编译阶段被处理的异常，所以它强制程序运行前处理所有的 Checked 异常；而 Runtime 异常则无须处理。</p>
<h2 id="异常类的继承体系"><a href="#异常类的继承体系" class="headerlink" title="异常类的继承体系"></a>异常类的继承体系</h2><p>Java提供了丰富的异常类，这些类有着严格的继承关系，如下图：</p>
<p><img src="https://files.catbox.moe/1is2gr.png"></p>
<p>从图示中可以看出，Java把所有的非正常情况分为两大类：异常（Exception）和错误（Error），他们都是Throwable的子类。</p>
<ul>
<li>Error：和虚拟机有关的问题，如系统崩溃、虚拟机错误等，这些错误无法恢复或者不可能被抓取，将导致应用程序中断，应用程序通常无法处理这些错误，因此不应该用异常处理方法来处理Error。同样，也不能在throws字句中声明该方法可能抛出Error。</li>
<li>Exception：程序中出现的非正常情况，其中异常又分为两类，RuntimeException（运行时异常）和CheckedException（检查时异常），这两类异常都是Exception的子类，其中RuntimeException及其子类不需要开发者显示处理。如果一个Exception没有继承RuntimeException类，则属于CheckedException，这类异常通常需要开发者显示处理。否则会出现编译错误。</li>
</ul>
<p>下面，先通过示例来演示运行时异常和检查时异常的区别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 定义方法，该方法抛出算术异常</span></span><br><span class="line"><span class="comment">	 * 算术异常是运行时异常</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> ArithmeticException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> <span class="keyword">throws</span> ArithmeticException&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 定义方法，该方法抛出检查时异常</span></span><br><span class="line"><span class="comment">	 * 检查时异常要求开发者必须显示处理</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">		<span class="comment">//因为该方法抛出的是运行时异常，即使不处理也不会发生编译错误</span></span><br><span class="line">		s.say();</span><br><span class="line">		<span class="comment">//该方法抛出的是检查时异常，要求开发者显示处理</span></span><br><span class="line">		<span class="comment">//如果不处理则编译错误</span></span><br><span class="line">		s.hello();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，定义了Student类以及两个实例方法：<br>其中say()方法抛出了一个ArithmeticException，因为ArithmeticException继承了RuntimeException，所以它是一个运行时异常，因此，在上述代码第25行调用该方法时，即使没有显式的处理该异常，程序也不会出现编译错误。<br>hello()方法抛出了ClassNotFoundException，ClassNotFoundException没有继承RuntimeException，因此是一个检查时异常，而检查时异常需要开发者显式处理，如果不处理，则会出现编译错误。</p>
<h2 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h2><p>对于计算机程序而言，没有人能保证自己写的程序永远不会出错！就算程序没有错误，你能保证用户总是按你的意愿来输入? 就算用户都是非常”聪明而且配合”的，你能保证运行该程序的操作系统永远稳定？你能保证运行该程序的硬件不会突然坏掉？你能保证网络永远通畅？<br>对于一个程序设计人员，需要尽可能地预知所有可能发生的情况，尽可能地保证程序在所有糟糕的情形下都可以运行。也就是说要时时刻刻考虑程序的健壮性。<br>Java 的异常处理机制可以让程序具有极好的容错性，让程序更加健壮。当程序运行出现意外情形时，系统会自动生成一个 Exception 对象来通知程序，从而实现将”业务功能实现代码”和”错误处理代码”分离，提供更好的可读性。</p>
<h3 id="try…catch捕获异常"><a href="#try…catch捕获异常" class="headerlink" title="try…catch捕获异常"></a>try…catch捕获异常</h3><p>正如前面示例中编写的代码，在代码28行如果不做任何处理，将会出现编译错误，代码也就无法执行。为了解决这个问题，可以使用try…catch捕获异常，并对异常进行处理，如果执行try语句块中的代码出现异常，系统会自动生成一个异常对象，该对象被提交给Java运行时环境，这个过程被称为throw（抛出）异常。<br>当Java运行时环境受到异常对象时，会寻找对应处理该异常对象的catch块，如果找到合适的catch块，则把该异常对象交给catch块处理，这个过程叫做catch（捕获）异常；如果Java运行时环境找不到捕获异常的catch块，则运行时环境终止，Java程序也将退出。<br>下面将演示上例中代码中异常的处理方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">		<span class="comment">//因为该方法抛出的是运行时异常，即使不处理也不会发生编译错误</span></span><br><span class="line">		s.say();</span><br><span class="line">		<span class="comment">//该方法抛出的是检查时异常，要求开发者显示处理</span></span><br><span class="line">		<span class="comment">//如果不处理则编译错误</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			s.hello();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的程序可以看出，将第9行可能抛出异常的代码放入了try语句块中，当这一行代码发生异常时，就会到后续的catch语句块中寻找与之对应的异常，如果找到则进入catch语句块中继续执行。避免了程序的中断。<br>接下来，通过示例来学习当代码发生异常时如果catch中有对应的异常和没有对应的异常时发生的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//创建Student对象</span></span><br><span class="line">		<span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">		<span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> s.getClass();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			System.out.println(<span class="string">&quot;未找到该属性&quot;</span>);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，使用了反射获取Student中的name变量，因为在Student中并没有定义name变量，所有当代码运行至第9行时，一定会发生NoSuchFieldException，并且在try后的catch中就存在与之对应的异常处理语句。程序将进入对应的catch语句块中，并向下执行。运行结果如下图所示：</p>
<p><img src="https://files.catbox.moe/0tsbm4.png"></p>
<p>如果程序发生异常时在catch语句中没有找到对应的异常，那么程序将终止运行，通过下面的示例来演示这种情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.ExceptionDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="comment">//创建Student对象</span></span><br><span class="line">            <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">            <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> s.getClass();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//此时会出现编译错误，提示必须对NoSuchFieldException进行捕获或者生命以便抛出</span></span><br><span class="line">                <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                System.out.println(<span class="string">&quot;未找到该属性&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://files.catbox.moe/sfb3lo.png"></p>
<h3 id="Java-7提供的多异常捕获"><a href="#Java-7提供的多异常捕获" class="headerlink" title="Java 7提供的多异常捕获"></a>Java 7提供的多异常捕获</h3><p>在Java 7以前，每个catch块只能捕获一种类型的异常；但是从Java 7开始，一个catch块可以捕获多种类型的异常。<br>使用catch块捕获多种类型异常时需要注意以下两点：</p>
<ol>
<li>捕获多种类型异常时，多种异常类型之间使用 | 隔开</li>
<li>捕获多种类型异常时，异常变量有隐式的final修饰，因此程序不能对异常变量重新赋值</li>
</ol>
<p>我们重构上一小节的程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//创建Student对象</span></span><br><span class="line">		<span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">		<span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> s.getClass();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (NoSuchFieldException | SecurityException e) &#123;</span><br><span class="line">			<span class="comment">//因为e是隐式final修饰的，所以不能重新赋值</span></span><br><span class="line"><span class="comment">//			e = new ArithmeticException();</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过重构代码可以发现在一个catch中捕获了NoSuchFieldException和SecurityException两个异常，在代码12行重新对e赋值发现编译出错，这是因为变量e是使用隐式的final修饰的，final修饰的变量初始化后不能被重新赋值。所以会编译错误。</p>
<h3 id="使用finally回收资源"><a href="#使用finally回收资源" class="headerlink" title="使用finally回收资源"></a>使用finally回收资源</h3><p>在开发中经常会打开一些资源，例如数据库连接，网络连接和磁盘文件等，这些资源在打开后都必须要显式回收。并且这些资源必须要进行回收，否则会持续占用内存资源。而且不会释放。<br>为了保证资源一定能被回收，异常处理机制提供了finally块，不管try块中的代码是否出现异常，也不管哪个catch语句块被执行，甚至在try块或者catch块中执行了return语句，finally中的代码总会被执行。其语法结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e1)&#123;</span><br><span class="line"> 	<span class="comment">//代码   </span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e2)&#123;</span><br><span class="line"> 	<span class="comment">//代码   </span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"> 	<span class="comment">//资源回收   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异常处理语法结构中只有 try 块是必需的，也就是说，如果没有 try 块，则不能有后面的 catch 块和 finally 块；catch 块和 finally 块都是可选的，但 catch 块和 finally 块至少出现其中之一，也可以同时出现;可以有多个 catch 块，捕获父类异常的 catch 块必须位于捕获子类异常的后面；但不能只有 try 块，既没有 catch 块，也没有 finally 块；多个 catch 块必须位于 try 块之后，finally 块必须位于所有的 catch块之后。并且finally语句块不能单独出现，只能和try…catch搭配使用。<br>下面，通过示例来了解finally的作用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本例将演示finally语句块一定会执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MR.W</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinallyDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//此处会抛出ArithmeticException</span></span><br><span class="line">			System.out.println(<span class="string">&quot;try&quot;</span>);</span><br><span class="line">			<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">5</span>/<span class="number">0</span>;</span><br><span class="line">		&#125;<span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">			<span class="comment">//catch语句块捕获了该异常</span></span><br><span class="line">			System.out.println(<span class="string">&quot;catch&quot;</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">//进入finally语句块</span></span><br><span class="line">			System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中第10行因为用整数除0，所以会抛出ArithmeticException，在try后的catch语句块中可以捕获该异常，并执行catch中的代码，catch后还有finally语句块，finally语句块的特点是不管是否会抛出异常，finally中的语句都会执行，所以程序结果运行如下图：</p>
<p><img src="https://files.catbox.moe/lh6d6f.png"></p>
<p>修改上例中的代码，即使try语句块中的代码不抛出异常，finally中的代码也会执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本例将演示finally语句块一定会执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MR.W</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinallyDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;try&quot;</span>);</span><br><span class="line">			<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">5</span>/<span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">			<span class="comment">//catch语句块捕获了该异常</span></span><br><span class="line">			System.out.println(<span class="string">&quot;catch&quot;</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">//进入finally语句块</span></span><br><span class="line">			System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中try语句块中被不会抛出异常，所以代码不会进入catch语句块中，但是仍然会进入finally语句块中并执行代码，结果如下图：</p>
<p><img src="https://files.catbox.moe/q6jegp.png"></p>
<p>除此以外Java还提供了增强版的try-with-resource语法，这节内容将在下一章中详细讲解。</p>
<h2 id="使用throws声明抛出异常"><a href="#使用throws声明抛出异常" class="headerlink" title="使用throws声明抛出异常"></a>使用throws声明抛出异常</h2><p>throws用于方法头中抛出异常，当定义一个方法并且该方法不知道如何处理这种类型的异常时，该异常交由调用者处理；如果main方法也不知道如何处理这种类型的异常，也可以使用throws声明抛出异常，该异常将交有JVM处理。JVM对异常的处理方法是，打印异常的跟踪栈信息，并终止程序的运行。<br>throws声明抛出异常只能在方法签名中使用，throws可以声明抛出一个异常类，多个异常类之间用逗号隔开。语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throws</span> Exception1,Exception2...</span><br></pre></td></tr></table></figure>

<p>如果某段代码中调用了一个带throws声明的方法，该方法抛出了Checked异常，则表明该方法要求调用者来处理该异常。也就是说方法的调用者要么在try语句块中显示捕获该异常，要么放在另一个带throws声明抛出的方法中。下面的示例将演示这种用法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException,SQLException&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Teacher</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			t.say();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序中定义了Teacher类，在Teacher中定义了say()方法，并且该方法在方法头中使用throws抛出了ClassCastException，SQLException，在main方法中创建了Teacher对象t，并调用了say方法，因为ClassNotFoundException，SQLException都是Checked异常，所以调用say方法时，必须显示的处理这两个异常，在上例中使用了try…catch对异常进行了处理。当然也可以在调用say方法代码所在的方法头继续使用throws抛出异常，但是由于say方法是在main方法中调用的，也就是说如果继续throws异常的话，会抛给虚拟机，但是并不建议将异常抛给虚拟机。下面的程序将演示这种情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> <span class="keyword">throws</span> ClassCastException,SQLException&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassCastException, SQLException &#123;</span><br><span class="line">		<span class="type">Teacher</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">		t.say();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序中第8行say方法抛出了异常，但是并没有处理，而是直接向上抛出，因为say方法是在main方法中调用的，如果继续抛出异常，main方法只能将异常抛给虚拟机。</p>
<h2 id="使用throw抛出异常"><a href="#使用throw抛出异常" class="headerlink" title="使用throw抛出异常"></a>使用throw抛出异常</h2><p>当程序出现错误时，系统会自动抛出异常；除此之外，Java也允许程序自行抛出异常，自行抛出异常使用throw语句来完成（注意此处的throw没有后面的s，与前面声明抛出的throws是有区别的）。</p>
<h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>很多时候，系统是否要抛出异常，可能需要根据应用的业务需求来决定，如果程序中的数据、执行与既定的业务需求不符，这就是一种异常。<br>由于与业务需求不符合产生的异常，必须由程序员来决定抛出，系统无法抛出这种异常。如果需要在程序中自行抛出异常，则应使用throw语句，throw语句可以单独使用，throw语句抛出的不是异常类，而是一个异常实例，而且每次只能抛出一个异常实例。throw语句的语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">throw ExceptionInstance;</span><br></pre></td></tr></table></figure>

<p>在开发中登录是常见的业务，当用户输入用户名和密码后，开发者需要对用户名进行校验其合法性，例如长度符合规定，如果不符合规定，就可以抛出一个异常。下面的程序将演示throw的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package cn.bytecollege;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class StringValid &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Scanner sc = new Scanner(System.in);</span><br><span class="line">		String username = sc.next();</span><br><span class="line">		valid(username);</span><br><span class="line">	&#125;</span><br><span class="line">	public static void valid(String username) &#123;</span><br><span class="line">		int length = username.length();</span><br><span class="line">		if(length&gt;12||length&lt;6) &#123;</span><br><span class="line">			throw new RuntimeException(&quot;用户名长度不合法&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序中，在valid方法中，如果用户输入的用户名长度小于6或者大于12就使用throw在方法内抛出异常，也就是说当用户名长度小于6或者大于12程序认定这是异常。当Java运行时接收到用户自行抛出的异常时，同样会中止当前的执行流，跳到该异常对应的catch块，由该catch块来处理该异常。也就是说，不管是系统自动抛出的异常，还是程序员手动抛出的异常，Java运行时环境对异常的处理没有任何差别。<br>如果throw语句抛出的异常是Checked异常，则该throw语句要么处于try块里，显式捕获该异常，要么放在一个带throws声明抛出的方法中，即把该异常交给该方法的调用者处理；如果throw语句抛出的异常是Runtime异常，则该语句无须放在try块里，也无须放在带throws声明抛出的方法中；程序既可以显式使用try…catch来捕获并处理该异常，也可以完全不理会该异常，把该异常交给该方法调用者处理。例如下面例子程序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package cn.bytecollege;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class StringValid2 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Scanner sc = new Scanner(System.in);</span><br><span class="line">		String username = sc.next();</span><br><span class="line">		try &#123;</span><br><span class="line">			valid(username);</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void valid(String username) throws Exception &#123;</span><br><span class="line">		int length = username.length();</span><br><span class="line">		if(length&gt;12||length&lt;6) &#123;</span><br><span class="line">			throw new Exception(&quot;用户名长度不合法&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中修改了valid方法，当用户输入的用户名长度不合法时，使用throw抛出了一个Checked异常，因此在方法头上需要使用throws声明抛出异常（当然，也可以在valid方法中使用try…catch处理，但是这么做没有意义，相当于自己的异常自己处理了，那么调用者也不清楚输入的数据是否合法）。当该方法抛出Checked异常后，也要求方法的调用者显示的处理，所以在main方法中显示了处理了异常。</p>
<h2 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h2><p>在上一小节学习了如何使用throw在方法内抛出异常，但是在程序开发选择抛出异常时，应该选择合适的异常类，从而可以明确地描述该异常情况。在这种情形下，应用程序常常需要抛出自定义异常。用户自定义异常都应该继承Exception基类，如果希望自定义Runtime异常，则应该继承RuntimeException基类。定义异常类时通常需要提供两个构造器：一个是无参数的构造器；另一个是带一个字符串参数的构造器，这个字符串将作为该异常对象的描述信息（也就是异常对象的getMessage()方法的返回值）。例如上一小节的示例，直接使用了RuntimeException或者Exception，这样并不能很清晰的描述异常信息，因此，可以自定义一个异常，专门描述校验用户名过程中发生的异常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package cn.bytecollege;</span><br><span class="line">/**</span><br><span class="line"> * 本例将演示自定义异常</span><br><span class="line"> * @author MR.W</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class UsernameException extends Exception&#123;</span><br><span class="line">	public UsernameException() &#123;</span><br><span class="line">		super();</span><br><span class="line">	&#125;</span><br><span class="line">	public UsernameException(String msg)&#123;</span><br><span class="line">		super(msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程序创建了AuctionException异常类，并为该异常类提供了两个构造器。尤其是第11行代码部分创建的带一个字符串参数的构造器，其执行体也非常简单，仅通过super来调用父类的构造器，正是这行super调用可以将此字符串参数传给异常对象的message属性，该message属性就是该异常对象的详细描述信息。<br>如果需要自定义Runtime异常，只需将AuctionException.java程序中的Exception基类改为RuntimeException基类，其他地方无须修改。</p>
<h2 id="异常转义"><a href="#异常转义" class="headerlink" title="异常转义"></a>异常转义</h2><p>前面介绍的异常处理方式有如下两种。</p>
<ul>
<li>在出现异常的方法内捕获并处理异常，该方法的调用者将不能再次捕获该异常。</li>
<li>该方法签名中声明抛出该异常，将该异常完全交给方法调用者处理。</li>
</ul>
<p>在实际应用中往往需要更复杂的处理方式——当一个异常出现时，单靠某个方法无法完全处理该异常，必须由几个方法协作才可完全处理该异常。也就是说，在异常出现的当前方法中，程序只对异常进行部分处理，还有些处理需要在该方法的调用者中才能完成，所以应该再次抛出异常，让该方法的调用者也能捕获到异常。为了实现这种通过多个方法协作处理同一个异常的情形，可以在catch块中结合throw语句来完成。如下例子程序示范了这种catch和throw同时使用的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.ExceptionDemo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义UsenameCheckedException异常类，继承Exception类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsenameCheckedException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UsenameCheckedException</span> <span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="comment">//调用父类的构造方法</span></span><br><span class="line">        <span class="built_in">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    String username;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">checked</span><span class="params">(String username)</span><span class="keyword">throws</span> UsenameCheckedException&#123;</span><br><span class="line">        <span class="keyword">if</span> (username.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsenameCheckedException</span>(<span class="string">&quot;用户名不能为空&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> username;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            user.checked(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (UsenameCheckedException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户名不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="访问异常信息"><a href="#访问异常信息" class="headerlink" title="访问异常信息"></a>访问异常信息</h2><p>如果程序需要在 catch 块中访问异常对象的相关信息，则可以通过访问 catch 块的后异常形参来获得。当 Java运行时决定调用某个 catch 块来处理该异常对象时，会将异常对象赋给 catch 块后的异常参数，程序即可通过该参数来获得异常的相关信息。 所有的异常对象都包含了如下几个常用方法。</p>
<ul>
<li>getMessage()∶ 返回该异常的详细描述字符串。</li>
<li>printStackTrace()∶将该异常的跟踪栈信息输出到标准错误输出。</li>
<li>getStackTrace()∶ 返回该异常的跟踪栈信息。下面例子程序演示了程序如何访问异常信息。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.ExceptionDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">5</span>/<span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            <span class="comment">//将该异常的跟踪栈信息输出到标准错误输出</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">//返回该异常的详细描述字符串</span></span><br><span class="line">            e.getMessage();</span><br><span class="line">            <span class="comment">//返回该异常的跟踪栈信息</span></span><br><span class="line">            e.getStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程序调用了 Exception 对象的 getMessage（）方法来得到异常对象的详细信息，也使用了 printStackTrace（）方法来打印该异常的跟踪信息。运行上面程序，会看到下图所示的界面。</p>
<p><img src="https://files.catbox.moe/h2a4d8.png"></p>
<h2 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h2><p>对于真实的企业级应用而言，常常有严格的分层关系，层与层之间有非常清晰的划分，上层功能的实现严格依赖于下层的API，也不会跨层访问。<br>把底层的原始异常直接传给用户是一种不负责任的表现。通常的做法是：程序先捕获原始异常，然后逐级向上抛出，直到某一层将该异常进行处理。<br>下面的程序将演示这种情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.ExceptionDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                B.b();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            C.c();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">c</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Java新特性</title>
    <url>/2022/08/04/Java%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h1 id="Java新特性"><a href="#Java新特性" class="headerlink" title="Java新特性"></a>Java新特性</h1><p>Lambda表达式是Java8中新增的特性，lambda表达式是一个可传递的代码块，可以在以后执行一次或多次。在以前定义的方法中，只能将基本类型或者引用类型的变量作为方法参数，在Java 8以后可以将一个代码片段作为方法参数。</p>
<h2 id="Lambda表达式入门"><a href="#Lambda表达式入门" class="headerlink" title="Lambda表达式入门"></a>Lambda表达式入门</h2><p>在集合中Java为开发者提供了遍历集合的简洁方式，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		list.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		list.forEach(e-&gt;System.out.println(e));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，调用了list对象的foreach方法，从程序可以看出，传入foreach的并不是一个变量，而是一段代码，这就是Lambda表达式。从上面的语法可以看出，Lambda表达式的主要作用就是代替匿名内部类的烦琐语法。<br>Lambda由3部分组成：</p>
<ol>
<li>形参列表：形参列表允许省略形参的数据类型，如果形参列表中有且只有1个参数，可以省略形参列表的括号</li>
<li>箭头函数：-&gt;必须有横线和大于号组成</li>
<li>代码块。如果代码块只包含一条语句，Lambda表达式允许省略代码块的花括号。</li>
</ol>
<p>下面，通过示例来学习Lambda的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表达式只有1个参数</span></span><br><span class="line">(a)-&gt;&#123;</span><br><span class="line">    System.out.print(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//表达式可以简写为</span></span><br><span class="line">a-&gt;&#123;</span><br><span class="line">    System.out.print(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果代码块中只有1条语句，可以省略大括号</span></span><br><span class="line">a-&gt;System.out.print(a)</span><br></pre></td></tr></table></figure>

<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>Lambda表达式的目标类型必须是函数式接口，所谓函数式接口代表只包含一个抽象方法的接口，函数式接口可以包含多个默认方法、类方法，但是只能声明一个抽象方法。</p>
<p>如果采用匿名内部类语法来创建函数式接口的实例，则只需要实现一个抽象方法，在这种情况下可采用Lambda表达式来创建对象。</p>
<p>注意：Java8 专门为函数式接口提供了@FunctionalInterface注解，该注解通常放在接口定义前，该注解对程序功能没有任何作用，它的作用是用于告诉编译器执行更严格的检查，检查该接口必须是函数式接口，否则编译器出错。</p>
<p>Lambda表达式的结果就是被作为对象，程序中晚期可以使用Lambda表达式进行赋值，例如在多线程Thread类的构造器中可以传入Runnable接口的子类对象。查看Runnable接口发现，该接口也被声明为一个函数式接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，就可以使用Lambda表达式来创建线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLambdaDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">				System.out.println(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		thread.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lambda 表达式实现的是匿名方法——因此它只能实现特定函数式接口中的唯一方法。这意味着 Lambda 表达式有如下两个限制。</p>
<ul>
<li>Lambda 表达式的目标类型必须是明确的函数式接口。</li>
<li>Lambda 表达式只能为函数式接口创建对象。Lambda 表达式只能实现一个方法，因此它只能为 只有一个抽象方法的接口（函数式接口）创建对象。</li>
</ul>
<p>下面定义一个函数式接口深入学习Lambda表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"><span class="comment">//函数式接口只能有一个抽象方法，并且要使用@FunctionalInterface声明</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个方法，方法参数是Consumer接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(Consumer consumer)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">		<span class="keyword">return</span> consumer.add(a, b);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> test((a,b)-&gt;&#123;</span><br><span class="line">			<span class="keyword">return</span> a+b;</span><br><span class="line">		&#125;);</span><br><span class="line">		System.out.println(k);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上例中定义了一个函数式接口，在测试类的test方法传入了接口并调用了Consumer接口的add方法，需要注意的是，此时add方法并没有方法实现，在main方法中调用了test，并将一段代码（即add方法的实现）也就是lambda表达式当做参数传入了test方法。换句话说在上例中使用了lambda表达替代了烦琐的匿名内部类。对比下面的代码就可以看出Lambda表达式的独到之处。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(Consumer consumer)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">		<span class="keyword">return</span> consumer.add(a, b);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> test(<span class="keyword">new</span> <span class="title class_">Consumer</span>() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> a+b;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		System.out.println(k);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从前面的程序可以看出Lambda表达式的使用离不开函数式接口，通常函数式接口中有且只能有1个抽象方法，这样使用Lambda表达式时也就明确了是哪个抽象方法的实现，如果接口中出现了多个抽象方法，那么就不能在接口上使用@FunctionInterface注解，会编译出错。因此，Java 8在java.util.function包中预定义了大量函数式接口，通常情况下这些接口完全可以满足开发需要：</p>
<ul>
<li>XxxFunction∶ 这类接口中通常包含一个 apply()抽象方法，该方法对参数进行处理、转换（apply() 方法的处理逻辑由 Lambda 表达式来实现），然后返回一个新的值。该函数式接口通常用于对指定数据进行转换处理。</li>
<li>XxxConsumer∶ 这类接口中通常包含一个 accept()抽象方法，该方法与 XxxFunction 接口中的 apply()方法基本相似，也负责对参数进行处理，只是该方法不会返回处理结果。</li>
<li>XxxxPredicate∶这类接口中通常包含一个 test()抽象方法，该方法通常用来对参数进行某种判断 test()方法的判断逻辑由 Lambda 表达式来实现），然后返回一个 boolean 值。该接口通常用于判断参数是否满足特定条件，经常用于进行筛滤数据。</li>
<li>XxxSupplier∶ 这类接口中通常包含一个 getAsXxx()抽象方法，该方法不需要输入参数，该方法会按某种逻辑算法（getAsXxx()方法的逻辑算法由 Lambda 表达式来实现）返回一个数据。综上所述，不难发现 Lambda 表达式的本质很简单，就是使用简洁的语法来创建函数式接口的实例——这种语法避免了匿名内部类的烦琐。</li>
</ul>
<p>下面在程序中示范上述接口的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据转换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MR.W</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CastUtil</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 定义方法将Object类型转换为String类型</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> function</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">castToString</span><span class="params">(Function&lt;Object, String&gt; function, Integer a)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> function.apply(a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的CastUtil类中定义了castToString，在该方法中第一个参数是一个Java 8 预定义的函数式接口，在方法内调用了Function接口的apply()方法，作用是将任意类型转换成String。但是此时这个方法并没有方法的实现，需要在调用此方法时传入方法的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.lambda;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10010</span>;</span><br><span class="line">		<span class="comment">//使用Lambda表达式，此时castToString方法的第一个参数</span></span><br><span class="line">		<span class="comment">//就是Function函数式接口apply()的实现</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> CastUtil.castToString((o)-&gt;&#123;</span><br><span class="line">			<span class="keyword">return</span> String.valueOf(o);</span><br><span class="line">		&#125;, a);</span><br><span class="line">		System.out.println(s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在测试类中，调用了CastUtil的castToString()方法，并传入了Lambda表达式，以此Lambda表达式作为apply()方法的实现，在表达式中使用了String.valueOf()方法将对象转换成String类型。</p>
<h2 id="方法引用与构造器引用"><a href="#方法引用与构造器引用" class="headerlink" title="方法引用与构造器引用"></a>方法引用与构造器引用</h2><p>前面已经介绍过，如果Lambda 表达式的代码块只有一条代码，程序就可以省略 Lambda 表达式中代码块的花括号。不仅如此，如果Lambda 表达式的代码块只有一条代码，还可以在代码块中使用方法引用和构造器引用。 方法引用和构造器引用可以让 Lambda表达式的代码块更加简洁。方法引用和构造器引用都需要使用两个英文冒号。<br>Lambda 表达式支持如下表所示的几种引用方式。</p>
<h3 id="引用类方法"><a href="#引用类方法" class="headerlink" title="引用类方法"></a>引用类方法</h3><p>下面的示例将演示类方法的引用，首先定义一个函数式接口，接口中定义抽象方法castToString()，该方法的作用是将一个对象转换成String对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.lambda;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span>&lt;T,R&gt; &#123;</span><br><span class="line">	R <span class="title function_">castToString</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在String的学习中可以知道，String类有提供了类方法valueOf(Object o)，该方法可以将任意对象转换成String类型，因此可以使用该方法作为Lambda表达式的实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Function&lt;Object, String&gt; function = a-&gt;&#123;</span><br><span class="line">			<span class="keyword">return</span> String.valueOf(a);</span><br><span class="line">		&#125;;</span><br><span class="line">		System.out.println(function.castToString(<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，创建了Lambda表达式作为了Function接口中castToString()方法的实现。在Lambda表达式中调用了String.valueOf()方法来进行对象到字符串的转换，在代码第8行调用了function接口的castToString()方法，实际上调用了就是代码第5行创建的Lambda表达式。<br>上面的Lambda表达式的代码块只有一行调用类方法的代码，因此可以使用如下方法引用进行替换。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Function&lt;Object, String&gt; function = String::valueOf;</span><br><span class="line">		System.out.println(function.castToString(<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面的类方法的引用，也就是调用了String类的valueOf()方法来实现Function函数式接口中唯一抽象方法。当调用castToString()方法时，调用参数将会传给String类的valueOf()类方法。</p>
<h3 id="引用对象的实例方法"><a href="#引用对象的实例方法" class="headerlink" title="引用对象的实例方法"></a>引用对象的实例方法</h3><p>下面演示第二种方法引用，引用对象的实例方法，首先使用Lambda表达式创建一个Function接口的子类对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;Object, String&gt; function = o-&gt;o.toString();</span><br></pre></td></tr></table></figure>

<p>上面的Lambda表达式只有一条语句，因此省略了该代码的花括号。<br>接下来程序调用function对象的castToString()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.lambda;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Function&lt;Object, String&gt; function = o-&gt;o.toString();</span><br><span class="line">		System.out.println(function.castToString(<span class="number">100</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序调用了function对象的castToString()方法时，由于function对象是Lambda表达式创建，castToString()方法的执行体就是Lambda表达式的代码部分，因此上面的程序输出了100.<br>上面的Lambda表达式代码只有一行，且调用了对象的o的toString()实例方法。因此代码可以进行如下替换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.lambda;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Function&lt;Object, String&gt; function = Object::toString;</span><br><span class="line">		System.out.println(function.castToString(<span class="number">100</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的Lambda表达式的代码只有一条语句，因此省略了代码块的花括号；而且由于表达式实现的castToString方法需要返回值，因此Lambda表达会将这行代码的值作为返回值。此时就可以使用方法引用进行替换，直接引用Object的toString()方法作为Lambda表达式的代码块。其中Function接口的castToString方法有个参数，当执行Lambda表达式代码块时，会自动调用传入参数的toString()方法。</p>
<h3 id="引用构造器"><a href="#引用构造器" class="headerlink" title="引用构造器"></a>引用构造器</h3><p>下面的实例将演示如何引用构造器，首先定义函数式接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.lambda;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">	StringBuilder <span class="title function_">get</span><span class="params">(String s)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数式接口包含了一个get()抽象方法，该方法的作用是使用String对象生成一个StringBuilder对象，接着使用Lambda表达式创建一个MyInterface的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.lambda;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefTest3</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">MyInterface</span> <span class="variable">myInterface</span> <span class="operator">=</span> (s)-&gt; <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s);</span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> myInterface.get(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码调用了myInterface对象的get()方法时，由于该对象是Lambda表达式创建的，因此get()方法执行体就是Lambda表达式的代码块部分，即执行体就是执行new StringBuilder(a)语句，并将这条语句的值作为方法的返回值。因此上面代码中Lambda表达式的代码可以进行如下替换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefTest3</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">MyInterface</span> <span class="variable">myInterface</span> <span class="operator">=</span> StringBuilder::<span class="keyword">new</span>;</span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> myInterface.get(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面的构造器引用，也就是调用StringBuilder类的构造方法来实现MyInteface函数式接口中唯一的抽象方法，当调用MyInterface接口的test()方法是，调用参数会传给StringBuilder构造器，从上面的程序中可以看出，调用myInterface对象的get()方法时，实际只传入了一个String类型的参数，这个String类型的参数会被传给StringBuilder的构造器。</p>
<h2 id="Lambda表达式和匿名内部类的联系和区别"><a href="#Lambda表达式和匿名内部类的联系和区别" class="headerlink" title="Lambda表达式和匿名内部类的联系和区别"></a>Lambda表达式和匿名内部类的联系和区别</h2><p>从前面介绍可以看出，Lambda 表达式是匿名内部类的一种简化，因此它可以部分取代匿名内部类的作用，Lambda 表达式与匿名内部类存在如下相同点。</p>
<ul>
<li>Lambda 表达式与匿名内部类一样，都可以直接访问”effectively final”的局部变量，以及外部 类的成员变量（包括实例变量和类变量）。</li>
<li>Lambda 表达式创建的对象与匿名内部类生成的对象一样，都可以直接调用从接口中继承的默认 方法。</li>
</ul>
<p>首先创建函数式接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.ano;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Display</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.ano;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTest</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Byte科技&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">book</span> <span class="operator">=</span> <span class="string">&quot;Java编程思想&quot;</span>;</span><br><span class="line">		<span class="type">Display</span> <span class="variable">display</span> <span class="operator">=</span> (a,b)-&gt;&#123;</span><br><span class="line">			<span class="comment">//访问外部类的实例变量</span></span><br><span class="line">			System.out.println(age);</span><br><span class="line">			<span class="comment">//访问外部类的类变量</span></span><br><span class="line">			System.out.println(name);</span><br><span class="line">			<span class="comment">//访问局部变量</span></span><br><span class="line">			System.out.println(book);</span><br><span class="line">			<span class="keyword">return</span> a+b;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">//调用display对象从接口继承的默认方法</span></span><br><span class="line">		display.print();</span><br><span class="line"><span class="comment">//		book = &quot;Java核心技术卷&quot;;</span></span><br><span class="line">		System.out.println(display.add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.ano;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">LambdaTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LambdaTest</span>();</span><br><span class="line">		test.test();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序使用Lambda表达式创建了一个Display接口的对象，Lambda表达式分别访问了外部类的实例变量，类变量从这些来看Lambda表达式的代码块和匿名内部类的方法体是相同的。<br>和匿名内部类相似，由于Lambda表达式访问了了book局部变量，因此该局部变量相当于有一个隐式的final修饰，不允许对book局部变量重新赋值。<br>当程序使用 Lambda 表达式创建了 Display 的对象之后，该对象不仅可调用接口中唯一的抽象方法，也可调用接口中的默认方法。<br>Lambda表达式与匿名内部类主要存在如下区别:</p>
<ul>
<li>匿名内部类可以为任意接口创建实例——不管接口包含多少个抽象方法，只要匿名内部类实现 所有的抽象方法即可;但 Lambda 表达式只能为函数式接口创建实例。</li>
<li>匿名内部类可以为抽象类甚至普通类创建实例;但 Lambda 表达式只能为函数式接口创建实例。</li>
<li>匿名内部类实现的抽象方法的方法体允许调用接口中定义的默认方法;但 Lambda 表达式的代 码块不允许调用接口中定义的默认方法。</li>
</ul>
<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>Java8 还新增了Stream、IntStream、LongStream、DoubleStream等流式API（注意：这里的Stream并不是IO中的Stream），这些API代表多个支持串行和并行聚集操作的元素。上面的4个接口中，Stream是一个通用的流接口，而IntStream、LongStream、DoubleStream则代表元素类型为int、long、double的流。<br>Java 8 还为上面每个流式 API 提供了对应的 Builder，例如 Stream.Builder、IntStream.Builder、 LongStream.Builder、DoubleStream.Builder，开发者可以通过这些 Builder 来创建对应的流 独立使用 Stream 的步骤如下∶</p>
<ol>
<li>使用 Stream 或 XxxStream 的 builder()类方法创建该 Stream 对应的 Builder。</li>
<li>重复调用 Builder 的 add()方法向该流中添加多个元素。</li>
<li>调用 Builder 的 build()方法获取对应的 Stream。</li>
<li>调用 Stream 的聚集方法。</li>
</ol>
<p>Stream提供了大量的方法进行聚集操作，这些方法可以是中间的，也可以是末端的。</p>
<ul>
<li>中间方法∶中间操作允许流保持打开状态，并允许直接调用后续方法。也就是说中间方法可以连续调用。</li>
<li>末端方法; 末端方法是对流的最终操作。当对某个 Stream 执行末端方法后，该流将会被”消耗” 且不再可用。换句话说就是末端方法一旦调用后就会关闭流，再不能对流进行操作，否则会抛出异常。</li>
</ul>
<p>下面先介绍Stream常用的中间方法：</p>
<ul>
<li>filter(Predicate predicate)∶ 过滤 Stream 中所有不符合 predicate 的元素。</li>
<li>mapToXxx(ToXxxFunction mapper)∶使用 ToXxxFunction 对流中的元素执行一对一的转换，该方 法返回的新流中包含了ToXxxFunction 转换生成的所有元素。</li>
<li>peek(Consumer action)∶ 依次对每个元素执行一些操作，该方法返回的流与原有流包含相同的元 素。该方法主要用于调试。</li>
<li>distinct()∶该方法用于排序流中所有重复的元素（判断元素重复的标准是使用 equals（）比较返回 true）。这是一个有状态的方法。</li>
<li>sorted()∶该方法用于保证流中的元素在后续的访问中处于有序状态。这是一个有状态的方法。</li>
<li>limit(long maxSize)∶ 该方法用于保证对该流的后续访问中最大允许访问的元素个数。这是一个 有状态的、短路方法。</li>
</ul>
<p>下面简单介绍一下 Stream 常用的末端方法。</p>
<ul>
<li>forEach(Consumer action)∶ 遍历流中所有元素，对每个元素执行 action。</li>
<li>toArray()∶将流中所有元素转换为一个数组。</li>
<li>reduce（）∶该方法有三个重载的版本，都用于通过某种操作来合并流中的元素。</li>
<li>min()∶ 返回流中所有元素的最小值。</li>
<li>max()∶ 返回流中所有元素的最大值。</li>
<li>count()∶ 返回流中所有元素的数量。</li>
<li>anyMatch(Predicate predicate)：判断流中是否至少包含一个元素符合 Predicate 条件。</li>
<li>allMatch(Predicate predicate)：判断流中是否每个元素都符合 Predicate 条件。</li>
<li>noneMatch(Predicate predicate)∶判断流中是否所有元素都不符合 Predicate 条件。</li>
<li>findFirst()∶ 返回流中的第一个元素。</li>
<li>findAny()∶返回流中的任意一个元素。</li>
</ul>
<p>下面，通过示例来学习Stream的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntStreamTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">IntStream</span> <span class="variable">is</span> <span class="operator">=</span> IntStream.builder()</span><br><span class="line">				.add(<span class="number">100</span>)</span><br><span class="line">				.add(<span class="number">10</span>)</span><br><span class="line">				.add(<span class="number">30</span>)</span><br><span class="line">				.add(<span class="number">40</span>)</span><br><span class="line">				.build();</span><br><span class="line">		<span class="comment">//调用聚集方法,下列方法都是末端方法，因此同时只能调用1个</span></span><br><span class="line"><span class="comment">//		System.out.println(&quot;最大值：&quot;+is.max().getAsInt());</span></span><br><span class="line"><span class="comment">//		System.out.println(&quot;最小值：&quot;+is.min().getAsInt());</span></span><br><span class="line"><span class="comment">//		System.out.println(&quot;总和：&quot;+is.sum());</span></span><br><span class="line"><span class="comment">//		System.out.println(&quot;总数&quot;+is.count());</span></span><br><span class="line"><span class="comment">//		System.out.println(&quot;平均值&quot;+is.average());</span></span><br><span class="line"><span class="comment">//		System.out.println(&quot;判断所有元素的是否都大于10:&quot;+is.allMatch(e-&gt;e&gt;10));</span></span><br><span class="line"><span class="comment">//		System.out.println(&quot;判断是否任意一个元素都大于10:&quot;+is.anyMatch(e-&gt;e&gt;20));</span></span><br><span class="line">		</span><br><span class="line">		is.forEach(System.out::println);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，Java8允许使用流式API来操作集合，这也是Stream的重要使用场景之一，Collection接口提供了stream()默认方法，该方法可以返回该集合对应的流，下面使用Stream来操作集合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListStreamDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="comment">//list中添加元素</span></span><br><span class="line">		list.add(<span class="string">&quot;Java编程思想&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;Java核心技术卷&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;Effective Java&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;Spring 入门与精通&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;并发编程之美&quot;</span>);</span><br><span class="line">		<span class="comment">//获取Stream</span></span><br><span class="line">		Stream&lt;String&gt; stream = list.stream();</span><br><span class="line">		<span class="comment">//统计包含Java字符串的元素总数</span></span><br><span class="line"><span class="comment">//		System.out.println(stream.filter(e-&gt;e.contains(&quot;Java&quot;)).count());</span></span><br><span class="line">		<span class="comment">//取出前3个元素</span></span><br><span class="line">		stream.limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的实例中首先获取了List的Stream，在代码20行对stream进行了过滤，筛选出了包含Java的字符串，然后调用了count()统计了过滤后的字符串个数。因为count()是末端方法，因此调用后再不能进行后续操作。代码22行是用limit取出了前3个元素，并对其进行了遍历。<br>需要注意的是，Stream对集合的操作并不影响List中保存的数据。</p>
]]></content>
  </entry>
  <entry>
    <title>Java泛型</title>
    <url>/2022/08/04/Java%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h1 id="Java泛型概述"><a href="#Java泛型概述" class="headerlink" title="Java泛型概述"></a>Java泛型概述</h1><p>在集合框架的内容中，对泛型已经有了初步的了解。泛型是JDK 1.5中新增的特性，在集合框架中使用，某种程度上是为了让集合记住其保存的元素的类型。在泛型产生之前，集合中存入一个元素，集合并不知道存入元素的数据类型，集合会把所有对象全部当做Object类型处理。当从集合中取出元素以后，就需要对元素进行向下转型，这样很容易引发ClassCastException异常。<br>当Java新增了泛型支持以后，集合就可以记住所添加元素的数据类型。并且在编译时可以检查被添加元素的数据类型，当试图添加和泛型规定的类型不一致的元素时会发生编译错误。<br>本章内将介绍泛型类、泛型接口、以及类型通配符、泛型方法等内容。</p>
<h2 id="泛型入门"><a href="#泛型入门" class="headerlink" title="泛型入门"></a>泛型入门</h2><p>在集合框架的内容中可以得知，集合中只能保存引用类型的数据，换句话说集合中只能保存对象。但是当把一个对象添加进集合时，集合并不确定被添加元素的类型，这是因为集合的设计者并不确定开发者会在集合中添加何种类型的元素，因此，设计者将所有的对象都当做Object对象处理，但是这么做会带来如下两个问题：</p>
<ul>
<li>集合对添加元素的类型没有限制，当存放时不会出现问题，但是在获取元素时，就有可能引发转型异常，例如一个集合中只能保存Student类型的对象，因为集合并不会对元素的类型进行检查，因此即使添加一个Teacher对象也不会出现问题。但是当取出元素时，将Object类型向下转型时，Teacher类型的对象转型时就会发生异常</li>
<li>当把对象放进集合时，集合会认为添加的类型都是Object类型的对象。取出时通常需要向下转型，这样无形中增加了编程的复杂度。</li>
</ul>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>JDK5以后，Java引入了泛型，即“参数化类型”。允许程序在创建集合时指定集合元素的类型（允许程序在创建对象或者调用方法时动态的指定）。例如：List&lt;Integer&gt;中只能添加Integer类型的对象，如果试图添加一个字符串时，将会发生编译错误。也就是说Java中参数化类型被称为泛型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericList</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//创建一个指保存Integer类型的List集合</span></span><br><span class="line">		List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">		<span class="comment">//向list中添加数据</span></span><br><span class="line">		list.add(<span class="number">20</span>);</span><br><span class="line">		list.add(<span class="number">30</span>);</span><br><span class="line">		list.add(<span class="number">40</span>);</span><br><span class="line">		<span class="comment">//向list中添加字符串，编译错误</span></span><br><span class="line"><span class="comment">//		list.add(&quot;Byte科技&quot;);</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上例中，创建了一个List集合，并且该List中只能保存Integer类型的对象（在List后增加了尖括号，在括号内放了Integer类型，此时这个尖括号连同里面的Integer类型表明此List只能存放Integer类型的对象）。在代码第13行试图在List中添加一个字符串，此时将发生编译错误。</p>
<h3 id="菱形语法"><a href="#菱形语法" class="headerlink" title="菱形语法"></a>菱形语法</h3><p>在Java 7以前，如果使用带泛型的接口、类定义变量，那么调用构造器创建对象时构造器后面也必须带泛型，例如下面的语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<p>在Java 7以前必须要这么书写，但是从Java 7以后，Java允许构造器后不需要带完整的泛型信息，只需要给出一对尖括号即可，Java编译器可以自动推断出尖括号中是什么数据类型。因此，上面的代码可以进行简化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>当将尖括号内的数据类型省略后，两个尖括号合并在一起很像是一个“菱形”，因此这种语法也被称为“菱形”语法。目的就是为了简化代码。</p>
<h2 id="深入泛型"><a href="#深入泛型" class="headerlink" title="深入泛型"></a>深入泛型</h2><p>所谓泛型，就是允许在定义类、接口、方法时使用类型形参，这个类型形参将在声明变量、创建对象、调用方法时动态地指定（即传入实际的类型参数，也可称为类型实参）。Java 5 改写了集合框架中的全部接口和类，为这些接口、类增加了泛型支持，从而可以在声明集合变量、创建集合对象时传入类型实参，这就是在前面程序中看到的 List&lt;String&gt;</p>
<h3 id="泛型类和泛型接口"><a href="#泛型类和泛型接口" class="headerlink" title="泛型类和泛型接口"></a>泛型类和泛型接口</h3><p>下面是List接口的代码片段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">    E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>List的接口声明比较简单，尖括号中的内容就是泛型的实质：允许在定义接口、类时声明类型形参，类型形参在整个接口、类中当成类型使用，几乎所有可使用普通类型的地方都可以使用这种类型形参。<br>例如使用List时，如果E形参传入String类型，则该List只能存放String类型的数据。<br>在开发中可以为任何类、接口增加泛型声明。下面定义一个自定义泛型Student类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&lt;T&gt; &#123;</span><br><span class="line">	<span class="keyword">private</span> T t;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(T t)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.t = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> T <span class="title function_">getT</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setT</span><span class="params">(T t)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.t = t;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> T <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//由于传给T形参的类型是String，因此构造器中只能是String类型</span></span><br><span class="line">		Student&lt;String&gt; s1 = <span class="keyword">new</span> <span class="title class_">Student</span>&lt;&gt;(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">		System.out.println(s1.getInfo());</span><br><span class="line">		<span class="comment">//由于传给T形参的是Double，所以构造器中只能是Double类型</span></span><br><span class="line">		Student&lt;Double&gt; s2 = <span class="keyword">new</span> <span class="title class_">Student</span>&lt;&gt;(<span class="number">2.0</span>);</span><br><span class="line">		System.out.println(s2.getInfo());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例中定义了一个带泛型声明的Student&lt;T&gt;类，使用Student&lt;T&gt;类是就可以为T类型传入实际类型。<br>定义泛型接口的方法和泛型类的方法类似，只需要在接口名后添加&lt;T&gt;即可。</p>
<h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><p>当使用一个泛型类型时（包括声明变量和创建对象两种情况），都应该为这个泛型类传入一个类型实参，如果没有传入类型实际参数，编译器就会提出泛型警告。例如如下示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中创建了一个ArrayList()集合，代码没有任何问题，但是由于List是一个有泛型声明的接口，此处使用List接口时没有传入实际类型参数，这将引起泛型警告。因此，要为List接口传入实际的类型参数——因为List集合里的元素类型是不确定的。修改上述代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java中可以使用类型通配符，类型通配符是一个问号（?）,将一个问号做为实际类型传给List集合，写作：List&lt;?&gt;，意思是元素类型未知的List。它的元素类型可以匹配任何类型。修改上例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	List&lt;?&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="comment">//编译错误</span></span><br><span class="line">	list.add(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这种带通配符的List仅表示它是各种泛型List的父类，并不能把元素加入到其中，上例中第4行就会发生编译错误，因为程序无法确定集合中元素的类型，所以不能向其中添加对象。查看List<E>接口源码可以发现，add()方法有参数类型E作为集合的元素类型，所以传给add的参数必须是E类对象或者其子类的对象，但是在上例中不知道E是什么类型，所以无法将任何对象添加进集合。</p>
<h3 id="通配符上限"><a href="#通配符上限" class="headerlink" title="通配符上限"></a>通配符上限</h3><p>如果想让上例中的代码正常工作，就需要学习通配符的上下限，也就是说我们得给定统配符的上限或者下限，本小节内，将介绍通配符上限的内容。<br>Java 泛型不仅允许在使用通配符形参时设定上限，而且可以在定义类型形参时设定上限，用于表示传给该类型形参的实际类型要么是该上限类型，要么是该上限类型的子类。下面程序示范了这种用法。<br>所谓通配符的上限就是规定泛型通配符在传入化类型时只能是某个类本身或者其子类。下面通过示例来学习：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Teacher&lt;Number&gt; t1 = <span class="keyword">new</span> <span class="title class_">Teacher</span>&lt;&gt;();	</span><br><span class="line">		Teacher&lt;Integer&gt; t2 =<span class="keyword">new</span> <span class="title class_">Teacher</span>&lt;&gt;();</span><br><span class="line">		Teacher&lt;Double&gt; t3 = <span class="keyword">new</span> <span class="title class_">Teacher</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//编译错误，因为String和Number不存在继承关系</span></span><br><span class="line">		Teacher&lt;String&gt; t4 = <span class="keyword">new</span> <span class="title class_">Teacher</span>&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上例中定义了一个泛型类，并且设置了泛型的上限Number，也就是说，当创建Teacher对象指定泛型类型时，只能传入Number类型或者Number类型的子类，在测试类中，分别传入了Number类型，Integer类型和Double类型，因为这些类型都是Number类型的子类，但是当传入String类型时，因为String并不是Number类型的子类，所以第9行代码会出现编译错误。所以设置通配符上限的目的就是限定参数化类型的传入值，只能是限定类型或者限定类型的子类。</p>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>前面介绍了在定义类、接口时可以使用类型形参，在该类的方法定义和成员变量定义、接口的方法定义中，这些类型形参可被当成普通类型来用。在另外一些情况下，定义类、接口时没有使用类型形参，但定义方法时想自己定义类型形参，这也是可以的，Java 5 还提供了对泛型方法的支持。</p>
<h3 id="定义泛型方法"><a href="#定义泛型方法" class="headerlink" title="定义泛型方法"></a>定义泛型方法</h3><p>所谓泛型方法就是在声明方法时定义一个或多个类型形参，泛型方法的语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 &lt;T&gt; 返回值类型 方法名(形参列表)&#123;</span><br><span class="line"> 	<span class="comment">//方法体   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面通过实例学习泛型方法的定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本例将演示泛型方法的定义及使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MR.W</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Master</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; T <span class="title function_">say</span><span class="params">(T t)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Master</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Master</span>();</span><br><span class="line">		<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> m.say(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		System.out.println(s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中第8行定义了一个泛型方法，并且指定了say()方法的参数和返回值都是指定的参数化类型，在main()方法中调用say()方法时，由于传入了一个String类型的参数，因此该方法的返回值类型也是指定的String类型，如果在第13行中将say的方法参数修改为整型，那么这个方法的返回值类型也会变成Integer类型，此时再使用String类型的变量接收返回值就会编译出错。<br>需要着重注意的是，在类和接口中定义的泛型，泛型的作用域是在当前类中，而方法中定义的泛型其作用域只是在当前方法。</p>
<h3 id="通配符下限"><a href="#通配符下限" class="headerlink" title="通配符下限"></a>通配符下限</h3><p>在上一节中学习了通配符的上限，同样也可以规定，通配符的下限。一旦规定了通配符下限，则只能传入指定类型的父类。在TreeSet的构造方法中就是用了通配符下限。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">NavigableSet</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(comparator));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中就是用了通配符的下限，也就是说在使用该构造方法时，?所能传入的类型只能是E的父类，而E的类型则是在创建TreeSet对象时指定的对象。请看下面的示例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		TreeSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码可以看出Comparator接口中定义了泛型下限，下限是创建TreeSet时规定了泛型是String类型，因此Comparator接口中的泛型只能是String或者其父类，如果修改为Integer类型，则会编译出错。</p>
<h2 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h2><p>在严格的泛型代码里，带泛型声明的类总应该带着类型参数。但为了与老的 Java 代码保持—致，也允许在使用带泛型声明的类时不指定实际的类型参数。如果没有为这个泛型类指定实际的类型参数，则该类型参数被称作 raw type（原始类型），默认是声明该类型参数时指定的第一个上限类型。<br> 当把一个具有泛型信息的对象赋给另一个没有泛型信息的变量时，所有在尖括号之间的类型信息都将被扔掉。比如一个 List&lt;String&gt;类型被转换为 List，则该 List 对集合元素的类型检查变成了类型参数的上限（即 Object）。下面程序示范了这种擦除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bird</span>&lt;T <span class="keyword">extends</span> <span class="title class_">CharSequence</span>&gt; &#123;</span><br><span class="line">	<span class="keyword">private</span> T type;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> T <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> type;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setType</span><span class="params">(T type)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.type = type;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序中定义了一个泛型类，并且泛型规定了上限，只能是CharSequence的子类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BirdTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Bird&lt;String&gt; b = <span class="keyword">new</span> <span class="title class_">Bird</span>&lt;String&gt;();</span><br><span class="line">		b.setType(<span class="string">&quot;麻雀&quot;</span>);</span><br><span class="line">		<span class="comment">//泛型擦除</span></span><br><span class="line">		<span class="type">Bird</span> <span class="variable">b2</span> <span class="operator">=</span>b;</span><br><span class="line">		<span class="comment">//此时泛型已经擦除了，编译器只知道getType的类型是CharSequence</span></span><br><span class="line">		<span class="comment">//并不知道是具体哪个子类，因此编译出错</span></span><br><span class="line"><span class="comment">//		String s = b2.getType();</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在测试类中创建了Bird类的对象b，并且制定了泛型为String类型，将b赋值给不带泛型的对象b2，此时编译器就会丢失b对象的泛型信息，即所有尖括号中的信息都会丢失。在代码11行，调用getType()方法时，此时编译器只知道该方法的返回值是CharSequence，但是具体是哪个子类就不清楚了，所以出现编译错误。</p>
]]></content>
  </entry>
  <entry>
    <title>JavaIO流</title>
    <url>/2022/08/04/JavaIO%E6%B5%81/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h1 id="Java-IO流概述"><a href="#Java-IO流概述" class="headerlink" title="Java IO流概述"></a>Java IO流概述</h1><p>在日常的开发中，经常会遇到对本地文件进行操作的功能，例如将数据库中的数据导出成Excel并保存在本地，或者将本地的文本文件读入程序中，再或者在本地新建目录删除目录等等。这些都需要对本地文件进行读写。<br>Java为开发者提供了File类用于操作本地的文件，File类是java.io包下代表与平台无关的文件和目录，也就是说，如果希望在程序中操作文件和目录，都可以通过File类来完成。值得指出的是，不管是文件还是目录都是使用File来操作的，File能新建、删除、重命名文件和目录，File不能访问文件内容本身。如果需要访问文件内容本身，则需要使用输入&#x2F;输出流。</p>
<h2 id="访问文件和目录"><a href="#访问文件和目录" class="headerlink" title="访问文件和目录"></a>访问文件和目录</h2><p>File类可以使用文件路径字符串来创建File实例，该文件路径字符串既可以是绝对路径，也可以是相对路径。一旦创建了File对象后，就可以调用File对象的方法来访问，File类提供了很多方法来操作文件和目录，下面列出一些比较常用的方法。</p>
<h3 id="访问文件名"><a href="#访问文件名" class="headerlink" title="访问文件名"></a>访问文件名</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>String getName()</td>
<td>返回File对象的文件名或者路径名</td>
</tr>
<tr>
<td>String getPath()</td>
<td>返回File对象对应的路径名</td>
</tr>
<tr>
<td>File getAbsoluteFile()</td>
<td>返回File对象的绝对路径</td>
</tr>
<tr>
<td><strong>String getAbsolutePath()</strong></td>
<td>返回File对象的绝对路径名</td>
</tr>
<tr>
<td>String getParent()</td>
<td>返回File对象的父目录</td>
</tr>
<tr>
<td>boolean renameTo(File newName)</td>
<td>重命名文件</td>
</tr>
</tbody></table>
<p>下面通过示例来学习以上方法的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">bytecollege</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;E:/ByteCollege/study/Node.exe&quot;</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path);</span><br><span class="line">        <span class="type">File</span> <span class="variable">newFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:/ByteCollege/study/Code.exe&quot;</span>);</span><br><span class="line">        <span class="comment">//返回File对象的文件名或者路径名</span></span><br><span class="line">        System.out.println(file.getName());</span><br><span class="line">        <span class="comment">//返回File对象对应的路径名</span></span><br><span class="line">        System.out.println(file.getPath());</span><br><span class="line">        <span class="comment">//返回File对象的绝对路径</span></span><br><span class="line">        System.out.println(file.getAbsoluteFile());</span><br><span class="line">        <span class="comment">//返回File对象的绝对路径名</span></span><br><span class="line">        System.out.println(file.getAbsolutePath());</span><br><span class="line">        <span class="comment">//返回File对象的父亲目录</span></span><br><span class="line">        System.out.println(file.getParent());</span><br><span class="line">        <span class="comment">//重命名文件</span></span><br><span class="line">        file.renameTo(newFile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后的结果为：</p>
<p><img src="https://files.catbox.moe/x1sr3b.png"></p>
<h3 id="文件检测相关方法"><a href="#文件检测相关方法" class="headerlink" title="文件检测相关方法"></a>文件检测相关方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>boolean exists()</strong></td>
<td>判断File对象所对应的文件或目录是否存在</td>
</tr>
<tr>
<td>boolean canWrite()</td>
<td>判断文件和目录是否可写</td>
</tr>
<tr>
<td>boolean canRead()</td>
<td>判断文件和目录是否可读</td>
</tr>
<tr>
<td><strong>boolean isFile()</strong></td>
<td>判断是否是文件</td>
</tr>
<tr>
<td><strong>boolean isDirectory()</strong></td>
<td>判断是否是目录</td>
</tr>
<tr>
<td>boolean isAbsolute()</td>
<td>判断是否是绝对路径</td>
</tr>
<tr>
<td>boolean isHidden()</td>
<td>判断文件是否隐藏</td>
</tr>
</tbody></table>
<p>下面通过示例来学习以上方法的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.IODemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/BYTE/study/Node.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//判断File对象所对应的文件或目录是否存在</span></span><br><span class="line">        System.out.println(file.exists());</span><br><span class="line">        <span class="comment">//判断文件和目录是否可写</span></span><br><span class="line">        System.out.println(file.canWrite());</span><br><span class="line">        <span class="comment">//判断文件和目录是否可读</span></span><br><span class="line">        System.out.println(file.canRead());</span><br><span class="line">        <span class="comment">//判断是否是文件</span></span><br><span class="line">        System.out.println(file.isFile());</span><br><span class="line">        <span class="comment">//判断是否是目录</span></span><br><span class="line">        System.out.println(file.isDirectory());</span><br><span class="line">        <span class="comment">//判断是否是绝对路径</span></span><br><span class="line">        System.out.println(file.isAbsolute());</span><br><span class="line">        <span class="comment">//判断文件是否隐藏</span></span><br><span class="line">        System.out.println(file.isHidden());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取文件信息"><a href="#获取文件信息" class="headerlink" title="获取文件信息"></a>获取文件信息</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>long lastModified()</td>
<td>最后一次修改时间，返回值为修改时间的毫秒数</td>
</tr>
<tr>
<td><strong>long lenght()</strong></td>
<td>获取文件长度，单位为字节</td>
</tr>
</tbody></table>
<p>下面通过示例来学习以上方法的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.IODemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/BYTE/study/Node.txt&quot;</span>);</span><br><span class="line">        System.out.println(file.lastModified());</span><br><span class="line">        System.out.println(file.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后的结果为：</p>
<p><img src="https://files.catbox.moe/9fx0o4.png"></p>
<h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>boolean mkdir()</strong></td>
<td>创建新目录</td>
</tr>
<tr>
<td><strong>boolean mkdirs()</strong></td>
<td>创建多层目录</td>
</tr>
<tr>
<td><strong>String[] list()</strong></td>
<td>列出File对象子文件名和路径名，返回String数组</td>
</tr>
<tr>
<td><strong>File[] listFiles()</strong></td>
<td>列出File对象的索引子文件和路径</td>
</tr>
<tr>
<td><strong>static File[] listRoots()</strong></td>
<td>获取系统根路径</td>
</tr>
<tr>
<td>boolean delete()</td>
<td>删除文件或者路径，如果有多层路径，调用1次只删除最后一层目录，并且目录必须为空</td>
</tr>
</tbody></table>
<p>下面通过示例来学习以上方法的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.IODemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/BYTE/study/Node.txt&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/BYTE/study/code&quot;</span>);</span><br><span class="line">        <span class="comment">//创建新目录</span></span><br><span class="line">        file2.mkdir();</span><br><span class="line">        <span class="comment">//创建多层目录</span></span><br><span class="line">        file2.mkdirs();</span><br><span class="line">        <span class="comment">//列出File对象子文件名和路径名，返回String数组</span></span><br><span class="line">        file2.list();</span><br><span class="line">        <span class="comment">//列出File对象的索引子文件和路径</span></span><br><span class="line">        file.listFiles();</span><br><span class="line">        <span class="comment">//获取系统根目录</span></span><br><span class="line">        file.listRoots();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取分区大小"><a href="#获取分区大小" class="headerlink" title="获取分区大小"></a>获取分区大小</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>long getTotalSpace()</td>
<td>获取分区大小</td>
</tr>
<tr>
<td>long getFreeSpace()</td>
<td>获取分区空闲大小</td>
</tr>
<tr>
<td>long getUsableSpace()</td>
<td>获取分区可用大小</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package cn.bytecollege.IODemo;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line"></span><br><span class="line">public class FileDemo4 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String path = &quot;D:/&quot;;</span><br><span class="line">        File file = new File(path);</span><br><span class="line">        //获取分区大小</span><br><span class="line">        System.out.println(file.getTotalSpace());</span><br><span class="line">        //获取分区空闲大小</span><br><span class="line">        System.out.println(file.getFreeSpace());</span><br><span class="line">        //获取分区可用空间大小</span><br><span class="line">        System.out.println(file.getUsableSpace());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后的结果为：</p>
<p><img src="https://files.catbox.moe/ja9op3.png"></p>
<h2 id="Java中的I-x2F-O流"><a href="#Java中的I-x2F-O流" class="headerlink" title="Java中的I&#x2F;O流"></a>Java中的I&#x2F;O流</h2><p>Java中I&#x2F;O流是实现输入&#x2F;输出的基础，可以方便的实现输入和输出操作，Java中把不同的输入&#x2F;输出源抽象表述为“流”，通过流的方式运行Java程序使用相同的方式来访问不同的输入&#x2F;输出源，这里的流可以理解为字节序列，通俗一点说就是一串0和1。</p>
<h3 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h3><p>流的分类可以从以下两个角度划分：</p>
<ol>
<li>流向：按照流的流向来分可以分为输入流和输出流，其中输入流只能从中读取数据，而不能向其写入数据；输出流只能向其写入数据，而不能从中读取数据。</li>
<li>读取单元：按照读取单元划分，流可以分为字节流和字符流，顾名思义所谓字节流就是输入和输出的基本单位都是字节，而字符流输入输出的基本单元都是字符。</li>
</ol>
<p>上面提到的输入和输出都涉及到方向的问题，这里的输入和输出都是从程序运行所在的内存角度划分的，也就是说从硬盘或者网络读取到程序运行内存中的流叫做输入流，反之从内存中写入硬盘的流则叫做输出流，换句话说，输入流和输出流都是以当前程序运行的内存作为参照物。<br>Java中输入流主要使用InputStream和Reader作为基类，而输出流主要使用OutputStream和Writer作为基类，它们都是一些抽象类，无法直接创建实例。</p>
<p><img src="https://files.catbox.moe/ciwosa.png"></p>
<h3 id="流的概念模型"><a href="#流的概念模型" class="headerlink" title="流的概念模型"></a>流的概念模型</h3><p>Java把所有设备里的有序数据抽象成流模型，简化了输入&#x2F;输出处理，理解了流的概念模型也就了解了Java IO。<br>Java中有关IO流的类都是从如下4个抽象类中派生的。</p>
<ul>
<li>InputStream&#x2F;Reader：所有输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream&#x2F;Writer：所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<p>对于InputStream和Reader而言，它们把输入设备抽象成一个“水管”，这个水管里的每个“水滴”依次排列，如下图所示：</p>
<p><img src="https://files.catbox.moe/hvvppe.png"></p>
<p>字节流和字符流的处理方式其实非常相似，只是它们处理的输入&#x2F;输出单位不同而已。输入流使用隐式的记录指针来表示当前正准备从哪个“水滴”开始读取，每当程序从InputStream或Reader里取出一个或多个“水滴”后，记录指针自动向后移动；除此之外，InputStream和Reader里都提供一些方法来控制记录指针的移动。<br>对于OutputStream和Writer而言，它们同样把输出设备抽象成一个“水管”，只是这个水管里没有任何水滴。<br>当执行输出时，程序相当于依次把“水滴”放入到输出流的水管中，输出流同样采用隐式的记录指针来标识当前水滴即将放入的位置，每当程序向OutputStream或Writer里输出一个或多个水滴后，记录指针自动向后移动。</p>
<h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><h4 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h4><p>InputStream是输入流的基类，读取的最小单元是字节。由于InputStream是抽象类，所以其本身并不能创建实例来执行输入。但它们将成为所有输入流的模板，所以它们的方法是所有输入流都可使用的方法。<br>InputStream里包含如下方法：</p>
<ul>
<li>int read()：从输入流中读取单个字节（相当于从如图所示的水管中取出一滴水），返回所读取的字节数据（字节数据可直接转换为int类型）。</li>
<li>int read(byte[]b)：从输入流中最多读取b.length个字节的数据，并将其存储在字节数组b中，返回实际读取的字节数。</li>
<li>int read(byte[]b,int off,int len)：从输入流中最多读取len个字节的数据，并将其存储在数组b中，放入数组b中时，并不是从数组起点开始，而是从off位置开始，返回实际读取的字节数。</li>
</ul>
<p>InputStream有个子类用于读取文件的输入流：FileInputStream，下面的程序将示范FileInputStream的使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.IODemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;D:/BYTE/study/Node.txt&quot;</span>;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">            <span class="type">byte</span>[] ch = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> length;</span><br><span class="line">            <span class="keyword">while</span> ((length = fileInputStream.read(ch)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(ch));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后的结果为：</p>
<p><img src="https://files.catbox.moe/tm3v9q.png"></p>
<h4 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h4><p>OutputStream是输出流的基类，输入的最小单元是字节。它提供了如下方法：</p>
<ul>
<li>void write(int c)：将指定的字节输出到输出流中，其中c既可以代表字节，也可以代表字符。</li>
<li>void write(byte[] buf)：将字节数组中的数据输出到指定输出流中。</li>
<li>void write(byte[] buf,int off,int len)：将字节数组中从off位置开始，长度为len的字节&#x2F;字符输出到输出流中。</li>
</ul>
<p>同样OutputStream也有子类用于输入文件流：FileOutputStream，下面的程序将示范FileOutputStream的使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.IODemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/BYTE/study/byte.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//创建文件</span></span><br><span class="line">            file.createNewFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException  e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//实例化FileOutputStream</span></span><br><span class="line">            <span class="type">FileOutputStream</span>  <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Bulid Your Technical Excellence&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;str.length();i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">int</span>)str.charAt(i);</span><br><span class="line">                fileOutputStream.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，同时使用输入流和输出流来复制文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytcollege.io.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;D:/BYTE/study/Node.txt&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> <span class="string">&quot;F:/Node.txt&quot;</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;----------------copy  start-----------------------&quot;</span>);</span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            copy(input,output);</span><br><span class="line">            <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">&quot;-----------------copy over!-----------------------&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;------------------&quot;</span>+(end-start)+<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(String input,String output)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(input);</span><br><span class="line">                <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(output);</span><br><span class="line">                <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fis);</span><br><span class="line">                <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fos);</span><br><span class="line">                <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">10</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> ((i=bis.read(bytes))&gt;-<span class="number">1</span>)&#123;</span><br><span class="line">                    bos.write(bytes);</span><br><span class="line">                &#125;</span><br><span class="line">                bis.colse();</span><br><span class="line">                bos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Java的IO流执行输出时，不要忘记关闭输出流，关闭输出流除了可以保证流的物理资源被回收之外，可能还可以将输出流缓冲区中的数据flush到物理节点里（因为在执行close()方法之前，自动执行输出流的flush()方法）</p>
<h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h4><p>在Reader里包含如下3个方法：</p>
<ul>
<li>int read()：从输入流中读取单个字符（相当于如图所示的水管中取出一滴水），返回所读取的字符数据（字符数据可直接转换为int类型）。</li>
<li>int read(char[]cbuf)：从输入流中最多读取cbuf.length个字符的数据，并将其存储在字符数组cbuf中，返回实际读取的字符数。</li>
<li>int read(char[]cbuf,int off,int len)：从输入流中最多读取len个字符的数据，并将其存储在字符数组cbuf中，放入数组cbuf中时，并不是从数组起点开始，而是从off位置开始，返回实际读取的字符数。</li>
</ul>
<p>对比InputStream和Reader所提供的方法，就不难发现这两个基类的功能基本是一样的，只是InputStream读取的最小单位是字节，而Reader读取的最小单位是字符。<br>Reader也有一个子类FileReader用于实现字符的读取，下面通过示例来学习FileReader的用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.IODemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;d:/BYTE/study/Node.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">while</span>((i=reader.read(chars))&gt;-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(chars,<span class="number">0</span>,i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h4><p>Writer抽象类中的方法和OutputStream方法类似，只需要将方法参数中的byte[]更换成char[]即可，字符流直接以字符作为操作单位，所以Writer可以用字符串来代替字符数组，即以String对象作为参数。Writer里还包含如下两个方法。</p>
<ul>
<li>void write(String str)：将str字符串里包含的字符输出到指定输出流中。</li>
<li>void write(String str,int off,int len)：将str字符串里从off位置开始，长度为len的字符输出到指定输出流中。</li>
</ul>
<p>同样Writer也有一个子类FileWriter用于实现字符的输出，下面通过示例来学习Writer的子类FileWirter的用法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.IODemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriterDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;d:/BYTE/study/Node.txt&quot;</span>);</span><br><span class="line">        <span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;F:/2.txt&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">while</span>((i=reader.read(chars))&gt;-<span class="number">1</span>)&#123;</span><br><span class="line">            writer.write(chars);</span><br><span class="line">        &#125;</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h2><p>对象序列化的目标是将对象保存到磁盘中，或允许在网络中直接传输对象。对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，通过网络将这种二进制流传输到另一个网络节点。其他程序一旦获得了这种二进制流（无论是从磁盘中获取的，还是通过网络获取的），都可以将这种二进制流恢复成原来的Java对象。<br>序列化机制允许将实现序列化的Java对象转换成字节序列，这些字节序列可以保存在磁盘上，或通过网络传输，以备以后重新恢复成原来的对象。序列化机制使得对象可以脱离程序的运行而独立存在。对象的序列化（Serialize）指将一个Java对象写入IO流中，与此对应的是，对象的反序列化（Deserialize）则指从IO流中恢复该Java对象。<br>如果需要让某个对象支持序列化机制，则必须让它的类是可序列化的（继承serializable接口，该接口是一个标记接口，实现该接口无须实现任何方法，它只是表明该类的实例是可序列化的）<br>使用Serializable来实现序列化非常简单，主要让目标类实现Serializable标记接口即可，无须实现任何方法。<br>一旦某个类实现了Serializable接口，该类的对象就是可序列化的，程序可以通过如下两个步骤来序列化该对象。</p>
<ol>
<li>创建一个ObjectOutputStream</li>
<li>调用ObjectOutputStream对象的writeObject()方法输出可序列化对象</li>
</ol>
<p>下面通过示例来学了对象的序列化和反序列化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.IODemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> cn.bytecollege.IODemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;student.txt&quot;</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file));</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        oos.writeObject(student);</span><br><span class="line"></span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file));</span><br><span class="line">        <span class="type">Student</span> <span class="variable">newStudent</span> <span class="operator">=</span> (Student)ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line">        System.out.println(newStudent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：<br>1.如果修改类是仅修改了方法，则反序列化不受任何影响。不需要修改serialVersionUID的值<br>2.如果修改类时仅仅修改了静态变量或者transient实例变量，则反序列化不受任何影响。不需要修改serialVersionUID的值。<br>3.如果修改类时修改了非瞬时的实例变量，则可能导致序列化版本不兼容。如果对象流中的对象和新类中包含同名的实例变量，而实例变量<strong>类型</strong>不同，则反序列化失败，类定义应该更新serialVersionUID类变量的值。如果对象流中的对象比新类中包含更多的实例变量，则多出的实例变量值被忽略，序列化版本可以兼容，类定义可以不更新serialVersionUID的值。如果新类比对象流中的对象包含更多的实例变量，则序列化版本也可以兼容，类定义可以不更新serialVersionUID的值。但反序列化的对的新对象中多出的实例变量值都是null。</p>
<h3 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h3><ol>
<li>遍历任意盘，打印出该盘中所有的只读文件的名称。</li>
<li>遍历任意盘，打印出该盘中所有的隐藏文件的名称。</li>
<li>遍历任意盘，打印出该盘中所有的路径及文件名称。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>HashMap添加元素及扩容机制</title>
    <url>/2022/08/05/HashMap%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E5%8F%8A%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h1 id="HashMap添加元素的过程"><a href="#HashMap添加元素的过程" class="headerlink" title="HashMap添加元素的过程"></a>HashMap添加元素的过程</h1><p><img src="https://files.catbox.moe/gqygu3.jpg"></p>
<p><strong>理解一：</strong></p>
<p>HashMap map &#x3D; new HashMap();</p>
<p>在实例化以后，添加第一个元素时，HashMap底层就会创建了一个长度为16的一位table数组</p>
<p>添加元素的时候调用hashCode方法，得到要添加元素的哈希值，通过哈希值得到数组的索引值</p>
<p>通过得到的索引值判断该位置是否有元素，如果没有元素则直接添加</p>
<p>有元素的话，则判断该元素的key是否和要添加元素的key是否一致，如果一致则直接覆盖</p>
<p>如果key值不一致，则需要判断这个位置的元素结点是链表的结点还是红黑树的结点</p>
<p>若是红黑树的结点则以红黑树的方式插入</p>
<p>若是链表的结点，则遍历链表，插入该元素，插入过程中key值一致则覆盖，不一致添加至下一位</p>
<p>重复以上在链表下存储结点的过程，若链表的长度大于8 但是数组的长度小于64</p>
<p>则数组扩容，链表转换为红黑树存放数据。</p>
<p>在数组中添加元素到达规定的阈值时，则对数组进行扩容，继续添加元素。</p>
<p><strong>理解二：</strong></p>
<p>首先添加第一个元素，若存放元素的数组table为null或里面没有元素，就去对数组进行扩容，扩容后，初始值为16，<br>然后根据传入的key,经过hash计算，得到关键码值（位置索引）</p>
<p>再判断table[i]是否等于null，如果为null，则直接将这个元素添加在该数组下标所在位置</p>
<p>如果table[i]不等于null，则表示该下标处已有元素</p>
<p>再判断已存在的元素的key值是不是等于要添加元素的key值。</p>
<p>如果相等，则直接覆盖已存在的元素</p>
<p>如果不相等，则判断存储在table[i]位置元素的数据结构是不是红黑树，如果是则用红黑树的方式插入</p>
<p>如果不是，则说明它所在位置元素是以链表的方式存储的</p>
<p>遍历链表，判断要添加元素的key是否存在</p>
<p>如果不存在，则直接添加在链表末尾</p>
<p>如果存在，则将已存在的元素直接覆盖，将自己的value赋值给已存在元素的value。</p>
<p>下一次如果继续有元素要添加在table[i]这个位置下，则重复以上添加操作，当所在链表的长度大于8之后，就将其存储元素方式，转换为红黑树方式存储。</p>
<p>每次成功添加一个元素后，就让元素个数加一，如果元素个数大于初始阈值threshold（12）则需要对table数组进行扩容。扩容之后重复以上操作，添加元素。</p>
<h1 id="HashMap扩容机制"><a href="#HashMap扩容机制" class="headerlink" title="HashMap扩容机制"></a>HashMap扩容机制</h1><p>HashMap的底层有数组 + 链表(红黑树)组成，数组的大小可以在构造方法时设置，默认大小为16，数组中每一个元素就是一个链表，jdk7之前链表中的元素采用头插法插入元素，jdk8之后采用尾插法插入元素，由于插入的元素越来越多，查找效率就变低了，所以满足某种条件时，链表会转换成红黑树。随着元素的增加，HashMap的数组会频繁扩容，如果构造时不赋予加载因子默认值，那么负载因子默认值为0.75,数组扩容的情况如下:<br>1:当添加某个元素后，数组的总的添加元素数大于了 数组长度 * 0.75(默认,也可自己设定),数组长度扩容为两倍。(如开始创建HashMap集合后，数组长度为16，临界值为16 * 0.75 &#x3D; 12，当加入元素后元素个数超过12，数组长度扩容为32，临界值变为24)</p>
<p>2：在没有红黑树的条件下，添加元素后数组中某个链表的长度超过了8，数组会扩容为两倍.(若开始创建HashMAp集合后，假设添加的元素都在一个链表中，当链表中元素为8时，再在链表中添加一个元素，此时若数组中不存在红黑树，则数组会扩容为两倍变成32，假设此时链表元素排列不变，再在该链表中添加一个元素，数组长度再扩容两倍，变为64，假设此时链表元素排列还是不变，则此时链表中存在10个元素，这是HashMap链表元素数存在的最大值，此时，再加入元素，满足了链表树化的两个条件(1:数组长度达到64, 2:该链表长度达到了8)，该链表会转换为红黑树</p>
<p><strong>HashMap创建的底层原理</strong></p>
<p>1:首先创建HashMap集合时，在不手动赋值的情况下会先设置默认负载因子0.75</p>
<p>2.向集合值添加元素会调用putVal()方法，前三个参数分别为<a href="https://so.csdn.net/so/search?q=hash&spm=1001.2101.3001.7020">hash</a>(key),key,value，即hash值，键值对。</p>
<p>3.hash(key)方法计算hash值</p>
<p> 计算方法是键的hashCode()方法与高位16进行异或运算得到hash值</p>
<p> 4.进入putVal方法，首先看上半部分</p>
<p> 首先判断数组中是否已经创建，此时还创建数组，所以此时调用</p>
<p>resize()方法设置初始容量<br>若未在构造方法时设置初始容量，则初始容量设置为16.(注意容量只能为2的倍数，即使输入的不是2的倍数也会自动转换)</p>
<p>将元素存储在i &#x3D; (n - 1) &amp; hash的下标链表中，因为此时为加入元素所以table[i]一定是null,元素一定会存入到数组中。 5.接着会跳过之后的判断语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">size代表了此时集合中已经加入的元素个数，当其值大于了临界值</span><br><span class="line">threshold(此时为<span class="number">12</span>)时，会调用resize()方法进行二倍扩容</span><br></pre></td></tr></table></figure>

<p>6.添加完第一个元素后继续添加下一个元素，因为重写了hashCode()方法，让两个元素的hash值相同，所以它们会存储在同一个链表中，进入putVal()方法后，上面的第一个if语句为false,因为已经初始化了数组，第二个if也是false，因为当前链表下的头元素已经存在，它会进入if语句的分支else语句</p>
<p> 7.第一个if语句判断链表中头元素与当前插入的元素是否是同一个元素(hash()方法与equals()方法比较)</p>
<p>这里重写了hash()方法所以hash值相同但两种内容不同所以进入else分支，判断当前数组中的结点是链表还是红黑树，如果是红黑树，就按红黑树的添加方式添加。此时我们还未形成红黑树，所以不会执行，进入else语句。</p>
<p>8.接下来进入一个死循环，死循环结束有两种方式</p>
<p>1.第一种结束方式:链表中没有找到与当前添加元素相同的元素(euqals()方法比较),就会用尾插法在链表末尾插入这个添加的元素，然后会进行if判断，判断添加元素前当前链表中元素是否达到了8，如果达到了，进入</p>
<p>treeifyBin(tab, hash)语句，在该语句中，我们只关注前半部分，在数组容量小于64时，数组会调用<br>resize()方法扩容为2倍 2.第二种结束方式</p>
<p>还是在for循环中，如果找到了与添加元素相同的元素(euqals()方法比较),直接跳出循环。然后进入if语句，覆盖掉链表中元素的“值”(value)，</p>
<p> 9.之后更新集合中元素的个数，判断是否超过了临界值，超过了就会扩容为2倍</p>
<h1 id="Java集合体系概述"><a href="#Java集合体系概述" class="headerlink" title="Java集合体系概述"></a>Java集合体系概述</h1><p>Java集合大致可以分为List、Set、Map和Queue，其中List代表有序、可重复的集合，Set代表无序、不可重复的集合，而Map则代表具有映射关系的集合。Queue 用于模拟队列这种数据结构，队列通常是指”先进先出”（FIFO）的容器。队列的头部保存在队列中存放时间最长的元素，队列的尾部保存在队列中存放时间最短的元素。新元素插入（offer）到队列的尾部，访问元素（poll）操作会返回队列头部的元素。通常，队列不允许随机访问队列中的元素。</p>
<h2 id="ArrayList和Vector"><a href="#ArrayList和Vector" class="headerlink" title="ArrayList和Vector"></a>ArrayList和Vector</h2><p>和ArrayList具有相同功能的类是Vector，Vector是Java早期提供的一个集合类，Vector和ArrayList的方法以及底层的实现基本相似，唯一不同的是Vector的方法都是线程安全的，打开Vector源码可以发现Vector的方法都是用synchronized修饰的（关于synchronized修饰符，会在多线程中讲解），因此Vector效率低于ArrayList。除此之外ArrayList和Vector的区别还体现在以下几个方面：</p>
<ol>
<li>ArrayList扩容后的长度是原长度的1.5倍，而Vector扩容后的长度是原长度的2倍</li>
<li>ArrayList调用无参构造方法创建对象时，会创建一个空的Object数组，当添加第一个元素时进行扩容，初始容量为10，当Vector调用无参构造创建对象时，则会直接初始化保存数据的数组，长度为10。</li>
</ol>
<h2 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h2><p>ArrayList和LinkedList虽然都是List接口的子类，但是在底层实现以及效率上存在以下区别</p>
<ol>
<li>ArrayList和LinkedList都实现了List接口</li>
<li>ArrayList和LinkedList都是非线程安全的，因此在多线程环境下可能会出现出现不同步的情况</li>
<li>ArrayList底层实现是数组，LinkedList底层实现是双向链表</li>
<li>ArrayList因为底层实现是数组，并且支持随机访问因此查找效率高，但是ArrayList在新增元素时会扩容以及复制数组元素，并且删除时也会进行数组复制，所以增删效率低。而LinkedList不支持随机访问，获取元素时必须从首节点开始从前往后遍历查找，因此查找效率低。但是增加和删除时最多涉及到两个节点的操作，因此增删效率高。</li>
</ol>
<h2 id="HashMap和Hashtable"><a href="#HashMap和Hashtable" class="headerlink" title="HashMap和Hashtable"></a>HashMap和Hashtable</h2><p>HashMap 和 Hashtable 都是 Map 接口的典型实现类，它们之间的关系完全类似于 ArrayList 和 Vector的关系∶ Hashtable 是一个古老的 Map 实现类，它从 JDK 1.0起就已经出现了，当它出现时，Java还没有提供Map 接口，所以它包含了两个烦琐的方法，即 elements() 类似于 Map接口定义的 values()方法）和 keys() 类似于 Map 接口定义的 keySet()方法。<br>除此之外，Hashtable 和 HashMap 存在三点典型区别。</p>
<ul>
<li>Hashtable 是一个线程安全的 Map接口实现，但 HashMap 是线程不安全的实现，所以 HashMap 比 Hashtable 的性能高一点;但如果有多个线程访问同一个 Map 对象时，使用 Hashtable 实现类会更好。</li>
<li>Hashtable 不允许使用 null 作为 key 和 value，如果试图把 null 值放进 Hashtable 中，将会引发 NullPointerException 异常; 但 HashMap 可以使用 null 作为 key 或 value。</li>
<li>HashMap数组初始长度为16，扩容后长度是原长度的2倍，Hashtable初始长度为11，扩容后的长度是原长度的2n+1</li>
</ul>
<p>对于 Map 的常用实现类而言，虽然 HashMap 和 Hashtable 的实现机制几乎一样，但由于Hashtable是一个古老的、线程安全的集合，因此 HashMap 通常比 Hashtable 要快。<br> TreeMap 通常比 HashMap、Hashtable 要慢（尤其在插入、删除 key-value 对时更慢），因为 TreeMap底层采用红黑树来管理 key-value 对（红黑树的每个节点就是一个 key-value 对）。 使用 TreeMap 有一个好处∶ TreeMap 中的 key-value 对总是处于有序状态，无须专门进行排序操作。当 TreeMap 被填充之后，就可以调用 keySet() ，取得由key 组成的 Set，然后使用 toArray()方法生成 key的数组，接下来使用 Arrays 的 binarySearch() 方法在已排序的数组中快速地查询对象。<br> 对于一般的应用场景，程序应该多考虑使用 HashMap，因为 HashMap 正是为快速查询设计的（HashMap 底层其实也是采用数组来存储 key-value 对）。但如果程序需要一个总是排好序的 Map 时，则可以考虑使用TreeMap。 LinkedHashMap 比 HashMap 慢一点，因为它需要维护链表来保持 Map中 key-value 时的添加顺序。</p>
]]></content>
  </entry>
  <entry>
    <title>面试集合篇</title>
    <url>/2022/08/12/%E9%9D%A2%E8%AF%95%E9%9B%86%E5%90%88%E7%AF%87/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h1 id="Java-集合框架有哪些？"><a href="#Java-集合框架有哪些？" class="headerlink" title="Java 集合框架有哪些？"></a>Java 集合框架有哪些？</h1><p>在java中的集合框架主要分为两部分：Collection接口和Map接口。这两个接口只是他们的父接口，在他们下面还有许多接口和实现类。详细框架结构如下图所示：</p>
<p><img src="https://files.catbox.moe/ub1wzl.png"></p>
<h2 id="说出一些集合框架的优点？"><a href="#说出一些集合框架的优点？" class="headerlink" title="说出一些集合框架的优点？"></a>说出一些集合框架的优点？</h2><p>集合框架的部分优点如下：</p>
<ul>
<li>使用核心集合类降低开发成本，而非实现我们自己的集合类。</li>
<li>随着使用经过严格测试的集合框架类，代码质量会得到提高。</li>
<li>通过使用 JDK 附带的集合类，可以降低代码维护成本。</li>
<li>复用性和可操作性。</li>
</ul>
<h2 id="集合框架中的泛型有什么优点？"><a href="#集合框架中的泛型有什么优点？" class="headerlink" title="集合框架中的泛型有什么优点？"></a>集合框架中的泛型有什么优点？</h2><p>Java5 引入了泛型，所有的集合接口和实现都大量地使用它。泛型允许我们为集合提供一个可以容纳的对象类型。因此，如果你添加其它类型的任何元素，它会在编译时报错。这避免了在运行时出现  因为你将会在编译时得到报错信息。</p>
<p>泛型也使得代码整洁，我们不需要使用显式转换和 instanceOf 操作符。它也给运行时带来好处，因为不会产生类型检查的字节码指令。</p>
<h1 id="Java-集合框架的基础接口有哪些？"><a href="#Java-集合框架的基础接口有哪些？" class="headerlink" title="Java 集合框架的基础接口有哪些？"></a>Java 集合框架的基础接口有哪些？</h1><ul>
<li><p>Collection ，为集合层级的根接口。一个集合代表一组对象，这些对象即为它的元素。Java 平台不提供这个接口任何直接的实现。</p>
</li>
<li><ul>
<li>Set ，是一个不能包含重复元素的集合。这个接口对数学集合抽象进行建模，被用来代表集合，就如一副牌。</li>
<li>List ，是一个有序集合，可以包含重复元素。你可以通过它的索引来访问任何元素。List 更像长度动态变换的数组。</li>
</ul>
</li>
<li><p>Map ，是一个将 key 映射到 value 的对象。一个 Map 不能包含重复的 key，每个 key 最多只能映射一个 value 。</p>
</li>
<li><p>一些其它的接口有 Queue、Dequeue、SortedSet、SortedMap 和 ListIterator 。</p>
</li>
</ul>
<h2 id="为何-Collection-不从-Cloneable-和-Serializable-接口继承？"><a href="#为何-Collection-不从-Cloneable-和-Serializable-接口继承？" class="headerlink" title="为何 Collection 不从 Cloneable 和 Serializable 接口继承？"></a>为何 Collection 不从 Cloneable 和 Serializable 接口继承？</h2><p>Collection 接口指定一组对象，对象即为它的元素。</p>
<ul>
<li>如何维护这些元素由 Collection 的具体实现决定。例如，一些如 List 的 Collection 实现允许重复的元素，而其它的如 Set 就不允许。</li>
<li>很多 Collection 实现有一个公有的 clone 方法。然而，把它放到集合的所有实现中也是没有意义的。这是因为 Collection 是一个抽象表现，重要的是实现。</li>
</ul>
<p>当与具体实现打交道的时候，克隆或序列化的语义和含义才发挥作用。所以，具体实现应该决定如何对它进行克隆或序列化，或它是否可以被克隆或序列化。在所有的实现中授权克隆和序列化，最终导致更少的灵活性和更多的限制，特定的实现应该决定它是否可以被克隆和序列化。</p>
<h2 id="为何-Map-接口不继承-Collection-接口？"><a href="#为何-Map-接口不继承-Collection-接口？" class="headerlink" title="为何 Map 接口不继承 Collection 接口？"></a>为何 Map 接口不继承 Collection 接口？</h2><p>尽管 Map 接口和它的实现也是集合框架的一部分，但 Map 不是集合，集合也不是 Map。因此，Map 继承 Collection 毫无意义，反之亦然。</p>
<p>如果 Map 继承 Collection 接口，那么元素去哪儿？Map 包含 key-value 对，它提供抽取 key 或 value 列表集合( Collection )的方法，但是它不适合“一组对象”规范。</p>
<h2 id="Collection-和-Collections-的区别？"><a href="#Collection-和-Collections-的区别？" class="headerlink" title="Collection 和 Collections 的区别？"></a>Collection 和 Collections 的区别？</h2><ul>
<li>Collection ，是集合类的上级接口，继承与他的接口主要有 Set 和List 。</li>
<li>Collections ，是针对集合类的一个工具类，它提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</li>
</ul>
<h2 id="集合框架里实现的通用算法有哪些？"><a href="#集合框架里实现的通用算法有哪些？" class="headerlink" title="集合框架里实现的通用算法有哪些？"></a>集合框架里实现的通用算法有哪些？</h2><p>Java 集合框架提供常用的算法实现，比如排序和搜索。</p>
<p>Collections类包含这些方法实现。大部分算法是操作 List 的，但一部分对所有类型的集合都是可用的。部分算法有排序、搜索、混编、最大最小值。</p>
<h2 id="集合框架底层数据结构总结"><a href="#集合框架底层数据结构总结" class="headerlink" title="集合框架底层数据结构总结"></a>集合框架底层数据结构总结</h2><p>1.List</p>
<ul>
<li>ArrayList ：Object 数组。</li>
<li>Vector ：Object 数组。</li>
<li>LinkedList ：双向链表(JDK6 之前为循环链表，JDK7 取消了循环)。</li>
</ul>
<p>2.Map</p>
<ul>
<li><p>HashMap ：</p>
</li>
<li><ul>
<li>JDK8 之前，HashMap 由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。</li>
<li>JDK8 以后，在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8 ）时，将链表转化为红黑树，以减少搜索时间。</li>
</ul>
</li>
<li><p>LinkedHashMap ：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a href="https://www.imooc.com/article/22931">《LinkedHashMap 源码详细分析（JDK1.8）》</a> 。</p>
</li>
<li><p>Hashtable ：数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。</p>
</li>
<li><p>TreeMap ：红黑树（自平衡的排序二叉树）。</p>
</li>
</ul>
<p>3.Set</p>
<ul>
<li>HashSet ：无序，唯一，基于 HashMap 实现的，底层采用 HashMap 来保存元素。</li>
<li>LinkedHashSet ：LinkedHashSet 继承自 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 HashMap 实现一样，不过还是有一点点区别的。</li>
<li>TreeSet ：有序，唯一，红黑树(自平衡的排序二叉树)。</li>
</ul>
<h1 id="什么是迭代器-Iterator-？"><a href="#什么是迭代器-Iterator-？" class="headerlink" title="什么是迭代器(Iterator)？"></a>什么是迭代器(Iterator)？</h1><p>Iterator 接口，提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素，但是不可以直接调用集合的 remove(Object Obj) 方法删除，可以通过迭代器的 remove() 方法删除。</p>
<h2 id="Iterator-和-ListIterator-的区别是什么？"><a href="#Iterator-和-ListIterator-的区别是什么？" class="headerlink" title=".Iterator 和 ListIterator 的区别是什么？"></a>.Iterator 和 ListIterator 的区别是什么？</h2><ul>
<li>Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。</li>
<li>Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。</li>
<li>ListIterator 实现了 Iterator 接口，并包含其他的功能。比如：增加元素，替换元素，获取前一个和后一个元素的索引等等。</li>
</ul>
<h2 id="快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？"><a href="#快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？" class="headerlink" title="快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？"></a>快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？</h2><p>差别在于 ConcurrentModification 异常：</p>
<ul>
<li>快速失败：当你在迭代一个集合的时候，如果有另一个线程正在修改你正在访问的那个集合时，就会抛出一个 ConcurrentModification 异常。 在 java.util 包下的都是快速失败。</li>
<li>安全失败：你在迭代的时候会去底层集合做一个拷贝，所以你在修改上层集合的时候是不会受影响的，不会抛出 ConcurrentModification 异常。在 java.util.concurrent 包下的全是安全失败的。</li>
</ul>
<h2 id="如何删除-List-中的某个元素？"><a href="#如何删除-List-中的某个元素？" class="headerlink" title="如何删除 List 中的某个元素？"></a>如何删除 List 中的某个元素？</h2><p>有两种方式，分别如下：</p>
<ul>
<li>方式一，使用 Iterator ，顺序向下，如果找到元素，则使用 remove 方法进行移除。</li>
<li>方式二，倒序遍历 List ，如果找到元素，则使用 remove 方法进行移除。</li>
</ul>
<h2 id="Enumeration-和-Iterator-接口有什么不同？"><a href="#Enumeration-和-Iterator-接口有什么不同？" class="headerlink" title="Enumeration 和 Iterator 接口有什么不同？"></a>Enumeration 和 Iterator 接口有什么不同？</h2><ul>
<li>Enumeration 跟 Iterator 相比较快两倍，而且占用更少的内存。</li>
<li>但是，Iterator 相对于 Enumeration 更安全，因为其他线程不能修改当前迭代器遍历的集合对象。同时，Iterators 允许调用者从底层集合中移除元素，这些 Enumerations 都没法完成。</li>
</ul>
<h2 id="为何-Iterator-接口没有具体的实现？"><a href="#为何-Iterator-接口没有具体的实现？" class="headerlink" title="为何 Iterator 接口没有具体的实现？"></a>为何 Iterator 接口没有具体的实现？</h2><p>Iterator 接口，定义了遍历集合的方法，但它的实现则是集合实现类的责任。每个能够返回用于遍历的 Iterator 的集合类都有它自己的 Iterator 实现内部类。</p>
<p>这就允许集合类去选择迭代器是 fail-fast 还是 fail-safe 的。比如，ArrayList 迭代器是 fail-fast 的，而 CopyOnWriteArrayList 迭代器是 fail-safe 的。</p>
<h1 id="Comparable-和-Comparator-的区别"><a href="#Comparable-和-Comparator-的区别" class="headerlink" title="Comparable 和 Comparator 的区别?"></a>Comparable 和 Comparator 的区别?</h1><ul>
<li>Comparable 接口，在 java.lang 包下，用于当前对象和其它对象的比较，所以它有一个 compareTo(Object obj) 方法用来排序，该方法只有一个参数。</li>
<li>Comparator 接口，在 java.util 包下，用于传入的两个对象的比较，所以它有一个 compare(Object obj1, Object obj2) 方法用来排序，该方法有两个参数。</li>
</ul>
<h2 id="compareTo-方法的返回值表示的意思？"><a href="#compareTo-方法的返回值表示的意思？" class="headerlink" title="compareTo 方法的返回值表示的意思？"></a>compareTo 方法的返回值表示的意思？</h2><ul>
<li>大于 0 ，表示对象大于参数对象。</li>
<li>小于 0 ，表示对象小于参数对象</li>
<li>等于 0 ，表示两者相等。</li>
</ul>
<h2 id="如何对-Object-的-List-排序？"><a href="#如何对-Object-的-List-排序？" class="headerlink" title="如何对 Object 的 List 排序？"></a>如何对 Object 的 List 排序？</h2><ul>
<li>对 Object[] 数组进行排序时，我们可以用 Arrays#sort(…) 方法。</li>
<li>对 List&lt;Object&gt; 数组进行排序时，我们可以用 Collections#sort(…) 方法。</li>
</ul>
<h1 id="有哪些关于-Java-集合框架的最佳实践？"><a href="#有哪些关于-Java-集合框架的最佳实践？" class="headerlink" title="有哪些关于 Java 集合框架的最佳实践？"></a>有哪些关于 Java 集合框架的最佳实践？</h1><ul>
<li>基于应用的需求来选择使用正确类型的集合，这对性能来说是非常重要的。例如，如果元素的大小是固定的，并且知道优先级，我们将会使用一个 Array ，而不是 ArrayList 。</li>
<li>一些集合类允许我们指定他们的初始容量。因此，如果我们知道存储数据的大概数值，就可以避免重散列或者大小的调整。</li>
<li>总是使用泛型来保证类型安全，可靠性和健壮性。同时，使用泛型还可以避免运行时的 ClassCastException 异常。</li>
<li>在 Map 中使用 JDK 提供的不可变类作为一个 key，这样可以避免 hashcode 的实现和我们自定义类的 equals 方法。</li>
<li>应该依照接口而不是实现来编程。</li>
<li>返回零长度的集合或者数组，而不是返回一个 null ，这样可以防止底层集合是空的。</li>
</ul>
<h1 id="List-和-Set-区别？"><a href="#List-和-Set-区别？" class="headerlink" title="List 和 Set 区别？"></a>List 和 Set 区别？</h1><p>List，Set 都是继承自 Collection 接口。</p>
<ul>
<li>List 特点：元素有放入顺序，元素可重复。</li>
<li>Set 特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉。</li>
</ul>
<p>注意：元素虽然无放入顺序，但是元素在 Set 中的位置是有该元素的 hashcode 决定的，其位置其实是固定的。</p>
<p>另外 List 支持 for 循环，也就是通过下标来遍历，也可以用迭代器，但是 Set 只能用迭代，因为他无序，无法用下标来取得想要的值。</p>
<p>Set 和 List 对比：</p>
<ul>
<li>Set：检索指定的元素效率高，删除和插入效率高，插入和删除可能会引起元素位置改变。</li>
<li>List：和数组类似，List 可以动态增长，查找指定的元素效率低，插入删除指定的元素效率低，因为可能会引起其他元素位置改变。</li>
</ul>
<p>当然，如果是随机访问（指定下标），则 List 会快于 Set 。总之，什么场景下使用 Set ，什么场景下使用 List ，还是比较明确的。</p>
<h1 id="List-和-Map-区别？"><a href="#List-和-Map-区别？" class="headerlink" title="List 和 Map 区别？"></a>List 和 Map 区别？</h1><ul>
<li>List 是对象集合，允许对象重复。</li>
<li>Map 是键值对的集合，不允许 key 重复</li>
</ul>
<h1 id="Array-和-ArrayList-有何区别？什么时候更适合用-Array？"><a href="#Array-和-ArrayList-有何区别？什么时候更适合用-Array？" class="headerlink" title="Array 和 ArrayList 有何区别？什么时候更适合用 Array？"></a>Array 和 ArrayList 有何区别？什么时候更适合用 Array？</h1><ul>
<li>Array 可以容纳基本类型和对象，而 ArrayList 只能容纳对象。</li>
<li>Array 是指定大小的，而 ArrayList 大小是固定的，可自动扩容。</li>
<li>Array 没有提供 ArrayList 那么多功能，比如 addAll、removeAll 和 iterator 等。</li>
</ul>
<p>尽管 ArrayList 明显是更好的选择，但也有些时候 Array 比较好用，比如下面的三种情况。</p>
<ul>
<li>1、如果列表的大小已经指定，大部分情况下是存储和遍历它们</li>
<li>2、对于遍历基本数据类型，尽管 Collections 使用自动装箱来减轻编码任务，在指定大小的基本类型的列表上工作也会变得很慢。</li>
<li>3、如果你要使用多维数组，使用 [][] 比 List 会方便。</li>
</ul>
<h1 id="ArrayList-与-LinkedList-区别？"><a href="#ArrayList-与-LinkedList-区别？" class="headerlink" title="ArrayList 与 LinkedList 区别？"></a>ArrayList 与 LinkedList 区别？</h1><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><ul>
<li>优点：ArrayList 是实现了基于动态数组的数据结构，因为地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着放的）。</li>
<li>缺点：因为地址连续，ArrayList 要移动数据，所以插入和删除操作效率比较低。</li>
</ul>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><ul>
<li>优点：LinkedList 基于链表的数据结构，地址是任意的，所以在开辟内存空间的时候不需要等一个连续的地址。对于新增和删除操作 add 和 remove ，LinedList 比较占优势。LinkedList 适用于要头尾操作或插入指定位置的场景。</li>
<li>缺点：因为 LinkedList 要移动指针，所以查询操作性能比较低。</li>
</ul>
<h2 id="适用场景分析："><a href="#适用场景分析：" class="headerlink" title="适用场景分析："></a>适用场景分析：</h2><ul>
<li>当需要对数据进行对随机访问的情况下，选用 ArrayList 。</li>
<li>当需要对数据进行多次增加删除修改时，采用 LinkedList 。</li>
</ul>
<p>如果容量固定，并且只会添加到尾部，不会引起扩容，优先采用 ArrayList 。</p>
<ul>
<li>当然，绝大数业务的场景下，使用 ArrayList 就够了。主要是，注意好避免 ArrayList 的扩容，以及非顺序的插入。</li>
</ul>
<h2 id="ArrayList-是如何扩容的？"><a href="#ArrayList-是如何扩容的？" class="headerlink" title="ArrayList 是如何扩容的？"></a>ArrayList 是如何扩容的？</h2><ul>
<li>如果通过无参构造的话，初始数组容量为 0 ，当真正对数组进行添加时，才真正分配容量。每次按照 1.5 倍（位运算）的比率通过 copeOf 的方式扩容。</li>
<li>在 JKD6 中实现是，如果通过无参构造的话，初始数组容量为10，每次通过 copeOf 的方式扩容后容量为原来的 1.5 倍。</li>
</ul>
<p>重点是 1.5 倍扩容，这是和 HashMap 2 倍扩容不同的地方。</p>
<h2 id="ArrayList-集合加入-1-万条数据，应该怎么提高效率？"><a href="#ArrayList-集合加入-1-万条数据，应该怎么提高效率？" class="headerlink" title="ArrayList 集合加入 1 万条数据，应该怎么提高效率？"></a>ArrayList 集合加入 1 万条数据，应该怎么提高效率？</h2><p>ArrayList 的默认初始容量为 10 ，要插入大量数据的时候需要不断扩容，而扩容是非常影响性能的。因此，现在明确了 10 万条数据了，我们可以直接在初始化的时候就设置 ArrayList 的容量！</p>
<p>这样就可以提高效率了~</p>
<h1 id="ArrayList-与-Vector-区别？"><a href="#ArrayList-与-Vector-区别？" class="headerlink" title="ArrayList 与 Vector 区别？"></a>ArrayList 与 Vector 区别？</h1><p>ArrayList 和 Vector 都是用数组实现的，主要有这么三个区别：</p>
<ul>
<li>1、Vector 是多线程安全的，线程安全就是说多线程访问同一代码，不会产生不确定的结果，而 ArrayList 不是。这个可以从源码中看出，Vector 类中的方法很多有 synchronized 进行修饰，这样就导致了 Vector 在效率上无法与 ArrayList 相比。</li>
</ul>
<p>Vector 是一种老的动态数组，是线程同步的，效率很低，一般不赞成使用。</p>
<ul>
<li>2、两个都是采用的线性连续空间存储元素，但是当空间不足的时候，两个类的增加方式是不同。</li>
<li>3、Vector 可以设置增长因子，而 ArrayList 不可以。</li>
</ul>
<p>适用场景分析：</p>
<ul>
<li>1、Vector 是线程同步的，所以它也是线程安全的，而 ArrayList 是线程无需同步的，是不安全的。如果不考虑到线程的安全因素，一般用 ArrayList 效率比较高。</li>
</ul>
<p>实际场景下，如果需要多线程访问安全的数组，使用 CopyOnWriteArrayList 。</p>
<ul>
<li>2、如果集合中的元素的数目大于目前集合数组的长度时，在集合中使用数据量比较大的数据，用 Vector 有一定的优势。</li>
</ul>
<p>这种情况下，使用 LinkedList 更合适。</p>
<h1 id="HashMap-和-Hashtable-的区别？"><a href="#HashMap-和-Hashtable-的区别？" class="headerlink" title="HashMap 和 Hashtable 的区别？"></a>HashMap 和 Hashtable 的区别？</h1><p>Hashtable 是在 Java 1.0 的时候创建的，而集合的统一规范命名是在后来的 Java2.0 开始约定的，而当时其他一部分集合类的发布构成了新的集合框架。</p>
<ul>
<li>（1）Hashtable 继承 Dictionary ，HashMap 继承的是 Java2 出现的 Map 接口。</li>
<li>（2）HashMap 去掉了 Hashtable 的 contains 方法，但是加上了 containsValue 和 containsKey 方法。</li>
<li>（3）HashMap 允许空键值，而 Hashtable 不允许。</li>
<li>【重点】（4）HashTable 是同步的，而 HashMap 是非同步的，效率上比 HashTable 要高。也因此，HashMap 更适合于单线程环境，而 HashTable 适合于多线程环境。</li>
<li>（5）HashMap 的迭代器（Iterator）是 fail-fast 迭代器，HashTable的 enumerator 迭代器不是 fail-fast 的。</li>
<li>【重要】（6）HashTable 中数组默认大小是 11 ，扩容方法是 old * 2 + 1 ，HashMap 默认大小是 16 ，扩容每次为 2 的指数大小。</li>
</ul>
<p>一般现在不建议用 HashTable 。主要原因是两点：</p>
<ul>
<li>一是，HashTable 是遗留类，内部实现很多没优化和冗余。</li>
<li>二是，即使在多线程环境下，现在也有同步的 ConcurrentHashMap 替代，没有必要因为是多线程而用 Hashtable 。</li>
</ul>
<h2 id="Hashtable-的-size-方法中明明只有一条语句-“return-count-”-，为什么还要做同步？"><a href="#Hashtable-的-size-方法中明明只有一条语句-“return-count-”-，为什么还要做同步？" class="headerlink" title="Hashtable 的 #size() 方法中明明只有一条语句 “return count;” ，为什么还要做同步？"></a>Hashtable 的 #size() 方法中明明只有一条语句 “return count;” ，为什么还要做同步？</h2><p>同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程 A 在执行 Hashtable 的 put 方法添加数据，线程 B 则可以正常调用 #size() 方法读取 Hashtable 中当前元素的个数，那读取到的值可能不是最新的，可能线程 A 添加了完了数据，但是没有对 count++ ，线程 B 就已经读取 count 了，那么对于线程 B 来说读取到的 count 一定是不准确的。</p>
<p>而给 #size() 方法加了同步之后，意味着线程 B 调用 #size() 方法只有在线程 A 调用 put 方法完毕之后才可以调用，这样就保证了线程安全性。</p>
<h1 id="HashSet-和-HashMap-的区别？"><a href="#HashSet-和-HashMap-的区别？" class="headerlink" title="HashSet 和 HashMap 的区别？"></a>HashSet 和 HashMap 的区别？</h1><ul>
<li>Set 是线性结构，值不能重复。HashSet 是 Set 的 hash 实现，HashSet 中值不能重复是用 HashMap 的 key 来实现的。</li>
<li>Map 是键值对映射，可以空键空值。HashMap 是 Map 的 hash 实现，key 的唯一性是通过 key 值 hashcode 的唯一来确定，value 值是则是链表结构。</li>
</ul>
<p>因为不同的 key 值，可能有相同的 hashcode ，所以 value 值需要是链表结构。</p>
<p>他们的共同点都是 hash 算法实现的唯一性，他们都不能持有基本类型，只能持有对象。</p>
<p>为了更好的性能，Netty 自己实现了 key 为基本类型的 HashMap ，例如 <a href="https://netty.io/4.1/api/io/netty/util/collection/IntObjectHashMap.html">IntObjectHashMap</a> 。</p>
<h1 id="HashSet-和-TreeSet-的区别？"><a href="#HashSet-和-TreeSet-的区别？" class="headerlink" title="HashSet 和 TreeSet 的区别？"></a>HashSet 和 TreeSet 的区别？</h1><ul>
<li>HashSet 是用一个 hash 表来实现的，因此，它的元素是无序的。添加，删除和 HashSet 包括的方法的持续时间复杂度是 O(1) 。</li>
<li>TreeSet 是用一个树形结构实现的，因此，它是有序的。添加，删除和 TreeSet 包含的方法的持续时间复杂度是 O(logn) 。</li>
</ul>
<h2 id="如何决定选用-HashMap-还是-TreeMap？"><a href="#如何决定选用-HashMap-还是-TreeMap？" class="headerlink" title="如何决定选用 HashMap 还是 TreeMap？"></a>如何决定选用 HashMap 还是 TreeMap？</h2><ul>
<li>对于在 Map 中插入、删除和定位元素这类操作，HashMap 是最好的选择。</li>
<li>然而，假如你需要对一个有序的 key 集合进行遍历， TreeMap 是更好的选择。</li>
</ul>
<p>基于你的 collection 的大小，也许向 HashMap 中添加元素会更快，再将 HashMap 换为 TreeMap 进行有序 key 的遍历。</p>
<h1 id="HashMap-和-ConcurrentHashMap-的区别？"><a href="#HashMap-和-ConcurrentHashMap-的区别？" class="headerlink" title="HashMap 和 ConcurrentHashMap 的区别？"></a>HashMap 和 ConcurrentHashMap 的区别？</h1><p>ConcurrentHashMap 是线程安全的 HashMap 的实现。主要区别如下：</p>
<ul>
<li>1、ConcurrentHashMap 对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用 lock 锁进行保护，相对 于Hashtable 的 syn 关键字锁的粒度更精细了一些，并发性能更好。而 HashMap 没有锁机制，不是线程安全的。</li>
</ul>
<p>JDK8 之后，ConcurrentHashMap 启用了一种全新的方式实现,利用 CAS 算法。</p>
<ul>
<li>2、HashMap 的键值对允许有 null ，但是 ConCurrentHashMap 都不允许。</li>
</ul>
<h1 id="队列和栈是什么，列出它们的区别？"><a href="#队列和栈是什么，列出它们的区别？" class="headerlink" title="队列和栈是什么，列出它们的区别？"></a>队列和栈是什么，列出它们的区别？</h1><p>栈和队列两者都被用来预存储数据。</p>
<ul>
<li><p>java.util.Queue是一个接口，它的实现类在Java并发包中。</p>
</li>
<li><ul>
<li>队列允许先进先出（FIFO）检索元素，但并非总是这样。</li>
<li>Deque 接口允许从两端检索元素。</li>
</ul>
</li>
<li><p>栈与队列很相似，但它允许对元素进行后进先出（LIFO）进行检索。</p>
</li>
<li><ul>
<li>Stack 是一个扩展自 Vector 的类，而 Queue 是一个接口。</li>
</ul>
</li>
</ul>
<h1 id="HashMap-的工作原理是什么？"><a href="#HashMap-的工作原理是什么？" class="headerlink" title="HashMap 的工作原理是什么？"></a>HashMap 的工作原理是什么？</h1><p>我们知道在 Java 中最常用的两种结构是数组和模拟指针（引用），几乎所有的数据结构都可以利用这两种来组合实现，HashMap 也是如此。实际上 HashMap 是一个“链表散列”。</p>
<p>HashMap 是基于 hashing 的原理。</p>
<p><img src="https://files.catbox.moe/9bvs8c.png"></p>
<ul>
<li>我们使用 #put(key, value) 方法来存储对象到 HashMap 中，使用 get(key) 方法从 HashMap 中获取对象。</li>
<li>当我们给 #put(key, value) 方法传递键和值时，我们先对键调用 #hashCode() 方法，返回的 hashCode 用于找到 bucket 位置来储存 Entry 对象。</li>
</ul>
<h2 id="当两个对象的-hashCode-相同会发生什么？"><a href="#当两个对象的-hashCode-相同会发生什么？" class="headerlink" title="当两个对象的 hashCode 相同会发生什么？"></a>当两个对象的 hashCode 相同会发生什么？</h2><p>因为 hashcode 相同，所以它们的 bucket 位置相同，“碰撞”会发生。</p>
<p>因为 HashMap 使用链表存储对象，这个 Entry（包含有键值对的 Map.Entry 对象）会存储在链表中。</p>
<h2 id="hashCode-和-equals-方法有何重要性？"><a href="#hashCode-和-equals-方法有何重要性？" class="headerlink" title="hashCode 和 equals 方法有何重要性？"></a>hashCode 和 equals 方法有何重要性？</h2><p>HashMap 使用 key 对象的 #hashCode() 和 #equals(Object obj) 方法去决定 key-value 对的索引。当我们试着从 HashMap 中获取值的时候，这些方法也会被用到。</p>
<ul>
<li>如果这两个方法没有被正确地实现，在这种情况下，两个不同 Key 也许会产生相同的 #hashCode() 和 #equals(Object obj) 输出，HashMap 将会认为它们是相同的，然后覆盖它们，而非把它们存储到不同的地方。</li>
</ul>
<p>同样的，所有不允许存储重复数据的集合类都使用 #hashCode() 和 #equals(Object obj) 去查找重复，所以正确实现它们非常重要。#hashCode() 和 #equals(Object obj) 方法的实现，应该遵循以下规则：</p>
<ul>
<li>如果 o1.equals(o2) ，那么 o1.hashCode() &#x3D;&#x3D; o2.hashCode() 总是为 true 的。</li>
<li>如果 o1.hashCode() &#x3D;&#x3D; o2.hashCode() ，并不意味 o1.equals(o2) 会为 true 。</li>
</ul>
<h2 id="HashMap-默认容量是多少？"><a href="#HashMap-默认容量是多少？" class="headerlink" title="HashMap 默认容量是多少？"></a>HashMap 默认容量是多少？</h2><p>默认容量都是 16 ，负载因子是 0.75 。就是当 HashMap 填充了 75% 的 busket 是就会扩容，最小的可能性是（16 * 0.75 &#x3D; 12），一般为原内存的 2 倍。</p>
<h2 id="有哪些顺序的-HashMap-实现类？"><a href="#有哪些顺序的-HashMap-实现类？" class="headerlink" title="有哪些顺序的 HashMap 实现类？"></a>有哪些顺序的 HashMap 实现类？</h2><ul>
<li>LinkedHashMap ，是基于元素进入集合的顺序或者被访问的先后顺序排序。</li>
<li>TreeMap ，是基于元素的固有顺序 (由 Comparator 或者 Comparable 确定)。</li>
</ul>
<h2 id="我们能否使用任何类作为-Map-的-key？"><a href="#我们能否使用任何类作为-Map-的-key？" class="headerlink" title="我们能否使用任何类作为 Map 的 key？"></a>我们能否使用任何类作为 Map 的 key？</h2><p>我们可以使用任何类作为 Map 的 key ，然而在使用它们之前，需要考虑以下几点：</p>
<ul>
<li>1、如果类重写了 equals 方法，它也应该重写 hashcode 方法。</li>
<li>2、类的所有实例需要遵循与 equals 和 hashcode 相关的规则。</li>
<li>3、如果一个类没有使用 equals ，你不应该在 hashcode 中使用它。</li>
<li>4、用户自定义 key 类的最佳实践是使之为不可变的，这样，hashcode 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保hashcode 和 equals 在未来不会改变，这样就会解决与可变相关的问题了。</li>
</ul>
<h2 id="HashMap-的长度为什么是-2-的幂次方？"><a href="#HashMap-的长度为什么是-2-的幂次方？" class="headerlink" title="HashMap 的长度为什么是 2 的幂次方？"></a>HashMap 的长度为什么是 2 的幂次方？</h2><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表&#x2F;红黑树长度大致相同。这个实现就是把数据存到哪个链表&#x2F;红黑树中的算法。</p>
<p>这个算法应该如何设计呢？我们首先可能会想到采用 % 取余的操作来实现。但是，重点来了：</p>
<ul>
<li>取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash % length &#x3D;&#x3D; hash &amp; (length - 1) 的前提是 length 是 2 的 n 次方；）。</li>
<li>并且，采用二进制位操作 &amp;，相对于 % 能够提高运算效率，</li>
</ul>
<p>这就解释了 HashMap 的长度为什么是 2 的幂次方。</p>
<h1 id="HashSet-的工作原理是什么？"><a href="#HashSet-的工作原理是什么？" class="headerlink" title="HashSet 的工作原理是什么？"></a>HashSet 的工作原理是什么？</h1><p>HashSet 是构建在 HashMap 之上的 Set hashing 实现类。让我们直接撸下源码，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>map 属性，当我们创建一个 HashMap 对象时，其内部也会创建一个 map 对象。后续 HashSet 所有的操作，实际都是基于这个 map 之上的封装。</li>
<li>PRESENT 静态属性，所有 map 中 KEY 对应的值，都是它，避免重复创建。</li>
<li>OK ，再来看一眼 add 方法，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;    </span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT) == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashSet-如何检查重复？"><a href="#HashSet-如何检查重复？" class="headerlink" title="HashSet 如何检查重复？"></a>HashSet 如何检查重复？</h2><p>当你把对象加入 HashSet 时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较。</p>
<ul>
<li><p>如果没有相符的 hashcode ，HashSet会假设对象没有重复出现。</p>
</li>
<li><p>但是如果发现有相同 hashcode 值的对象，这时会调用 equals 方法来检查 hashcode 相等的对象是否真的相同。</p>
</li>
<li><ul>
<li>如果两者相同，HashSet 就不会让加入操作成功。</li>
<li>如果两者不同，HashSet 就会让加入操作成功。</li>
</ul>
</li>
</ul>
<h1 id="TreeMap-原理"><a href="#TreeMap-原理" class="headerlink" title="TreeMap 原理"></a>TreeMap 原理</h1><p>Java 中的 TreeMap 是使用红黑树实现的。</p>
<h1 id="Java-Priority-Queue-是什么"><a href="#Java-Priority-Queue-是什么" class="headerlink" title="Java Priority Queue 是什么?"></a>Java Priority Queue 是什么?</h1><p>PriorityQueue 是一个基于优先级堆的无界队列，它的元素都以他们的自然顺序有序排列。</p>
<ul>
<li>在它创建的时候，我们可以可以提供一个比较器 Comparator 来负责PriorityQueue 中元素的排序。</li>
<li>PriorityQueue 不允许 null元素，不允许不提供自然排序的对象，也不允许没有任何关联 Comparator 的对象。</li>
<li>最后，PriorityQueue 不是线程安全的，在执行入队和出队操作它需要 O(log(n)) 的时间复杂度。</li>
</ul>
<h2 id="poll-方法和-remove-方法的区别？"><a href="#poll-方法和-remove-方法的区别？" class="headerlink" title="poll 方法和 remove 方法的区别？"></a>poll 方法和 remove 方法的区别？</h2><p>poll 和 remove 方法，都是从队列中取出一个元素，差别在于：</p>
<ul>
<li>poll 方法，在获取元素失败的时候会返回空</li>
<li>remove() 方法，失败的时候会抛出异常。</li>
</ul>
<h2 id="LinkedHashMap-和-PriorityQueue-的区别是什么？"><a href="#LinkedHashMap-和-PriorityQueue-的区别是什么？" class="headerlink" title="LinkedHashMap 和 PriorityQueue 的区别是什么？"></a>LinkedHashMap 和 PriorityQueue 的区别是什么？</h2><ul>
<li>PriorityQueue 保证最高或者最低优先级的的元素总是在队列头部，LinkedHashMap 维持的顺序是元素插入的顺序。</li>
<li>当遍历一个 PriorityQueue 时，没有任何顺序保证，但是 LinkedHashMap 课保证遍历顺序是元素插入的顺序。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>面试基础篇</title>
    <url>/2022/08/12/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h1 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h1><p>面向对象是一种思想，世间万物都可以看做一个对象，这里只讨论面向对象编程（OOP），Java 是一个支持并发、基于类和面向对象的计算机编程语言。面向对象软件开发具有以下优点：</p>
<ul>
<li>代码开发模块化，更易维护和修改。</li>
<li>代码复用性强。</li>
<li>增强代码的可靠性和灵活性。</li>
<li>增加代码的可读性。</li>
</ul>
<h2 id="请说说面向对象的特征"><a href="#请说说面向对象的特征" class="headerlink" title="请说说面向对象的特征"></a>请说说面向对象的特征</h2><p>四点：封装、继承、多态、抽象。</p>
<p>1.封装</p>
<p>封装，给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。在 Java 当中，有 4 种修饰符： default、public、private 和 protected 。每一种修饰符给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。</p>
<p>下面列出了使用封装的一些好处：</p>
<ul>
<li>通过隐藏对象的属性来保护对象内部的状态。</li>
<li>提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。</li>
<li>禁止对象之间的不良交互提高模块化。</li>
</ul>
<p>2.继承</p>
<p>继承，给对象提供了从基类获取字段和方法的能力。继承提供了代码的重用行，也可以在不修改类的情况下给现存的类添加新特性。</p>
<p>3.多态</p>
<p>多态，是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操作，可以应用到其他类型的值上面。</p>
<p>4.抽象</p>
<p>抽象，是把想法从具体的实例中分离出来的步骤，因此，要根据他们的功能而不是实现细节来创建类。</p>
<p>Java 支持创建只暴漏接口而不包含方法实现的抽象的类。这种抽象技术的主要目的是把类的行为和实现细节分离开。</p>
<h2 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h2><ul>
<li><p>面向过程</p>
</li>
<li><ul>
<li>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源。比如，单片机、嵌入式开发、Linux&#x2F;Unix 等一般采用面向过程开发，性能是最重要的因素。</li>
<li>缺点：没有面向对象易维护、易复用、易扩展。</li>
</ul>
</li>
<li><p>面向对象</p>
</li>
<li><ul>
<li>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护。</li>
<li>缺点：性能比面向过程低</li>
</ul>
</li>
</ul>
<h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><p>1.重写 override</p>
<ul>
<li>方法名、参数、返回值相同。</li>
<li>子类方法不能缩小父类方法的访问权限。</li>
<li>子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。</li>
<li>存在于父类和子类之间。</li>
<li>方法被定义为 final 不能被重写。</li>
</ul>
<p>2.重载 overload</p>
<ul>
<li>参数类型、个数、顺序至少有一个不相同。</li>
<li>不能重载只有返回值不同的方法名。</li>
<li>存在于父类和子类、同类中。</li>
</ul>
<p>对比图：</p>
<table>
<thead>
<tr>
<th>区别</th>
<th>重载</th>
<th>重写</th>
</tr>
</thead>
<tbody><tr>
<td>英文</td>
<td>Overload</td>
<td>Override</td>
</tr>
<tr>
<td>定义</td>
<td>方法名称相同，参数列表的类型或个数不同</td>
<td>方法名称、参数类型、返回值类型全部相同</td>
</tr>
<tr>
<td>权限</td>
<td>对权限没有要求</td>
<td>被重写的方法不能拥有更严格的权限</td>
</tr>
<tr>
<td>范围</td>
<td>发生在一个类中</td>
<td>发生在继承类中</td>
</tr>
</tbody></table>
<h2 id="Java-中，什么是构造方法？什么是构造方法重载？什么是拷贝构造方法？"><a href="#Java-中，什么是构造方法？什么是构造方法重载？什么是拷贝构造方法？" class="headerlink" title="Java 中，什么是构造方法？什么是构造方法重载？什么是拷贝构造方法？"></a>Java 中，什么是构造方法？什么是构造方法重载？什么是拷贝构造方法？</h2><p>1.构造方法</p>
<p>当新对象被创建的时候，构造方法会被调用。每一个类都有构造方法。在程序员没有给类提供构造方法的情况下，Java 编译器会为这个类创建一个默认的构造方法。</p>
<p>2.构造方法重载</p>
<p>Java 中构造方法重载和方法重载很相似。可以为一个类创建多个构造方法。每一个构造方法必须有它自己唯一的参数列表。</p>
<p>3.拷贝构造方法</p>
<p>Java 不支持像 C++ 中那样的<a href="http://www.runoob.com/cplusplus/cpp-copy-constructor.html">拷贝构造方法</a>，这个不同点是因为如果你不自己写构造方法的情况下，Java 不会创建默认的拷贝构造方法。</p>
<h1 id="JDK、JRE、JVM-分别是什么关系？"><a href="#JDK、JRE、JVM-分别是什么关系？" class="headerlink" title="JDK、JRE、JVM 分别是什么关系？"></a>JDK、JRE、JVM 分别是什么关系？</h1><p>简单说，就是 JDK 包含 JRE 包含 JVM。</p>
<h2 id="什么是JDK？"><a href="#什么是JDK？" class="headerlink" title="什么是JDK？"></a>什么是JDK？</h2><p>JDK 即为 Java 开发工具包，包含编写 Java 程序所必须的编译、运行等开发工具以及 JRE。开发工具如：</p>
<ul>
<li>用于编译 Java 程序的 javac 命令。</li>
<li>用于启动 JVM 运行 Java 程序的 Java 命令。</li>
<li>用于生成文档的 Javadoc 命令。</li>
<li>用于打包的 jar 命令等等。</li>
</ul>
<h2 id="什么是JRE？"><a href="#什么是JRE？" class="headerlink" title="什么是JRE？"></a>什么是JRE？</h2><p>JRE 即为 Java 运行环境，提供了运行 Java 应用程序所必须的软件环境，包含有 Java 虚拟机（JVM）和丰富的系统类库。系统类库即为 Java 提前封装好的功能类，只需拿来直接使用即可，可以大大的提高开发效率。</p>
<h2 id="什么是JVM？"><a href="#什么是JVM？" class="headerlink" title="什么是JVM？"></a>什么是JVM？</h2><p>JVM 即为 Java 虚拟机，提供了字节码文件(.class)的运行环境支持。</p>
<p><img src="https://files.catbox.moe/c9wfxq.png"></p>
<h2 id="为什么-Java-被称作是“平台无关的编程语言”？"><a href="#为什么-Java-被称作是“平台无关的编程语言”？" class="headerlink" title="为什么 Java 被称作是“平台无关的编程语言”？"></a>为什么 Java 被称作是“平台无关的编程语言”？</h2><p>Java 虚拟机是一个可以执行 Java 字节码的虚拟机进程。</p>
<ul>
<li>Java 源文件( .java )被编译成能被 Java 虚拟机执行的字节码文件( .class )。</li>
<li>Java 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</li>
</ul>
<h2 id="JDK-各版本的新特性？"><a href="#JDK-各版本的新特性？" class="headerlink" title="JDK 各版本的新特性？"></a>JDK 各版本的新特性？</h2><p>对于大多数面试官，肯定不会问你 JDK 各版本的新特性，更多的会问 JDK8 引入了什么重要的特性？一般上，关键的回答是Lambda 表达式和集合之流式操作，然后说说你在项目中怎么使用的。</p>
<h2 id="Java-和-C-的区别？"><a href="#Java-和-C-的区别？" class="headerlink" title="Java 和 C++ 的区别？"></a>Java 和 C++ 的区别？</h2><ul>
<li>都是面向对象的语言，都支持封装、继承和多态。</li>
<li>Java 不提供指针来直接访问内存，程序内存更加安全。</li>
<li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li>
<li>【重要】Java 有自动内存管理机制，不需要程序员手动释放无用内存。</li>
</ul>
<h1 id="什么是字节码？采用字节码的最大好处是什么？"><a href="#什么是字节码？采用字节码的最大好处是什么？" class="headerlink" title="什么是字节码？采用字节码的最大好处是什么？"></a>什么是字节码？采用字节码的最大好处是什么？</h1><h2 id="什么是字节码？"><a href="#什么是字节码？" class="headerlink" title="什么是字节码？"></a><strong>什么是字节码？</strong></h2><p>这个问题，面试官可以衍生提问，Java 是编译执行的语言，还是解释执行的语言。</p>
<p>Java 中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。</p>
<p>编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在 Java 中，这种供虚拟机理解的代码叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。</p>
<p>每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java 源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。这也就是解释了 Java 的编译与解释并存的特点。</p>
<p><strong>Java 源代码&#x3D;&gt; 编译器 &#x3D;&gt; JVM 可执行的 Java 字节码(即虚拟指令)&#x3D;&gt; JVM &#x3D;&gt; JVM 中解释器 &#x3D;&gt; 机器可执行的二进制机器码 &#x3D;&gt; 程序运行</strong></p>
<h2 id="采用字节码的好处"><a href="#采用字节码的好处" class="headerlink" title="采用字节码的好处"></a>采用字节码的好处</h2><p>Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p>
<p>解释型语言：解释型语言，是在运行的时候将程序翻译成机器语言。解释型语言的程序不需要在运行前编译，在运行程序的时候才翻译，专门的解释器负责在每个语句执行的时候解释程序代码。这样解释型语言每执行一次就要翻译一次，效率比较低。</p>
<h1 id="Java-中的几种基本数据类型是什么？各自占用多少字节？"><a href="#Java-中的几种基本数据类型是什么？各自占用多少字节？" class="headerlink" title="Java 中的几种基本数据类型是什么？各自占用多少字节？"></a>Java 中的几种基本数据类型是什么？各自占用多少字节？</h1><p>Java 支持的数据类型包括基本数据类型和引用类型。</p>
<p>基本数据类型如下：</p>
<ul>
<li>整数值型：byte、short、int、long</li>
<li>字符型：char</li>
<li>浮点类型：float、double</li>
<li>布尔型：boolean</li>
<li>整数型：默认 int 型，小数默认是 double 型。Float 和 Long 类型的必须加后缀。比如：float f &#x3D; 100f 。</li>
</ul>
<p>引用类型声明的变量是指该变量在内存中实际存储的是一个引用地址，实体在堆中。</p>
<ul>
<li>引用类型包括类、接口、数组等。</li>
<li>特别注意，String 是引用类型不是基本类型。</li>
</ul>
<h2 id="什么是值传递和引用传递"><a href="#什么是值传递和引用传递" class="headerlink" title="什么是值传递和引用传递"></a>什么是值传递和引用传递</h2><ul>
<li>值传递，是对基本型变量而言的，传递的是该变量的一个副本，改变副本不影响原变量。</li>
<li>引用传递，一般是对于对象型变量而言的，传递的是该对象地址的一个副本，并不是原对象本身。</li>
</ul>
<p>一般认为，Java 内的传递都是值传递，Java 中实例对象的传递是引用传递</p>
<h2 id="是否可以在-static-环境中访问非-static-变量？"><a href="#是否可以在-static-环境中访问非-static-变量？" class="headerlink" title="是否可以在 static 环境中访问非 static 变量？"></a>是否可以在 static 环境中访问非 static 变量？</h2><p>static 变量在 Java 中是属于类的，它在所有的实例中的值是一样的。当类被 Java 虚拟机载入的时候，会对 static 变量进行初始化。</p>
<p>如果你的代码尝试不用实例来访问非 static 的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</p>
<h2 id="char-型变量中能不能存贮一个中文汉字？为什么？"><a href="#char-型变量中能不能存贮一个中文汉字？为什么？" class="headerlink" title="char 型变量中能不能存贮一个中文汉字？为什么？"></a>char 型变量中能不能存贮一个中文汉字？为什么？</h2><ul>
<li>在 C 语言中，char 类型占 1 个字节，而汉字占 2 个字节，所以不能存储。</li>
<li>在 Java 语言中，char 类型占 2 个字节，而且 Java 默认采用 Unicode 编码，一个 Unicode 码是 16 位，所以一个 Unicode 码占两个字节，Java 中无论汉字还是英文字母，都是用 Unicode 编码来表示的。所以，在 Java 中，char 类型变量可以存储一个中文汉字。</li>
</ul>
<h1 id="String、StringBuffer、StringBuilder-的区别？"><a href="#String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="String、StringBuffer、StringBuilder 的区别？"></a>String、StringBuffer、StringBuilder 的区别？</h1><p>Java 平台提供了两种类型的字符串：String 和 StringBuffer&#x2F;StringBuilder，它们可以储存和操作字符串。</p>
<ul>
<li>String ，是只读字符串，也就意味着 String 引用的字符串内容是不能被改变的。</li>
</ul>
<p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。</p>
<ul>
<li>StringBuffer&#x2F;StringBuilder 类，表示的字符串对象可以直接进行修改。StringBuilder 是 Java 5 中引入的，它和 StringBuffer 的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被 synchronized 修饰，因此它的效率也比 StringBuffer 要高。</li>
</ul>
<p>StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。</p>
<p>相同情况下使用 StirngBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<h2 id="对于三者使用的总结？"><a href="#对于三者使用的总结？" class="headerlink" title="对于三者使用的总结？"></a>对于三者使用的总结？</h2><ul>
<li>操作少量的数据 &#x3D; String 。</li>
</ul>
<p>这个也是实际编码较为经常使用的方式。</p>
<ul>
<li>单线程操作字符串缓冲区下操作大量数据 &#x3D; StringBuilder 。</li>
</ul>
<p>甚至有时，我们为了避免每个线程重复创建 StringBuilder 对象，会通过 ThreadLocal + StringBuilder 的方式，进行对 StringBuilder 的重用。</p>
<ul>
<li>多线程操作字符串缓冲区下操作大量数据 &#x3D; StringBuffer</li>
</ul>
<p>实际场景下，我们基本不太会出现，多线程操作同一个 StringBuffer 对象。</p>
<h2 id="String-s-new-String-quot-xyz-quot-会创建几个对象？"><a href="#String-s-new-String-quot-xyz-quot-会创建几个对象？" class="headerlink" title="String s = new String(&quot;xyz&quot;) 会创建几个对象？"></a><code>String s = new String(&quot;xyz&quot;)</code> 会创建几个对象？</h2><ul>
<li>首先，在 String 池内找，找到 “xyz” 字符串，不创建 “xyz” 对应的 String 对象，否则创建一个对象。</li>
<li>然后，遇到 new 关键字，在内存上创建 String 对象，并将其返回给 s ，又一个对象。</li>
</ul>
<p>所以，总共是 1 个或者 2 个对象。</p>
<h2 id="String-为什么是不可变的？"><a href="#String-为什么是不可变的？" class="headerlink" title="String 为什么是不可变的？"></a>String 为什么是不可变的？</h2><p>简单的来说，String 类中使用 final 关键字字符数组保存字符串。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span>[] value;</span><br></pre></td></tr></table></figure>

<ul>
<li>所以 String 对象是不可变的。</li>
</ul>
<p>而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串 char[] value ，但是没有用 final 关键字修饰。</p>
<ul>
<li>所以这两种对象都是可变的。</li>
</ul>
<h1 id="什么是自动拆装箱"><a href="#什么是自动拆装箱" class="headerlink" title="什么是自动拆装箱"></a>什么是自动拆装箱</h1><p>自动装箱和拆箱，就是基本类型和引用类型之间的转换。</p>
<h2 id="为什么要转换？"><a href="#为什么要转换？" class="headerlink" title="为什么要转换？"></a>为什么要转换？</h2><p>如果你在 Java5 下进行过编程的话，你一定不会陌生这一点，你不能直接地向集合( Collection )中放入原始类型值，因为集合只接收对象。</p>
<ul>
<li>通常这种情况下你的做法是，将这些原始类型的值转换成对象，然后将这些转换的对象放入集合中。使用 Integer、Double、Boolean 等这些类，我们可以将原始类型值转换成对应的对象，但是从某些程度可能使得代码不是那么简洁精炼。</li>
<li>为了让代码简练，Java5 引入了具有在原始类型和对象类型自动转换的装箱和拆箱机制。</li>
<li>但是自动装箱和拆箱并非完美，在使用时需要有一些注意事项，如果没有搞明白自动装箱和拆箱，可能会引起难以察觉的 Bug 。</li>
</ul>
<h2 id="int-和-Integer-有什么区别？"><a href="#int-和-Integer-有什么区别？" class="headerlink" title="int 和 Integer 有什么区别？"></a>int 和 Integer 有什么区别？</h2><ul>
<li>int 是基本数据类型。</li>
<li>Integer 是其包装类，注意是一个类。</li>
</ul>
<h1 id="equals-与-x3D-x3D-的区别？"><a href="#equals-与-x3D-x3D-的区别？" class="headerlink" title="equals 与 &#x3D;&#x3D; 的区别？"></a>equals 与 &#x3D;&#x3D; 的区别？</h1><ul>
<li><p>值类型（<code>int</code>,<code>char</code>,<code>long</code>,<code>boolean</code>等）的话</p>
</li>
<li><ul>
<li>都是用 &#x3D;&#x3D; 判断相等性。</li>
</ul>
</li>
<li><p>对象引用的话</p>
</li>
<li><ul>
<li>&#x3D;&#x3D; 判断引用所指的对象是否是同一个。</li>
<li>equals 方法，是 Object 的成员函数，有些类会覆盖(`override&#96;) 这个方法，用于判断对象的等价性。</li>
</ul>
</li>
</ul>
<p>例如 String 类，两个引用所指向的 String 都是 `“abc”&#96; ，但可能出现他们实际对应的对象并不是同一个（和 JVM 实现方式有关），因此用 &#x3D;&#x3D; 判断他们可能不相等，但用 equals 方法判断一定是相等的。</p>
<h2 id="如何在父类中为子类自动完成所有的-hashCode-和-equals-实现？这么做有何优劣？"><a href="#如何在父类中为子类自动完成所有的-hashCode-和-equals-实现？这么做有何优劣？" class="headerlink" title="如何在父类中为子类自动完成所有的 hashCode 和 equals 实现？这么做有何优劣？"></a>如何在父类中为子类自动完成所有的 hashCode 和 equals 实现？这么做有何优劣？</h2><p>父类的 equals ，一般情况下是无法满足子类的 equals 的需求。</p>
<ul>
<li><p>比如所有的对象都继承 Object ，默认使用的是 Object 的 equals 方法，在比较两个对象的时候，是看他们是否指向同一个地址。但是我们的需求是对象的某个属性相同，就相等了，而默认的 equals 方法满足不了当前的需求，所以我们要重写 equals 方法。</p>
</li>
<li><p>如果重写了 equals 方法，就必须重写 hashCode 方法，否则就会降低 Map 等集合的索引速度。</p>
<p>​</p>
</li>
</ul>
<h2 id="这样的-a-hashCode-有什么用，与-a-equals-b-有什么关系"><a href="#这样的-a-hashCode-有什么用，与-a-equals-b-有什么关系" class="headerlink" title="这样的 a.hashCode() 有什么用，与 a.equals(b) 有什么关系?"></a>这样的 a.hashCode() 有什么用，与 a.equals(b) 有什么关系?</h2><p>这个问题，和上述问题，就是换个姿势，差不了太多。</p>
<p>1.equals 方法，用于比较对象的内容是否相等。</p>
<p>当覆盖了 equals 方法时，比较对象是否相等将通过覆盖后的 equals 方法进行比较（判断对象的内容是否相等）。</p>
<p>2.hashCode 方法，大多在集合中用到。</p>
<p>将对象放入到集合中时，首先判断要放入对象的 hashCode 值与集合中的任意一个元素的 hashCode 值是否相等，如果不相等直接将该对象放入集合中。</p>
<p>如果 hashCode 值相等，然后再通过 equals 方法判断要放入对象与集合中的任意一个对象是否相等，如果 equals 判断不相等，直接将该元素放入到集合中，否则不放入。</p>
<h2 id="有没有可能-2-个不相等的对象有相同的-hashCode？"><a href="#有没有可能-2-个不相等的对象有相同的-hashCode？" class="headerlink" title="有没有可能 2 个不相等的对象有相同的 hashCode？"></a>有没有可能 2 个不相等的对象有相同的 hashCode？</h2><p>可能会发生，这个被称为哈希碰撞。当然，相等的对象，即我们重写了 equals 方法，一定也要重写 hashCode 方法，否则将出现我们在 HashMap 中，相等的对象作为 key ，将找不到对应的 value 。</p>
<p>所以说，equals 和 hashCode 的关系会是：</p>
<ul>
<li>equals 不相等，hashCode 可能相等。</li>
<li>equals 相等，请重写 hashCode 方法，保证 hashCode 相等。</li>
</ul>
<h1 id="final、finally、finalize-的区别？"><a href="#final、finally、finalize-的区别？" class="headerlink" title="final、finally、finalize 的区别？"></a>final、finally、finalize 的区别？</h1><p>1.final</p>
<p>final ，是修饰符关键字。</p>
<ul>
<li>如果一个类被声明为 final ，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract 的，又被声明为 final 的。</li>
<li>将变量或方法声明为 final ，可以保证它们在使用中不被改变。被声明为 final 的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为 final 的方法也同样只能使用，不能重写。</li>
</ul>
<p>另外，在早期的 Java 实现版本中，会将 <code>final</code> 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的 Java 版本已经不需要使用 <code>final</code> 方法进行这些优化了）。类中所有的<code>private</code> 方法都隐式地指定为 <code>final</code> 。</p>
<p>2.finally</p>
<p>在异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。</p>
<p>在以下 4 种特殊情况下，finally块不会被执行：</p>
<ul>
<li>在 finally 语句块中发生了异常。</li>
<li>在前面的代码中用了 System.exit() 退出程序。</li>
<li>程序所在的线程死亡。</li>
<li>关闭 CPU 。</li>
</ul>
<p>3.finalize</p>
<p>finalize ，是方法名。</p>
<p>Java 允许使用 #finalize() 方法，在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。</p>
<ul>
<li>它是在 Object 类中定义的，因此所有的类都继承了它。</li>
<li>子类覆盖 finalize() 方法，以整理系统资源或者执行其他清理工作。</li>
<li>#finalize() 方法，是在垃圾收集器删除对象之前对这个对象调用的。</li>
</ul>
<p>一般情况下，我们在业务中不会自己实现这个方法，更多是在一些框架中使用 。</p>
<h2 id="String-类能被继承吗，为什么？"><a href="#String-类能被继承吗，为什么？" class="headerlink" title="String 类能被继承吗，为什么？"></a>String 类能被继承吗，为什么？</h2><p>不能，因为 String 是 final 修饰。</p>
<h1 id="抽象类和接口有什么区别？"><a href="#抽象类和接口有什么区别？" class="headerlink" title="抽象类和接口有什么区别？"></a>抽象类和接口有什么区别？</h1><p>从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</p>
<ul>
<li>Java 提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：接口中所有的方法隐含的都是抽象的，而抽象类则可以同时包含抽象和非抽象的方法。</li>
<li>类可以实现很多个接口，但是只能继承一个抽象类。类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。</li>
<li>抽象类可以在不提供接口方法实现的情况下实现接口。</li>
<li>Java 接口中声明的变量默认都是 final 的。抽象类可以包含非 final 的变量。</li>
<li>Java 接口中的成员函数默认是 public 的。抽象类的成员函数可以是 private，protected 或者是 public 。</li>
<li>接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含 #main(String[] args) 方法的话是可以被调用的。</li>
</ul>
<h2 id="继承和组合的区别在哪？"><a href="#继承和组合的区别在哪？" class="headerlink" title="继承和组合的区别在哪？"></a>继承和组合的区别在哪？</h2><ul>
<li><p>继承：指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系。在 Java 中，此类关系通过关键字 extends 明确标识，在设计时一般没有争议性。</p>
</li>
<li><p>组合：组合是关联关系的一种特例，他体现的是整体与部分、拥有的关系，即 has-a 的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享。</p>
</li>
<li><ul>
<li>比如，计算机与 CPU 、公司与员工的关系等。</li>
<li>表现在代码层面，和关联关系是一致的，只能从语义级别来区分。</li>
</ul>
</li>
</ul>
<p>因为组合能带来比继承更好的灵活性，所以有句话叫做“组合优于继承”。</p>
<h2 id="请详细讲述一下-RandomAccess-接口有什么作用？"><a href="#请详细讲述一下-RandomAccess-接口有什么作用？" class="headerlink" title="请详细讲述一下 RandomAccess 接口有什么作用？"></a>请详细讲述一下 RandomAccess 接口有什么作用？</h2><p>RandomAccess 用来当标记的，是一种标记接口，接口的非典型用法。意思是，随机访问任意下标元素都比较快。</p>
<p>用处，当要实现某些算法时，会判断当前类是否实现了 RandomAccess 接口，会根据结果选择不同的算法。</p>
<h1 id="讲讲类的实例化顺序？"><a href="#讲讲类的实例化顺序？" class="headerlink" title="讲讲类的实例化顺序？"></a>讲讲类的实例化顺序？</h1><p>初始化顺序如下：</p>
<ul>
<li>父类静态变量</li>
<li>父类静态代码块</li>
<li>子类静态变量、</li>
<li>子类静态代码块</li>
<li>父类非静态变量（父类实例成员变量）</li>
<li>父类构造函数</li>
<li>子类非静态变量（子类实例成员变量）</li>
<li>子类构造函数</li>
</ul>
<h1 id="什么是内部类？"><a href="#什么是内部类？" class="headerlink" title="什么是内部类？"></a>什么是内部类？</h1><p>简单的说，就是在一个类、接口或者方法的内部创建另一个类。这样理解的话，创建内部类的方法就很明确了。</p>
<h2 id="内部类的作用是什么"><a href="#内部类的作用是什么" class="headerlink" title="内部类的作用是什么"></a>内部类的作用是什么</h2><p>内部类提供了更好的封装，除了该外围类，其他类都不能访问。</p>
<h2 id="Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以实现接口？"><a href="#Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以实现接口？" class="headerlink" title="Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？"></a>Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？</h2><p>可以继承其他类或实现其他接口，在 Java 集合的流式操作中，我们常常这么干。</p>
<h2 id="内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"><a href="#内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？" class="headerlink" title="内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"></a>内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？</h2><p>一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。</p>
<h1 id="什么是-Java-IO-？"><a href="#什么是-Java-IO-？" class="headerlink" title="什么是 Java IO ？"></a>什么是 Java IO ？</h1><p>Java IO 相关的类，在 java.io 包下，具体操作分成面向字节(Byte)和面向字符(Character)两种方式。如下图所示：</p>
<p><img src="https://files.catbox.moe/l03fl3.png"></p>
<h1 id="什么是-Java-序列化？"><a href="#什么是-Java-序列化？" class="headerlink" title="什么是 Java 序列化？"></a>什么是 Java 序列化？</h1><p>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。</p>
<ul>
<li>可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。</li>
<li>序列化是为了解决在对对象流进行读写操作时所引发的问题。</li>
</ul>
<p>反序列化的过程，则是和序列化相反的过程。</p>
<p>另外，我们不能将序列化局限在 Java 对象转换成二进制数组，例如说，我们将一个 Java 对象，转换成 JSON 字符串，或者 XML 字符串，这也可以理解为是序列化。</p>
<h2 id="如何实现-Java-序列化？"><a href="#如何实现-Java-序列化？" class="headerlink" title="如何实现 Java 序列化？"></a>如何实现 Java 序列化？</h2><p>如下的方式，就是 Java 内置的序列化方案，实际场景下，我们可以自定义序列化的方案，例如说 Google Protobuf 。</p>
<p>将需要被序列化的类，实现 Serializable 接口，该接口没有需要实现的方法，implements Serializable 只是为了标注该对象是可被序列化的。</p>
<ul>
<li><p>序列化</p>
</li>
<li><ul>
<li>然后，使用一个输出流(如：FileOutputStream)来构造一个 ObjectOutputStream(对象流)对象</li>
<li>接着，使用 ObjectOutputStream 对象的 #writeObject(Object obj) 方法，就可以将参数为 obj 的对象写出(即保存其状态)。</li>
</ul>
</li>
<li><p>反序列化</p>
</li>
<li><ul>
<li>要恢复的话则用输入流。</li>
</ul>
</li>
</ul>
<h2 id="Java-序列话中，如果有些字段不想进行序列化怎么办？"><a href="#Java-序列话中，如果有些字段不想进行序列化怎么办？" class="headerlink" title="Java 序列话中，如果有些字段不想进行序列化怎么办？"></a>Java 序列话中，如果有些字段不想进行序列化怎么办？</h2><p>对于不想进行序列化的变量，使用 transient 关键字修饰。</p>
<ul>
<li>当对象被序列化时，阻止实例中那些用此关键字修饰的的变量序列化。</li>
<li>当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。</li>
<li>transient 只能修饰变量，不能修饰类和方法。</li>
</ul>
<h1 id="如何实现对象克隆？"><a href="#如何实现对象克隆？" class="headerlink" title="如何实现对象克隆？"></a>如何实现对象克隆？</h1><p>一般来说，有两种方式：</p>
<ul>
<li>1、实现 Cloneable 接口，并重写 Object 类中的 #clone() 方法。可以实现浅克隆，也可以实现深克隆。</li>
<li>2、实现 Serializable 接口，通过对象的序列化和反序列化实现克隆。可以实现真正的深克隆。</li>
</ul>
<h1 id="error-和-exception-有什么区别？CheckedException-和-RuntimeException-有什么区别？"><a href="#error-和-exception-有什么区别？CheckedException-和-RuntimeException-有什么区别？" class="headerlink" title="error 和 exception 有什么区别？CheckedException 和 RuntimeException 有什么区别？"></a>error 和 exception 有什么区别？CheckedException 和 RuntimeException 有什么区别？</h1><p>ava 的异常体系，基于共同的祖先 java.lang.Throwable 类。如下图所示：</p>
<p><img src="https://files.catbox.moe/yhuzvs.png"></p>
<p>Throwable 类图</p>
<ul>
<li><p>Error（错误），表示系统级的错误和程序不必处理的异常，是 Java 运行环境中的内部错误或者硬件问题。</p>
</li>
<li><ul>
<li>例如：内存资源不足等。</li>
<li>对于这种错误，程序基本无能为力，除了退出运行外别无选择，它是由 Java 虚拟机抛出的。</li>
</ul>
</li>
<li><p>Exception（异常），表示需要捕捉或者需要程序进行处理的异常，它处理的是因为程序设计的瑕疵而引起的问题或者在外的输入等引起的一般性问题，是程序必须处理的。Exception 又分为运行时异常，受检查异常。</p>
</li>
<li><ul>
<li>RuntimeException(运行时异常)，表示无法让程序恢复的异常，导致的原因通常是因为执行了错误的操作，建议终止逻辑，因此，编译器不检查这些异常。</li>
<li>CheckedException(受检查异常)，是表示程序可以处理的异常，也即表示程序可以修复（由程序自己接受异常并且做出处理），所以称之为受检查异常。</li>
</ul>
</li>
</ul>
<h2 id="异常的使用的注意地方？"><a href="#异常的使用的注意地方？" class="headerlink" title="异常的使用的注意地方？"></a>异常的使用的注意地方？</h2><p>神作《Effective Java》中对异常的使用给出了以下指导原则：</p>
<ul>
<li>不要将异常处理用于正常的控制流（设计良好的 API 不应该强迫它的调用者为了正常的控制流而使用异常）。</li>
<li>对可以恢复的情况使用受检异常，对编程错误使用运行时异常。</li>
<li>避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）。</li>
<li>优先使用标准的异常。</li>
<li>每个方法抛出的异常都要有文档。</li>
<li>保持异常的原子性</li>
<li>不要在 catch 中忽略掉捕获到的异常。</li>
</ul>
<h2 id="Throwable-类常用方法？"><a href="#Throwable-类常用方法？" class="headerlink" title="Throwable 类常用方法？"></a>Throwable 类常用方法？</h2><ul>
<li><p>getMessage() 方法：返回异常发生时的详细信息。</p>
</li>
<li><p>getCause() 方法：获得导致当前 Throwable 异常的 Throwable 异常。</p>
</li>
<li><p>getStackTrace()方法：获得 Throwable 对象封装的异常信息。</p>
</li>
<li><p>printStackTrace() 方法：在控制台上打印。</p>
</li>
</ul>
<h2 id="请列出-5-个运行时异常？"><a href="#请列出-5-个运行时异常？" class="headerlink" title="请列出 5 个运行时异常？"></a>请列出 5 个运行时异常？</h2><ul>
<li>NullPointerException</li>
<li>IndexOutOfBoundsException</li>
<li>ClassCastException</li>
<li>ArrayStoreException</li>
<li>BufferOverflowException</li>
</ul>
<h2 id="throw-与-throws-的区别-？"><a href="#throw-与-throws-的区别-？" class="headerlink" title="throw 与 throws 的区别 ？"></a>throw 与 throws 的区别 ？</h2><ul>
<li>throw ，用于在程序中显式地抛出一个异常。</li>
<li>throws ，用于指出在该方法中没有处理的异常。每个方法必须显式指明哪些异常没有处理，以便该方法的调用者可以预防可能发生的异常。最后，多个异常用逗号分隔。</li>
</ul>
<h2 id="异常处理中-finally-语句块的重要性"><a href="#异常处理中-finally-语句块的重要性" class="headerlink" title="异常处理中 finally 语句块的重要性?"></a>异常处理中 finally 语句块的重要性?</h2><p>不管程序是否发生了异常, finally 语句块都会被执行，甚至当没有catch 声明但抛出了一个异常时, finally 语句块也会被执行。</p>
<p>finally 语句块通常用于释放资源, 如 I&#x2F;O 缓冲区, 数据库连接等等。</p>
<h1 id="说说反射的用途及实现？"><a href="#说说反射的用途及实现？" class="headerlink" title="说说反射的用途及实现？"></a>说说反射的用途及实现？</h1><p>Java 反射机制主要提供了以下功能：</p>
<ul>
<li>在运行时构造一个类的对象。</li>
<li>判断一个类所具有的成员变量和方法。</li>
<li>调用一个对象的方法。</li>
<li>生成动态代理。</li>
</ul>
<p>反射的应用很多，很多框架都有用到：</p>
<ul>
<li>Spring 框架的 IoC 基于反射创建对象和设置依赖属性。</li>
<li>Spring MVC 的请求调用对应方法，也是通过反射。</li>
<li>JDBC 的 Class#forName(String className) 方法，也是使用反射</li>
</ul>
<h2 id="反射中，Class-forName-和-ClassLoader-区别？"><a href="#反射中，Class-forName-和-ClassLoader-区别？" class="headerlink" title="反射中，Class.forName 和 ClassLoader 区别？"></a>反射中，Class.forName 和 ClassLoader 区别？</h2><p>这两者，都可用来对类进行加载。差别在于：</p>
<ul>
<li>Class.forName(…) 方法，除了将类的 .class 文件加载到JVM 中之外，还会对类进行解释，执行类中的 static 块。</li>
<li>ClassLoader 只干一件事情，就是将 .class 文件加载到 JVM 中，不会执行 static 中的内容，只有在 newInstance 才会去执行 static 块。</li>
</ul>
<p>Class.forName(name, initialize, loader) 方法，带参函数也可控制是否加载 static 块，并且只有调用了newInstance 方法采用调用构造函数，创建类的对象。</p>
<h2 id="UnsupportedOperationException-是什么？"><a href="#UnsupportedOperationException-是什么？" class="headerlink" title="UnsupportedOperationException 是什么？"></a>UnsupportedOperationException 是什么？</h2><p>UnsupportedOperationException ，是用于表明操作不支持的异常。</p>
<p>在 JDK 类中已被大量运用，在集合框架java.util.Collections.UnmodifiableCollection 将会在所有 add 和 remove 操作中抛出这个异常。</p>
<h1 id="什么时候用断言（assert）？"><a href="#什么时候用断言（assert）？" class="headerlink" title="什么时候用断言（assert）？"></a>什么时候用断言（assert）？</h1><p>断言，在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。</p>
<ul>
<li>一般来说，断言用于保证程序最基本、关键的正确性。断言检查通常在开发和测试时开启。为了保证程序的执行效率，在软件发布后断言检查通常是关闭的。</li>
<li>断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为true；如果表达式的值为false，那么系统会报告一个AssertionError 错误。断言的使用如下面的代码所示：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span>(a &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>断言可以有两种形式：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>assert Expression1; 。</li>
<li>assert Expression1 : Expression2; 。</li>
<li>Expression1 应该总是产生一个布尔值。</li>
<li>Expression2 可以是得出一个值的任意表达式；这个值用于生成显示更多调试信息的字符串消息。</li>
</ul>
</li>
</ul>
</li>
<li><p>要在运行时启用断言，可以在启动 JVM 时使用 -enableassertions 或者 -ea 标记。要在运行时选择禁用断言，可以在启动 JVM 时使用 -da 或者 -disableassertions 标记。要在系统类中启用或禁用断言，可使用 -esa 或 -dsa 标记。还可以在包的基础上启用或者禁用断言。</p>
</li>
</ul>
<p>当然，实际场景下，我们会在 Spring 的源码中看到，它自己封装了 Assert 类，实现更方便的断言功能，并且，在生产环境下也启用。</p>
<p>另外，在单元测试中，也会使用自己封装的断言类，判断执行结果的正确与错误。</p>
<h1 id="Java-对象创建的方式？"><a href="#Java-对象创建的方式？" class="headerlink" title="Java 对象创建的方式？"></a>Java 对象创建的方式？</h1><ol>
<li>使用 new 关键字 创建对象。</li>
<li>使用 Class 类的 newInstance 方法(反射机制)。</li>
<li>使用 Constructor 类的 newInstance 方法(反射机制)。</li>
<li>使用 clone 方法创建对象。</li>
<li>使用(反)序列化机制创建对象。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Java多线程</title>
    <url>/2022/08/17/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<p>大部分时候，我们都做着单线程的编程，前面所有程序都只有一条顺序执行流——程序从main方法开始执行，依次向下执行每行代码，如果程序执行某行代码时遇到了阻塞，则程序将会停滞在该处。但实际的情况是，单线程的程序往往功能非常有限，例如下载网络资源时如果使用单线程，除了物理带宽的限制，单线程下载会让下载进度变的异常缓慢，这就带来了非常糟糕的体验。<br>Java语言提供了非常优秀的多线程支持，程序可以通过非常简单的方式来启动多线程。</p>
<h2 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h2><h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><p>几乎所有的操作系统都支持进程的概念，所有运行中的任务通常对应一个进程（Process）。当一个程序进入内存运行时，即变成一个进程。进程是处于运行过程中的程序，并且具有一定的独立功能，进程是系统进行资源分配和调度的一个独立单位。<br>线程是进程的组成部分，一个进程可以拥有多个线程，一个线程必须有一个父进程。线程可以拥有自己的堆栈、自己的程序计数器和自己的局部变量，但不拥有系统资源，它与父进程的其他线程共享该进程所拥有的全部资源。<br>简而言之，一个程序运行后至少有一个进程，一个进程里可以包含多个线程，但至少要包含一个线程。</p>
<h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><p>并发性（concurrency）和并行性（parallel）是两个概念。<br>并行指在同一时刻，有多条指令在多个处理器上同时执行；<br>并发指在同一时刻只能有一条指令执行，但多个进程指令被快速轮换执行，使得在宏观上具有多个进程同时执行的效果。<br>在单CPU的时代多个任务都是并发执行的，这是因为单个CPU同时只能执行一个任务。在单CPU时代多任务是共享一个CPU的，当一个任务占用CPU运行时，其他任务就会被挂起，当占用CPU的任务时间片用完后，会把CPU让给其他任务来使用，所以在单CPU时代多线程编程是没有太大意义的，并且线程间频繁的上下文切换还会带来额外开销。</p>
<h3 id="线程的创建和启动"><a href="#线程的创建和启动" class="headerlink" title="线程的创建和启动"></a>线程的创建和启动</h3><p>Java使用Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流（一段顺序执行的代码）</p>
<h4 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h4><p>通过继承Thread类来创建并启动多线程的步骤如下。</p>
<ol>
<li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务。因此把run()方法称为线程执行体。</li>
<li>创建Thread子类0实例，即创建了线程对象。</li>
<li>调用线程对象的start()方法来启动该线程。</li>
</ol>
<p>下面通过示例来演示该方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">	<span class="comment">//重写run方法，run方法体中的内容即线程所做的事情</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">&quot;==============&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line">		t.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中定义了类MyThread1，并集成了Thread类重写了run方法，run方法的方法体即使线程执行的任务，需要注意的是，在代码14行启动线程时，并不是直接调用run()方法，而是调用了start()方法。<br>除此之外，上面程序还用到了线程的如下两个方法。</p>
<ul>
<li>Thread.currentThread()：currentThread()是Thread类的静态方法，该方法总是返回当前正在执行的线程对象。</li>
<li>getName()：该方法是Thread类的实例方法，该方法返回调用该方法线程的名字。</li>
</ul>
<h4 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h4><p>由于Java是单继承的，如果使用继承Thread类的方式去创建线程的话，就不能继承其他类，这无疑降低了代码的灵活性，因此Java还为开发者提供了Runnable接口创建多线程。实现Runnable接口来创建并启动多线程的步骤如下：</p>
<ol>
<li>定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</li>
<li>创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</li>
</ol>
<p>下面，通过示例演示实现Runnable接口创建线程。</p>
<ol>
<li>调用线程对象的start()方法来启动该线程。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">&quot;==============&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">MyThread2</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">		thread.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序，通过继承Runnable接口并重写run()方法，创建了线程，需要注意的是在启动线程时，MyThread并没有start()方法，所以使用了Thread的构造方法，将线程t传入并启动了线程，此处启动的并不是线程thread，而是线程t。</p>
<blockquote>
<p>Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。</p>
</blockquote>
<h4 id="使用Callable和Future创建线程"><a href="#使用Callable和Future创建线程" class="headerlink" title="使用Callable和Future创建线程"></a>使用Callable和Future创建线程</h4><p>从Java 5开始，Java提供了Callable接口，该接口像是Runnable接口的增强版，Callable接口提供了一个call()方法可以作为线程执行体，但call()方法比run()方法功能更强大。</p>
<ul>
<li>call()方法可以有返回值。</li>
<li>call()方法可以声明抛出异常。</li>
</ul>
<p>因此我们完全可以提供一个Callable对象作为Thread的target，而该线程的线程执行体就是该Callable对象的call()方法。问题是：Callable接口是Java 5新增的接口，而且它不是Runnable接口的子接口，所以Callable对象不能直接作为Thread的target。而且call()方法还有一个返回值——call()方法并不是直接调用，它是作为线程执行体被调用的。<br>因此，Java 5提供了Future接口来代表Callable接口里call()方法的返回值，并为Future接口提供了一个FutureTask实现类，该实现类实现了Future接口，并实现了Runnable接口——可以作为Thread类的target。<br>在Future接口里定义了如下几个公共方法来控制它关联的Callable任务。</p>
<ul>
<li>boolean cancel(boolean mayInterruptIfRunning)：试图取消该Future里关联的Callable任务。</li>
<li>V get()：返回Callable任务里call()方法的返回值。调用该方法将导致程序阻塞，必须等到子线程结束后才会得到返回值。</li>
<li>V get(long timeout,TimeUnit unit)：返回Callable任务里call()方法的返回值。该方法让程序最多阻塞timeout和unit指定的时间，如果经过指定时间后Callable任务依然没有返回值，将会抛出TimeoutException异常。</li>
<li>boolean isCancelled()：如果在Callable任务正常完成前被取消，则返回true。</li>
<li>boolean isDone()：如果Callable任务已完成，则返回 true。</li>
</ul>
<p>创建并启动有返回值的线程的步骤如下：</p>
<ul>
<li>创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，且该call()方法有返回值。</li>
<li>创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。</li>
<li>使用FutureTask对象作为Thread对象的target创建并启动新线程。</li>
<li>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。</li>
</ul>
<p>下面通过示例学习使用Callable创建并启动线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread3</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt;&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (;i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=========&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="type">MyThread3</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread3</span>();</span><br><span class="line">		FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(t);</span><br><span class="line">		</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">		</span><br><span class="line">		thread.start();</span><br><span class="line">		<span class="comment">//获取返回值</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;线程 的返回值是：&quot;</span>+task.get());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程序中创建 Callable 实现类与创建 Runnable 实现类并没有太大的差别，只是Callable的call()方法允许声明抛出异常，而且允许带返回值。上面程序中是以 Callable 对象来启动线程的关键代码。程序先创建一个Callable实现类的实例，然后将该实例包装成一个FutureTask对象。<br>程序启动以FutureTask对象为target的线程。程序最后调用FutureTask对象的get()方法来返回call()方法的返回值——该方法将导致主线程被阻塞，直到call()方法结束并返回为止。<br>运行结果如下：</p>
<p><img src="https://files.catbox.moe/dr49gx.png"></p>
<p>通过继承Thread类或实现Runnable、Callable接口都可以实现多线程，不过实现Runnable接口与实现Callable接口的方式基本相同，只是Callable接口里定义的方法有返回值，可以声明抛出异常而已。因此可以将实现Runnable接口和实现Callable接口归为一种方式。这种方式与继承Thread方式之间的主要差别如下。采用实现Runnable、Callable接口的方式创建多线程</p>
<ul>
<li>线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。</li>
<li>在这种方式下，多个线程可以共享同一个 target 对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</li>
<li>劣势是：编程稍稍复杂，如果需要访问当前线程，则必须使用Thread.currentThread()方法。</li>
</ul>
<p>采用继承Thread类的方式创建多线程。</p>
<ul>
<li>劣势是：因为线程类已经继承了Thread类，所以不能再继承其他父类。</li>
<li>优势是：编写简单，如果需要访问当前线程，则无须使用Thread.currentThread()，直接使用this即可获得当前线程。</li>
</ul>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态，在线程的生命周期中，它要经过新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）和死亡（Dead）五种状态。<br><strong>1.NEW</strong><br>Java源码对NEW状态的说明是：创建成功但是没有调用start()方法启动的Thread线程实例都处于NEW状态。当然，并不是Thread线程实例的start()方法一经调用，其状态就从NEW状态到RUNNABLE状态，此时并不意味着线程立即获取CPU时间片并且立即执行，中间需要一系列操作系统的内部操作。<br><strong>2.RUNNABLE</strong><br>当Java线程的Thread实例的start()方法被调用后，操作系统中的对应线程进入的并不是运行状态，而是就绪状态，而Java线程并没有这个就绪状态。Java中的线程管理是通过JNI本地调用的方式委托操作系统的线程管理API完成的。<br>一个操作系统线程如果处于就绪状态，就表示“万事俱备，只欠东风”，即该线程已经满足执行条件，但是还不能执行。处于就绪状态的线程需要等待系统的调度，一旦就绪状态被系统选中，获得CPU时间片，线程就开始占用CPU，开始执行线程的代码，这时线程的操作系统状态发生了改变，进入了运行状态。在操作系统中，处于运行状态的线程在CPU时间片用完之后，又回到就绪状态，等待CPU的下一次调度。就这样，操作系统线程在就绪状态和执行状态之间被系统反复地调度，这种情况会一直持续，直到线程的代码逻辑执行完成或者异常终止。这时线程的操作系统状态又发生了改变，进入线程的最后状态TERMINATED状态。<br>就绪状态和运行状态都是操作系统中的线程状态。在Java语言中，并没有细分这两种状态，而是将这两种状态合并成同一种状态——RUNNABLE状态。因此，在Thread.State枚举类中，没有定义线程的就绪状态和运行状态，只是定义了RUNNABLE状态。这就是Java线程状态和操作系统中线程状态不同的地方。<br><strong>3.WAITING</strong><br>处于WAITING（无限期等待）状态的线程不会被分配CPU时间片，需要被其他线程显式地唤醒，才会进入就绪状态。线程调用以下3种方法会让自己进入无限等待状态：</p>
<ul>
<li>Object.wait()方法，对应的唤醒方式为Object.notify()&#x2F;Object.notifyAll()。</li>
<li>Thread.join()方法，对应的唤醒方式为：被合入的线程执行完毕。</li>
<li>LockSupport.park()方法，对应的唤醒方式LockSupport.unpark(Thread)。</li>
</ul>
<p><strong>4.TIMED_WAITING</strong><br>线程处于一种特殊的等待状态，准确地说，线程处于限时等待状态。能让线程处于限时等待状态的操作大致有以下几种：</p>
<ol>
<li>Thread.sleep(int n)：使得当前线程进入限时等待状态，等待时间为n毫秒。</li>
<li>Object.wait()：带时限的抢占对象的monitor锁。</li>
<li>Thread.join()：带时限的线程合并。</li>
<li>LockSupport.parkNanos()：让线程等待，时间以纳秒为单位。</li>
<li>LockSupport.parkUntil()：让线程等待，时间可以灵活设置。</li>
</ol>
<p><strong>5.BLOCKED</strong><br>线程处于一种阻塞状态，该状态并不会占用CPU资源，以下情况会让线程进入阻塞状态：</p>
<ol>
<li>线程等待获取锁，而该锁被其他线程持有，则该线程进入阻塞状态。当其他线程释放了该锁，并且线程调度器允许该线程持有该锁时，该线程退出阻塞状态。</li>
<li>IO阻塞，线程发起了一个阻塞式IO操作后，如果不具备IO操作的条件，线程就会进入阻塞状态。IO包括磁盘IO、网络IO等。IO阻塞的一个简单例子：线程等待用户输入内容后继续执行。</li>
</ol>
<p><strong>6.TERMINATED</strong><br>处于RUNNABLE状态的线程在run()方法执行完成之后就变成终止状态TERMINATED了。当然，如果在run()方法执行过程中发生了运行时异常而没有被捕获，run()方法将被异常终止，线程也会变成TERMINATED状态。</p>
<h3 id="新建和就绪状态"><a href="#新建和就绪状态" class="headerlink" title="新建和就绪状态"></a>新建和就绪状态</h3><p>当程序使用 new 关键字创建了一个线程之后，该线程就处于新建状态，此时它和其他的Java对象一样，仅仅由Java虚拟机为其分配内存，并初始化其成员变量的值。此时的线程对象没有表现出任何线程的动态特征，程序也不会执行线程的线程执行体。当线程对象调用了start()方法之后，该线程处于就绪状态，Java虚拟机会为其创建方法调用栈和程序计数器，处于这个状态中的线程并没有开始运行，只是表示该线程可以运行了。至于该线程何时开始运行，取决于JVM里线程调度器的调度。<br>线程的调度目前主要分为两种：分时调度和抢占式调度。</p>
<ol>
<li>分时调度：系统平均分配CPU时间片，所有线程轮流占用CPU，也就是说在时间片调度的分配上所有线程“人人平等”。</li>
<li>抢占式调度：系统按照线程优先级分配CPU时间片。优先级高的线程优先分配CPU时间片，如果所有就绪线程的优先级相同，那么会随机选择一个，优先级高的线程获取的CPU时间片相对多一些。</li>
</ol>
<p>由于目前大部分操作系统都是使用抢占式调度模型进行线程调度，Java的线程管理和调度是委托给操作系统完成的，与之相对应，Java的线程调度也是使用抢占式调度模型。</p>
<blockquote>
<p>启动线程使用 start()方法，而不是 run()方法！永远不要调用线程对象的run()方法！调用start()方法来启动线程，系统会把该run()方法当成线程执行体来处理；但如果直接调用线程对象的run()方法，则run()方法立即就会被执行，而且在 run()方法返回之前其他线程无法并发执行——也就是说，系统把线程对象当成一个普通对象，而run()方法也是一个普通方法，而不是线程执行体。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.cycle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Thread state====&quot;</span>+getState());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//此时线程处于新建状态</span></span><br><span class="line">		<span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;Thread state====&quot;</span>+thread.getState());</span><br><span class="line">		thread.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的程序可以看出当thread线程创建对象后，此时打印线程为新建状态（NEW）,当启动线程，线程已经程开始运行时在代码第6行打印了运行状态（RUNNABLE）</p>
<p>只能对处于新建状态的线程调用 start()方法，否则将引发IllegalThreadStateException异常。也就是说当线程调用过start()方法后再不能重复调用，否则将引发异常。</p>
<h3 id="运行和阻塞状态"><a href="#运行和阻塞状态" class="headerlink" title="运行和阻塞状态"></a>运行和阻塞状态</h3><p>如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状态，如果计算机只有一个 CPU，那么在任何时刻只有一个线程处于运行状态。当然，在一个多处理器的机器上，将会有多个线程并行（注意是并行：parallel）执行；当线程数大于处理器数时，依然会存在多个线程在同一个CPU上轮换的现象。<br>当一个线程开始运行后，它不可能一直处于运行状态（除非它的线程执行体足够短，瞬间就执行结束了），线程在运行过程中需要被中断，目的是使其他线程获得执行的机会，线程调度的细节取决于底层平台所采用的策略。对于采用抢占式策略的系统而言，系统会给每个可执行的线程一个小时间段来处理任务；当该时间段用完后，系统就会剥夺该线程所占用的资源，让其他线程获得执行的机会。在选择下一个线程时，系统会考虑线程的优先级。<br>当发生如下情况时，线程将会进入阻塞状态。</p>
<ul>
<li>线程调用sleep()方法主动放弃所占用的处理器资源。</li>
<li>线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞。</li>
<li>线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有。关于同步监视器的知识、后面将有更深入的介绍。</li>
<li>线程在等待某个通知（notify）。</li>
</ul>
<p>当前正在执行的线程被阻塞之后，其他线程就可以获得执行的机会。被阻塞的线程会在合适的时候重新进入就绪状态，注意是就绪状态而不是运行状态。也就是说，被阻塞线程的阻塞解除后，必须重新等待线程调度器再次调度它。<br>针对上面几种情况，当发生如下特定的情况时可以解除上面的阻塞，让该线程重新进入就绪状态。</p>
<ul>
<li>调用sleep()方法的线程经过了指定时间。</li>
<li>线程调用的阻塞式IO方法已经返回。</li>
<li>线程成功地获得了试图取得的同步监视器。</li>
<li>线程正在等待某个通知时，其他线程发出了一个通知。</li>
</ul>
<p>下图显示了线程状态转换图。</p>
<p><img src="https://files.catbox.moe/2fphnq.png"></p>
<p>下面通过示例来演示程序进入阻塞状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.cycle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">		System.out.println(<span class="string">&quot;Thread state====&quot;</span>+getState());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">		thread.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的程序发现启动线程后，线程一直处于阻塞状态，这是因为在代码第9行程序一直在等待着用户的输入。</p>
<h3 id="线程死亡"><a href="#线程死亡" class="headerlink" title="线程死亡"></a>线程死亡</h3><p>线程会以如下3种方式结束，结束后就处于死亡状态。</p>
<ul>
<li>run()或call()方法执行完成，线程正常结束。</li>
<li>线程抛出一个未捕获的 Exception或Error。</li>
<li>直接调用该线程的stop()方法来结束该线程——该方法容易导致死锁，通常不推荐使用。</li>
</ul>
<p><strong>当主线程结束时，其他线程不受任何影响，并不会随之结束。一旦子线程启动起来后，它就拥有和主线程相同的地位，它不会受主线程的影响。</strong><br>为了测试某个线程是否已经死亡，可以调用线程对象的isAlive()方法，当线程处于就绪、运行、阻塞3种状态时，该方法将返回true；当线程处于新建、死亡2种状态时，该方法将返回false。<br>下面通过程序来演示该状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.cycle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;state====&quot;</span>+getState());</span><br><span class="line">		System.out.println(<span class="string">&quot;isAlive====&quot;</span>+isAlive());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">		thread.start();</span><br><span class="line">		<span class="comment">//主线程休眠3秒，等待thread线程执行完毕</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//再次获取thread的状态</span></span><br><span class="line">		System.out.println(<span class="string">&quot;thread state====&quot;</span>+thread.getState());</span><br><span class="line">		System.out.println(<span class="string">&quot;thread isAlive====&quot;</span>+thread.isAlive());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中代码第12行启动了thread线程，启动该线程后让主线程休眠3s，给予thread线程充分的执行时间，当主线程休眠结束后，再次获取thread线程的状态，发现发现打印了TERMINATED。运行结果如下：<br><img src="https://files.catbox.moe/uwmrx6.png"><br><strong>不要对处于死亡状态的线程调用start()方法，程序只能对新建状态的线程调用start()方法，对新建状态的线程两次调用start()方法也是错误的。这都会引发IllegalThreadState Exception异常。</strong></p>
<h2 id="控制线程"><a href="#控制线程" class="headerlink" title="控制线程"></a>控制线程</h2><p>Java 的线程支持提供了一些便捷的工具方法，通过这些便捷的工具方法可以很好地控制线程的执行。</p>
<h3 id="join线程"><a href="#join线程" class="headerlink" title="join线程"></a>join线程</h3><p>Thread提供了让一个线程等待另一个线程执行完成的方法——join()，当某个程序在执行流中调用其他线程的join()方法时，调用线程将被阻塞，直到被join()方法加入的线程执行结束，通俗点说就是在A线程中调用线程B的join()方法，线程A会一直等待直到线程B执行结束再执行，也可以理解为插队。<br>下面通过示例来学习该方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.cycle;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ThreadB threadB;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ThreadA</span><span class="params">(ThreadB threadB)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.threadB = threadB;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">			System.out.println(getName()+<span class="string">&quot;-----------&quot;</span>+i);</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">20</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					threadB.start();</span><br><span class="line">					threadB.join();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.cycle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadB</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">			System.out.println(getName()+<span class="string">&quot;==============&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.cycle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">ThreadB</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadB</span>();</span><br><span class="line">		<span class="type">ThreadA</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadA</span>(b);</span><br><span class="line">		</span><br><span class="line">		b.setName(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">		a.setName(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">		a.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>在上面的程序中创建了a、b两个线程，其中在a线程for循环中当i等于20时，启动b线程并调用了b线程的join方法，此时a线程会一直等待b线程执行，直到b线程执行结束，再继续执行。<br>join()方法有如下3种重载形式。</p>
<ul>
<li>join()：等待被join的线程执行完成。此方法会把当前线程线程状态变成WAITING，直到被join的线程执行结束。</li>
<li>join(long millis)：等待被join的线程的时间最长为millis毫秒。如果在millis毫秒内被join的线程还没有执行结束，则不再等待。此方法会把当前线程状态变为TIMED_WAITING，直到被join的线程执行结束，或者等待被合并线程执行millis的时间</li>
<li>join(long millis,int nanos)：等待被join的线程的时间最长为millis毫秒加nanos毫微秒。此方法会把当前线程状态变为TIMED_WAITING，直到被join的线程执行结束，或者等待被合并线程执行millis+nanos的时间</li>
</ul>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>有一种线程，它是在后台运行的，它的任务是为其他的线程提供服务，这种线程被称为“后台线程（Daemon Thread）”，又称为“守护线程”，JVM的垃圾回收线程就是典型的后台线程。<br>后台线程有个特征：如果所有的前台线程都死亡，后台线程会自动死亡。<br>调用Thread对象的setDaemon(true)方法可将指定线程设置成后台线程。下面程序将执行线程设置成后台线程，可以看到当所有的前台线程死亡时，后台线程随之死亡。当整个虚拟机中只剩下后台线程时，程序就没有继续运行的必要了，所以虚拟机也就退出了。<br>除此以外可以通过isDaemon()方法判断线程是否是守护线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.cycle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeamonThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">			System.out.println(getName()+<span class="string">&quot;===========&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.cycle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeamonTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">DeamonThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeamonThread</span>();</span><br><span class="line">		t.setName(<span class="string">&quot;deamon&quot;</span>);</span><br><span class="line">		<span class="comment">//设置线程t为守护线程</span></span><br><span class="line">		t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">		t.start();</span><br><span class="line">		<span class="comment">//主线程循环次数大幅少于守护线程，当前台线程执行结束时</span></span><br><span class="line">		<span class="comment">//守护线程不管是否执行完毕都会结束</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-----------&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的程序发现当前台线程（此时只有两个线程运行，一个main线程，一个守护线程，所以main线程就是前台线程）运行结束时，守护线程不管是否执行完毕都会结束。这是因为当主线程也就是程序中唯一的前台线程运行结束后，JVM 会主动退出，因而后台线程也就被结束了。<br>只有前台线程全部终止了，相当于没有了被守护者，守护线程也就没有工作可做了，也就可以全部终止了。当然，用户线程全部终止，JVM进程也就没有继续的必要了。<br>使用守护线程时，有以下几点需要特别注意：</p>
<ol>
<li>守护线程必须在启动前将其守护状态设置为true，启动之后不能再将用户线程设置为守护线程，否则JVM会抛出一个InterruptedException异常。具体来说，如果线程为守护线程，就必须在线程实例的start()方法调用之前调用线程实例的setDaemon(true)，设置其daemon实例属性值为true。</li>
<li>守护线程存在被JVM强行终止的风险，所以在守护线程中尽量不去访问系统资源，如数据库连接。守护线程被强行终止时，可能会引发系统资源操作不负责任的中断，从而导致资源不可逆的损坏。</li>
<li>守护线程创建的线程也是守护线程。在守护线程中创建的线程，新的线程都是守护线程。在创建之后，如果通过调用setDaemon(false)将新的线程显式地设置为用户线程，新的线程可以调整成用户线程。</li>
</ol>
<h3 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h3><h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h4><p>如果需要让当前正在执行的线程暂停一段时间，并进入阻塞状态，则可以通过调用Thread类的静态sleep()方法来实现。</p>
<ul>
<li>static void sleep(long millis)：让当前正在执行的线程暂停millis毫秒，并进入阻塞状态，该方法受到系统计时器和线程调度器的精度与准确度的影响。</li>
<li>static void sleep(long millis,int nanos)：让当前正在执行的线程暂停millis毫秒加nanos毫微秒，并进入阻塞状态，该方法受到系统计时器和线程调度器的精度与准确度的影响。</li>
</ul>
<p>当前线程调用 sleep()方法进入阻塞状态后，在其睡眠时间段内，该线程不会获得执行的机会，即使系统中没有其他可执行的线程，处于sleep()中的线程也不会执行，因此sleep()方法常用来暂停程序的执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.cycle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//间隔1秒打印1次</span></span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LockSupport类"><a href="#LockSupport类" class="headerlink" title="LockSupport类"></a>LockSupport类</h4><p>LockSupport是JUC提供的一个线程阻塞与唤醒的工具类，该工具类可以让线程在任意位置阻塞和唤醒，其所有的方法都是静态方法。<br>LockSupport常用方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无限期阻塞当前线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">park</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//唤醒某个被阻塞的线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unpark</span><span class="params">(Thread thread)</span>;</span><br><span class="line"><span class="comment">//阻塞当前线程，有超时时间限制</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parkNanos</span><span class="params">(<span class="type">long</span> nanos)</span>;</span><br><span class="line"><span class="comment">//阻塞当前线程，直到某个时间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parkUntil</span><span class="params">(<span class="type">long</span> deadline)</span>;</span><br><span class="line"><span class="comment">//无限期阻塞当前线程，带blocker对象，用于给诊断工具确定线程受阻塞的原因</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">park</span><span class="params">(Object blocker)</span>;</span><br><span class="line"><span class="comment">//限时阻塞当前线程，带blocker对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parkNanos</span><span class="params">(Object blocker, <span class="type">long</span> nanos)</span>;</span><br><span class="line"><span class="comment">//获取被阻塞线程的blocker对象，用于分析阻塞的原因</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getBlocker</span><span class="params">(Thread t)</span>;</span><br></pre></td></tr></table></figure>

<p>LockSupport的方法主要有两类：park和unpark。park的英文意思为停车，如果把Thread看成一辆车的话，park()方法就是让车停下，其作用是将调用park()方法的当前线程阻塞；而unpark()方法是让车启动，然后跑起来，其作用是将指定线程Thread唤醒。<br>下面通过示例学习LockSupport的使用：<br><strong>LockSupport.park()和Thread.sleep()的区别：</strong><br>从功能上说，LockSupport.park()与Thread.sleep()方法类似，都是让线程阻塞，二者的区别如下：</p>
<ol>
<li>Thread.sleep()没法从外部唤醒，只能自己醒过来；而被LockSupport.park()方法阻塞的线程可以通过调用LockSupport.unpark()方法去唤醒。</li>
<li>Thread.sleep()方法声明了InterruptedException中断异常，这是一个受检异常，调用者需要捕获这个异常或者再抛出；而调用LockSupport.park()方法时不需要捕获中断异常。</li>
<li>被LockSupport.park()方法、Thread.sleep()方法所阻塞的线程有一个特点，当被阻塞线程的Thread.interrupt()方法被调用时，被阻塞线程的中断标志将被设置，该线程将被唤醒。不同的是，二者对中断信号的响应方式不同：LockSupport.park()方法不会抛出InterruptedException异常，仅仅设置了线程的中断标志；而Thread.sleep()方法会抛出InterruptedException异常。</li>
<li>与Thread.sleep()相比，调用LockSupport.park()能更精准、更加灵活地阻塞、唤醒指定线程。</li>
</ol>
<p><strong>注意：通过LockSupport.park()方法进入阻塞的线程和通过Thread.sleep()进入阻塞的线程一样，都不会释放锁。</strong><br><strong>LockSupport.part()和Object.wait()的区别：</strong></p>
<ol>
<li>Object.wait()方法需要在synchronized块中执行，而LockSupport.park()可以在任意地方执行。</li>
<li>当被阻塞线程被中断时，Object.wait()方法抛出了中断异常，调用者需要捕获或者再抛出；当被阻塞线程被中断时，LockSupport.park()不会抛出异常，调用时不需要处理中断异常。</li>
<li>如果线程在没有被Object.wait()阻塞之前被Object.notify()唤醒，也就是说在Object.wait()执行之前去执行Object.notify()，就会抛出IllegalMonitorStateException异常，是不被允许的；而线程在没有被LockSupport.park()阻塞之前被LockSupport.unPark()唤醒，也就是说在LockSupport.park()执行之前去执行LockSupport.unPark()，不会抛出任何异常，是被允许的。</li>
</ol>
<h3 id="线程让步"><a href="#线程让步" class="headerlink" title="线程让步"></a>线程让步</h3><p>yield()方法是一个和 sleep()方法有点相似的方法，它也是 Thread 类提供的一个静态方法，它也可以让当前正在执行的线程暂停，但它不会阻塞该线程，它只是将该线程转入就绪状态。yield()只是让当前线程暂停一下，让系统的线程调度器重新调度一次，线程调度器会从线程就绪队列里获取一个线程优先级高的线程，当然完全可能的情况是：当某个线程调用了yield()方法暂停之后，线程调度器又将其调度出来重新执行。<br>当某个线程调用了yield()方法暂停之后，只有优先级与当前线程相同，或者优先级比当前线程更高的处于就绪状态的线程才会获得执行的机会。下面程序使用yield()方法来让当前正在执行的线程暂停。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.cycle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YieldThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">			System.out.println(getName()+<span class="string">&quot;    &quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">YieldThread</span> <span class="variable">y1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">YieldThread</span>();</span><br><span class="line">		y1.setName(<span class="string">&quot;y1&quot;</span>);</span><br><span class="line">		<span class="comment">//y1.setPriority(MAX_PRIORITY);</span></span><br><span class="line">		y1.start();</span><br><span class="line">		<span class="type">YieldThread</span> <span class="variable">y2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">YieldThread</span>();</span><br><span class="line">		<span class="comment">//y2.setPriority(MIN_PRIORITY);</span></span><br><span class="line">		y2.setName(<span class="string">&quot;y2&quot;</span>);</span><br><span class="line">		y2.start();</span><br><span class="line">		System.out.println(<span class="string">&quot;调用Thread.yield()&quot;</span>);</span><br><span class="line">		Thread.yield();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程序中的第一行粗体字代码调用yield()静态方法让当前正在执行的线程暂停，让系统线程调度器重新调度。<br><strong>sleep()方法和yield()方法的区别：</strong></p>
<ol>
<li>sleep()方法暂停当前线程后，会给其他线程执行机会，不会理会其他线程的优先级；但yield()方法只会给优先级相同，或优先级更高的线程执行机会。</li>
<li>sleep()方法会将线程转入阻塞状态，直到经过阻塞时间才会转入就绪状态；而yield()不会将线程转入阻塞状态，它只是强制当前线程进入就绪状态。因此完全有可能某个线程调用yield()方法暂停之后，立即再次获得处理器资源被执行。</li>
<li>sleep()方法声明抛出了 InterruptedException 异常，所以调用 sleep()方法时要么捕捉该异常，要么显式声明抛出该异常；而yield()方法则没有声明抛出任何异常。</li>
</ol>
<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>每个线程执行时都具有一定的优先级，优先级高的线程获得较多的执行机会，而优先级低的线程则获得较少的执行机会。每个线程默认的优先级都与创建它的父线程的优先级相同，在默认情况下，main线程具有普通优先级，由main线程创建的子线程也具有普通优先级。<br>Thread类提供了setPriority(int newPriority)、getPriority()方法来设置和返回指定线程的优先级，其中setPriority()方法的参数可以是一个整数，范围是1～10之间，也可以使用Thread类的如下3个静态常量。</p>
<ul>
<li>MAX_PRIORITY：其值是10。</li>
<li>MIN_PRIORITY：其值是1。</li>
<li>NORM_PRIORITY：其值是5。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.cycle;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">			System.out.println(<span class="built_in">this</span>.getPriority()+<span class="string">&quot;========&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">PriorityThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityThread</span>();</span><br><span class="line">		thread.setPriority(MAX_PRIORITY);</span><br><span class="line">		thread.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然Java提供了10个优先级级别，但这些优先级级别需要操作系统的支持。不同操作系统上的优先级并不相同，而且也不能很好地和Java的10个优先级对应。在这种情况下，我们应该尽量避免直接为线程指定优先级。</p>
<h3 id="线程的停止"><a href="#线程的停止" class="headerlink" title="线程的停止"></a>线程的停止</h3><p>Java语言提供了stop()方法终止正在运行的线程，但是Java将Thread的stop()方法设置为过时，不建议大家使用。为什么呢？在程序中，我们是不能随便中断一个线程的，我们无法知道这个线程正运行在什么状态，它可能持有某把锁，强行中断线程可能导致锁不能释放的问题；或者线程可能在操作数据库，强行中断线程可能导致数据不一致的问题。正是由于调用stop()方法来终止线程可能会产生不可预料的结果，因此不推荐调用stop()方法。<br>所以，这里介绍一下Thread的interrupt()方法，此方法本质不是用来中断一个线程，而是将线程设置为中断状态。<br>当我们调用线程的interrupt()方法时，它有两个作用：</p>
<ol>
<li><p>如果此线程处于阻塞状态（如调用了Object.wait()方法），就会立马退出阻塞，并抛出InterruptedException异常，线程就可以通过捕获InterruptedException来做一定的处理，然后让线程退出。更确切地说，如果线程被Object.wait()、Thread.join()和Thread.sleep()三种方法之一阻塞，此时调用该线程的interrupt()方法，该线程将抛出一个InterruptedException中断异常（该线程必须事先预备好处理此异常），从而提早终结被阻塞状态。</p>
</li>
<li><p>如果此线程正处于运行之中，线程就不受任何影响，继续运行，仅仅是线程的中断标记被设置为true。所以，程序可以在适当的位置通过调用isInterrupted()方法来查看自己是否被中断，并执行退出操作。</p>
<p>​</p>
</li>
</ol>
<p><strong>线程中断：</strong></p>
<p>首先，一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止。所以，Thread.stop, Thread.suspend, Thread.resume 都已经被废弃了。而 Thread.interrupt 的作用其实也不是中断线程， 而是「通知线程应该中断了」，具体到底中断还是继续运行， 应该由被通知的线程自己处理。具体来说，当对一个线程，调用 interrupt() 时，① 如果线程处于被阻塞状态（例如处于sleep, wait, join 等状态），那么线程将立即退出被阻塞状态， 并抛出一个InterruptedException异常。 仅此而已。② 如果线程处于正常活动状态，那么会将该线程的中断标志设置为 true，仅此而已。被设置中断标志的线程将继续正常运行，不受影响。<br>  interrupt() 并不能真正的中断线程， 需要被调用的线程自己进行配合才行。也就是说，一个线程如果有被中断的需求，那么就可以这样做。① 在正常运行任务时，经常检查本线程的中断标志位，如果被设置了中断标志就自行停止线程。② 在调用阻塞方法时正确处理InterruptedException异常。（例如，catch异常后就结束线程。）   thread.interrupt();Thread.interrupted()清除标志位是为了下次继续检测标志位。 如果一个线程被设置中断标志后，选择结束线程那么自然不存在下次的问题，而如果一个线程被设置中断标识后，进行了一些处理后选择继续进行任务，而且这个任务也是需要被中断的，那么当然需要清除标志位了。</p>
<h3 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h3><h4 id="死锁及死锁产生的条件"><a href="#死锁及死锁产生的条件" class="headerlink" title="死锁及死锁产生的条件"></a>死锁及死锁产生的条件</h4><p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去，如图所示：</p>
<p><img src="https://files.catbox.moe/slpiro.png"></p>
<p>在上图中，线程A已经持有了资源2，它同时还想申请资源1，线程B已经持有了资源1，它同时还想申请资源2，所以线程A和线程B就因为相互等待对方已经持有的资源，而进入了死锁状态。<br>那么为什么会产生死锁呢？死锁的产生必须具备以下四个条件。</p>
<ol>
<li>互斥条件：指线程对已经获取到的资源进行排它性使用，即该资源同时只由一个线程占用。如果此时还有其他线程请求获取该资源，则请求者只能等待，直至占有资源的线程释放该资源。</li>
<li>请求并持有条件：指一个线程已经持有了至少一个资源，但又提出了新的资源请求，而新资源已被其他线程占有，所以当前线程会被阻塞，但阻塞的同时并不释放自己已经获取的资源。</li>
<li>不可剥夺条件：指线程获取到的资源在自己使用完之前不能被其他线程抢占，只有在自己使用完毕后才由自己释放该资源。</li>
<li>环路等待条件：指在发生死锁时，必然存在一个线程—资源的环形链，即线程集合{T0, T1, T2, …, Tn}中的T0正在等待一个T1占用的资源，T1正在等待T2占用的资源，……Tn正在等待已被T0占用的资源。</li>
</ol>
<p>下面通过示例来演示线程死锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resourceA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resourceB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建线程A</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resourceA)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">&quot;get ResourceA&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//休眠1秒给线程B运行机会</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">&quot;waiting get resourcesB&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceB)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread()+<span class="string">&quot;get resourceB&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//创建线程B</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resourceB)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">&quot;get ResourceB&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//休眠1秒给线程A运行机会</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">&quot;waiting get resourcesA&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceA)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread()+<span class="string">&quot;get resourceA&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<p><img src="https://files.catbox.moe/2xijud.png"></p>
<p>从结果分析可以得出：<br>Thread-0是线程A, Thread-1是线程B，代码首先创建了两个资源，并创建了两个线程。从输出结果可以知道，线程调度器先调度了线程A，也就是把CPU资源分配给了线程A，线程A使用synchronized（resourceA）方法获取到了resourceA的监视器锁，然后调用sleep函数休眠1s，休眠1s是为了保证线程A在获取resourceB对应的锁前让线程B抢占到CPU，获取到资源resourceB上的锁。线程A调用sleep方法后线程B会执行synchronized（resourceB）方法，这代表线程B获取到了resourceB对象的监视器锁资源，然后调用sleep方法休眠1s。好了，到了这里线程A获取到了resourceA资源，线程B获取到了resourceB资源。线程A休眠结束后会企图获取resourceB资源，而resourceB资源被线程B所持有，所以线程A会被阻塞而等待。而同时线程B休眠结束后会企图获取resourceA资源，而resourceA资源已经被线程A持有，所以线程A和线程B就陷入了相互等待的状态，也就产生了死锁。下面谈谈本例是如何满足死锁的四个条件的。<br>首先，resourceA和resourceB都是互斥资源，当线程A调用synchronized（resourceA）方法获取到resourceA上的监视器锁并释放前，线程B再调用synchronized（resourceA）方法尝试获取该资源会被阻塞，只有线程A主动释放该锁，线程B才能获得，这满足了资源互斥条件。<br>线程A首先通过synchronized（resourceA）方法获取到resourceA上的监视器锁资源，然后通过synchronized（resourceB）方法等待获取resourceB上的监视器锁资源，这就构成了请求并持有条件。<br>线程A在获取resourceA上的监视器锁资源后，该资源不会被线程B掠夺走，只有线程A自己主动释放resourceA资源时，它才会放弃对该资源的持有权，这构成了资源的不可剥夺条件。<br>线程A持有objectA资源并等待获取objectB资源，而线程B持有objectB资源并等待objectA资源，这构成了环路等待条件。所以线程A和线程B就进入了死锁状态。</p>
<h4 id="如何避免线程死锁"><a href="#如何避免线程死锁" class="headerlink" title="如何避免线程死锁"></a>如何避免线程死锁</h4><p>要想避免死锁，只需要破坏掉至少一个构造死锁的必要条件即可，但是学过操作系统的读者应该都知道，目前只有请求并持有和环路等待条件是可以被破坏的。<br>造成死锁的原因其实和申请资源的顺序有很大关系，使用资源申请的有序性原则就可以避免死锁，那么什么是资源申请的有序性呢？我们对上面线程B的代码进行如下修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resourceA)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">&quot;get ResourceB&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//休眠1秒给线程A运行机会</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">&quot;waiting get resourcesA&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceB)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread()+<span class="string">&quot;get resourceA&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<p><img src="https://files.catbox.moe/1oq822.png"></p>
<p>如上代码让在线程B中获取资源的顺序和在线程A中获取资源的顺序保持一致，其实资源分配有序性就是指，假如线程A和线程B都需要资源1,2,3, …, n时，对资源进行排序，线程A和线程B只有在获取了资源n-1时才能去获取资源n。<br>可以简单分析一下为何资源的有序分配会避免死锁，比如上面的代码，假如线程A和线程B同时执行到了synchronized（resourceA），只有一个线程可以获取到resourceA上的监视器锁，假如线程A获取到了，那么线程B就会被阻塞而不会再去获取资源B，线程A获取到resourceA的监视器锁后会去申请resourceB的监视器锁资源，这时候线程A是可以获取到的，线程A获取到resourceB资源并使用后会放弃对资源resourceB的持有，然后再释放对resourceA的持有，释放resourceA后线程B才会被从阻塞状态变为激活状态。所以资源的有序性破坏了资源的请求并持有条件和环路等待条件，因此避免了死锁。</p>
<h2 id="JMM模型"><a href="#JMM模型" class="headerlink" title="JMM模型"></a>JMM模型</h2><p>JMM（Java Memory Model）：Java 内存模型，是 Java 虚拟机规范中所定义的一种内存模型，Java 内存模型是标准化的，屏蔽掉了底层不同计算机的区别。也就是说，JMM 是 JVM 中定义的一种并发编程的底层模型机制。</p>
<h3 id="JMM简介"><a href="#JMM简介" class="headerlink" title="JMM简介"></a>JMM简介</h3><p>Java内存模型规定，将所有的变量都存放在主内存中，当线程使用变量时，会把主内存中的变量复制到自己的工作空间或者叫作工作内存，线程读写变量时的操作的是自己工作内存中的变量。<br>Java线程间修改共享变量的可见性由Java内存模型控制（即JMM），JMM决定以线程对共享变量的写入对另一个线程可见，从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系。<br>JMM内存模型规定详解如下：</p>
<ul>
<li>所有的共享变量都存储于主内存。这里所说的变量指的是实例变量和类变量，不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。</li>
<li>每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。</li>
<li>线程对变量的所有的操作（读，写）都必须在工作内存中完成，而不能直接读写主内存中的变量。</li>
<li>不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。</li>
</ul>
<p>JMM是一个抽象的概念，并不真实存在，其抽象模型示意图如下：</p>
<p><img src="https://files.catbox.moe/cbtjwx.png"></p>
<p>从上图可以看出，如果A、B两个线程之间要通信，必须经历以下2个步骤</p>
<ol>
<li>线程A把本次内存中更新过的共享变量刷新到主内存中去。</li>
<li>线程B从主内存中读取线程A已经更新过的共享变量。</li>
</ol>
<p>然而，JMM 这样的规定可能会导致线程对共享变量的修改没有即时更新到主内存，或者线程没能够及时将共享变量的最新值同步到工作内存中，从而使得线程在使用共享变量的值时，该值并不是最新的。</p>
<h3 id="JMM特性"><a href="#JMM特性" class="headerlink" title="JMM特性"></a>JMM特性</h3><p>JMM的关键技术点都是围绕着多线程的原子性、可见性和有序性来建立的。因此，我们首先必须了解这些概念。</p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>原子性是指，一个或者多个操作不可分割，要么全部执行，并且执行过程中不会被任何因素打断，要么就都不执行。Java中可以使用synchronized保证原子性。</p>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>可见性是指当一个线程修改了某一个共享变量的值时，其他线程是否能够立即知道这个修改。显然，对于串行程序来说，可见性问题是不存在的。因为你在任何一个操作步骤中修改了某个变量，在后续的步骤中读取这个变量的值时，读取的一定是修改后的新值。Java中的volatile、synchronized、Lock都能保证可见性。如一个变量被volatile修饰后，表示当一个线程修改共享变量后，其会立即被更新到主内存中，其他线程读取共享变量时，会直接从主内存中读取。而synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>对于一个线程的执行代码而言，我们总是习惯性地认为代码是从前往后依次执行的。这么理解也不能说完全错误，因为就一个线程内而言，确实会表现成这样。但是，在并发时，程序的执行可能就会出现乱序。给人的直观感觉就是：写在前面的代码，会在后面执行。听起来有些不可思议，有序性问题的原因是程序在执行时，可能会进行指令重排，重排后的指令与原指令的顺序未必一致。<br>在单核CPU的场景下，当指令被重排序之后，如何保障运行的正确性呢？其实很简单，编译器和CPU都需要遵守As-if-Serial规则。<br>As-if-Serial规则的具体内容为：无论如何重排序，都必须保证代码在单线程下运行正确。为了遵守As-if-Serial规则，编译器和CPU不会对存在数据依赖关系的操作进行重排序，因为这种重排序会改变执行结果。但是，如果指令之间不存在数据依赖关系，这些指令可能被编译器和CPU重排序。<br>下面是一段非常简单的示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReorderDemo</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">//①</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>; <span class="comment">//②</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a+b; <span class="comment">//③</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例代码中，③和①之间存在数据依赖关系，同时③和②之间也存在数据依赖关系。因此，在最终执行的指令序列中，③不能被重排序到①和②的前面，因为③排到①和②的前面，程序的结果将会被改变。但①和②之间没有数据依赖关系，编译器和CPU可以重排序①和②之间的执行顺序。<br>虽然编译器和CPU遵守了As-if-Serial规则，无论如何，也只能在单CPU执行的情况下保证结果正确。在多核CPU并发执行的场景下，由于CPU的一个内核无法清晰分辨其他内核上指令序列中的数据依赖关系，因此可能出现乱序执行，从而导致程序运行结果错误。因此As-if-Serial规则只能保障单内核指令重排序之后的执行结果正确，不能保障多内核以及跨CPU指令重排序之后的执行结果正确。</p>
<h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h2><h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><p>在多线程编程中经常会出现程序运行结果和预期结果不一致的问题，例如两个线程对初始值为0的同一变量自增，结果不一定是2，也有可能1，这种多个线程对同一个对象中的实例变量进行并发访问时发生，产生的后果就是“脏读”，这就是非线程安全。其根源就是没有保证线程的原子性。<br>下面通过示例演示该问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumberPrint</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> NumberPrint numberPrint;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Thread1</span><span class="params">(NumberPrint numberPrint)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.numberPrint = numberPrint;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		numberPrint.num++;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">&quot;============&quot;</span>+numberPrint.num);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">NumberPrint</span> <span class="variable">numberPrint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumberPrint</span>();</span><br><span class="line">		<span class="type">Thread1</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread1</span>(numberPrint);</span><br><span class="line">		</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">		t1.setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">		t2.setName(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的程序发现程序有时候会输出1和2，这是符合预期的，但是如果多运行几次就会发现还会输出2和2，这就出现了不符合预期，也就是线程不同步的情况，为什么会出现这种情况呢，在前面的内容中知道当线程获得资源后会执行run方法中方法体，当分配的资源使用完毕后不管run方法是否执行完都会立即停止然后下一个线程继续执行。<br><strong>注意：++操作并不是一个原子操作，实际上自增操作中包含了以下3步：</strong></p>
<ol>
<li><strong>读取自增变量的值</strong></li>
<li><strong>对变量进行自增</strong></li>
<li><strong>将自增的结果保存进变量</strong></li>
</ol>
<p>在上述代码中可能就会出现如下的执行情况：</p>
<ol>
<li>T1时刻线程1读取了变量num值为0，并完成了自增值成为了1</li>
<li>T2时刻线程1停止运行，由于已经保存自增后的值，线程2读取num的值也为1，并完成了自增操作，num变成了2。</li>
<li>T3时刻线程2停止运行，线程1打印num值2</li>
<li>T4时刻线程1停止运行，线程2打印num值2</li>
</ol>
<p>因此，上述程序有可能打印的并不是1、2，而是2、2。上述过程可以描述如下表：</p>
<table>
<thead>
<tr>
<th>时刻</th>
<th>线程1</th>
<th>线程2</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>1.读取num&#x3D;02.自增 num&#x3D;13.写入num&#x3D;1</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>1.读取num&#x3D;12.自增 num&#x3D;23.写入num&#x3D;2</td>
</tr>
<tr>
<td>T3</td>
<td>1.打印num&#x3D;2</td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>1.打印num&#x3D;2</td>
</tr>
</tbody></table>
<p>从执行过程来看，很明显自增操作并没有保证原子性，那么如何解决这种问题呢？在接下来的同步方法和同步代码块中将会深入学习。</p>
<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>为了解决多线程环境下访问同一对象的实例变量值不同步的情况，Java的多线程支持引入同步监视器来解决这个问题。一种解决方式就是在方法头中加入synchronized关键字让方法成为同步方法，对于同步方法而言，无须显式指定同步监视器，同步方法的同步监视器是this，也就是该对象本身。<br>重构上面的程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> NumberPrint numberPrint;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Thread1</span><span class="params">(NumberPrint numberPrint)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.numberPrint = numberPrint;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">&quot;============&quot;</span>+numberPrint.num++;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">NumberPrint</span> <span class="variable">numberPrint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumberPrint</span>();</span><br><span class="line">		<span class="type">Thread1</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread1</span>(numberPrint);</span><br><span class="line">		</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">		t1.setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">		t2.setName(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的程序可以发现无论运行多少次，运行的结果都是符合预期的：打印了1和2，同步监视器可以理解为为synchronized所修饰的方法加锁，当方法被加锁后在多线程环境下一旦线程获得资源（这里的资源是指锁和CPU时间片），那么在此方法执行结束之前，其他线程都不能进入该方法，这也就避免了多个线程访问同一对象的实例变量时出现值不同步的情况。换句话说synchronized可以保证操作的原子性。</p>
<h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>除此之外，Java还可以使用同步代码块来解决线程安全问题，同步代码块语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line"> 	<span class="comment">//此处代码即需要同步的代码   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用同步代码块继续重构上面的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> NumberPrint numberPrint;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Thread1</span><span class="params">(NumberPrint numberPrint)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.numberPrint = numberPrint;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (numberPrint) &#123;</span><br><span class="line">			numberPrint.num++;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">&quot;============&quot;</span>+numberPrint.num);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">NumberPrint</span> <span class="variable">numberPrint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumberPrint</span>();</span><br><span class="line">		<span class="type">Thread1</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread1</span>(numberPrint);</span><br><span class="line">		</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">		t1.setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">		t2.setName(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的程序发现运行结果也是符合预期的。需要注意的是，当选取锁时一定要保证该锁在当前运行环境中是唯一的，如果锁失去了唯一性，同步代码块也就不能达到同步的目的。<br><strong>任何时刻只能有一个线程可以获得对同步监视器的锁定，当同步代码块执行完成后，该线程会释放对该同步监视器的锁定。</strong><br>任何线程进入同步代码块、同步方法之前，必须先获得对同步监视器的锁定，那么何时会释放对同步监视器的锁定呢？程序无法显式释放对同步监视器的锁定，线程会在如下几种情况下释放对同步监视器的锁定。</p>
<ul>
<li>当前线程的同步方法、同步代码块执行结束，当前线程即释放同步监视器。</li>
<li>当前线程在同步代码块、同步方法中遇到break、return终止了该代码块，当前线程将会释放同步监视器。</li>
<li>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致了该代码块、该方法异常结束时，当前线程将会释放同步监视器。</li>
<li>当前线程执行同步代码块或同步方法时，程序执行了同步监视器对象的wait()方法，则当前线程暂停，并释放同步监视器。</li>
</ul>
<p>在如下所示的情况下，线程不会释放同步监视器。</p>
<ul>
<li>线程执行同步代码块或同步方法时，程序调用 Thread.sleep()、Thread.yield()方法来暂停当前线程的执行，当前线程不会释放同步监视器。</li>
</ul>
<h3 id="Synchronized实现原理"><a href="#Synchronized实现原理" class="headerlink" title="Synchronized实现原理"></a>Synchronized实现原理</h3><p>当使用了synchronized加锁后，对源代码进行反编译，可以看出源代码中有monitorenter和monitorexit两条指令，每一个对象都有一个monitor，一个monitor只能被一个线程拥有。当一个线程执行到monitorenter指令时会尝试获取相应对象的monitor，获取规则如下：</p>
<ul>
<li>如果monitor的进入数为0，则该线程可以进入monitor，并将monitor进入数设置为1，该线程即为monitor的拥有者。</li>
<li>如果当前线程已经拥有该monitor，只是重新进入，则进入monitor的进入数加1，所以synchronized关键字实现的锁是可重入的锁。</li>
<li>如果monitor已被其他线程拥有，则当前线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor。</li>
</ul>
<p><strong>monitorexit</strong><br>只有拥有相应对象的monitor的线程才能执行monitorexit指令。每执行一次该指令monitor进入数减1，当进入数为0时当前线程释放monitor，此时其他阻塞的线程将可以尝试获取该monitor。</p>
<h3 id="synchronized的内存语义"><a href="#synchronized的内存语义" class="headerlink" title="synchronized的内存语义"></a>synchronized的内存语义</h3><p>前面介绍了共享变量内存可见性问题主要是由于线程的工作内存导致的，下面我们来讲解synchronized的内存语义，这个内存语义就可以解决共享变量内存可见性问题。</p>
<ol>
<li>进入synchronized块的内存语义是把在synchronized块内使用到的变量从线程的工作内存中清除，这样在synchronized块内使用到该变量时就不会从线程的工作内存中获取，而是直接从主内存中获取。</li>
<li>退出synchronized块的内存语义是把在synchronized块内对共享变量的修改刷新到主内存。</li>
</ol>
<p>其实这也是加锁和释放锁的语义，当获取锁后会清空锁块内本地内存中将会被用到的共享变量，在使用这些共享变量时从主内存进行加载，在释放锁时将本地内存中修改的共享变量刷新到主内存。除可以解决共享变量内存可见性问题外，synchronized经常被用来实现原子性操作。另外请注意，synchronized关键字会引起线程上下文切换并带来线程调度开销。</p>
<h2 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h2><p>从Java 5开始，Java提供了一种功能更强大的线程同步机制——通过显式定义同步锁对象来实现同步，在这种机制下，同步锁使用Lock对象充当。<br>Lock接口的主要抽象方法如下：<br>从Lock提供的接口方法可以看出，显式锁至少比Java内置锁多了以下优势：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>lock()</td>
<td>抢占锁，如果抢占成功则向下运行，如果失败则阻塞抢锁线程</td>
</tr>
<tr>
<td>void lockInterruptibly() throws InterruptedException</td>
<td>可中断抢锁，当前线程在抢锁的过程中可以响应中断信号。</td>
</tr>
<tr>
<td>boolean tryLock()</td>
<td>尝试抢锁，线程为非阻塞模式，在调用tryLock()方法后立即返回。如果抢锁成功则返回true，如果抢锁失败则返回false</td>
</tr>
<tr>
<td>boolean tryLock(long time,TimeUnit unit)throws InterruptedException</td>
<td>限时抢锁，到达超时时间返回false，并且此限时抢锁方法也可以响应中断信号</td>
</tr>
<tr>
<td>void unlock()</td>
<td>释放锁</td>
</tr>
<tr>
<td>Condition newCondition()</td>
<td>获取与显示锁绑定的Condition对象，用于“等待—通知”方式的线程间通信。</td>
</tr>
</tbody></table>
<p>与synchronized关键字不同，显式锁不再作为Java内置特性来实现，而是作为Java语言可编程特性来实现。这就为多种不同功能的锁实现留下了空间，各种锁实现可能有不同的调度算法、性能特性或者锁定语义。<br>从Lock提供的接口方法可以看出，显式锁至少比Java内置锁多了以下优势：<br><strong>1.可中断获取锁</strong><br>使用synchronized关键字获取锁的时候，如果线程没有获取到被阻塞，阻塞期间该线程是不响应中断信号（interrupt）的；而调用Lock.lockInterruptibly()方法获取锁时，如果线程被中断，线程将抛出中断异常。<br><strong>2.可非阻塞获取锁</strong><br>使用synchronized关键字获取锁时，如果没有成功获取，线程只有被阻塞；而调用Lock.tryLock()方法获取锁时，如果没有获取成功，线程也不会被阻塞，而是直接返回false。<br><strong>3.可限时抢锁</strong><br>调用Lock.tryLock(long time,TimeUnit unit)方法，显式锁可以设置限定抢占锁的超时时间。而在使用synchronized关键字获取锁时，如果不能抢到锁，线程只能无限制阻塞。<br>因此可以看出Lock提供了比synchronized方法和synchronized代码块更广泛的锁定操作，Lock实现允许更灵活的结构，可以具有差别很大的属性，并且支持多个相关的Condition对象。<br>Lock是控制多个线程对共享资源进行访问的工具。通常，锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</p>
<h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>ReentrantLock是JUC包提供的显式锁的一个基础实现类，ReentrantLock类实现了Lock接口，它拥有与synchronized相同的并发性和内存语义，但是拥有了限时抢占、可中断抢占等一些高级锁特性。<br>在实现线程安全的控制中，比较常用的是ReentrantLock（可重入锁）。使用该Lock对象可以显式地加锁、释放锁。<br>ReentrantLock是一个可重入的独占（或互斥）锁，其中两个修饰词的含义为：</p>
<ol>
<li>可重入的含义：表示该锁能够支持一个线程对资源的重复加锁，也就是说，一个线程可以多次进入同一个锁所同步的临界区代码块。比如，同一线程在外层函数获得锁后，在内层函数能再次获取该锁，甚至多次抢占到同一把锁。</li>
<li>独占的含义：在同一时刻只能有一个线程获取到锁，而其他获取锁的线程只能等待，只有拥有锁的线程释放了锁后，其他的线程才能够获取锁。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumberPrint</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">	<span class="keyword">private</span> NumberPrint numberPrint;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(NumberPrint numberPrint)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.numberPrint = numberPrint;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			numberPrint.num++;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">&quot;============&quot;</span>+numberPrint.num);</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用ReentrantLock对象来进行同步，加锁和释放锁出现在不同的作用范围内时，通常建议使用 finally 块来确保在必要时释放锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">NumberPrint</span> <span class="variable">numberPrint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumberPrint</span>();</span><br><span class="line">		<span class="type">MyThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(numberPrint);</span><br><span class="line">		</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">		t1.setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">		t2.setName(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock锁具有可重入性，也就是说，一个线程可以对已被加锁的ReentrantLock锁再次加锁，ReentrantLock对象会维持一个计数器来追踪lock()方法的嵌套调用，线程在每次调用lock()加锁后，必须显式调用unlock()来释放锁，所以一段被锁保护的代码可以调用另一个被相同锁保护的方法。</p>
<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>在多线程并发编程中synchronized和volatile都扮演着重要的角色，volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。如果volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。</p>
<h3 id="volatile的作用"><a href="#volatile的作用" class="headerlink" title="volatile的作用"></a>volatile的作用</h3><p>上面介绍了使用synchronized的方式可以解决共享变量内存可见性问题，但是使用锁太笨重，因为它会带来线程上下文的切换开销。对于解决内存可见性问题，Java还提供了一种弱形式的同步，也就是使用volatile关键字。该关键字可以确保对一个变量的更新对其他线程马上可见。<strong>当一个变量被声明为volatile时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存</strong>。当其他线程读取该共享变量时，会从主内存重新获取最新值，而不是使用当前线程的工作内存中的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolitaleDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyTest</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">()</span>&#123;</span><br><span class="line">            num = <span class="number">60</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">MyTest</span> <span class="variable">myTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTest</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----&quot;</span>);</span><br><span class="line">        <span class="comment">//创建一个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t started&quot;</span>);</span><br><span class="line">                <span class="comment">//让当前线程休眠，运行主线程</span></span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                <span class="comment">//修改num的值</span></span><br><span class="line">                myTest.change();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t update num&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="comment">//此处while循环一直检测num是否变成60</span></span><br><span class="line">        <span class="keyword">while</span>(myTest.num==<span class="number">0</span>)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上例VolatileDemo中新建了内部类MyTest，并在其中定义了变量num，此时num没有做内存可见性处理。<br>在main方法中新建了线程t1，调用了MyTest中的change()方法，修改num的值为60。并在main方法中检测num是否还是0。<br>运行程序可以发现，程序一直没有停止，也没有输出最后的end，这说明t1修改了共享变量num的值后，对main线程是不可见了。<br>修改代码，将变量使用volatile修饰，再次运行程序可发现程序检测到num值被修改为了60。并且输出了end。<br>但是需要注意的是<strong>volatile只能保证可见性和有序性</strong>。并不能保证原子性。<br>那么一般在什么时候才使用volatile关键字呢？</p>
<ul>
<li>写入变量值不依赖变量的当前值时。因为如果依赖当前值，将是获取—计算—写入三步操作，这三步操作不是原子性的，而volatile不保证原子性。</li>
<li>读写变量值时没有加锁。因为加锁本身已经保证了内存可见性，这时候不需要把变量声明为volatile的。</li>
</ul>
<h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><p><strong>volatile的另一作用是禁止指令重排序</strong>，也就是保证有序性，那么什么是指令重排序呢？<br>指令重排序是指在执行程序时，编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。<br>重排序分3种类型：</p>
<ol>
<li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术，来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序。由于处理器使用缓存和读&#x2F;写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ol>
<p>从Java源代码到最终实际执行的指令序列，会分别经历下面3种重排序。</p>
<p><img src="https://files.catbox.moe/njondn.png"></p>
<p>上述的1属于编译器重排序，2和3属于处理器重排序。这些重排序可能会导致多线程程序出现内存可见性问题。<br>对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障（Memory Barriers，Intel称之为Memory Fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序。<br>下面，先通过示例来学习指令重排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 线程 A</span></span><br><span class="line">a = <span class="number">1</span>;           <span class="comment">// 1</span></span><br><span class="line">flag = <span class="literal">true</span>;     <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程 B</span></span><br><span class="line"><span class="keyword">if</span> (flag) &#123; <span class="comment">// 3</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a; <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单看上面的程序好像没有问题，最后 i 的值是 1。但是为了提高性能，编译器和处理器常常会在不改变数据依赖的情况下对指令做重排序。假设线程 A 在执行时被重排序成先执行代码 2，再执行代码 1；而线程 B 在线程 A 执行完代码 2 后，读取了 flag 变量。<br>由于条件判断为真，线程 B 将读取变量 a。此时，变量 a 还根本没有被线程 A 写入，那么 i 最后的值是 0，导致执行结果不正确。那么如何程序执行结果正确呢？这里仍然可以使用 volatile 关键字。<br>这个例子中， 使用 volatile 不仅保证了变量的内存可见性，还禁止了指令的重排序，<strong>即保证了 volatile 修饰的变量编译后的顺序与程序的执行顺序一样</strong>。那么使用 volatile 修饰 flag 变量后，在线程 A 中，保证了代码 1 的执行顺序一定在代码 2 之前。<br>对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障（Memory Barriers，Intel称之为Memory Fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序。</p>
<h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>内存屏障又称内存栅栏（Memory Fences），是一系列的CPU指令，它的作用主要是保证特定操作的执行顺序，保障并发执行的有序性。在编译器和CPU都进行指令的重排优化时，可以通过在指令间插入一个内存屏障指令，告诉编译器和CPU，禁止在内存屏障指令前（或后）执行指令重排序。<br>由于不同CPU硬件实现内存屏障的方式不同，JMM屏蔽了这种底层CPU硬件平台的差异，定义了不对应任何CPU的JMM逻辑层内存屏障，由JVM在不同的硬件平台生成对应的内存屏障机器码。<br>JMM内存屏障主要有Load和Store两类，具体如下：</p>
<ol>
<li>Load Barrier（读屏障）：在读指令前插入读屏障，可以让高速缓存中的数据失效，重新从主存加载数据。</li>
<li>Store Barrier（写屏障）：在写指令之后插入写屏障，能让写入缓存的最新数据写回主存。</li>
<li>在实际使用时，会对以上JMM的Load Barrier和Store Barrier两类屏障进行组合，组合成LoadLoad（LL）、StoreStore（SS）、LoadStore（LS）、StoreLoad（SL）四个屏障，用于禁止特定类型的CPU重排序。</li>
</ol>
<h4 id="LoadLoad（LL）屏障"><a href="#LoadLoad（LL）屏障" class="headerlink" title="LoadLoad（LL）屏障"></a>LoadLoad（LL）屏障</h4><p>在执行预加载（或支持乱序处理）的指令序列中，通常需要显式地声明LoadLoad屏障，因为这些Load指令可能会依赖其他CPU执行的Load指令的结果。<br>一段使用LoadLoad（LL）屏障的伪代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Load1;LoadLoad;Load2;</span><br></pre></td></tr></table></figure>

<p>该示例的含义为：在Load2要读取的数据被访问前，使用LoadLoad屏障保证Load1要读取的数据被读取完毕。</p>
<h4 id="StoreStore（SS）屏障"><a href="#StoreStore（SS）屏障" class="headerlink" title="StoreStore（SS）屏障"></a>StoreStore（SS）屏障</h4><p>通常情况下，如果CPU不能保证从高速缓冲向主存（或其他CPU）按顺序刷新数据，那么它需要使用StoreStore屏障。<br>一段使用StoreStore（SS）屏障的伪代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Store1;StoreStore;Store2;</span><br></pre></td></tr></table></figure>

<p>该示例的含义为：在Store2及后续写入操作执行前，使StoreStore屏障保证Store1的写入结果对其他CPU可见。</p>
<h4 id="LoadStore（LS）屏障"><a href="#LoadStore（LS）屏障" class="headerlink" title="LoadStore（LS）屏障"></a>LoadStore（LS）屏障</h4><p>该屏障用于在数据写入操作执行前确保完成数据的读取。一段使用LoadStore（LS）屏障的伪代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Load1;LoadStore;Store2;</span><br></pre></td></tr></table></figure>

<p>该示例的含义为：在Store2及后续写入操作执行前，使LoadStore屏障保证Load1要读取的数据被读取完毕。</p>
<h4 id="（SL）屏障"><a href="#（SL）屏障" class="headerlink" title="（SL）屏障"></a>（SL）屏障</h4><p>该屏障用于在数据读取操作执行前，确保完成数据的写入。使用StoreLoad（SL屏障）屏障的伪代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Store1;StoreLoad;Load2;</span><br></pre></td></tr></table></figure>

<p>该示例的含义为：在Load2及后续所有读取操作执行前，使StoreLoad屏障保证Store1的写入对所有CPU可见。StoreLoad（SL）屏障的开销是4种屏障中最大的，但是此屏障是一个“全能型”的屏障，兼具其他3个屏障的效果，现代的多核CPU大多支持该屏障。</p>
<h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><p>当线程在系统内运行时，线程的调度具有一定的透明性，程序通常无法准确控制线程的轮换执行，但我们可以通过一些机制来保证线程协调运行。例如A、B两个线程，当A线程在工作时B线程等待，当A线程运行结束时通知B线程，B线程继续执行。</p>
<h3 id="等待-x2F-通知机制"><a href="#等待-x2F-通知机制" class="headerlink" title="等待&#x2F;通知机制"></a>等待&#x2F;通知机制</h3><p>方法wait()的作用是使当前执行代码的线程进行等待，wait()方法是Object类的方法，该方法用来将当前线程置入“预执行队列”中，并且在wait()所在的代码行处停止执行，直到接到通知或被中断为止。在调用wait()之前，线程必须获得该对象的对象级别锁，即只能在同步方法或同步块中调用wait()方法。在执行wait()方法后，当前线程释放锁。在从wait()返回前，线程与其他线程竞争重新获得锁。如果调用wait()时没有持有适当的锁，则抛出IllegalMonitorStateException，它是RuntimeException的一个子类，因此，不需要try-catch语句进行捕捉异常。<br>方法notify()也要在同步方法或同步块中调用，即在调用前，线程也必须获得该对象的对象级别锁。如果调用notify()时没有持有适当的锁，也会抛出IllegalMonitorStateException。该方法用来通知那些可能等待该对象的对象锁的其他线程，如果有多个线程等待，则由线程规划器随机挑选出其中一个呈wait状态的线程，对其发出通知notify，并使它等待获取该对象的对象锁。需要说明的是，在执行notify()方法后，当前线程不会马上释放该对象锁，呈wait状态的线程也并不能马上获取该对象锁，要等到执行notify()方法的线程将程序执行完，也就是退出synchronized代码块后，当前线程才会释放锁，而呈wait状态所在的线程才可以获取该对象锁。当第一个获得了该对象锁的wait线程运行完毕以后，它会释放掉该对象锁，此时如果该对象没有再次使用notify语句，则即便该对象已经空闲，其他wait状态等待的线程由于没有得到该对象的通知，还会继续阻塞在wait状态，直到这个对象发出一个notify或notifyAll。<br>notifyAll()方法可以使所有正在等待队列中等待同一共享资源的“全部”线程从等待状态退出，进入可运行状态。此时，优先级最高的那个线程最先执行，但也有可能是随机执行，因为这要取决于JVM虚拟机的实现。<br>用一句话来总结一下wait和notify：wait使线程停止运行，而notify使停止的线程继续运行。<br>下面，先来通过示例学习如果不在同步块中使用的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.notify;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			wait();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">super</span>.run();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">WaitDemo</span> <span class="variable">waitDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitDemo</span>();</span><br><span class="line">		waitDemo.run();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="https://files.catbox.moe/e1stij.png"></p>
<p>假设现在有2个线程，两个线程共享同一个实例变量，一个线程对变量加1，另一个线程对变量减1，并输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.notify;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShareNumber</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span>  <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">			<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">				<span class="comment">// 如果n==1就等待</span></span><br><span class="line">				<span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						wait();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// 如果n==0 就自增，并唤醒自减的线程</span></span><br><span class="line">					n++;</span><br><span class="line">					System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=============&quot;</span> + n);</span><br><span class="line">					notify();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inc</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">			<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">				<span class="comment">// 如果n==0就等待</span></span><br><span class="line">				<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						wait();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// 如果n==0 就自增，并唤醒自减的线程</span></span><br><span class="line">					n--;</span><br><span class="line">					System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=============&quot;</span> + n);</span><br><span class="line">					notify();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.notify;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IncThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ShareNumber shareNumber;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">IncThread</span><span class="params">(ShareNumber shareNumber)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.shareNumber = shareNumber;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		shareNumber.inc();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.notify;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ShareNumber shareNumber;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">AddThread</span><span class="params">(ShareNumber shareNumber)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.shareNumber = shareNumber;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		shareNumber.add();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> cn.bytecollege.notify;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">ShareNumber</span> <span class="variable">shareNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShareNumber</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="type">AddThread</span> <span class="variable">add</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddThread</span>(shareNumber);</span><br><span class="line">		<span class="type">IncThread</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IncThread</span>(shareNumber);</span><br><span class="line">		add.setName(<span class="string">&quot;add&quot;</span>);</span><br><span class="line">		inc.setName(<span class="string">&quot;inc&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		add.start();</span><br><span class="line">		inc.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下图:</p>
<p><img src="https://files.catbox.moe/hdj6nq.png"></p>
<h3 id="DCL之单例模式（饿汉模式、懒汉模式、双重检查模式）"><a href="#DCL之单例模式（饿汉模式、懒汉模式、双重检查模式）" class="headerlink" title="DCL之单例模式（饿汉模式、懒汉模式、双重检查模式）"></a>DCL之单例模式（饿汉模式、懒汉模式、双重检查模式）</h3><h4 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h4><p>谓的“饿汉”是因为程序刚启动时就创建了实例，通俗点说就是刚上菜，大家还没有开始吃的时候就先自己吃一口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第3行 通过一个私有构造方法限制了创建此类对象的途径（反射忽略）。这种方法很安全，但从某种程度上有点浪费资源，比方说从一开始就创建了Singleton实例，但很少去用它，这就造成了方法区资源的浪费，因此出现了另外一种单例模式，即懒汉单例模式</p>
<h4 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h4><p>之所以叫“懒汉”是因为只有真正叫它的时候，才会出现，不叫它它就不理，跟它没关系。也就是说真正用到它的时候才去创建实例，并不是一开始就创建实例。如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> == singleton)&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看似很简单的一段代码，但存在一个问题，就是线程不安全的问题。例如，现在有1000个线程，都需要这一个Singleton的实例，验证一下是否拿到同一个实例，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> == singleton)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);<span class="comment">//象征性的睡了1ms</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; System.out.println(Singleton.getInstance().hashCode())).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>部分运行结果，乱七八糟：</p>
<p>944436457、1638599176、710946821、67862359<br>为什么会这样？第一个线程过来了，执行到第7行，睡了1ms,正在睡的同时第二个线程来了，第二个线程执行到第5行时，结果肯定为空，因此接下来将会有两个线程各自创建一个对象，这必然会导致Singleton.getInstance().hashCode()结果不一致。可以通过给整个方法加上一把锁改进如下：</p>
<p>通过给getInstance()方法加上synchronized来解决线程一致性问题，结果分析虽然显示所有实例的hashcode都一致，但是synchronized的粒度太大了，即锁的临界区太大了，有点影响效率，例如如果第4行和第5行之间有业务处理逻辑，不会涉及共享变量，那么每次对这部分业务逻辑加锁必然会导致效率低下。为了解决粗粒度的问题，可以对代码进一步改进：通过分析运行结果发现，虽然锁的粒度变小了，但线程不安全了。为什么会这样呢？因为有种情况，线程1执行完if判断后还没有拿到锁的时候时间片用完了，此时线程2来了，执行if判断时发现对象还是空的，继续往下执行，很顺利的拿到锁了，因此线程2创建了一个对象，当线程2创建完之后释放掉锁，这时线程1激活了，顺利的拿到锁，又创建了一个对象。所以代码还需要再一步的改进。</p>
<p>就是需要考虑指令重排序的问题，因此得加入volatile来禁止指令重排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        一堆业务处理代码</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> == singleton)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;<span class="comment">//锁粒度变小</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">null</span> == singleton)&#123;<span class="comment">//DCL</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; System.out.println(Singleton.getInstance().hashCode())).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过在第10行又加了一层if判断，也就是所谓的Double Check Lock。也就是说即便拿到锁了，也得去作一步判断，如果这时判断对像不为空，那么就不用再创建对象，直接返回就可以了，很好的解决了“改进2”中的问题。但这里第8行是不是可以去了，我个人觉得都行，保留第8行的话，是为了提升效率，因为如果去了，每个线程过来就直接抢锁，抢锁本身就会影响效率，而if判断就几ns，且大部分线程是不需要抢锁的，所以最好保留。</p>
<h3 id="生产者-x2F-消费者问题"><a href="#生产者-x2F-消费者问题" class="headerlink" title="生产者&#x2F;消费者问题"></a>生产者&#x2F;消费者问题</h3><p>在多线程中有一个经典的问题：生产者&#x2F;消费者问题，当生产者生产好产品，通知消费者消费。当消费者消费产品后再通知生产者生产产品，如果在生产者在生产前发现已经有生产好的产品，则不生产，先等待消费者消费，同样，当消费者消费产品时发现生产者没有生产好产品，则等待生产者先生产。<br>生产者-消费者问题不仅仅是一个多线程同步问题的经典案例，而且业内已经将解决该问题的方案抽象成了一种设计模式——“生产者-消费者”模式。“生产者-消费者”模式是一个经典的多线程设计模式，它为多线程间的协作提供了良好的解决方案。<br>这个问题就可以通过线程间通信来解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">	<span class="comment">//判断是否有产品,如果是true则有产品，如果为false，则没有产品</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> flag=<span class="literal">false</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 生产</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">product</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">			<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(flag) &#123;</span><br><span class="line">					<span class="comment">//如果有产品，则等待消费者消费</span></span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						wait();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">//生产产品</span></span><br><span class="line">					flag = <span class="literal">true</span>;</span><br><span class="line">					System.out.println(Thread.currentThread().getName()+<span class="string">&quot;====&quot;</span>+<span class="string">&quot;生产产品&quot;</span>);</span><br><span class="line">					<span class="comment">//通知消费者消费</span></span><br><span class="line">					notify();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">			<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">					<span class="comment">//如果没有产品，则等待生产者生产</span></span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						wait();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">//消费产品</span></span><br><span class="line">					System.out.println(Thread.currentThread().getName()+<span class="string">&quot;====&quot;</span>+<span class="string">&quot;消费产品&quot;</span>);</span><br><span class="line">					flag = <span class="literal">false</span>;</span><br><span class="line">					<span class="comment">//通知生产者生产</span></span><br><span class="line">					notify();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.consumer;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者线程</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Factory factory;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ConsumerThread</span><span class="params">(Factory factory)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.factory = factory;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		factory.consumer();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.consumer;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者线程</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Factory factory;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ProductThread</span><span class="params">(Factory factory)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.factory = factory;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		factory.product();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Factory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Factory</span>();</span><br><span class="line">		<span class="type">ConsumerThread</span> <span class="variable">consumner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConsumerThread</span>(factory);</span><br><span class="line">		<span class="type">ProductThread</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProductThread</span>(factory);</span><br><span class="line">		</span><br><span class="line">		consumner.setName(<span class="string">&quot;consumer&quot;</span>);</span><br><span class="line">		product.setName(<span class="string">&quot;product&quot;</span>);</span><br><span class="line"></span><br><span class="line">		consumner.start();</span><br><span class="line">		product.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于显式锁进行“等待——通知”方式的线程间通信"><a href="#基于显式锁进行“等待——通知”方式的线程间通信" class="headerlink" title="基于显式锁进行“等待——通知”方式的线程间通信"></a>基于显式锁进行“等待——通知”方式的线程间通信</h3><p>在前面介绍Java的线程间通信机制时，基于Java内置锁实现一种简单的“等待-通知”方式的线程间通信：通过Object对象的wait、notify两类方法作为开关信号，用来完成通知方线程和等待方线程之间的通信。<br>“等待-通知”方式的线程间通信机制，具体来说是指一个线程A调用了同步对象的wait()方法进入等待状态，而另一线程B调用了同步对象的notify()或者notifyAll()方法去唤醒等待线程，当线程A收到线程B的唤醒通知后，就可以重新开始执行了。<br>需要特别注意的是，在通信过程中，线程需要拥有同步对象的监视器，在执行Object对象的wait、notify方法之前，线程必须先通过抢占到内置锁而成为其监视器的持有者。<br>与Object对象的wait、notify两类方法相类似，基于Lock显式锁，JUC也为大家提供了一个用于线程间进行“等待-通知”方式通信的接口——java.util.concurrent.locks.Condition。</p>
<h3 id="Condition接口主要方法"><a href="#Condition接口主要方法" class="headerlink" title="Condition接口主要方法"></a>Condition接口主要方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">  <span class="comment">//此方法功能上与Object.wait()等效，使当前线程加入await()等待队列，并释放锁</span></span><br><span class="line">  <span class="comment">//其他线程调用signal()等待队列中，并释放当前锁</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">  <span class="type">long</span> <span class="title function_">awaitNanos</span><span class="params">(<span class="type">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">  <span class="comment">//线程等待超时返回false,其他情况返回true</span></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">  <span class="comment">//此方法在功能上与Object.notify()等效，唤醒一个在await()等待队列中的线程</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span>;</span><br><span class="line">  <span class="comment">//此方法与Object.notifyAll()等效，唤醒await()等待队列中所有的线程</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免与Object中的wait&#x2F;notify&#x2F;notifyAll方法在使用时发生混淆，JUC对Condition接口的方法改变了名称，同样的wait&#x2F;notify&#x2F;notifyAll方法，在Condition接口中名称被改为await&#x2F;signal&#x2F;signalAll方法。<br>Condition的“等待-通知”方法和Object的“等待-通知”方法的语义等效关系为：</p>
<ul>
<li>Condition类的await方法和Object类的wait方法等效。</li>
<li>Condition类的signal方法和Object类的notify方法等效。</li>
<li>Condition类的signalAll方法和Object类的notifyAll方法等效。</li>
</ul>
<p>Condition对象的signal（通知）方法和同一个对象的await（等待）方法是一一配对使用的，也就是说，一个Condition对象的signal（或signalAll）方法不能去唤醒其他Condition对象上的await线程。<br>Condition对象是基于显式锁的，所以不能独立创建一个Condition对象，而是需要借助于显式锁实例去获取其绑定的Condition对象。不过，每一个Lock显式锁实例都可以有任意数量的Condition对象。不过，每一个Lock显式锁实例都可以有任意数量的Condition对象。具体来说，可以通过lock.newCondition()方法去获取一个与当前显式锁绑定的Condition实例，然后通过该Condition实例进行“等待-通知”方式的线程间通信。<br>下面通过示例来学习Condition的用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始阻塞&quot;</span>);</span><br><span class="line">                    condition.await();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;阻塞已经被放开&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始阻塞&quot;</span>);</span><br><span class="line">                    condition.signalAll();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;阻塞已经被放开&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>系统启动一个新线程的成本是比较高的，因为它涉及与操作系统交互。在这种情形下，使用线程池可以很好地提高性能，尤其是当程序中需要创建大量生存期很短暂的线程时，更应该考虑使用线程池。<br>线程池在系统启动时即创建大量空闲的线程，程序将一个Runnable对象或Callable对象传给线程池，线程池就会启动一个线程来执行它们的run()或call()方法，当run()或call()方法执行结束后，该线程并不会死亡，而是再次返回线程池中成为空闲状态，等待执行下一个Runnable对象的run()或call()方法。<br>除此之外，使用线程池可以有效地控制系统中并发线程的数量，当系统中包含大量并发线程时，会导致系统性能剧烈下降，甚至导致JVM崩溃，而线程池的最大线程数参数可以控制系统中并发线程数不超过此数。<br>线程池相关类定义在java.util.concurrent包中，也就是常说的JUC包，首先我们了解一下线程池相关的类和接口，其架构图如下：</p>
<p><img src="https://files.catbox.moe/dxrazm.png"></p>
<p><strong>1.Executor</strong><br>Executor是Java异步目标任务的“执行者”接口，其目标是执行目标任务。“执行者”Executor提供了execute()接口来执行已提交的Runnable执行目标实例。<br><strong>2.ExecutorService</strong><br>ExecutorService继承于Executor。它是Java异步目标任务的“执行者服务接口”，对外提供异步任务的接收服务。ExecutorService提供了“接收异步任务并转交给执行者”的方法，如submit系列方法、invoke系列方法等。<br><strong>3.AbstractExecutorService</strong><br>AbstractExecutorService是一个抽象类，它实现了ExecutorService接口。AbstractExecutorService存在的目的是为ExecutorService中的接口提供默认实现。<br><strong>4.ThreadPoolExecutor</strong><br>ThreadPoolExecutor是JUC线程池的核心实现类。线程的创建和终止需要很大的开销，线程池中预先提供了指定数量的可重用线程，所以使用线程池会节省系统资源，并且每个线程池都维护了一些基础的数据统计，方便线程的管理和监控。<br><strong>5.ScheduledExecutorService</strong><br>ScheduledExecutorService是一个接口，它继承于ExecutorService。它是一个可以完成“延时”和“周期性”任务的调度线程池接口。<br><strong>6.ScheduledThreadPoolExecutor</strong><br>ScheduledThreadPoolExecutor继承于ThreadPoolExecutor，它提供了ScheduledExecutorService线程池接口中“延时执行”和“周期执行”等抽象调度方法的具体实现。<br><strong>7.Executors</strong><br>Executors是一个静态工厂类，它通过静态工厂方法返回ExecutorService、ScheduledExecutorService等线程池示例对象，这些静态工厂方法可以理解为一些快捷的创建线程池的方法。</p>
<h3 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h3><p>Java为开发者提供了ThreadPoolExecutor用于创建线程池，先查看一下该类的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                              ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="built_in">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从源代码可以看出构造方法包含了7个参数，这7个参数的含义如下:</p>
<ul>
<li>corePoolSize：线程池中会维护一个最小的线程数量，即使这些线程处理空闲状态，他们也不会被销毁，除非设置了allowCoreThreadTimeOut。这里的最小线程数量即是corePoolSize。</li>
<li>maximumPoolSize：一个任务被提交到线程池以后，首先会找有没有空闲存活线程，如果有则直接将任务交给这个空闲线程来执行，如果没有则会缓存到工作队列中，如果工作队列满了，才会创建一个新线程，然后从工作队列的头部取出一个任务交由新线程来处理，而将刚提交的任务放入工作队列尾部。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即由maximunPoolSize指定。</li>
<li>keepAliveTime：空闲线程存活时间，一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间后，这个空闲线程会被销毁，这里的指定时间由keepAliveTime来设定。</li>
<li>unit：空闲线程存活时间单位</li>
<li>workQueue：新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务，Java中提供了4中工作队列：<ul>
<li>ArrayBlockingQueue：基于数组的有界阻塞队列，按FIFO排序。新任务进来后，会放到该队列的队尾，有界的数组可以防止资源耗尽问题。当线程池中线程数量达到corePoolSize后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。如果队列已经是满的，则创建一个新线程，如果线程数量已经达到maxPoolSize，则会执行拒绝策略。</li>
<li>LinkedBlockingQueue：基于链表的无界阻塞队列（其实最大容量为Interger.MAX_VALUE），按照FIFO排序。由于该队列的近似无界性，当线程池中线程数量达到corePoolSize后，再有新任务进来，会一直存入该队列，而不会去创建新线程到maxPoolSize，因此使用该工作队列时，参数maxPoolSize其实是不起作用的。有两个快捷创建线程池的工厂方法Executors.newSingleThreadExecutor和Executors.newFixedThreadPool使用了这个队列，并且都没有设置容量（无界队列）。</li>
<li>SynchronousQueue：一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，不会缓存，而是直接被调度执行该任务，如果没有可用线程，则创建新线程，如果线程数量达到maxPoolSize，则执行拒绝策略。快捷工厂方法Executors.newCachedThreadPool所创建的线程池使用此队列。</li>
<li>PriorityBlockingQueue：具有优先级的无界阻塞队列，优先级通过参数Comparator实现。</li>
</ul>
</li>
<li>threadFactory：线程工厂，创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等</li>
<li>handler 拒绝策略：当工作队列中的任务已到达最大限制，并且线程池中的线程数量也达到最大限制，这时如果有新任务提交进来，该如何处理呢。这里的拒绝策略，就是解决这个问题的，java中提供了4中拒绝策略：<ul>
<li>CallerRunsPolicy：该策略下，在调用者线程中直接执行被拒绝任务的run方法，除非线程池已经shutdown，则直接抛弃任务。</li>
<li>AbortPolicy：该策略下，直接丢弃任务，并抛出RejectedExecutionException异常。该策略是线程池默认的拒绝策略。</li>
<li>DiscardPolicy：该策略下，直接丢弃任务，并且不会抛出任何异常。</li>
<li>DiscardOldestPolicy：该策略下，抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列。</li>
</ul>
</li>
</ul>
<p>通过上述参数的描述可以梳理线程池的工作流程如下图所示：</p>
<p><img src="https://files.catbox.moe/tmwxdo.png"></p>
<p>在使用线程池的过程中需要注意一下两点：</p>
<ol>
<li>核心和最大线程数量、BlockingQueue队列等参数如果配置得不合理，可能会造成异步任务得不到预期的并发执行，造成严重的排队等待现象。</li>
<li>线程池的调度器创建线程的一条重要的规则是：在corePoolSize已满之后，还需要等阻塞队列已满，才会去创建新的线程。</li>
</ol>
<h3 id="常用线程池"><a href="#常用线程池" class="headerlink" title="常用线程池"></a>常用线程池</h3><p>在Java 5以前，开发者必须手动实现自己的线程池；从Java 5开始，Java内建支持线程池。Java 5新增了一个Executors工厂类来产生线程池，该工厂类包含如下几个静态工厂方法来创建线程池。</p>
<h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool()"></a>newCachedThreadPool()</h4><p>创建一个具有缓存功能的线程池，系统根据需要创建线程，这些线程将会被缓存在线程池中。“可缓存线程池”的特点大致如下：</p>
<ol>
<li>在接收新的异步任务target执行目标实例时，如果池内所有线程繁忙，此线程池就会添加新线程来处理任务。</li>
<li>此线程池不会对线程池大小进行限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</li>
<li>如果部分线程空闲，也就是存量线程的数量超过了处理任务数量，就会回收空闲（60秒不执行任务）线程。</li>
</ol>
<p>“可缓存线程池”的适用场景：需要快速处理突发性强、耗时较短的任务场景，如Netty的NIO处理场景、REST API接口的瞬时削峰场景。“可缓存线程池”的线程数量不固定，只要有空闲线程就会被回收；接收到的新异步任务执行目标，查看是否有线程处于空闲状态，如果没有就直接创建新的线程。</p>
<h4 id="newFixedThreadPool-int-nThreads"><a href="#newFixedThreadPool-int-nThreads" class="headerlink" title="newFixedThreadPool(int nThreads)"></a>newFixedThreadPool(int nThreads)</h4><p>该方法用于创建一个“固定数量的线程池”，其唯一的参数用于设置池中线程的“固定数量”。<br>“固定数量的线程池”的特点大致如下：</p>
<ol>
<li>如果线程数没有达到“固定数量”，每次提交一个任务线程池内就创建一个新线程，直到线程达到线程池固定的数量。</li>
<li>线程池的大小一旦达到“固定数量”就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</li>
<li>在接收异步任务的执行目标实例时，如果池中的所有线程均在繁忙状态，新任务会进入阻塞队列中（无界的阻塞队列）。</li>
</ol>
<p>“固定数量的线程池”的适用场景：需要任务长期执行的场景。“固定数量的线程池”的线程数能够比较稳定地保证一个数，能够避免频繁回收线程和创建线程，故适用于处理CPU密集型的任务，在CPU被工作线程长时间占用的情况下，能确保尽可能少地分配线程。<br>“固定数量的线程池”的弊端：内部使用无界队列来存放排队任务，当大量任务超过线程池最大容量需要处理时，队列无限增大，使服务器资源迅速耗尽。</p>
<h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor()"></a>newSingleThreadExecutor()</h4><p>该方法用于创建一个“单线程化线程池”，也就是只有一个线程的线程池，所创建的线程池用唯一的工作线程来执行任务，使用此方法创建的线程池能保证所有任务按照指定顺序（如FIFO）执行。<br>从以上输出中可以看出，该线程池有以下特点：</p>
<ol>
<li>单线程化的线程池中的任务是按照提交的次序顺序执行的。</li>
<li>池中的唯一线程的存活时间是无限的。</li>
<li>当池中的唯一线程正繁忙时，新提交的任务实例会进入内部的阻塞队列中，并且其阻塞队列是无界的。</li>
</ol>
<p>总体来说，单线程化的线程池所适用的场景是：任务按照提交次序，一个任务一个任务地逐个执行的场景。</p>
<h4 id="newScheduledThreadPool-int-corePoolSize"><a href="#newScheduledThreadPool-int-corePoolSize" class="headerlink" title="newScheduledThreadPool(int corePoolSize)"></a>newScheduledThreadPool(int corePoolSize)</h4><p>该方法用于创建一个“可调度线程池”，即一个提供“延时”和“周期性”任务调度功能的ScheduledExecutorService类型的线程池。<br>上面4个方法中的前3个方法返回一个ExecutorService对象，该对象代表一个线程池，它可以执行 Runnable 对象或 Callable 对象所代表的线程；而后1个方法返回一个ScheduledExecutorService线程池，它是ExecutorService的子类，它可以在指定延迟后执行线程任务。<br>ExecutorService代表尽快执行线程的线程池（只要线程池中有空闲线程，就立即执行线程任务），程序只要将一个Runnable对象或Callable对象（代表线程任务）提交给该线程池，该线程池就会尽快执行该任务。ExecutorService里提供了如下3个方法。</p>
<ul>
<li>Future&lt;?&gt; submit(Runnable task)：将一个Runnable对象提交给指定的线程池，线程池将在有空闲线程时执行Runnable对象代表的任务。其中Future对象代表Runnable任务的返回值——但run()方法没有返回值，所以Future对象将在run()方法执行结束后返回null。但可以调用Future的isDone()、isCancelled()方法来获得Runnable对象的执行状态。</li>
<li>Future submit(Runnable task,T result)：将一个Runnable对象提交给指定的线程池，线程池将在有空闲线程时执行Runnable对象代表的任务。其中result显式指定线程执行结束后的返回值，所以Future对象将在run()方法执行结束后返回result。</li>
<li>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)：将一个Callable对象提交给指定的线程池，线程池将在有空闲线程时执行Callable对象代表的任务。其中Future代表Callable对象里call()方法的返回值。</li>
</ul>
<p>ScheduledExecutorService 代表可在指定延迟后或周期性地执行线程任务的线程池，它提供了如下4个方法。</p>
<ul>
<li>ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay,TimeUnit unit)：指定callable任务将在delay延迟后执行。</li>
<li>ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay,TimeUnit unit)：指定command任务将在delay延迟后执行。</li>
<li>ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period,TimeUnit unit)：指定command任务将在delay延迟后执行，而且以设定频率重复执行。也就是说，在 initialDelay 后开始执行，依次在 initialDelay+period、initialDelay+2*period…处重复执行，依此类推。</li>
<li>ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,long initialDelay, long delay,TimeUnit unit)：创建并执行一个在给定初始延迟后首次启用的定期操作，随后在每一次执行终止和下一次执行开始之间都存在给定的延迟。如果任务在任一次执行时遇到异常，就会取消后续执行；否则，只能通过程序来显式取消或终止该任务。</li>
</ul>
<p>当用完一个线程池后，应该调用该线程池的shutdown()方法，该方法将启动线程池的关闭序列，调用shutdown()方法后的线程池不再接收新任务，但会将以前所有已提交任务执行完成。当线程池中的所有任务都执行完成后，池中的所有线程都会死亡；另外也可以调用线程池的shutdownNow()方法来关闭线程池，该方法试图停止所有正在执行的活动任务，暂停处理正在等待的任务，并返回等待执行的任务列表。<br>使用线程池来执行线程任务的步骤如下。</p>
<ol>
<li>调用Executors类的静态工厂方法创建一个ExecutorService对象，该对象代表一个线程池。</li>
<li>创建Runnable实现类或Callable实现类的实例，作为线程执行任务。</li>
<li>调用ExecutorService对象的submit()方法来提交Runnable实例或Callable实例。</li>
<li>当不想提交任何任务时，调用ExecutorService对象的shutdown()方法来关闭线程池。</li>
</ol>
<p>下面通过示例来学习线程池的简单用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">&quot;==========&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Thread1</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread1</span>();</span><br><span class="line">		<span class="type">Thread1</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread1</span>();</span><br><span class="line">		<span class="type">Thread1</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread1</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">		service.submit(thread1);</span><br><span class="line">		service.submit(thread2);</span><br><span class="line">		service.submit(thread3);</span><br><span class="line">		</span><br><span class="line">		service.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中创建了3个线程，以及一个固定线程个数为2的线程池，将3个线程提交给线程池运行，从结果中可以发现thread3并没有执行，这是因为线程池中只有2个线程，任务数多于线程数，线程池执行了拒绝策略。</p>
<h3 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h3><p>一般情况下，线程池启动后建议手动关闭。在介绍线程池的关闭之前，我们先了解一下线程池的状态。线程池总共存在5种状态，定义在ThreadPoolExecutor类中，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>

<p>线程池的5种状态具体如下:</p>
<ol>
<li>RUNNING：线程池创建之后的初始状态，这种状态下可以执行任务。</li>
<li>SHUTDOWN：该状态下线程池不再接受新任务，但是会将工作队列中的任务执行完毕。</li>
<li>STOP：该状态下线程池不再接受新任务，也不会处理工作队列中的剩余任务，并且将会中断所有工作线程。</li>
<li>TIDYING：该状态下所有任务都已终止或者处理完成，将会执行terminated()钩子方法。</li>
<li>TERMINATED：执行完terminated()钩子方法之后的状态。</li>
</ol>
<p>线程池的状态转换规则为：</p>
<ol>
<li>线程池创建之后状态为RUNNING。</li>
<li>执行线程池的shutdown()实例方法，会使线程池状态从RUNNING转变为SHUTDOWN。</li>
<li>执行线程池的shutdownNow()实例方法，会使线程池状态从RUNNING转变为STOP。</li>
<li>当线程池处于SHUTDOWN状态时，执行其shutdownNow()方法会将其状态转变为STOP。</li>
<li>等待线程池的所有工作线程停止，工作队列清空之后，线程池状态会从STOP转变为TIDYING。</li>
<li>执行完terminated()钩子方法之后，线程池状态TIDYING转变为TERMINATED。</li>
</ol>
<p>线程池状态转换规则如下图：</p>
<p><img src="https://files.catbox.moe/wn9ujo.png"></p>
<p>关闭线程池主要涉及以下3个方法：</p>
<ol>
<li><p>shutdown：是JUC提供的一个有序关闭线程池的方法，此方法会等待当前工作队列中的剩余任务全部执行完成之后，才会执行关闭，但是此方法被调用之后线程池的状态转为SHUTDOWN，线程池不会再接收新的任务。</p>
</li>
<li><p>shutdownNow：是JUC提供的一个立即关闭线程池的方法，此方法会打断正在执行的工作线程，并且会清空当前工作队列中的剩余任务，返回的是尚未执行的任务。</p>
</li>
<li><p>awaitTermination：等待线程池完成关闭。在调用线程池的shutdown()与shutdownNow()方法时，当前线程会立即返回，不会一直等待直到线程池完成关闭。如果需要等到线程池关闭完成，可以调awaitTermination()方法。</p>
<p>​</p>
</li>
</ol>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>在Java的多线程并发执行过程中，为了保证多个线程对变量的安全访问，可以将变量放到ThreadLocal类型的对象中，使变量在每个线程中都有独立值，不会出现一个线程读取变量时被另一个线程修改的现象。ThreadLocal类通常被翻译为“线程本地变量”类或者“线程局部变量”类。</p>
<h3 id="ThreadLocal基本使用"><a href="#ThreadLocal基本使用" class="headerlink" title="ThreadLocal基本使用"></a>ThreadLocal基本使用</h3><p>ThreadLocal位于JDK的java.lang核心包中。如果程序创建了一个ThreadLocal实例，那么在访问这个变量的值时，每个线程都会拥有一个独立的、自己的本地值。“线程本地变量”可以看成专属于线程的变量，不受其他线程干扰，保存着线程的专属数据。<br>ThreadLocal类比较简单主要的方法只有以下4个：</p>
<ol>
<li>set(T value)：该方法用于设置“线程本地变量”在当前线程的ThreadLocalMap中对应的值。</li>
<li>get()：该方法用于获取“线程本地变量”在当前线程的ThreadLocalMap中对应的值，相当于获取线程本地值。</li>
<li>remove()：该方法用于当前线程的ThreadLocalMap中移除“线程本地变量”所对应的值。</li>
<li>initialValue()：该方法是当“线程本地变量”在当前线程的ThreadLocalMap中尚未绑定值时，initialValue()方法用于获取初始值。如果没有调用set()直接调用get()，就会调用该方法，但是该方法只会被调用一次。默认情况下，initialValue()方法返回null，如果不想返回null，可以继承ThreadLocal以覆盖此方法。</li>
</ol>
<p>下面先通过两个示例来学习ThreadLocal的基本使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">		ThreadLocal&lt;Integer&gt; local = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Integer&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">				local.set(num);</span><br><span class="line">				<span class="type">Integer</span> <span class="variable">k</span> <span class="operator">=</span> local.get();</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">					k++;</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t k=&quot;</span>+k);</span><br><span class="line">			&#125;,<span class="string">&quot;MyThread---&quot;</span>+i).start();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;----------k=&quot;</span>+num+<span class="string">&quot;----------&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例中创建了5个线程，每个线程从ThreadLocal中获取了一个num的副本分别进行自增，可以看出最后的结果5个线程分别输出了最终值k&#x3D;6，而num的值还是1，换句话说，每个线程都复制了一份num并对属于自己的num进行自增而不影响num。</p>
]]></content>
  </entry>
  <entry>
    <title>Java并发编程</title>
    <url>/2022/08/22/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<p>在前面的内容中，学习了多线程相关的内容，在多线程环境下保证线程安全是首要考虑的问题，保证线程安全最简单的方式就是使用synchronized修饰方法或者代码片段，那么synchronized的底层原理是如何实现的，这就需要先深入了解对象在内存中的结构。在本章节中将详细学习synchronized关键字的原理及Java中的并发类。</p>
<h2 id="Java对象结构"><a href="#Java对象结构" class="headerlink" title="Java对象结构"></a>Java对象结构</h2><p>Java对象结构包括三部分：对象头、对象体和对齐字节。 在本小节内将详细介绍Java的对象头。<br><strong>1.对象头</strong><br>对象头：对象头包括三个字段，第一个字段叫作Mark Word（标记字），用于存储自身运行时的数据，例如GC标志位、哈希码、锁状态等信息。<br>第二个字段叫作Class Pointer（类对象指针），用于存放方法区Class对象的地址，虚拟机通过这个指针来确定这个对象是哪个类的实例。<br>第三个字段叫作Array Length（数组长度）。如果对象是一个Java数组，那么此字段必须有，用于记录数组长度的数据；如果对象不是一个Java数组，那么此字段不存在，所以这是一个可选字段。<br><strong>2.对象体</strong><br>对象体包含对象的实例变量（成员变量），用于成员属性值，包括父类的成员属性值。这部分内存按4字节对齐。<br><strong>3.对齐字节</strong><br>对齐字节也叫作填充对齐，其作用是用来保证Java对象所占内存字节数为8的倍数HotSpot VM的内存管理要求对象起始地址必须是8字节的整数倍。对象头本身是8的倍数，当对象的实例变量数据不是8的倍数时，便需要填充数据来保证8字节的对齐。<br>接下来，对Object实例结构中几个重要的字段的作用做一下简要说明：</p>
<ol>
<li>Mark Word（标记字）字段主要用来表示对象的线程锁状态，另外还可以用来配合GC存放该对象的hashCode。</li>
<li>Class Pointer（类对象指针），用于存放方法区Class对象的地址，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li>
<li>Array Length（数组长度）字段占用32位（在32位JVM中）字节，这是可选的，只有当本对象是一个数组对象时才会有这个部分。</li>
<li>对象体用于保存对象属性值，是对象的主体部分，占用的内存空间大小取决于对象的属性数量和类型。</li>
<li>对齐字节并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。当对象实例数据部分没有对齐（8字节的整数倍）时，就需要通过对齐填充来补全。</li>
</ol>
<h3 id="对象结构中的字段长度"><a href="#对象结构中的字段长度" class="headerlink" title="对象结构中的字段长度"></a>对象结构中的字段长度</h3><p>Mark Word、Class Pointer、Array Length等字段的长度都与JVM的位数有关。Mark Word的长度为JVM的一个Word（字）大小，也就是说32位JVM的MarkWord为32位，64位JVM的Mark Word为64位。Class Pointer（类对象指针）字段的长度也为JVM的一个Word（字）大小，即32位JVM的Mark Word为32位，64位JVM的Mark Word为64位。<br>所以，在32位JVM虚拟机中，Mark Word和Class Pointer这两部分都是32位的；在64位JVM虚拟机中，Mark Word和Class Pointer这两部分都是64位的。<br>对于对象指针而言，如果JVM中的对象数量过多，使用64位的指针将浪费大量内存，通过简单统计，64位JVM将会比32位JVM多耗费50%的内存。为了节约内存可以使用选项+UseCompressedOops开启指针压缩。UseCompressedOops中的Oop为Ordinary object pointer（普通对象指针）的缩写。</p>
<ul>
<li>Class对象的属性指针（静态变量）。</li>
<li>Object对象的属性指针（成员变量）。</li>
<li>普通对象数组的元素指针。</li>
</ul>
<p>当然，也不是所有的指针都会压缩，一些特殊类型的指针不会压缩，比如指向PermGen（永久代）的Class对象指针（JDK 8中指向元空间的Class对象指针）、本地变量、堆栈元素、入参、返回值和NULL指针等。需要注意的是在堆内存小于32GB的情况下，64位虚拟机的UseCompressedOops选项是默认开启的，该选项表示开启Oop对象的指针压缩会将原来64位的Oop对象指针压缩为32位。<br>手动开启和关闭Oop对象指针压缩的Java指令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -XX:+UseCompressedOops mainclass</span><br></pre></td></tr></table></figure>

<p>如果对象是一个数组，那么对象头还需要有额外的空间用于存储数组的长度（Array Length字段）。Array Length字段的长度也随着JVM架构的不同而不同：在32位JVM上，长度为32位；在64位JVM上，长度为64位。64位JVM如果开启了Oop对象的指针压缩，Array Length字段的长度也将由64位压缩至32位。</p>
<h2 id="Mark-Word的结构信息"><a href="#Mark-Word的结构信息" class="headerlink" title="Mark Word的结构信息"></a>Mark Word的结构信息</h2><p>Java内置锁涉及很多重要信息，这些都存放在对象结构中，并且存放于对象头的Mark Word字段中。Mark Word的位长度为JVM的一个Word大小，也就是说32位JVM的Mark Word为32位，64位JVM为64位。Mark Word的位长度不会受到Oop对象指针压缩选项的影响。<br><strong>Java内置锁的状态总共有4种，级别由低到高依次为：无锁、偏向锁、轻量级锁和重量级锁。</strong>其实在JDK 1.6之前，Java内置锁还是一个重量级锁，是一个效率比较低下的锁，在JDK 1.6之后，JVM为了提高锁的获取与释放效率，对synchronized的实现进行了优化，引入了偏向锁和轻量级锁，从此以后Java内置锁的状态就有了4种（无锁、偏向锁、轻量级锁和重量级锁），并且4种状态会随着竞争的情况逐渐升级，而且是不可逆的过程，即不可降级，也就是说只能进行锁升级（从低级别到高级别）。</p>
<h3 id="不同锁状态下得Mark-Word字段结构"><a href="#不同锁状态下得Mark-Word字段结构" class="headerlink" title="不同锁状态下得Mark Word字段结构"></a>不同锁状态下得Mark Word字段结构</h3><p>Mark Word字段的结构与Java内置锁的状态强相关。为了让Mark Word字段存储更多的信息，JVM将Mark Word最低两个位设置为Java内置锁状态位，不同锁状态下的32位Mark Word结构如下表所示。</p>
<p><img src="https://files.catbox.moe/wfd5k1.png"></p>
<p>64位的Mark Word与32位的Mark Word结构相似，具体如下表所示。</p>
<p><img src="https://files.catbox.moe/pbfmlv.png"></p>
<h3 id="位Mark-Word的构成"><a href="#位Mark-Word的构成" class="headerlink" title="位Mark Word的构成"></a>位Mark Word的构成</h3><p>由于目前主流的JVM都是64位，因此我们使用64位的Mark Word。接下来对64位的Mark Word中各部分的内容进行具体介绍。</p>
<ul>
<li>lock：锁状态标记位，占两个二进制位，由于希望用尽可能少的二进制位表示尽可能多的信息，因此设置了lock标记。该标记的值不同，整个Mark Word表示的含义就不同。</li>
<li>biased_lock：对象是否启用偏向锁标记，只占1个二进制位。为1时表示对象启用偏向锁，为0时表示对象没有偏向锁。lock和biased_lock两个标记位组合在一起共同表示Object实例处于什么样的锁状态。二者组合的含义具体如下表所示。 | <strong>biased_lock</strong> | <strong>lock</strong> | <strong>状态</strong> | | — | — | — | | 0 | 01 | 无锁 | | 1 | 01 | 偏向锁 | | 0 | 00 | 轻量级锁 | | 0 | 10 | 重量级锁 | | 0 | 11 | GC标记 |</li>
<li>age：4位的Java对象分代年龄。在GC中，对象在Survivor区复制一次，年龄就增加1。当对象达到设定的阈值时，将会晋升到老年代。默认情况下，并行GC的年龄阈值为15，并发GC的年龄阈值为6。由于age只有4位，因此最大值为15，这就是-XX:MaxTenuringThreshold选项最大值为15的原因。</li>
<li>identity_hashcode：31位的对象标识HashCode（哈希码）采用延迟加载技术，当调用Object.hashCode()方法或者System.identityHashCode()方法计算对象的HashCode后，其结果将被写到该对象头中。当对象被锁定时，该值会移动到Monitor（监视器）中。</li>
<li>thread：54位的线程ID值为持有偏向锁的线程ID。</li>
<li>epoch：偏向时间戳。</li>
<li>ptr_to_lock_record：占62位，在轻量级锁的状态下指向栈帧中锁记录的指针。</li>
<li>ptr_to_heavyweight_monitor：占62位，在重量级锁的状态下指向对象监视器的指针。</li>
</ul>
<h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><p>在JDK 1.6版本之前，所有的Java内置锁都是重量级锁。重量级锁会造成CPU在用户态和核心态之间频繁切换，所以代价高、效率低。JDK 1.6版本为了减少获得锁和释放锁所带来的性能消耗，引入了偏向锁和轻量级锁的实现。所以，在JDK 1.6版本中内置锁一共有4种状态：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这些状态随着竞争情况逐渐升级。内置锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能再降级成偏向锁。这种能升级却不能降级的策略，其目的是提高获得锁和释放锁的效率。锁升级过程大致如下：</p>
<p><img src="https://files.catbox.moe/vw8itt.png"></p>
<h3 id="无锁状态"><a href="#无锁状态" class="headerlink" title="无锁状态"></a>无锁状态</h3><p>Java对象刚创建时还没有任何线程来竞争，说明该对象处于无锁状态（无线程竞争它），这时偏向锁标识位是0，锁状态是01。无锁状态下对象的Mark Word如下表所示。</p>
<p><img src="https://files.catbox.moe/aofpug.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoneLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> Logger.getLogger(<span class="string">&quot;NoneLock&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        log.info(<span class="string">&quot;未进入同步块，MarkWord 为：&quot;</span>);</span><br><span class="line">        log.info(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="偏向锁状态"><a href="#偏向锁状态" class="headerlink" title="偏向锁状态"></a>偏向锁状态</h3><p>偏向锁是指一段同步代码一直被同一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。如果内置锁处于偏向状态，当有一个线程来竞争锁时，先用偏向锁，表示内置锁偏爱这个线程，这个线程要执行该锁关联的同步代码时，不需要再做任何检查和切换。偏向锁在竞争不激烈的情况下效率非常高。偏向锁状态的Mark Word会记录内置锁自己偏爱的线程ID，内置锁会将该线程当作自己的熟人。偏向锁状态下对象的Mark Word下表。</p>
<p><img src="https://files.catbox.moe/u5c7tk.png"></p>
<p>偏向锁的核心原理是：如果不存在线程竞争的一个线程获得了锁，那么锁就进入偏向状态，此时Mark Word的结构变为偏向锁结构，锁对象的锁标志位（lock）被改为01，偏向标志位（biased_lock）被改为1，然后线程的ID记录在锁对象的MarkWord中（使用CAS操作完成）。以后该线程获取锁时判断一下线程ID和标志位，就可以直接进入同步块，连CAS操作都不需要，这样就省去了大量有关锁申请的操作，从而也就提升了程序的性能。所以，在没有锁竞争的场合，偏向锁有很好的优化效果。但是，一旦有第二条线程需要竞争锁，那么偏向模式立即结束，进入轻量级锁的状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BiasableLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> Logger.getLogger(<span class="string">&quot;BiasableLock&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        log.info(<span class="string">&quot;未进入同步块，MarkWord 为：&quot;</span>);</span><br><span class="line">        log.info(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">        log.info(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                log.info((<span class="string">&quot;t1进入同步块，MarkWord 为：&quot;</span>));</span><br><span class="line">                log.info(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如在大部分情况下同步块是没有竞争的，那么可以通过偏向来提高性能。即在无竞争时，之前获得锁的线程再次获得锁时会判断偏向锁的线程ID是否指向自己，如果是，那么该线程将不用再次获得锁，直接就可以进入同步块；如果未指向当前线程，当前线程就会采用CAS操作将Mark Word中的线程ID设置为当前线程ID，如果CAS操作成功，那么获取偏向锁成功，执行同步代码块，如果CAS操作失败，那么表示有竞争，抢锁线程被挂起，撤销占锁线程的偏向锁，然后将偏向锁膨胀为轻量级锁。<br>偏向锁的缺点：如果锁对象时常被多个线程竞争，偏向锁就是多余的，并且其撤销的过程会带来一些性能开销。<br>需要注意的是Java默认开始偏向锁，但是在JVM启动后延迟4秒才会启用偏向锁，因此在程序开始线程休眠了5秒就是保证偏向锁开启。</p>
<h3 id="轻量级锁状态"><a href="#轻量级锁状态" class="headerlink" title="轻量级锁状态"></a>轻量级锁状态</h3><p>当有两个线程开始竞争这个锁对象时，情况就发生变化了，不再是偏向（独占）锁了，锁会升级为轻量级锁，两个线程公平竞争，哪个线程先占有锁对象，锁对象的Mark Word就指向哪个线程的栈帧中的锁记录。轻量级锁状态下对象的MarkWord如下表所示。</p>
<p><img src="https://files.catbox.moe/cluwqh.png"></p>
<p>当锁处于偏向锁，又被另一个线程企图抢占时，偏向锁就会升级为轻量级锁。企图抢占的线程会通过自旋的形式尝试获取锁，不会阻塞抢锁线程，以便提高性能。<br>自旋原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要进行内核态和用户态之间的切换来进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免了用户线程和内核切换的消耗。<br>但是，线程自旋是需要消耗CPU的，如果一直获取不到锁，那么线程也不能一直占用CPU自旋做无用功，所以需要设定一个自旋等待的最大时间。JVM对于自旋周期的选择，JDK 1.6之后引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不是固定的，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定的。线程如果自旋成功了，下次自旋的次数就会更多，如果自旋失败了，自旋的次数就会减少。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThinLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> Logger.getLogger(<span class="string">&quot;App&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        log.info(<span class="string">&quot;未进入同步块，MarkWord 为：&quot;</span>);</span><br><span class="line">        log.info(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">        log.info(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                log.info((<span class="string">&quot;t1进入同步块，MarkWord 为：&quot;</span>));</span><br><span class="line">                log.info(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                log.info((<span class="string">&quot;t2进入同步块，MarkWord 为：&quot;</span>));</span><br><span class="line">                log.info(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果持有锁的线程执行的时间超过自旋等待的最大时间仍没有释放锁，就会导致其他争用锁的线程在最大等待时间内还是获取不到锁，自旋不会一直持续下去，这时争用线程会停止自旋进入阻塞状态，该锁膨胀为重量级锁。<br>轻量锁存在的目的是尽可能不动用操作系统层面的互斥锁，因为其性能比较差。线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁地阻塞和唤醒对CPU来说是一件负担很重的工作。同时我们可以发现，很多对象锁的锁定状态只会持续很短的一段时间，例如整数的自加操作，在很短的时间内阻塞并唤醒线程显然不值得，为此引入了轻量级锁。轻量级锁是一种自旋锁，因为JVM本身就是一个应用，所以希望在应用层面上通过自旋解决线程同步问题。<br>轻量级锁的执行过程：在抢锁线程进入临界区之前，如果内置锁（临界区的同步对象）没有被锁定，JVM首先将在抢锁线程的栈帧中建立一个锁记录（LockRecord），用于存储锁对象当前 Mark Word 的拷贝（官方称为 Displaced Mark Word），owner 指针指向对象的 Mark Word。，这时的线程堆栈与内置锁对象头大致如下图所示：</p>
<p><img src="https://files.catbox.moe/hkb5xd.png"></p>
<p>然后抢锁线程将使用CAS自旋操作，尝试将内置锁对象头的Mark Word的ptr_to_lock_record（锁记录指针）更新为抢锁线程栈帧中锁记录的地址，如果这个更新执行成功了，这个线程就拥有了这个对象锁。然后JVM将Mark Word中的lock标记位改为00（轻量级锁标志），即表示该对象处于轻量级锁状态。抢锁成功之后，JVM会将Mark Word中原来的锁对象信息（如哈希码等）保存在抢锁线程锁记录的Displaced Mark Word（可以理解为放错地方的Mark Word）字段中，再将抢锁线程中锁记录的owner指针指向锁对象。</p>
<p><img src="https://files.catbox.moe/vu8bx6.png"></p>
<h4 id="轻量级锁的分类"><a href="#轻量级锁的分类" class="headerlink" title="轻量级锁的分类"></a>轻量级锁的分类</h4><p>轻量级锁主要有两种：普通自旋锁和自适应自旋锁。</p>
<h5 id="普通自旋锁"><a href="#普通自旋锁" class="headerlink" title="普通自旋锁"></a>普通自旋锁</h5><p>所谓普通自旋锁，就是指当有线程来竞争锁时，抢锁线程会在原地循环等待，而不是被阻塞，直到那个占有锁的线程释放锁之后，这个抢锁线程才可以获得锁。</p>
<h5 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h5><p>所谓自适应自旋锁，就是等待线程空循环的自旋次数并非是固定的，而是会动态地根据实际情况来改变自旋等待的次数，自旋次数由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。自适应自旋锁的大概原理是：（1）如果抢锁线程在同一个锁对象上之前成功获得过锁，JVM就会认为这次自旋很有可能再次成功，因此允许自旋等待持续相对更长的时间。（2）如果对于某个锁，抢锁线程很少成功获得过，那么JVM将可能减少自旋时间甚至省略自旋过程，以避免浪费处理器资源。自适应自旋解决的是“锁竞争时间不确定”的问题。自适应自旋假定不同线程持有同一个锁对象的时间基本相当，竞争程度趋于稳定。总的思想是：根据上一次自旋的时间与结果调整下一次自旋的时间。<br>注意：JDK 1.6的轻量级锁使用的是普通自旋锁，且需要使用-XX:+UseSpinning选项手工开启。JDK 1.7后，轻量级锁使用自适应自旋锁，JVM启动时自动开启，且自旋时间由JVM自动控制。轻量级锁也被称为非阻塞同步、乐观锁，因为这个过程并没有把线程阻塞挂起，而是让线程空循环等待。</p>
<h3 id="重量级锁状态"><a href="#重量级锁状态" class="headerlink" title="重量级锁状态"></a>重量级锁状态</h3><p>在JVM中，每个对象都关联一个监视器，这里的对象包含Object实例和Class实例。监视器是一个同步工具，相当于一个许可证，拿到许可证的线程即可进入临界区进行操作，没有拿到则需要阻塞等待。重量级锁通过监视器的方式保障了任何时间只允许一个线程通过受到监视器保护的临界区代码。<br>重量级锁会让其他申请的线程之间进入阻塞，性能降低。重量级锁也叫同步锁，这个锁对象Mark Word再次发生变化，会指向一个监视器对象，该监视器对象用集合的形式来登记和管理排队的线程。重量级锁状态下对象的Mark Word如下表所示。</p>
<p><img src="https://files.catbox.moe/zaf8ms.png"></p>
<p>总结起来，锁升级状态如下图所示：</p>
<p><img src="https://files.catbox.moe/abuq3a.png"></p>
<h2 id="偏向锁、轻量级锁、重量级锁的对比"><a href="#偏向锁、轻量级锁、重量级锁的对比" class="headerlink" title="偏向锁、轻量级锁、重量级锁的对比"></a>偏向锁、轻量级锁、重量级锁的对比</h2><p>总结一下synchronized的执行过程，大致如下：</p>
<ol>
<li>线程抢锁时，JVM首先检测内置锁对象Mark Word中的biased_lock（偏向锁标识）是否设置成1，lock（锁标志位）是否为01，如果都满足，确认内置锁对象为可偏向状态。</li>
<li>在内置锁对象确认为可偏向状态之后，JVM检查Mark Word中的线程ID是否为抢锁线程ID，如果是，就表示抢锁线程处于偏向锁状态，抢锁线程快速获得锁，开始执行临界区代码。</li>
<li>如果Mark Word中的线程ID并未指向抢锁线程，就通过CAS操作竞争锁。如果竞争成功，就将Mark Word中的线程ID设置为抢锁线程，偏向标志位设置为1，锁标志位设置为01，然后执行临界区代码，此时内置锁对象处于偏向锁状态。</li>
<li>如果CAS操作竞争失败，就说明发生了竞争，撤销偏向锁，进而升级为轻量级锁。</li>
<li>JVM使用CAS将锁对象的Mark Word替换为抢锁线程的锁记录指针，如果成功，抢锁线程就获得锁。如果替换失败，就表示其他线程竞争锁，JVM尝试使用CAS自旋替换抢锁线程的锁记录指针，如果自旋成功（抢锁成功），那么锁对象依然处于轻量级锁状态。</li>
<li>如果JVM的CAS替换锁记录指针自旋失败，轻量级锁就膨胀为重量级锁，后面等待锁的线程也要进入阻塞状态。</li>
</ol>
<p>总体来说，偏向锁是在没有发生锁争用的情况下使用的；一旦有了第二个线程争用锁，偏向锁就会升级为轻量级锁；如果锁争用很激烈，轻量级锁的CAS自旋到达阈值后，轻量级锁就会升级为重量级锁。三种内置锁的对比如表所示。</p>
<p><img src="https://files.catbox.moe/xcekhg.png"></p>
<h2 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h2><p>CAS（Compare And Swap）是一种无锁算法，该算法关键依赖两个值——期望值（旧值）和新值，底层CPU利用原子操作判断内存原值与期望值是否相等，如果相等就给内存地址赋新值，否则不做任何操作。<br>使用CAS进行无锁编程的步骤大致如下：</p>
<ol>
<li>获得字段的期望值（oldValue）。</li>
<li>计算出需要替换的新值（newValue）。</li>
<li>通过CAS将新值（newValue）放在字段的内存地址上，如果CAS失败就重复第（1）步到第（2）步，一直到CAS成功，这种重复俗称CAS自旋。</li>
</ol>
<h2 id="锁的概述"><a href="#锁的概述" class="headerlink" title="锁的概述"></a>锁的概述</h2><h3 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h3><p>乐观锁和悲观锁是在数据库中引入的名词，但是在并发包锁里面也引入了类似的思想。<br>悲观锁指对数据被外界修改持保守态度，认为数据很容易就会被其他线程修改，所以在数据被处理前先对数据进行加锁，并在整个数据处理过程中，使数据处于锁定状态。悲观锁的实现往往依靠数据库提供的锁机制，即在数据库中，在对数据记录操作前给记录加排它锁。如果获取锁失败，则说明数据正在被其他线程修改，当前线程则等待或者抛出异常。如果获取锁成功，则对记录进行操作，然后提交事务后释放排它锁。在Java中synchronized便是一种悲观锁。<br>乐观锁是相对悲观锁来说的，它认为数据在一般情况下不会造成冲突，所以在访问记录前不会加排它锁，而是在进行数据提交更新时，才会正式对数据冲突与否进行检测。例如CAS算法就是一种乐观锁。</p>
<h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><p>根据线程获取锁的抢占机制，锁可以分为公平锁和非公平锁，公平锁表示线程获取锁的顺序是按照线程请求锁的时间早晚来决定的，也就是最早请求锁的线程将最早获取到锁。而非公平锁则在运行时闯入，也就是先来不一定先得。<br>ReentrantLock提供了公平和非公平锁的实现。</p>
<ul>
<li>公平锁：ReentrantLock pairLock &#x3D; new ReentrantLock（true）。</li>
<li>非公平锁：ReentrantLock pairLock &#x3D; new ReentrantLock（false）。如果构造函数不传递参数，则默认是非公平锁。</li>
</ul>
<p>例如，假设线程A已经持有了锁，这时候线程B请求该锁其将会被挂起。当线程A释放锁后，假如当前有线程C也需要获取该锁，如果采用非公平锁方式，则根据线程调度策略，线程B和线程C两者之一可能获取锁，这时候不需要任何其他干涉，而如果使用公平锁则需要把C挂起，让B获取当前锁。<br>在没有公平性需求的前提下尽量使用非公平锁，因为公平锁会带来性能开销。</p>
<h2 id="JUC容器"><a href="#JUC容器" class="headerlink" title="JUC容器"></a>JUC容器</h2><p>Java同步容器类通过Synchronized（内置锁）来实现同步的容器，比如Vector、HashTable以及SynchronizedList等容器。线程安全的同步容器类主要有Vector、Stack、HashTable等。另外，Java还提供了一组包装方法，将一个普通的基础容器包装成一个线程安全的同步容器。例如通过Collections.synchronized包装方法能将一个普通的容器包装成一个线程安全的Sorted同步容器。</p>
<h3 id="什么是JUC容器"><a href="#什么是JUC容器" class="headerlink" title="什么是JUC容器"></a>什么是JUC容器</h3><p>JUC基于非阻塞算法（Lock Free，无锁编程）提供了一组高并发容器，包括高并发的List、Set、Queue、Map容器。<br>JUC高并发容器是基于非阻塞算法（或者无锁编程算法）实现的容器类，无锁编程算法主要通过CAS（Compare And Swap）+Volatile组合实现，通过CAS保障操作的原子性，通过volatile保障变量内存的可见性。无锁编程算法的主要优点如下：</p>
<ol>
<li>开销较小：不需要在内核态和用户态之间切换进程。</li>
<li>读写不互斥：只有写操作需要使用基于CAS机制的乐观锁，读读操作之间可以不用互斥。</li>
</ol>
<p>JUC包中提供了List、Set、Queue、Map各种类型的高并发容器，如ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、CopyOnWriteArrayList和CopyOnWriteArraySet。在性能上，ConcurrentHashMap通常优于同步的HashMap，ConcurrentSkipListMap通常优于同步的TreeMap。当读取和遍历操作远远大于列表的更新操作时，CopyOnWriteArrayList优于同步的ArrayList。<br><strong>1.List</strong><br>JUC包中的高并发List主要有CopyOnWriteArrayList，对应的基础容器为ArrayList。<br>CopyOnWriteArrayList相当于线程安全的ArrayList，它实现了List接口。在读多写少的场景中，其性能远远高于ArrayList的同步包装容器。<br><strong>2.Set</strong><br>JUC包中的Set主要有CopyOnWriteArraySet和ConcurrentSkipListSet。<br>CopyOnWriteArraySet继承自AbstractSet类，对应的基础容器为HashSet。其内部组合了一个CopyOnWriteArrayList对象，它的核心操作是基于CopyOnWriteArrayList实现的。<br>ConcurrentSkipListSet是线程安全的有序集合，对应的基础容器为TreeSet。它继承自AbstractSet，并实现了NavigableSet接口。ConcurrentSkipListSet是通过ConcurrentSkipListMap实现的。<br><strong>3.Map</strong><br>JUC包中Map主要有ConcurrentHashMap和ConcurrentSkipListMap。<br>ConcurrentHashMap对应的基础容器为HashMap。JDK 6中的ConcurrentHashMap采用一种更加细粒度的“分段锁”加锁机制，JDK 8中采用CAS无锁算法。<br>ConcurrentSkipListMap对应的基础容器为TreeMap。其内部的Skip List（跳表）结构是一种可以代替平衡树的数据结构，默认是按照Key值升序的。<br><strong>4.Queue</strong><br>JUC包中的Queue的实现类包括三类：单向队列、双向队列和阻塞队列。<br>ConcurrentLinkedQueue是基于列表实现的单向队列，按照FIFO（先进先出）原则对元素进行排序。新元素从队列尾部插入，而获取队列元素则需要从队列头部获取。<br>ConcurrentLinkedDeque是基于链表的双向队列，但是该队列不允许null元素。作为双向队列，ConcurrentLinkedDeque可以当作“栈”来使用，并且高效地支持并发环境。<br>除了提供普通的单向队列、双向队列外，JUC拓展了队列，增加了可阻塞的插入和获取等操作，提供了一组阻塞队列，具体如下：</p>
<ul>
<li>ArrayBlockingQueue：基于数组实现的可阻塞的FIFO队列。</li>
<li>LinkedBlockingQueue：基于链表实现的可阻塞的FIFO队列。</li>
<li>PriorityBlockingQueue：按优先级排序的队列。</li>
<li>DelayQueue：按照元素的Delay时间进行排序的队列。</li>
<li>SynchronousQueue：无缓冲等待队列。</li>
</ul>
<h3 id="CopyOnWriteArrayList的使用"><a href="#CopyOnWriteArrayList的使用" class="headerlink" title="CopyOnWriteArrayList的使用"></a>CopyOnWriteArrayList的使用</h3><p>从源码中可以看出CopyOnWriteArrayList同样继承了List接口，因此CopyOnWriteArrayList的使用和ArrayList基本一致：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyOnWriteListDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        CopyOnWriteArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//加锁——复制——添加</span></span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除元素</span></span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        list.remove(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//修改</span></span><br><span class="line">        <span class="comment">//加锁——复制——修改</span></span><br><span class="line">        list.set(<span class="number">0</span>,<span class="number">200</span>);</span><br><span class="line">        <span class="comment">//查询</span></span><br><span class="line">        <span class="comment">//不加锁</span></span><br><span class="line">        list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CopyOnWriteArrayList的原理"><a href="#CopyOnWriteArrayList的原理" class="headerlink" title="CopyOnWriteArrayList的原理"></a>CopyOnWriteArrayList的原理</h3><p>CopyOnWrite（写时复制）就是在修改器对一块内存进行修改时，不直接在原有内存块上进行写操作，而是将内存复制一份，在新的内存中进行写操作，写完之后，再将原来的指针（或者引用）指向新的内存，原来的内存被回收。CopyOnWriteArrayList是写时复制思想的一种典型实现，其含有一个指向操作内存的内部指针array，而可变操作（add、set等）是在array数组的副本上进行的。当元素需要被修改或者增加时，并不直接在array指向的原有数组上操作，而是首先对array进行一次复制，将修改的内容写入复制的副本中。写完之后，再将内部指针array指向新的副本，这样就可以确保修改操作不会影响访问器的读取操作。CopyOnWriteArrayList的原理如图所示。</p>
<p><img src="https://files.catbox.moe/0eo9nr.png"></p>
<h3 id="ConcurrentHashMap-（JDK-1-7）原理"><a href="#ConcurrentHashMap-（JDK-1-7）原理" class="headerlink" title="ConcurrentHashMap （JDK 1.7）原理"></a>ConcurrentHashMap （JDK 1.7）原理</h3><p>JDK 1.7的ConcurrentHashMap的锁机制基于粒度更小的分段锁，分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，分段锁技术将Key分成一个一个小Segment存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发访问。</p>
<p><img src="https://files.catbox.moe/q9wkiy.png"></p>
<p>ConcurrentHashMap的内部结构的组成部分具体如下：<br><strong>1.HashEntry</strong><br>HashEntry结构用于存储“Key-Value对”（即“键-值对”）数据，以及存储其后继节点的指针。<br><strong>2.Segment</strong><br>ConcurrentHashMap中的一个段称为Segment，Segment继承了ReentrantLock，所以一个段又是一个ReentrantLock。Segment内部拥有一个HashEntry数组类型的成员table，数组中的每个元素又是一个链表，这个由HashEntry链接起来的链表对应一个哈希表的桶，也就是说，table的一个元素对应哈希表的一个桶。Segment在ConcurrentHashMap中扮演锁的角色，每个Segment守护着一个HashEntry数组中的元素，当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。<br><strong>3.ConcurrentHashMap</strong><br>ConcurrentHashMap在默认并发级别会创建包含16个Segment对象的数组，每个Segment大约守护整个哈希表中桶总数的1&#x2F;16，其中第N个哈希桶由第N mod 16个锁来保护。假设使用合理的哈希算法使关键字能够均匀地分部，那么这大约能使对锁的请求减少到原来的1&#x2F;16。默认并发级别的情况下，ConcurrentHashMap支持多达16个并发的写入线程。</p>
<h4 id="ConCurrentHashMap核心源码解析"><a href="#ConCurrentHashMap核心源码解析" class="headerlink" title="ConCurrentHashMap核心源码解析"></a>ConCurrentHashMap核心源码解析</h4><p><strong>1.成员变量</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//segment默认初始容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"><span class="comment">//默认线程并发数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">//HashEntry数组最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//Segment数组中HashEntry数组的最小容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_SEGMENT_TABLE_CAPACITY</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SEGMENTS</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">16</span>;</span><br><span class="line"><span class="comment">//加锁前的重试次数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RETRIES_BEFORE_LOCK</span> <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p><strong>2.构造方法</strong><br>ConcurrentHashMap构造器和HashMap类似，都调用了重载的构造器，此处不一一讲解，只讲解被调用的核心构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,</span></span><br><span class="line"><span class="params">                             <span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span> &#123;</span><br><span class="line">    	<span class="comment">//判断传入的参数是否合法，如果不合法</span></span><br><span class="line">        <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    	<span class="comment">//如果最大并发数超出最大并发数则赋值为最大并发数</span></span><br><span class="line">        <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">            concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">        <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sshift</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ssize</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    	<span class="comment">//左移ssize使它成为2的N次方，concurrencyLevel是16，因此ssift是4</span></span><br><span class="line">        <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">            ++sshift;</span><br><span class="line">            ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    	segmentShift和segmentMask都是用于定位segment和HashEntry数组中的元素</span><br><span class="line">        <span class="built_in">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">        <span class="built_in">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    	<span class="comment">//计算每个segment数组的大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> initialCapacity / ssize;</span><br><span class="line">        <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">            ++c;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">    	<span class="comment">//使得HashEntry[]的最小容量为2，作用是让segment添加第二个元素时才扩容</span></span><br><span class="line">        <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">            cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 创建segment数组，并创建segment[0]加入数组中</span></span><br><span class="line">        Segment&lt;K,V&gt; s0 =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Segment</span>&lt;K,V&gt;(loadFactor, (<span class="type">int</span>)(cap * loadFactor),</span><br><span class="line">                             (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">HashEntry</span>[cap]);</span><br><span class="line">        Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Segment</span>[ssize];</span><br><span class="line">        UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">        <span class="built_in">this</span>.segments = ss;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//Segment构造方法</span></span><br><span class="line">Segment(<span class="type">float</span> lf, <span class="type">int</span> threshold, HashEntry&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">            <span class="built_in">this</span>.loadFactor = lf;</span><br><span class="line">            <span class="built_in">this</span>.threshold = threshold;</span><br><span class="line">            <span class="built_in">this</span>.table = tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结上述代码可以看出在构造方法内主要做了以下4件事情：</p>
<ol>
<li>创建了Segment数组，初始长度为16，并且不可扩容</li>
<li>初始化Segment数组中HashEntry数组，初始长度为2，因为负载因子是0.75，因此扩容的阈值的1.5，也就是说在HashEntry数组中添加第一个元素时并不会扩容，添加第二个元素时才会扩容。</li>
<li>初始化Segment[0]，其他位置还是null。</li>
<li>计算处segmentShift值为32-4&#x3D;8，segmentMask为16-1&#x3D;15</li>
</ol>
<p><strong>3.put()</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 1. 计算 key 的 hash 值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="comment">// 2. 根据 hash 值找到 Segment 数组中的位置 j</span></span><br><span class="line">    <span class="comment">//    hash 是 32 位，无符号右移 segmentShift(28) 位，剩下高 4 位，</span></span><br><span class="line">    <span class="comment">//    然后和 segmentMask(15) 做一次与操作，也就是说 j 是 hash 值的高 4 位，也就是槽的数组下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="comment">// 由于初始化的时候初始化了 segment[0]，其他位置还是 null，</span></span><br><span class="line">    <span class="comment">// ensureSegment(j) 对 segment[j] 进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="literal">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="comment">// 3. 插入新值到 槽 s 中</span></span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处的put()方法较为简单，即通过计算得出对应位置的Segment，并在Segment内部进行put操作。接下来查看在Segment中put的流程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">put</span><span class="params">(K key, <span class="type">int</span> hash, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    		<span class="comment">//获取Segment独占锁</span></span><br><span class="line">            HashEntry&lt;K,V&gt; node = tryLock() ? <span class="literal">null</span> :</span><br><span class="line">                scanAndLockForPut(key, hash, value);</span><br><span class="line">            V oldValue;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取Segment内部HashEntry数组</span></span><br><span class="line">                HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">                <span class="comment">//利用key的hash计算存放的位置</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">                <span class="comment">//获取链表的头结点</span></span><br><span class="line">                HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">                <span class="comment">//遍历链表</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                        K k;</span><br><span class="line">                        <span class="comment">//如果遍历过程中发现存放元素的key和链表中已有元素的key相等，则直接覆盖</span></span><br><span class="line">                        <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                            (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                            oldValue = e.value;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                                e.value = value;</span><br><span class="line">                                ++modCount;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        e = e.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//如果不为null，则直接将元素设置为表头，如果是null,初始化并设置为链表表头</span></span><br><span class="line">                        <span class="keyword">if</span> (node != <span class="literal">null</span>)</span><br><span class="line">                            node.setNext(first);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            node = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> count + <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">//如果超过了该Segment中HashEntry的阈值，则对HashEntry扩容</span></span><br><span class="line">                        <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                            rehash(node);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            <span class="comment">//如果没有达到，则放置到tab的index位置</span></span><br><span class="line">                            setEntryAt(tab, index, node);</span><br><span class="line">                        ++modCount;</span><br><span class="line">                        count = c;</span><br><span class="line">                        oldValue = <span class="literal">null</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//解锁</span></span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="ConcurrentHashMap-（JDK-1-8）原理"><a href="#ConcurrentHashMap-（JDK-1-8）原理" class="headerlink" title="ConcurrentHashMap （JDK 1.8）原理"></a>ConcurrentHashMap （JDK 1.8）原理</h3><p>JDK 1.8对ConcurrentHashMap的内部结构进行了改进，改采用数组+链表或红黑树来实现，但是从Segment（分段锁）技术角度来说，其原理是类似的。<br>JDK 1.7的ConcurrentHashMap为了进行并发热点的分离，默认情况下将一个table分裂成16个小的table（Segment表示），从而在Segment维度进行比较细粒度的并发控制。实际上，如果并发线程多，这种粒度还是不够细。所以，JDK 1.8的ConcurrentHashMap将并发控制的粒度进一步细化，也就是进一步进行并发热点的分离，将并发粒度细化到每一个桶。既然如此，比较粗粒度的Segment已经没有存在的必要，每一个桶已经变化成实质意义的Segment，所以该结构直接被丢弃。<br>JDK 1.7的ConcurrentHashMap每一个桶都为链表结构，为了提升节点的访问性能，JDK 1.8引入了红黑树的结构，当桶的节点数超过一定的阈值（默认为64）时，JDK 1.8将链表结构自动转换成红黑树的结构，可以理解为将链式桶转换成树状桶。<br>ConcurrentHashMap的内部结构的层次关系为ConcurrentHashMap→链式桶&#x2F;树状桶。这样设计的好处在于，每次访问的时候只需对一个桶进行锁定，而不需要将整个Map集合都进行粗粒度的锁定。<br>JDK 1.8的ConcurrentHashMap引入红黑树的原因是：链表查询的时间复杂度为O(n)，红黑树查询的时间复杂度为O(log(n))，所以在节点比较多的情况下，使用红黑树可以大大提升性能。<br>一个JDK 1.8版本ConcurrentHashMap实例的内部结构示例如图所示。从图示来看ConcurrentHashMap的数据结构和HashMap的基本一致。</p>
<p><img src="https://files.catbox.moe/dy11ld.png"></p>
<p><strong>1.Node</strong><br>此结构为ConcurrentHashMap的核心内部类，它包装了“Key-Value对”，所有插入ConcurrentHashMap的数据都包装在其中。<br><strong>2.TreeBin(Node子类)</strong><br>当数据链表（链式桶）长度大于8时，会转换为TreeBin（树状桶）。TreeBin作为根节点，可以认为是红黑树对象。在ConcurrentHashMap的table“数组”中，存放的就是TreeBin对象，而不是TreeNode对象。<br><strong>3.TreeNode</strong><br>树状桶节点类<br>JDK 1.8版本的ConcurrentHashMap中通过一个Node&lt;K,V&gt;[]数组table来保存添加到哈希表中的桶，而在同一个Bucket位置是通过链表和红黑树的形式来保存的。但是数组table是懒加载的，只有在第一次添加元素的时候才会初始化。</p>
<h4 id="ConcurrentHashMap核心源码解析"><a href="#ConcurrentHashMap核心源码解析" class="headerlink" title="ConcurrentHashMap核心源码解析"></a>ConcurrentHashMap核心源码解析</h4><p><strong>1.成员变量</strong><br>JDK 1.8版本ConcurrentHashMap的主要成员属性大致如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最大容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//默认容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"><span class="comment">//最大数组容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="comment">//最大并发数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CONCURRENCY_LEVEL</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"><span class="comment">//链表转红黑树阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"><span class="comment">//红黑树蜕化会为链表的的节点数阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"><span class="comment">//链表转红黑树的数组容量阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"><span class="comment">//常量：表示正则转移</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOVED</span>     <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// hash for forwarding nodes</span></span><br><span class="line"><span class="comment">//常量：表示已经转换为树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEBIN</span>   <span class="operator">=</span> -<span class="number">2</span>; <span class="comment">// hash for roots of trees</span></span><br><span class="line"><span class="comment">//用于保存元素的数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"><span class="comment">//用于控制表初始化和扩容的控制属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> sizeCtl;</span><br></pre></td></tr></table></figure>

<ol>
<li>table：table用于保存添加到哈希表中的桶。</li>
<li>DEFAULT_CAPACITY：table的默认长度。默认初期长度为16，在第一次添加元素时，会将table初始化成16个元素的数组。</li>
<li>MIN_TREEIFY_CAPACITY：链式桶转成红黑树桶的阈值。在增加“Key-Value对”时，当链表长度大于该值时，将链表转换成红黑树。</li>
<li>UNTREEIFY_THRESHOLD：红黑树桶还原回链式桶的阈值，也就是红黑树转为链表的阈值，当在容量变动时重新计算存储位置后，当原有的红黑树内节点数量小于6时，将红黑树转换成链表。</li>
<li>MIN_TREEIFY_CAPACITY：链式桶转换成红黑树桶还有一个要求，table的容量达到最小树形化容量的阈值，只有当哈希表中的table容量大于该值时，才允许树将链表转换成红黑树的操作。否则，尽管单个桶内的元素太多，仍然选择直接扩容，而不是将桶树形化。</li>
<li>sizeCtl：sizeCtl用来控制table的初始化和扩容操作的过程，其值大致如下：<ol>
<li>-1代表table正在初始化，其他线程应该交出CPU时间片</li>
<li>-N表示有N-1个线程正在进行扩容操作，严格来说，当其为负数时，只用到其低16位，如果其低16位数值为M，此时有M-1个线程进行扩容。</li>
<li>大于0分两种情况：如果table未初始化，sizeCtl表示table需要初始化的大小；如果table初始化完成，sizeCtl表示table的容量，默认是table大小的0.75倍。</li>
</ol>
</li>
</ol>
<p><strong>2.构造器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这构造函数里，什么都不干</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该构造器相对比较简单，主要作用就是计算初始容量及sizeCtl，其中sizeCtl&#x3D;(1.5+initialCapacity+1)，目的是向上去最近的2的n次方。如果initialCapacity为10，则sizeCtl为16。<br><strong>3.put()</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 得到 hash 值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="comment">// 用于记录相应链表的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 如果数组&quot;空&quot;，进行数组初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 初始化数组</span></span><br><span class="line">            tab = initTable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找该 hash 值对应的数组下标，得到第一个节点 f</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果数组该位置为空，</span></span><br><span class="line">            <span class="comment">// 用一次 CAS 操作将这个新值放入其中即可</span></span><br><span class="line">            <span class="comment">// 如果 CAS 失败，那就是有并发操作，进到下一个循环</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// hash可以等于 MOVED，此处需要到后面才能看明白，从字面意思也可以看出，肯定是因为在扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// 帮助数据迁移</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">			<span class="comment">// 代码执行到此处，说明f 是该位置的头结点，而且不为空</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 获取数组该位置的头结点的监视器锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123; <span class="comment">// 头结点的 hash 值大于 0，说明是链表</span></span><br><span class="line">                        <span class="comment">// 用于累加，记录链表的长度</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 遍历链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 如果发现了&quot;相等&quot;的 key，判断是否要进行值覆盖，然后也就可以 break 了</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 到了链表的最末端，将这个新值放到链表的最后面</span></span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123; <span class="comment">// 红黑树</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">// 调用红黑树的插值方法插入新节点</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断是否要将链表转换为红黑树，临界值和 HashMap 一样，也是 8</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">// 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换，</span></span><br><span class="line">                    <span class="comment">// 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树</span></span><br><span class="line">                    <span class="comment">//    具体源码我们就不看了，扩容部分后面说</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码可以看出，ConcurrentHashMap的put的流程基本和HashMap一致，只是在ConcurrentHashMap中通过CAS和Synchronized来保证线程安全。</p>
<h3 id="16-7-6-ConCurrentHashMap-1-7和1-8的区别"><a href="#16-7-6-ConCurrentHashMap-1-7和1-8的区别" class="headerlink" title="16.7.6 ConCurrentHashMap 1.7和1.8的区别"></a>16.7.6 ConCurrentHashMap 1.7和1.8的区别</h3><p>两者主要区别如下：</p>
<ol>
<li>数据结构不同：Java7中使用了Segment+HashEntry实现，Java8中则使用哈希表+链表+红黑树实现</li>
<li>加锁方式不同：Java7中使用了分段锁，但是锁力度相对较大（因为锁住的是整个HashEntry数组），Java8中使用了Synchronized和CAS代替分段锁，这样降低了锁粒度，并且只有在CAS失败以后才尝试加锁。</li>
<li>初始化数组时，在Java8中不需要加锁，因为使用了sizeCtl作为标志位，当其值为-1时，则表明正则有线程初始化。</li>
<li>在Java7中寻找元素需要2次定位，第一次定位到Segment数组元素，第二次定位到HashEntry数组。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Java_Socket编程</title>
    <url>/2022/08/22/Java-Socket%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h2 id="网络基础知识"><a href="#网络基础知识" class="headerlink" title="网络基础知识"></a>网络基础知识</h2><p>所谓计算机网络，就是把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规模大、功能强的网络系统，从而使众多的计算机可以方便地互相传递信息，共享硬件、软件、数据信息等资源。</p>
<p>通过计算机网络可以向全社会提供各种经济信息、科研情报和咨询服务。其中，国际互联网Internet上的全球信息网（WWW，World Wide Web）服务就是一个最典型也是最成功的例子。实际上，今天的网络承载绝大部分大型企业的运转，一个大型的、全球性的企业或组织的日常工作流程都是建立在互联网基础之上的。计算机网络的品种很多，根据各种不同的分类原则，可以得到各种不同类型的计算机网络。计算机网络通常是按照规模大小和延伸范围来分类的，常见的划分为：局域网（LAN）、城域网（MAN）、广域网（WAN）。Internet可以视为世界上最大的广域网。</p>
<p>如果按照网络的拓扑结构来划分，可以分为星型网络、总线网络、环线网络、树型网络、星型环线网络等；如果按照网络的传输介质来划分，可以分为双绞线网、同轴电缆网、光纤网和卫星网等。</p>
<p>计算机网络中实现通信必须有一些约定，这些约定被称为通信协议。通信协议负责对传输速率、传输代码、代码结构、传输控制步骤、出错控制等制定处理标准。为了让两个节点之间能进行对话，必须在它们之间建立通信工具，使彼此之间能进行信息交换。</p>
<p>开放系统互连参考模型把计算机网络分成物理层、数据链路层、网络层、传输层、会话层、表示层、应用层七层，受到计算机界和通信业的极大关注。通过十多年的发展和推进，OSI模式已成为各种计算机网络结构的参考标准。</p>
<ul>
<li>应用层：应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。我们把应用层交互的数据单元称为报文。</li>
<li>传输层：运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</li>
<li>网络层：在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP&#x2F;IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称数据报。</li>
<li>数据链路层：数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</li>
<li>物理层：在物理层上所传送的数据单位是比特。物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异， 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</li>
</ul>
<h3 id="TCP-x2F-IP协议"><a href="#TCP-x2F-IP协议" class="headerlink" title="TCP&#x2F;IP协议"></a>TCP&#x2F;IP协议</h3><p>IP 协议则是一种非常重要的通信协议。IP（Internet Protocol）协议又称互联网协议，是支持网间互联的数据报协议。它提供网间连接的完善功能，包括IP数据报规定互联网络范围内的地址格式。</p>
<p>经常与IP协议放在一起的还有TCP（Transmission Control Protocol）协议，即传输控制协议，它规定一种可靠的数据信息传递服务。虽然IP和TCP这两个协议功能不尽相同，也可以分开单独使用，但它们是在同一个时期作为一个协议来设计的，并且在功能上也是互补的。因此实际使用中常常把这两个协议统称为TCP&#x2F;IP协议，TCP&#x2F;IP协议最早出现在UNIX操作系统中，现在几乎所有的操作系统都支持TCP&#x2F;IP协议，因此TCP&#x2F;IP协议也是Internet中最常用的基础协议。</p>
<p>计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。</p>
<p>TCP在传输之前会进行三次沟通，一般称为“三次握手”，传完数据断开的时候要进行四次沟通，一般称为“四次挥手”。要理解这个过程首先需要理解TCP中的两个序号和三个标志位的含义：</p>
<ul>
<li>seq：sequence number的缩写，表示所传数据的序号。TCP传输时每一个字节都有一个序号，发送数据时会将数据的第一个序号发送给对方，接收方会按序号检查是否接收完整了，如果没接收完整就需要重新传送，这样就可以保证数据的完整性。</li>
<li>ack：acknoledgement number的缩写，表示确认号。接收端用它来给发送端反馈已经成功接收到的数据信息的，它的值为希望接收的下一个数据包起始序号，也就是ack值所代表的序号前面数据已经成功接收到了。</li>
<li>ACK：确认位，只有ACK&#x3D;1的时候ack才起作用。正常通信时ACK为1，第一次发起请求时因为没有需要确认接收的数据所以ACK为0。</li>
<li>SYN：同步位，用于在建立连接时同步序号。刚开始建立连接时并没有历史接收的数据，所以ack也就没办法设置，这时按照正常的机制就无法运行了，SYN的作用就是来解决这个问题的，当接收端接收到SYN&#x3D;1的报文时就会直接将ack设置为接收到的seq+1的值，注意这里的值并不是校验后设置的，而是根据SYN直接设置的，这样正常的机制就可以运行了，所以SYN叫同步位。需要注意的是，SYN会在前两次握手时都为1，这是因为通信的双方的ack都需要设置一个初始值。</li>
<li>FIN：终止位，用来在数据传输完毕后释放连接。</li>
</ul>
<p>整个传输过程如图所示。</p>
<p><img src="https://files.catbox.moe/k6fz1x.png"></p>
<p>图中上部为三次握手，下部为四次挥手，这里的四次挥手中画的是客户端提出的终止连接，在实际传输过程中也有可能是服务端提出终止连接，它们的处理过程都是一样的。TCP的传输是双全工模式，也就是说传输的双方是对等的，可以同时传输数据，所以无论连接还是关闭都需要对双方同时进行。三次握手中前两次可以保证服务端可以正确接收并返回请求，后两次可以保证客户端可以正确接收并返回请求，而且在三次握手的过程中还使用SYN标志初始化了双方的ack值。四次挥手就是双方分别发送FIN标志来关闭连接并让对方确认。四次挥手过程如下：</p>
<ul>
<li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li>
<li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加 1 。和 SYN 一样，一个 FIN 将占用一个序号</li>
<li>服务器-关闭与客户端的连接，发送一个 FIN 给客户端</li>
<li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加 1</li>
</ul>
<h3 id="IP地址和端口号"><a href="#IP地址和端口号" class="headerlink" title="IP地址和端口号"></a>IP地址和端口号</h3><p>IP 地址用于唯一地标识网络中的一个通信实体，这个通信实体既可以是一台主机，也可以是一台打印机，或者是路由器的某一个端口。而在基于IP协议网络中传输的数据包，都必须使用IP地址来进行标识。<br>IP地址是数字型的，IP地址是一个32位（32bit）整数，但通常为了便于记忆，通常把它分成4个8位的二进制数，每8位之间用圆点隔开，每个8位整数可以转换成一个0～255的十进制整数，因此我们看到的IP地址常常是这种形式：202.9.128.88。<br>IP地址被分成了A、B、C、D、E五类，每个类别的网络标识和主机标识各有规则。</p>
<ul>
<li>A类：10.0.0.0 ～ 10.255.255.255</li>
<li>B类：172.16.0.0 ～ 172.31.255.255</li>
<li>C类：192.168.0.0 ～192.168.255.255</li>
</ul>
<p>IP 地址用于唯一地标识网络上的一个通信实体，但一个通信实体可以有多个通信程序同时提供网络服务，此时还需要使用端口。端口是一个16位的整数，用于表示数据交给哪个通信程序处理。端口号可以从0到65535。</p>
<h2 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h2><p>Java提供了InetAddress类来代表IP地址，InetAddress下还有两个子类：Inet4Address、Inet6Address，它们分别代表Internet Protocol version 4（IPv4）地址和Internet Protocol version 6（IPv6）地址。<br>InetAddress类没有提供构造器，而是提供了如下两个静态方法来获取InetAddress实例。</p>
<ul>
<li>getByName(String host)：根据主机获取对应的InetAddress对象。</li>
<li>getByAddress(byte[]addr)：根据原始IP地址来获取对应的InetAddress对象。</li>
</ul>
<p>InetAddress还提供了如下三个方法来获取InetAddress实例对应的IP地址和主机名。</p>
<ul>
<li>String getCanonicalHostName()：获取此 IP 地址的全限定域名。</li>
<li>String getHostAddress()：返回该InetAddress实例对应的IP地址字符串（以字符串形式）。</li>
<li>String getHostName()：获取此 IP 地址的主机名。</li>
</ul>
<p>除此之外，InetAddress 类还提供了一个 getLocalHost()方法来获取本机 IP 地址对应的InetAddress实例。<br>下面通过示例来学习InetAddress的用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        <span class="comment">//根据主机获取对应的InetAddress对象</span></span><br><span class="line">        address.getByName(<span class="string">&quot;192.168.31.160&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] bytes = address.getAddress();</span><br><span class="line">        <span class="comment">//根据原始IP地址来获取对应的InetAddress对象</span></span><br><span class="line">        InetAddress.getByAddress(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">adr</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;192.168.31.160&quot;</span>);</span><br><span class="line">        <span class="comment">//获取此IP地址的全限定域名</span></span><br><span class="line">        adr.getCanonicalHostName();</span><br><span class="line">        <span class="comment">//返回该InetAddress实例对应的IP地址字符串（以字符串形式）</span></span><br><span class="line">        adr.getHostAddress();</span><br><span class="line">        <span class="comment">//获取此 IP 地址的主机名。</span></span><br><span class="line">        adr.getHostName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基于TCP协议的网络编程"><a href="#基于TCP协议的网络编程" class="headerlink" title="基于TCP协议的网络编程"></a>基于TCP协议的网络编程</h2><p>TCP&#x2F;IP通信协议是一种可靠的网络协议，它在通信的两端各建立一个Socket，从而在通信的两端之间形成网络虚拟链路。一旦建立了虚拟的网络链路，两端的程序就可以通过虚拟链路进行通信。Java对基于TCP协议的网络通信提供了良好的封装，Java使用Socket对象来代表两端的通信端口，并通过Socket产生IO流来进行网络通信。</p>
<h3 id="ServerSocket创建服务端"><a href="#ServerSocket创建服务端" class="headerlink" title="ServerSocket创建服务端"></a>ServerSocket创建服务端</h3><p>Java中能接收其他通信实体连接请求的类是ServerSocket，ServerSocket对象用于监听来自客户端的 Socket 连接，如果没有连接，它将一直处于等待状态。ServerSocket 包含一个监听来自客户端连接请求的方法。</p>
<ul>
<li>Socket accept()：如果接收到一个客户端Socket的连接请求，该方法将返回一个与客户端Socket对应的Socket；否则该方法将一直处于等待状态，线程也被阻塞。</li>
</ul>
<p>ServerSocket类提供了如下几个构造器。</p>
<ul>
<li>ServerSocket(int port)：用指定的端口port来创建一个ServerSocket。该端口应该有一个有效的端口整数值，即0～65535。</li>
<li>ServerSocket(int port,int backlog)：增加一个用来改变连接队列长度的参数backlog。</li>
<li>ServerSocket(int port,int backlog,InetAddress localAddr)：在机器存在多个 IP地址的情况下，允许通过localAddr参数来指定将ServerSocket绑定到指定的IP地址。</li>
</ul>
<p>当ServerSocket使用完毕后，应使用ServerSocket的close()方法来关闭该ServerSocket。<br>下面我们使用ServerSocker创建服务端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServer</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//创建服务端Socket对象，监听10086端口</span></span><br><span class="line">		<span class="keyword">try</span>(<span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">10086</span>)) &#123;</span><br><span class="line">			<span class="comment">//为了服务端为了能接受多个请求。因此使用while循环</span></span><br><span class="line">			<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">				<span class="comment">//监听到客户端的请求</span></span><br><span class="line">				<span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-3-2-使用Socket通信"><a href="#18-3-2-使用Socket通信" class="headerlink" title="18.3.2 使用Socket通信"></a>18.3.2 使用Socket通信</h3><p>客户端通常可以使用Socket的构造器来连接到指定服务器，Socket通常可以使用如下两个构造器。</p>
<ul>
<li>Socket(InetAddress&#x2F;String remoteAddress, int port)：创建连接到指定远程主机、远程端口的Socket，该构造器没有指定本地地址、本地端口，默认使用本地主机的默认IP地址，默认使用系统动态分配的端口。</li>
<li>Socket(InetAddress&#x2F;String remoteAddress, int port, InetAddresslocalAddr, int localPort)：创建连接到指定远程主机、远程端口的Socket，并指定本地IP地址和本地端口，适用于本地主机有多个IP地址的情形。</li>
</ul>
<p>下面通过示例来学习Socket的使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClient</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">10086</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当客户端、服务器端产生了对应的Socket之后，就得到了如图12.4所示的通信示意图，程序无须再区分服务器端、客户端，而是通过各自的Socket进行通信。Socket提供了如下两个方法来获取输入流和输出流。</p>
<ul>
<li>InputStream getInputStream()：返回该Socket对象对应的输入流，让程序通过该输入流从Socket中取出数据。</li>
<li>OutputStream getOutputStream()：返回该Socket对象对应的输出流，让程序通过该输出流向Socket中输出数据。</li>
</ul>
<p>接下来使用Socket和ServerSocket进行简单的通信。<br>第一步：新建客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClient</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="comment">//获取从服务器响应的数据</span></span><br><span class="line">			<span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">10086</span>);</span><br><span class="line">			<span class="comment">//使用字符转换流将字节流转换成字符流</span></span><br><span class="line">			<span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream());</span><br><span class="line">			<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">			<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步：新建服务端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端启动&quot;</span>);</span><br><span class="line">        <span class="comment">//创建服务端Socket对象，监听10086端口</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">10086</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="comment">//监听到客户端的请求</span></span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">                <span class="comment">//向客户端进行响应</span></span><br><span class="line">                <span class="type">PrintStream</span> <span class="variable">printStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(os);</span><br><span class="line">                printStream.print(<span class="string">&quot;receive&quot;</span>);</span><br><span class="line">                printStream.close();</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上例中MyClient内，创建Socket对象用于连接服务端，其中127.0.0.1指本机IP，10086则是服务器的端口号，为了便于打印服务端响应的数据，将服务端响应的输入字节流包装成字符流。接受到服务端响应的数据后进行打印。<br>在服务端，使用accept()方法监听客户端的请求，当请求到达后，获取输出流，对客户端进行响应。</p>
<h3 id="Socket连续通信"><a href="#Socket连续通信" class="headerlink" title="Socket连续通信"></a>Socket连续通信</h3><p>在上一小节的示例中示范了客户端和服务端之间的简单通信，但是发现客户端无法和服务端连续通信，也就是说在客户端和服务端通信后客户端就结束了，在本小节中将以简单的聊天室为例学习Socket的连续通信。<br>首先新建服务端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;Socket&gt; serverList = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;---------服务端启动-----------&quot;</span>);</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">10086</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">           <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span>  serverSocket.accept();</span><br><span class="line">           <span class="comment">//把socket放入List</span></span><br><span class="line">            serverList.add(socket);</span><br><span class="line">            <span class="comment">//启动线程处理socket请求</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServerThread</span>(socket).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上例代码中，将每个服务端的接收到的Socket都放入集合中，并且为这个Socket启动线程，在线程内将客户端发送的数据响应给所有已经连接的Socket。服务端线程代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader br;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerThread</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//获取Socket输入流</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span>((line=br.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;server:&quot;</span>+line);</span><br><span class="line">                System.out.println(Server.serverList.size());</span><br><span class="line">                <span class="comment">//向每个Socket发送接收到的数据</span></span><br><span class="line">                <span class="keyword">for</span> (Socket socket:Server.serverList) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(socket!=<span class="built_in">this</span>.socket)&#123;</span><br><span class="line">                        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">                        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(os);</span><br><span class="line">                        ps.println(line);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从整体来看服务端所做的事情就是接收客户端请求并将客户端发送来的数据向所有已经连接的Socket进行发送。接下来，编写客户端代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">10086</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ClientThread</span>(socket).start();</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(socket.getOutputStream()));</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(socket.getOutputStream());</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//获取键盘输入流</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            ps.println(s);</span><br><span class="line">            ps.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在客户端内当连接到服务器后启动线程循环接收从服务端发送的数据，然后循环接收从键盘输入的数据，并发送给服务器。由服务器转发给所有客户端。客户端线程代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader br;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClientThread</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//获取输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line">            br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span>((s= br.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是在整个过程中并没有关闭流，因为一旦关闭流以后再去接收和发送数据将会抛出异常。</p>
<h2 id="基于UDP协议的网络编程"><a href="#基于UDP协议的网络编程" class="headerlink" title="基于UDP协议的网络编程"></a>基于UDP协议的网络编程</h2><p>UDP 协议是一种不可靠的网络协议，它在通信实例的两端各建立一个 Socket，但这两个 Socket 之间并没有虚拟链路，这两个 Socket 只是发送、接收数据报的对象。Java 提供了DatagramSocket 对象作为基于 UDP协议的 Socket，使用 DatagramPacket 代表 DatagramSocket 发送、接收的数据报。 <br>UDP 协议是英文 User Datagram Protocol 的缩写，即用户数据报协议，主要用来支持那些需要在计算机之间传输数据的网络连接。UDP协议目前应用不如 TCP 协议广泛，但 UDP 协议依然是一个非常实用和可行的网络传输层协议。尤其是在一些实时性很强的应用场景中，比如网络游戏、视频会议等， UDP 协议是一种面向非连接的协议，面向非连接指的是在正式通信前不必与对方先建立连接，不管对方状态就直接发送。至于对方是否可以接收到这些数据内容，UDP 协议无法控制，因此说 UDP协议是一种不可靠的协议。UDP 协议适用于一次只传送少量数据、对可靠性要求不高的应用环境。 与前面介绍的 TCP 协议一样，UDP 协议直接位于IP 协议之上。实际上，IP 协议属于 OSI参考模型的网络层协议，而 UDP 协议和 TCP 协议都属于传输层协议。 因为 UDP 协议是面向非连接的协议，没有建立连接的过程，因此它的通信效率很高;但也正因为如此，它的可靠性不如 TCP 协议。 UDP 协议的主要作用是完成网络数据流和数据报之间的转换——在信息的发送端，UDP 协议将网络数据流封装成数据报，然后将数据报发送出去;在信息的接收端，UDP 协议将数据报转换成实际数据内容。</p>
<h3 id="使用DatagramSocket发送接收数据"><a href="#使用DatagramSocket发送接收数据" class="headerlink" title="使用DatagramSocket发送接收数据"></a>使用DatagramSocket发送接收数据</h3><p>Java 使用DatagramSocket 代表 UDP协议的 Socket， 它的唯一作用就是接收和发送数据报，Java 使用 DatagramPacket 来代表数据报， DatagramSocket 接收和发送的数据都是通过 DatagramPacket 对象完成的。<br>DatagramScoket包含如下三个构造器：</p>
<ul>
<li>DatagramSocket()∶创建一个 DatagramSocket 实例，并将该对象绑定到本机默认 IP 地址、本机 所有可用端口中随机选择的某个端口。</li>
<li>DatagramSocket(int prot)∶ 创建一个 DatagramSocket 实例，并将该对象绑定到本机默认 IP 地址、指定端口。</li>
<li>DatagramSocket(int port，InetAddres laddr)∶ 创建一个 DatagramSocket 实例，并将该对象绑定到 指定 IP地址、指定端口。</li>
</ul>
<p>通过上面三个构造器中的任意一个构造器即可创建一个 DatagramSocket 实例，通常在创建服务器时，创建指定端口的 DatagramSocket 实例——这样保证其他客户端可以将数据发送到该服务器。一旦得到了 DatagramSocket 实例之后，就可以通过如下两个方法来接收和发送数据。</p>
<ul>
<li>receive(DatagramPacket p)∶ 从该 DatagramSocket 中接收数据报。</li>
<li>send(DatagramPacket p)∶以该 DatagramSocket 对象向外发送数据报。</li>
</ul>
<p>从上面两个方法可以看出，使用 DatagramSocket 发送数据报时，DatagramSocket 并不知道将该数据报发送到哪里，而是由 DatagramPacket 自身决定数据报的目的地。<br>下面看一下 DatagramPacket 的构造器。</p>
<ul>
<li>DatagramPacket(byte[] buf，int length)∶以一个空数组来创建 DatagramPacket 对象，该对象的作用 是接收 DatagramSocket 中的数据。</li>
<li>DatagramPacket(byte[] buf，int length，InetAddress addr， int port)∶ 以一个包含数据的数组来创建 DatagramPacket 对象，创建该DatagramPacket 对象时还指定了IP 地址和端口——这就决定了该数据报的目的地。</li>
<li>DatagramPacket(byte[] buf， int offset， int length)∶ 以一个空数组来创建 DatagramPacket 对象，并 指定接收到的数据放入 buf 数组中时从 offset 开始，最多放 length 个字节。</li>
<li>DatagramPacket（byte[] buf，int offset， int length，InetAddress address，int port）∶创建一个用于发送的 DatagramPacket 对象，指定发送 buf 数组中从 offset 开始，总共 length 个字节。</li>
</ul>
<p>下面程序使用DatagramSocket实现服务端和客户端的网络通信。<br>首先编写服务端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建服务端</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">10086</span>);</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//创建数据包对象</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">datagramPacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes,bytes.length);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//接收数据包</span></span><br><span class="line">            socket.receive(datagramPacket);</span><br><span class="line">            bytes = datagramPacket.getData();</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="number">0</span>,bytes.length);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看出使用DatagramSocket编程相对简单，需要注意的是客户端和服务端发送和接收数据都必须放在数据包中，也就是说需要创建DatagramPacket对象。接下来编写客户端。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">datagramPacket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            bytes = s.getBytes(Charset.defaultCharset());</span><br><span class="line">            datagramPacket = <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes,bytes.length,address,<span class="number">10086</span>);</span><br><span class="line">            socket.send(datagramPacket);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Java反射与注解</title>
    <url>/2022/08/22/Java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<p>本章将会深入介绍 Java类的加载、连接和初始化知识，并重点介绍 java.lang.reflect 包下的接口和类，包括 Class、Method、Field、Constructor 和 Array等，这些类分别代表类、方法、成员变量、构造器和数组，Java 程序可以使用这些类动态地获取某个对象。某个类的运行时信息，并可以动态地创建 Java 对象，动态地调用Java方法，访问并修改指定对象的成员变量值。</p>
<h2 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h2><p>当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过加载、连接、初始化三个步骤来对该类进行初始化。如果没有意外，JVM 将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载或类初始化。 类加载指的是将类的** class 文件**读入内存，并为之创建一个 java.lang.Class 对象，也就是说，当程序中使用任何类时，系统都会为之建立一个 java.lang.Class 对象。<br>类的加载由类加载器完成，类加载器通常由 JVM提供，这些类加载器也是前面所有程序运行的基础，JVM 提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承 ClassLoader基类来创建自己的类加载器。 <br>通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。</p>
<ul>
<li>从本地文件系统加载 class 文件，这是前面绝大部分示例程序的类加载方式。</li>
<li>从JAR 包加载 class 文件，这种方式也是很常见的，前面介绍 JDBC 编程时用到的数据库驱动类 就放在 JAR 文件中，JVM 可以从 JAR 文件中直接加载该 class 文件。</li>
<li>通过网络加载class 文件。</li>
<li>把一个 Java 源文件动态编译，并执行加载。</li>
</ul>
<p> </p>
<h2 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h2><p>Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。一个Class文件包含一下几部分：</p>
<ol>
<li>魔数：每个Class文件的头4个字节称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。很多文件存储标准中都使用魔数来进行身份识别，譬如图片格式，如gif或者jpeg等在文件头中都存有魔数。使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。文件格式的制定者可以自由地选择魔数值，只要这个魔数值还没有被广泛采用过同时又不会引起混淆即可。</li>
<li>版本号：紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（Minor Version），第7和第8个字节是主版本号（Major Version）。Java的版本号是从45开始的，JDK 1.1之后的每个JDK大版本发布主版本号向上加1（JDK 1.0～1.1使用了45.0～45.3的版本号），高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件。</li>
<li>常量池：紧接着主次版本号之后的是常量池入口，常量池可以理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一，常量池中主要存放两大类常量：字面量（Literal）和符号引用（SymbolicReferences）。字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括了下面三类常量：<ol>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ol>
</li>
<li>访问标志：在常量池结束之后，紧接着的两个字节代表访问标志（access_fags），这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等。</li>
<li>类索引、父类索引、与接口索引集合：Class文件中由这三项数据来确定这个类的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句（如果这个类本身是一个接口，则应当是extends语句）后的接口顺序从左到右排列在接口索引集合中。</li>
<li>字段表集合：字段表（field_info）用于描述接口或者类中声明的变量。字段（field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。描述实例变量和类变量以及实例变量的信息包括：字段的作用域（public、private、protected修饰符）、是实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰符，是否强制从主内存读写）、可否被序列化（transient修饰符）、字段数据类型（基本类型、对象、数组）、字段名称。</li>
<li>方法表集合：Class文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式，方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。</li>
<li>属性表集合：在Class文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松了一些，不再要求各个属性表具有严格顺序，并且只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识的属性。</li>
</ol>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>类加载器负责加载所有的类，系统为所有被载入内存中的类生成一个java.lang.Class实例。一旦一个类被载入JVM中，同一个类就不会被再次载入了。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。<br>当JVM启动时，会形成由3个类加载器组成的初始类加载器层次结构。</p>
<ul>
<li>Bootstrap ClassLoader：根类加载器。它负责加载Java的核心类。</li>
<li>Extension ClassLoader：扩展类加载器。它负责加载 JRE 的扩展目录（%JAVA_HOME%&#x2F;jre&#x2F;lib&#x2F;ext）中JAR包的类。</li>
<li>System ClassLoader：系统类加载器。它负责在JVM启动时加载来自java命令的-classpath选项、java.class.path系统属性，或CLASSPATH环境变量所指定的JAR包和类路径。</li>
</ul>
<h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><p>JVM的类加载机制主要有如下3种。</p>
<ul>
<li>全盘负责，所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他 Class 也将由该类加载器负责载入，除非显式使用另外一个类加载器来载入。</li>
<li>双亲委派，所谓父类委托，则是先让 parent（父）类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。</li>
<li>缓存机制。缓存机制将会保证所有加载过的 Class 都会被缓存，当程序中需要使用某个 Class 时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区中。</li>
</ul>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备、解析3个部分统称为连接（Linking），这7个阶段的发生顺序如下图所示。</p>
<p><img src="https://files.catbox.moe/zdnzba.png"></p>
<p>下面将详细讲解在类加载过程中每一步中的详细过程：<br><strong>1.加载</strong><br>“加载”是“类加载”（Class Loading）过程的一个阶段，希望读者没有混淆这两个看起来很相似的名词。在加载阶段，虚拟机需要完成以下3件事情：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<p><strong>2.验证</strong><br>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<ol>
<li>文件格式验证，第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。这一阶段可能包括下面这些验证点：<ol>
<li>是否以魔术0xCAFEBABE</li>
<li>主、次版本号是否在当前虚拟机处理范围内</li>
<li>常量池的常量中是否有不被支持的类型</li>
<li>指向常量的各种索引值是否有执行不存在的常量或者不符合类型的常量</li>
<li>CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据。</li>
<li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。</li>
</ol>
</li>
<li>元数据验证，第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，这个阶段可能包括的验证点如下：<ol>
<li>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。</li>
<li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）。</li>
<li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li>
<li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。</li>
</ol>
</li>
<li>字节码验证，第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件，例如：<ol>
<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似</li>
<li>这样的情况：在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中。</li>
<li>保证跳转指令不会跳转到方法体以外的字节码指令上。</li>
<li>保证方法体中的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。</li>
</ol>
</li>
<li>符号引用验证,最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生，符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，通常需要校验下列内容：<ol>
<li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li>
<li>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。</li>
<li>符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问。</li>
</ol>
</li>
</ol>
<p><strong>3.准备</strong><br>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这个阶段中有两个容易产生混淆的概念需要强调一下，首先，这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。<br><strong>4.解析</strong><br>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，符号引用是以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。直接引用则是指：可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。<br><strong>5.初始化</strong><br>类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码（或者说是字节码）。在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器&lt;clinit&gt;()方法的过程。</p>
<h2 id="通过反射获取类信息"><a href="#通过反射获取类信息" class="headerlink" title="通过反射获取类信息"></a>通过反射获取类信息</h2><h3 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h3><p>每个类被加载之后，系统就会为该类生成一个对应的Class对象，通过该Class对象就可以访问到JVM中的这个类。在Java程序中获得Class对象通常有如下3种方式。</p>
<ol>
<li>使用Class类的forName(String clazzName)静态方法。该方法需要传入字符串参数，该字符串参数的值是某个类的全限定类名（必须添加完整包名）。</li>
<li>调用某个类的class属性来获取该类对应的Class对象。例如，Person.class将会返回Person类对应的Class对象。</li>
<li>调用某个对象的getClass()方法。该方法是java.lang.Object类中的一个方法，所以所有的Java对象都可以调用该方法，该方法将会返回该对象所属类对应的Class对象。</li>
</ol>
<p>下面，通过示例来演示获取Class对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">		<span class="comment">//第一种方式：通过forName(&quot;&quot;);</span></span><br><span class="line">		<span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">		<span class="comment">//第二种方式：通过类名</span></span><br><span class="line">		<span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> String.class;</span><br><span class="line">		<span class="comment">//第三种方式：getClass();</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line">		<span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> s.getClass();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取构造器"><a href="#获取构造器" class="headerlink" title="获取构造器"></a>获取构造器</h3><p>Class类提供了大量的实例方法来获取该Class对象所对应类的详细信息，下面4个方法用于获取Class对应类所包含的构造器。<br>下面4个方法用于获取Class对应类所包含的构造器。</p>
<ul>
<li>Connstructor getConstructor(Class&lt;?&gt;… parameterTypes)：返回此Class对象对应类的指定public构造器。</li>
<li>Constructor&lt;?&gt;[]getConstructors()：返回此Class对象对应类的所有public构造器。</li>
<li>Constructor<T> getDeclaredConstructor(Class&lt;?&gt;…parameterTypes)：返回此Class对象对应类的指定构造器，与构造器的访问权限无关。</li>
<li>Constructor&lt;?&gt;[]getDeclaredConstructors()：返回此Class对象对应类的所有构造器，与构造器的访问权限无关。</li>
</ul>
<p>下面通过示例演示获取构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name,String gender,Integer age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException,</span><br><span class="line">            NoSuchMethodException, InvocationTargetException,</span><br><span class="line">            InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;cn.bytecollege.Person&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con1</span> <span class="operator">=</span> clazz.getConstructor();</span><br><span class="line"></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con2</span> <span class="operator">=</span> clazz.getConstructor(String.class,String.class,Integer.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过反射可以获取类中定义的构造方法，获取了构造方法就可以利用反射获取的构造方法来创建对象。<br>通过反射来生成对象有如下两种方式。</p>
<ul>
<li>使用Class对象的newInstance()方法来创建该Class对象对应类的实例，这种方式要求该 Class 对象的对应类有默认构造器，而执行 newInstance()方法时实际上是利用默认构造器来创建该类的实例。</li>
<li>先使用 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的newInstance()方法来创建该Class对象对应类的实例。通过这种方式可以选择使用指定的构造器来创建实例。</li>
</ul>
<p>下面通过示例来演示利用反射创建对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException,</span><br><span class="line">            NoSuchMethodException, InvocationTargetException,</span><br><span class="line">            InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">//获取class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;cn.bytecollege.Person&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取无参构造方法</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con1</span> <span class="operator">=</span> clazz.getConstructor();</span><br><span class="line">        <span class="comment">//通过class创建对象</span></span><br><span class="line">        <span class="type">Persion</span> <span class="variable">p1</span> <span class="operator">=</span> (Persion) con1.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取带参构造方法</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con2</span> <span class="operator">=</span> clazz.getConstructor(String.class,String.class,Integer.class);</span><br><span class="line">        <span class="comment">//通过class创建对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> (Person) con2.newInstance(<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;男&quot;</span>,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取类包含的方法"><a href="#获取类包含的方法" class="headerlink" title="获取类包含的方法"></a>获取类包含的方法</h3><p>下面4个方法用于获取Class对应类所包含的方法。</p>
<ul>
<li>Method getMethod(String name,Class&lt;?&gt;…parameterTypes)：返回此Class对象对应类的指定public方法。</li>
<li>Method[]getMethods()：返回此Class对象所表示的类的所有public方法。</li>
<li>Method getDeclaredMethod(String name,Class&lt;?&gt;…parameterTypes)：返回此Class对象对应类的指定方法，与方法的访问权限无关。</li>
<li>Method[] getDeclaredMethods()：返回此Class对象对应类的全部方法，与方法的访问权限无关。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">	String name;</span><br><span class="line">    Integer age;</span><br><span class="line">    Date birthday;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;public 修饰的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private 修饰的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">method3</span><span class="params">(String name, Integer sex, Date age)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;默认修饰&quot;</span>+name+<span class="string">&quot; &quot;</span>+sex+<span class="string">&quot; &quot;</span>+age);</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">&quot; &quot;</span>+sex+<span class="string">&quot; &quot;</span>+age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">method4</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;protected 修饰的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加载Class对象</span></span><br><span class="line">        <span class="comment">//会报出不存在该类的异常</span></span><br><span class="line">        Class c=Class.forName(<span class="string">&quot;cn.bytecollege.Teacher&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有公共方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;================获取所有公共方法=================&quot;</span>);</span><br><span class="line">        Method[] methods=c.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method:methods) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;公共方法:&quot;</span>+method);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取所有方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;================获取所有的方法=================&quot;</span>);</span><br><span class="line">        Method[] declaredMethods=c.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method declaredmethod:declaredMethods) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;所有方法:&quot;</span>+declaredmethod);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;================获取特定（带参）方法=================&quot;</span>);</span><br><span class="line">        Method method1=c.getMethod(<span class="string">&quot;method1&quot;</span>,String.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;特定（带参）方法:&quot;</span>+method1);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;================获取特定（不带参）方法=================&quot;</span>);</span><br><span class="line">        Method method2=c.getDeclaredMethod(<span class="string">&quot;method2&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;特定（不带参）方法:&quot;</span>+method2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;================获取特定（多参）方法=================&quot;</span>);</span><br><span class="line">        Method method3=c.getDeclaredMethod(<span class="string">&quot;method3&quot;</span>, String.class, Integer.class, Date.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;特定（多参）方法:&quot;</span>+method3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后的结果是：</p>
<p><img src="https://files.catbox.moe/b6kolz.png"></p>
<p>每个Method对象对应一个方法，获得Method对象后，程序就可通过该Method来调用它对应的方法。在Method里包含一个invoke()方法，该方法的签名如下。</p>
<ul>
<li>Object invoke(Object obj,Object…args)：该方法中的obj是执行该方法的主调，后面的args是执行该方法时传入该方法的实参。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package cn.bytecollege;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class Msym &#123;</span><br><span class="line">    public void test(String[] arg)&#123;</span><br><span class="line">        for (String string : arg) &#123;</span><br><span class="line">            System.out.println(string);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException,</span><br><span class="line">    NoSuchMethodException, InvocationTargetException, </span><br><span class="line">    InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        //获取字节码对象</span><br><span class="line">        Class clazz = Class.forName(&quot;cn.bytecollege.Msym&quot;);</span><br><span class="line">        //获取一个对象</span><br><span class="line">        Constructor con =  clazz.getConstructor();</span><br><span class="line">        Msym m = (Msym) con.newInstance();</span><br><span class="line">        String[] s = new String[]&#123;&quot;aa&quot;,&quot;bb&quot;&#125;;</span><br><span class="line">        //获取Method对象</span><br><span class="line">        Method method = clazz.getMethod(&quot;test&quot;, String[].class);</span><br><span class="line">        //调用invoke方法来调用</span><br><span class="line">        method.invoke(m, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取类包含的Field"><a href="#获取类包含的Field" class="headerlink" title="获取类包含的Field"></a>获取类包含的Field</h3><ul>
<li>Field getField(String name)：返回此Class对象对应类的指定public Field。</li>
<li>Field[]getFields()：返回此Class对象对应类的所有public Field。</li>
<li>Field getDeclaredField(String name)：返回此Class对象对应类的指定Field，与Field的访问权限无关。</li>
<li>Field[] getDeclaredFields()：返回此Class对象对应类的全部 Field，与Field的访问权限无关。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException,</span><br><span class="line">    SecurityException,IllegalArgumentException,IllegalAccessException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Byte&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> a.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> cl.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">s</span> <span class="operator">=</span> field.get(a);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        field.set(a, <span class="string">&quot;byte&quot;</span>);</span><br><span class="line">        s = field.get(a);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过Class对象的getFields()或getField()方法可以获取该类所包括的全部Field或指定Field。Field提供了如下两组方法来读取或设置Field值。</p>
<ul>
<li>getXxx(Object obj)：获取obj对象该Field的属性值。此处的Xxx对应8个基本类型，如果该属性的类型是引用类型，则取消get后面的Xxx。</li>
<li>setXxx(Object obj,Xxx val)：将obj对象的该Field设置成val值。此处的Xxx对应8个基本类型，如果该属性的类型是引用类型，则取消set后面的Xxx。</li>
</ul>
<h2 id="反射操作数组"><a href="#反射操作数组" class="headerlink" title="反射操作数组"></a>反射操作数组</h2><p>在java.lang.reflect包下还提供了一个Array类，Array对象可以代表所有的数组。程序可以通过使用Array来动态地创建数组，操作数组元素等。<br>Array提供了如下几类方法。</p>
<ul>
<li>static Object newInstance(Class&lt;?&gt;componentType,int…length)：创建一个具有指定的元素类型、指定维度的新数组。</li>
<li>static xxx getXxx(Object array,int index)：返回array数组中第index个元素。其中xxx是各种基本数据类型，如果数组元素是引用类型，则该方法变为get(Object array,int index)。</li>
<li>static void setXxx(Object array,int index,xxx val)：将array数组中第index个元素的值设为val。其中xxx是各种基本数据类型，如果数组元素是引用类型，则该方法变成set(Object array,int index,Object val)。</li>
</ul>
<p>下面程序示范了如何使用Array来生成数组，为指定数组元素赋值，并获取指定数组元素的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//创建一个元素类型为String，长度为10的数组</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">arr</span> <span class="operator">=</span> Array.newInstance(String.class,<span class="number">10</span>);</span><br><span class="line">            <span class="comment">//依次为arr数组中index为5、6的元素赋值</span></span><br><span class="line">            Array.set(arr,<span class="number">5</span>,<span class="string">&quot;Byte&quot;</span>);</span><br><span class="line">            Array.set(arr,<span class="number">6</span>,<span class="string">&quot;科技&quot;</span>);</span><br><span class="line">            <span class="comment">//依次取出arr数组中index为5、6的元素的值；</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">str1</span> <span class="operator">=</span> Array.get(arr,<span class="number">5</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">str2</span> <span class="operator">=</span> Array.get(arr,<span class="number">6</span>);</span><br><span class="line">            <span class="comment">//输出arr数组中index为5、6的元素</span></span><br><span class="line">            System.out.print(str1);</span><br><span class="line">            System.out.print(str2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>Java 5开始，Java增加了元数据（MetaData）的支持，也就是Annotation（注解），注解可以理解为代码里的特殊标识，这些标识可以在编译、类加载、运行时被读取，并进行相应的处理。通过Annotation，开发者可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。<br>Annotation是一个特殊的接口，程序可以通过反射来获取指定程序元素的Annotation对象，然后通过Annotation对象来取得注释里的元数据。</p>
<h3 id="基本Annotation"><a href="#基本Annotation" class="headerlink" title="基本Annotation"></a>基本Annotation</h3><p>Java提供的4个基本Annotation的用法——使用Annotation时要在其前面增加@符号，并把该Annotation当成一个修饰符使用，用于修饰它支持的程序元素。<br>4个基本的Annotation如下：</p>
<ol>
<li>@Override：用来指定方法重写的，它可以强制一个子类必须覆盖父类的方法。</li>
<li>@Deprecated：用于表示某个程序元素（类、方法等）已过时，当其他程序使用已过时的类、方法时，编译器将会给出警告。</li>
<li>@SuppressWarnings：指示被该Annotation修饰的程序元素（以及该程序元素中的所有子元素）取消显示指定的编译器警告。</li>
<li>@SafeVarargs：是Java 7专门为抑制“堆污染”警告提供的（了解）。</li>
</ol>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>JDK除了在java.lang下提供了4个基本的Annotation之外，还在java.lang.annotation包下提供了4个Meta Annotation（元Annotation），这4个元Annotation都用于修饰其他的Annotation定义。可以理解为在注解中使用的注解。</p>
<h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h4><p>@Retention只能用于修饰一个Annotation定义，用于指定被修饰的Annotation可以保留多长时间，@Retention包含一个RetentionPolicy类型的value成员变量，所以使用@Retention时必须为该value成员变量指定值。<br>value成员变量的值只能是如下3个。</p>
<ul>
<li>RetentionPolicy.CLASS：编译器将把Annotation记录在class文件中。当运行Java程序时，JVM不再保留Annotation。这是默认值。</li>
<li>RetentionPolicy.RUNTIME：编译器将把Annotation记录在class文件中。当运行Java程序时，JVM也会保留Annotation，程序可以通过反射获取该Annotation信息。</li>
<li>RetentionPolicy.SOURCE：Annotation只保留在源代码中，编译器直接丢弃这种Annotation。</li>
</ul>
<p>如果需要通过反射获取注释信息，就需要使用value属性值为RetentionPolicy.RUNTIME的@Retention。使用@Retention元数据Annotation可采用如下代码为value指定值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(value = RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果Annotation里只有一个value成员变量，使用该Annotation时可以直接在Annotation后的括号里指定value成员变量的值，无须使用name&#x3D;value的形式。查看元注解@Rentention源码可以发现@Rentention注解中只有一个value属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the retention policy.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the retention policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RetentionPolicy <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此在上例中的代码可以进行简写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h4><p>@Target也只能修饰一个Annotation定义，它用于指定被修饰的Annotation能用于修饰哪些程序单元。@Target元Annotation也包含一个名为value的成员变量，该成员变量的值只能是如下几个。</p>
<ul>
<li>ElementType.ANNOTATION_TYPE：指定该策略的Annotation只能修饰Annotation。</li>
<li>ElementType.CONSTRUCTOR：指定该策略的Annotation只能修饰构造器。</li>
<li>ElementType.FIELD：指定该策略的Annotation只能修饰成员变量。</li>
<li>ElementType.LOCAL_VARIABLE：指定该策略的Annotation只能修饰局部变量。</li>
<li>ElementType.METHOD：指定该策略的Annotation只能修饰方法定义。</li>
<li>ElementType.PACKAGE：指定该策略的Annotation只能修饰包定义。</li>
<li>ElementType.PARAMETER：指定该策略的Annotation可以修饰参数。</li>
<li>ElementType.TYPE：指定该策略的Annotation可以修饰类、接口（包括注释类型）或枚举定义。</li>
</ul>
<p>与使用@Retention类似的是，使用@Target也可以直接在括号里指定value值，而无须使用name&#x3D;value的形式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(value = RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h4><p>@Documented用于指定被该元Annotation修饰的Annotation类将被javadoc工具提取成文档，如果定义Annotation类时使用了@Documented修饰，则所有使用该Annotation修饰的程序元素的API文档中将会包含该Annotation说明。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(value = RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><p>@Inherited元Annotation指定被它修饰的Annotation将具有继承性——如果某个类使用了@A Annotation（定义该Annotation时使用了@Inherited修饰）修饰，则其子类将自动被@A修饰。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Inherited;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(value = RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>定义新的Annotation类型使用@interface关键字（在原有的interface关键字前增加@符号）定义一个新的Annotation类型与定义一个接口非常像，如下代码可定义一个简单的Annotation类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义了该Annotation之后，因为没有指定@Rentention，因此就可以在程序的任何地方使用该Annotation。在默认情况下，Annotation可用于修饰任何程序元素，包括类、接口、方法等。<br>Annotation不仅可以是这种简单的Annotation，还可以带成员变量，Annotation的成员变量在Annotation定义中以无形参的方法形式来声明，其方法名和返回值定义了该成员变量的名字和类型。如下代码可以定义一个有成员变量的Annotation。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnno&#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">age</span><span class="params">()</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦在Annotation里定义了成员变量之后，使用该Annotation时就应该为该Annotation的成员变量指定值，如下代码所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"><span class="meta">@MyAnno(name=&quot;张三&quot;,age=18)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以在定义Annotation的成员变量时为其指定初始值（默认值），指定成员变量的初始值可使用default关键字。如下代码定义了@MyAnno Annotation，该Annotation里包含了两个成员变量：name和age，这两个成员变量使用default指定了初始值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnno&#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">age</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">18</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果为Annotation的成员变量指定了默认值，使用该Annotation时则可以不为这些成员变量指定值，而是直接使用默认值。</p>
<h3 id="获取Annotation的信息"><a href="#获取Annotation的信息" class="headerlink" title="获取Annotation的信息"></a>获取Annotation的信息</h3><p>当开发者使用Annotation修饰了类、方法、Field等成员之后，这些Annotation不会自己生效，必须由开发者提供相应的工具来提取并处理Annotation信息。Java使用Annotation接口来代表程序元素前面的注释，该接口是所有Annotation类型的父接口。Java 5在java.lang.reflect包下新增了AnnotatedElement接口，该接口代表程序中可以接受注释的程序元素。该接口主要有如下几个实现类。</p>
<ul>
<li>Class：类定义。</li>
<li>Constructor：构造器定义。</li>
<li>Field：类的成员变量定义。</li>
<li>Method：类的方法定义。</li>
<li>Package：类的包定义。</li>
</ul>
<p>AnnotatedElement接口是所有程序元素（如Class、Method、Constructor等）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象（如Class、Method、Constructor等）之后，程序就可以调用该对象的如下3个方法来访问Annotation信息。</p>
<ul>
<li>getAnnotation(Class<T>annotationClass)：返回该程序元素上存在的指定类型的注释，如果该类型的注释不存在，则返回null。</li>
<li>Annotation[]getAnnotations()：返回该程序元素上存在的所有注释。</li>
<li>boolean isAnnotationPresent(Class&lt; ? extendsAnnotation&gt;annotationClass)：判断该程序元素上是否存在指定类型的注释，如果存在则返回true，否则返回false。</li>
</ul>
<h4 id="获取注解"><a href="#获取注解" class="headerlink" title="获取注解"></a>获取注解</h4><p>在下面的示例中，结合自定义注解，获取Class上的注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.anno;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetAnnotation</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, SecurityException &#123;</span><br><span class="line">		<span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Student.class;</span><br><span class="line">		<span class="comment">//获取类上的注解</span></span><br><span class="line">		Annotation[] annotations1 = clazz.getDeclaredAnnotations();</span><br><span class="line">		<span class="keyword">for</span> (Annotation annotation : annotations1) &#123;</span><br><span class="line">			System.out.println(annotation);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//获取成员变量上的注解</span></span><br><span class="line">		<span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">		Annotation[] annotations2 = field.getAnnotations();</span><br><span class="line">		<span class="keyword">for</span> (Annotation annotation : annotations2) &#123;</span><br><span class="line">			System.out.println(annotation);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//获取方法上的注解</span></span><br><span class="line">		Annotation[] annotations3 = clazz.getAnnotations();</span><br><span class="line">		<span class="keyword">for</span> (Annotation annotation : annotations3) &#123;</span><br><span class="line">			System.out.println(annotation);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Java虚拟机入门</title>
    <url>/2022/08/22/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<p>对于Java程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete&#x2F;free代码，不容易出现内存泄漏和内存溢出问题，看起来由虚拟机管理内存一切都很美好。不过，也正是因为Java程序员把控制内存的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那排查错误、修正问题将会成为一项异常艰难的工作。</p>
<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如下图所示。</p>
<p><img src="https://files.catbox.moe/zp9mu4.png"></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。<br>由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。<br>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。</p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。<br>局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。<br>这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）来表示，其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。请读者注意，这里说的“大小”是指变量槽的数量，虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特，或者更多）来实现一个变量槽，这是完全由具体的虚拟机实现自行决定的事情。<br>在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。<br>《Java虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机（譬如Hot-Spot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>对于Java应用程序来说，Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java世界里“几乎”所有的对象实例都在这里分配内存。在《Java虚拟机规范》中对Java堆的描述是：“所有的对象实例以及数组都应当在堆上分配”。<br>Java堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC堆”（Garbage Collected Heap，幸好国内没翻译成“垃圾堆”）。从回收内存的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以Java堆中经常会出现“新生代”“老年代”“永久代”“Eden空间”“From Survivor空间”“To Survivor空间”等名词。<br>根据《Java虚拟机规范》的规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。但对于大对象（典型的如数组对象），多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。虽然《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”（Non-Heap），目的是与Java堆区分开来。<br>《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域的确是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。<br>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。在JDK 1.4中新加入了NIO（New Input&#x2F;Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I&#x2F;O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p>
<h2 id="如何判断对象是垃圾"><a href="#如何判断对象是垃圾" class="headerlink" title="如何判断对象是垃圾"></a>如何判断对象是垃圾</h2><p>在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，需要做的一件事情就是要判断哪些对象是垃圾。</p>
<h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>引用计数算法是相对简单的一种算法，就是在对象中添加一个引用计数器，每当有一个地方引用该对象，则计数器加一；当对象不再被引用是，计数器值就减一。当一个对象的计数器为0时，这个对象就不能再被使用。也就可以判定为垃圾。<br>引用计数算法（Reference Counting）虽然占用了一些额外的内存空间来进行计数，但它的原理简单，判定效率也很高，Python语言中就采用了这种算法，但是这种算法有一个弊端：当两个对象互相引用时这两个对象的引用计数器值永远不会为0，这就意味着这两个对象即使没有其他地方引用了，也不会被回收。</p>
<h3 id="根可达性算法"><a href="#根可达性算法" class="headerlink" title="根可达性算法"></a>根可达性算法</h3><p>主流的编程语言的内存管理都通过根可达性分析算法来判断对象是否是垃圾。这个算法的基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，则证明此对象是不可能再被使用的。<br>如图所示，对象object 5、object 6、object 7虽然互有关联，但是它们到GCRoots是不可达的，因此它们将会被判定为可回收的对象。</p>
<p><img src="https://files.catbox.moe/e48iam.png"></p>
<p>在Java技术体系里面，固定可作为GC Roots的对象包括以下几种：</p>
<ul>
<li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</li>
<li>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。</li>
<li>在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。</li>
<li>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</li>
<li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</li>
<li>所有被同步锁（synchronized关键字）持有的对象。</li>
</ul>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>在JDK 1.2版之前，Java里面的引用是很传统的定义：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该reference数据是代表某块内存、某个对象的引用。<br>在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为强引用（StronglyRe-ference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。</p>
<ul>
<li>强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj&#x3D;new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</li>
<li>软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。</li>
<li>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。</li>
<li>虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。</li>
</ul>
<p>即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。<br>如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。<br>finalize()方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。</p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h3><p>最早出现也是最基础的垃圾收集算法是“标记-清除”（Mark-Sweep）算法，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。标记过程就是对象是否属于垃圾的判定过程。<br>它的主要缺点有两个：第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；第二个是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
<p><img src="https://files.catbox.moe/jzhkzk.png"></p>
<h3 id="标记复制算法"><a href="#标记复制算法" class="headerlink" title="标记复制算法"></a>标记复制算法</h3><p>标记-复制算法可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。这样实现简单，运行高效，不过其缺陷也显而易见，这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费多。</p>
<p><img src="https://files.catbox.moe/1zm9iv.png"></p>
<p>现在的商用Java虚拟机大多都优先采用了这种收集算法去回收新生代，IBM公司曾有一项专门研究对新生代“朝生夕灭”的特点做了更量化的诠释——新生代中的对象有98%熬不过第一轮收集。因此并不需要按照1∶1的比例来划分新生代的内存空间。<br>在1989年，Andrew Appel针对具备“朝生夕灭”特点的对象，提出了一种更优化的半区复制分代策略，现在称为“Appel式回收”。HotSpot虚拟机的Serial、ParNew等新生代收集器均采用了这种策略来设计新生代的内存布局[插图]。Appel式回收的具体做法是把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新生代容量的90%（Eden的80%加上一个Survivor的10%），只有一个Survivor空间，即10%的新生代是会被“浪费”的。</p>
<h3 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h3><p>“标记-整理”（Mark-Compact）算法，其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存，“标记-整理”算法的示意图如图所示。<br>标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。</p>
<p><img src="https://files.catbox.moe/qxs4m8.png"></p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。</p>
<h2 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器</h2><p>《Java虚拟机规范》中对垃圾收集器应该如何实现并没有做出任何规定，因此不同的厂商、不同版本的虚拟机所包含的垃圾收集器都可能会有很大差别，不同的虚拟机一般也都会提供各种参数供用户根据自己的应用特点和要求组合出各个内存分代所使用的收集器。</p>
<p><img src="https://files.catbox.moe/5rts2b.png"></p>
<p>上图展示了七种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用，图中收集器所处的区域，则表示它是属于新生代收集器抑或是老年代收集器。</p>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>Serial收集器是最基本、发展历史最悠久的收集器，曾经（在JDK 1.3.1之前）是虚拟机新生代收集的唯一选择。这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。Serial收集器是针对新生代的收集器，采用的是标记-复制算法，Serial Old收集器是针对老年代的收集器，采用的是标记-整理算法。它的优点是实现简单高效，但是缺点是会给用户带来停顿。</p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>ParNew收集器其实就是Serial收集器的多线程版本，除了Serial收集器外，目前只有它能与CMS收集器配合工作。</p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 &#x3D; 运行用户代码时间 &#x2F;（运行用户代码时间 +垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a><a href="http://192.168.31.254/java-advance/%E7%AC%AC20%E7%AB%A0%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%A5%E9%97%A8.html#parallel-old%E6%94%B6%E9%9B%86%E5%99%A8"></a>Parallel Old收集器</h3><p>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。这个收集器是在JDK 1.6中才开始提供的。</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B&#x2F;S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。CMS收集器是基于“标记—清除”算法实现的。</p>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1是一款面向服务端应用的垃圾收集器。HotSpot开发团队赋予它的使命是（在比较长期的）未来可以替换掉JDK 1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点。</p>
<ol>
<li>并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。</li>
<li>分代收集：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。</li>
<li>空间整合：与CMS的“标记—清理”算法不同，G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。</li>
<li>可预测的停顿：可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</li>
</ol>
<h3 id="JVM常用参数"><a href="#JVM常用参数" class="headerlink" title="JVM常用参数"></a>JVM常用参数</h3><table>
<thead>
<tr>
<th>参数名称</th>
<th>含义</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-Xms</td>
<td>初始堆大小</td>
<td>物理内存的1&#x2F;64(&lt;1GB)</td>
<td>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.</td>
</tr>
<tr>
<td>-Xmx</td>
<td>最大堆大小</td>
<td>物理内存的1&#x2F;4(&lt;1GB)</td>
<td>默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</td>
</tr>
<tr>
<td>-Xmn</td>
<td>年轻代大小(1.4or later)</td>
<td></td>
<td>注意：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。整个堆大小&#x3D;年轻代大小 + 老年代大小 + 持久代（永久代）大小.增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3&#x2F;8</td>
</tr>
<tr>
<td>-XX:NewSize</td>
<td>设置年轻代大小(for 1.3&#x2F;1.4)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-XX:MaxNewSize</td>
<td>年轻代最大值(for 1.3&#x2F;1.4)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-XX:PermSize</td>
<td>设置持久代(perm gen)初始值</td>
<td>物理内存的1&#x2F;64</td>
<td></td>
</tr>
<tr>
<td>-XX:MaxPermSize</td>
<td>设置持久代最大值</td>
<td>物理内存的1&#x2F;4</td>
<td></td>
</tr>
<tr>
<td>-Xss</td>
<td>每个线程的堆栈大小</td>
<td></td>
<td>JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.根据应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右一般小的应用， 如果栈不是很深， 应该是128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。（校长）和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:-Xss is translated in a VM flag named ThreadStackSize”一般设置这个值就可以了</td>
</tr>
<tr>
<td>-XX:NewRatio</td>
<td>年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)</td>
<td></td>
<td>-XX:NewRatio&#x3D;4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1&#x2F;5Xms&#x3D;Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</td>
</tr>
<tr>
<td>-XX:SurvivorRatio</td>
<td>Eden区与Survivor区的大小比值</td>
<td></td>
<td>设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1&#x2F;10</td>
</tr>
<tr>
<td>-XX:+DisableExplicitGC</td>
<td>关闭System.gc()</td>
<td></td>
<td>这个参数需要严格的测试</td>
</tr>
<tr>
<td>-XX:PretenureSizeThreshold</td>
<td>对象超过多大是直接在旧生代分配</td>
<td>0</td>
<td>单位字节 新生代采用Parallel ScavengeGC时无效另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象.</td>
</tr>
<tr>
<td>-XX:ParallelGCThreads</td>
<td>并行收集器的线程数</td>
<td></td>
<td>此值最好配置与处理器数目相等 同样适用于CMS</td>
</tr>
<tr>
<td>-XX:MaxGCPauseMillis</td>
<td>每次年轻代垃圾回收的最长时间(最大暂停时间)</td>
<td></td>
<td>如果无法满足此时间,JVM会自动调整年轻代大小,以满足此值.</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>Java面试重要知识点</title>
    <url>/2022/08/22/Java%E9%9D%A2%E8%AF%95%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h1 id="为什么-Java-中只有值传递？"><a href="#为什么-Java-中只有值传递？" class="headerlink" title="为什么 Java 中只有值传递？"></a>为什么 Java 中只有值传递？</h1><p>开始之前，我们先来搞懂下面这两个概念：</p>
<ul>
<li>形参&amp;实参</li>
<li>值传递&amp;引用传递</li>
</ul>
<h2 id="形参-amp-实参"><a href="#形参-amp-实参" class="headerlink" title="形参&amp;实参"></a>形参&amp;实参</h2><p>方法的定义可能会用到 <strong>参数</strong>（有参的方法），参数在程序语言中分为：</p>
<ul>
<li><strong>实参（实际参数）</strong> ：用于传递给函数&#x2F;方法的参数，必须有确定的值。</li>
<li><strong>形参（形式参数）</strong> ：用于定义函数&#x2F;方法，接收实参，不需要有确定的值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line"><span class="comment">// hello 为实参</span></span><br><span class="line">sayHello(hello);</span><br><span class="line"><span class="comment">// str 为形参</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="值传递-amp-引用传递"><a href="#值传递-amp-引用传递" class="headerlink" title="值传递&amp;引用传递"></a>值传递&amp;引用传递</h2><p>程序设计语言将实参传递给方法（或函数）的方式分为两种：</p>
<ul>
<li><strong>值传递</strong> ：方法接收的是实参值的拷贝，会创建副本。</li>
<li><strong>引用传递</strong> ：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。</li>
</ul>
<p>很多程序设计语言（比如 C++、 Pascal )提供了两种参数传递的方式，不过，在 Java 中只有值传递。</p>
<h2 id="为什么-Java-只有值传递？"><a href="#为什么-Java-只有值传递？" class="headerlink" title="为什么 Java 只有值传递？"></a>为什么 Java 只有值传递？</h2><p><strong>为什么说 Java 只有值传递呢？</strong> 不需要太多废话，我通过 3 个例子来给大家证明。</p>
<h3 id="案例1：传递基本类型参数"><a href="#案例1：传递基本类型参数" class="headerlink" title="案例1：传递基本类型参数"></a>案例1：传递基本类型参数</h3><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    swap(num1, num2);</span><br><span class="line">    System.out.println(<span class="string">&quot;num1 = &quot;</span> + num1);</span><br><span class="line">    System.out.println(<span class="string">&quot;num2 = &quot;</span> + num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">    System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">    System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a = <span class="number">20</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line">num1 = <span class="number">10</span></span><br><span class="line">num2 = <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p>在 <code>swap()</code> 方法中，<code>a</code>、<code>b</code> 的值进行交换，并不会影响到 <code>num1</code>、<code>num2</code>。因为，<code>a</code>、<code>b</code> 的值，只是从 <code>num1</code>、<code>num2</code> 的复制过来的。也就是说，a、b 相当于 <code>num1</code>、<code>num2</code> 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p>
<p><img src="https://files.catbox.moe/bv4h6y.png"></p>
<p>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看案例2。</p>
<h3 id="案例2：传递引用类型参数1"><a href="#案例2：传递引用类型参数1" class="headerlink" title="案例2：传递引用类型参数1"></a>案例2：传递引用类型参数1</h3><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">     System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">     change(arr);</span><br><span class="line">     System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">     <span class="comment">// 将数组的第一个元素变为0</span></span><br><span class="line">     array[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p><img src="https://files.catbox.moe/0e4fc7.png"></p>
<p>看了这个案例很多人肯定觉得 Java 对引用类型的参数采用的是引用传递。</p>
<p>实际上，并不是的，这里传递的还是值，不过，这个值是实参的地址罢了！</p>
<p>也就是说 <code>change</code> 方法的参数拷贝的是 <code>arr</code> （实参）的地址，因此，它和 <code>arr</code> 指向的是同一个数组对象。这也就说明了为什么方法内部对形参的修改会影响到实参。</p>
<p>为了更强有力地反驳 Java 对引用类型的参数采用的不是引用传递，我们再来看下面这个案例！</p>
<h3 id="案例3-：传递引用类型参数2"><a href="#案例3-：传递引用类型参数2" class="headerlink" title="案例3 ：传递引用类型参数2"></a>案例3 ：传递引用类型参数2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">xiaoZhang</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小张&quot;</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">xiaoLi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小李&quot;</span>);</span><br><span class="line">    swap(xiaoZhang, xiaoLi);</span><br><span class="line">    System.out.println(<span class="string">&quot;xiaoZhang:&quot;</span> + xiaoZhang.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;xiaoLi:&quot;</span> + xiaoLi.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Person person1, Person person2)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">temp</span> <span class="operator">=</span> person1;</span><br><span class="line">    person1 = person2;</span><br><span class="line">    person2 = temp;</span><br><span class="line">    System.out.println(<span class="string">&quot;person1:&quot;</span> + person1.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;person2:&quot;</span> + person2.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">person1:小李</span><br><span class="line">person2:小张</span><br><span class="line">xiaoZhang:小张</span><br><span class="line">xiaoLi:小李</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p>怎么回事？？？两个引用类型的形参互换并没有影响实参啊！</p>
<p><code>swap</code> 方法的参数 <code>person1</code> 和 <code>person2</code> 只是拷贝的实参 <code>xiaoZhang</code> 和 <code>xiaoLi</code> 的地址。因此， <code>person1</code> 和 <code>person2</code> 的互换只是拷贝的两个地址的互换罢了，并不会影响到实参 <code>xiaoZhang</code> 和 <code>xiaoLi</code> 。</p>
<p><img src="https://files.catbox.moe/dksq1v.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java 中将实参传递给方法（或函数）的方式是 <strong>值传递</strong> ：</p>
<ul>
<li>如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。</li>
<li>如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。</li>
</ul>
<h1 id="Java-序列化详解"><a href="#Java-序列化详解" class="headerlink" title="Java 序列化详解"></a>Java 序列化详解</h1><h2 id="序列化和反序列化相关概念"><a href="#序列化和反序列化相关概念" class="headerlink" title="序列化和反序列化相关概念"></a>序列化和反序列化相关概念</h2><h3 id="什么是序列化-什么是反序列化"><a href="#什么是序列化-什么是反序列化" class="headerlink" title="#什么是序列化?什么是反序列化?"></a><a href="https://javaguide.cn/java/basis/serialization.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96">#</a>什么是序列化?什么是反序列化?</h3><p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p>
<p>简单来说：</p>
<ul>
<li><strong>序列化</strong>： 将数据结构或对象转换成二进制字节流的过程</li>
<li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流的过程转换成数据结构或者对象的过程</li>
</ul>
<p>对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。</p>
<p>维基百科是如是介绍序列化的：</p>
<blockquote>
<p><strong>序列化</strong>（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。</p>
</blockquote>
<p>综上：<strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p>
<p><img src="https://files.catbox.moe/o4wwwq.png"></p>
<h3 id="实际开发中有哪些用到序列化和反序列化的场景？"><a href="#实际开发中有哪些用到序列化和反序列化的场景？" class="headerlink" title="实际开发中有哪些用到序列化和反序列化的场景？"></a>实际开发中有哪些用到序列化和反序列化的场景？</h3><ol>
<li>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li>
<li>将对象存储到文件中的时候需要进行序列化，将对象从文件中读取出来需要进行反序列化。</li>
<li>将对象存储到缓存数据库（如 Redis）时需要用到序列化，将对象从缓存数据库中读取出来需要反序列化。</li>
</ol>
<h3 id="序列化协议对应于-TCP-x2F-IP-4-层模型的哪一层？"><a href="#序列化协议对应于-TCP-x2F-IP-4-层模型的哪一层？" class="headerlink" title="#序列化协议对应于 TCP&#x2F;IP 4 层模型的哪一层？"></a><a href="https://javaguide.cn/java/basis/serialization.html#%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE%E5%AF%B9%E5%BA%94%E4%BA%8E-tcp-ip-4-%E5%B1%82%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%93%AA%E4%B8%80%E5%B1%82">#</a>序列化协议对应于 TCP&#x2F;IP 4 层模型的哪一层？</h3><p>我们知道网络通信的双方必须要采用和遵守相同的协议。TCP&#x2F;IP 四层模型是下面这样的，序列化协议属于哪一层呢？</p>
<ol>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>网络接口层</li>
</ol>
<p><img src="https://files.catbox.moe/90tg58.png"></p>
<p>如上图所示，OSI 七层协议模型中，表示层做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据。这不就对应的是序列化和反序列化么？</p>
<p>因为，OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP&#x2F;IP 四层模型中的应用层，所以序列化协议属于 TCP&#x2F;IP 协议应用层的一部分。</p>
<h2 id="常见序列化协议对比"><a href="#常见序列化协议对比" class="headerlink" title="常见序列化协议对比"></a>常见序列化协议对比</h2><p>JDK 自带的序列化方式一般不会用 ，因为序列化效率低并且部分版本有安全漏洞。比较常用的序列化协议有 hessian、kyro、protostuff。</p>
<p>下面提到的都是基于二进制的序列化协议，像 JSON 和 XML 这种属于文本类序列化方式。虽然 JSON 和 XML 可读性比较好，但是性能较差，一般不会选择。</p>
<h3 id="JDK-自带的序列化方式"><a href="#JDK-自带的序列化方式" class="headerlink" title="JDK 自带的序列化方式"></a>JDK 自带的序列化方式</h3><p>JDK 自带的序列化，只需实现 <code>java.io.Serializable</code>接口即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcRequest</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1905122041950251207L</span>;</span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="keyword">private</span> Object[] parameters;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] paramTypes;</span><br><span class="line">    <span class="keyword">private</span> RpcMessageTypeEnum rpcMessageTypeEnum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>序列化号 serialVersionUID 属于版本控制的作用。序列化的时候 serialVersionUID 也会被写入二级制序列，当反序列化时会检查 serialVersionUID 是否和当前类的 serialVersionUID 一致。如果 serialVersionUID 不一致则会抛出 <code>InvalidClassException</code> 异常。强烈推荐每个序列化类都手动指定其 <code>serialVersionUID</code>，如果不手动指定，那么编译器会动态生成默认的序列化号</p>
</blockquote>
<p>我们很少或者说几乎不会直接使用这个序列化方式，主要原因有两个：</p>
<ol>
<li><strong>不支持跨语言调用</strong> : 如果调用的是其他语言开发的服务的时候就不支持了。</li>
<li><strong>性能差</strong> ：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li>
</ol>
<h3 id="Kryo"><a href="#Kryo" class="headerlink" title="Kryo"></a>Kryo</h3><p>Kryo 是一个高性能的序列化&#x2F;反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。</p>
<p>另外，Kryo 已经是一种非常成熟的序列化实现了，已经在 Twitter、Groupon、Yahoo 以及多个著名开源项目（如 Hive、Storm）中广泛的使用。</p>
<p><a href="https://github.com/Snailclimb/guide-rpc-framework">guide-rpc-frameworkopen in new window</a> 就是使用的 kyro 进行序列化，序列化和反序列化相关的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Kryo serialization class, Kryo serialization efficiency is very high, but only compatible with Java language</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020年05月13日 19:29:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KryoSerializer</span> <span class="keyword">implements</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Because Kryo is not thread safe. So, use ThreadLocal to store Kryo objects</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Kryo&gt; kryoThreadLocal = ThreadLocal.withInitial(() -&gt; &#123;</span><br><span class="line">        <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kryo</span>();</span><br><span class="line">        kryo.register(RpcResponse.class);</span><br><span class="line">        kryo.register(RpcRequest.class);</span><br><span class="line">        <span class="keyword">return</span> kryo;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] serialize(Object obj) &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">             <span class="type">Output</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Output</span>(byteArrayOutputStream)) &#123;</span><br><span class="line">            <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> kryoThreadLocal.get();</span><br><span class="line">            <span class="comment">// Object-&gt;byte:将对象序列化为byte数组</span></span><br><span class="line">            kryo.writeObject(output, obj);</span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            <span class="keyword">return</span> output.toBytes();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Serialization failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(<span class="type">byte</span>[] bytes, Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">             <span class="type">Input</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Input</span>(byteArrayInputStream)) &#123;</span><br><span class="line">            <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> kryoThreadLocal.get();</span><br><span class="line">            <span class="comment">// byte-&gt;Object:从byte数组中反序列化出对对象</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> kryo.readObject(input, clazz);</span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            <span class="keyword">return</span> clazz.cast(o);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Deserialization failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h3><p>Protobuf 出自于 Google，性能还比较优秀，也支持多种语言，同时还是跨平台的。就是在使用中过于繁琐，因为你需要自己定义 IDL 文件和生成对应的序列化代码。这样虽然不然灵活，但是，另一方面导致 protobuf 没有序列化漏洞的风险。</p>
<blockquote>
<p>Protobuf 包含序列化格式的定义、各种语言的库以及一个 IDL 编译器。正常情况下你需要定义 proto 文件，然后使用 IDL 编译器编译成你需要的语言</p>
</blockquote>
<p>一个简单的 proto 文件如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// protobuf的版本</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="comment">// SearchRequest会被编译成不同的编程语言的相应对象，比如Java中的class、Go中的struct</span></span><br><span class="line">message Person &#123;</span><br><span class="line">  <span class="comment">//string类型字段</span></span><br><span class="line">  <span class="type">string</span> <span class="variable">name</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// int 类型字段</span></span><br><span class="line">  <span class="type">int32</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ProtoStuff"><a href="#ProtoStuff" class="headerlink" title="ProtoStuff"></a>ProtoStuff</h3><p>由于 Protobuf 的易用性，它的哥哥 Protostuff 诞生了。</p>
<p>protostuff 基于 Google protobuf，但是提供了更多的功能和更简易的用法。虽然更加易用，但是不代表 ProtoStuff 性能更差。</p>
<h3 id="hessian"><a href="#hessian" class="headerlink" title="hessian"></a>hessian</h3><p>hessian 是一个轻量级的,自定义描述的二进制 RPC 协议。hessian 是一个比较老的序列化实现了，并且同样也是跨语言的。</p>
<p><img src="https://files.catbox.moe/23r9k6.png"></p>
<p>dubbo RPC 默认启用的序列化方式是 hessian2 ,但是，Dubbo 对 hessian2 进行了修改，不过大体结构还是差不多。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Kryo 是专门针对 Java 语言序列化方式并且性能非常好，如果你的应用是专门针对 Java 语言的话可以考虑使用，并且 Dubbo 官网的一篇文章中提到说推荐使用 Kryo 作为生产环境的序列化方式。(文章地址：<a href="https://dubbo.apache.org/zh/docs/v2.7/user/references/protocol/rest/">https://dubbo.apache.org/zh/docs/v2.7/user/references/protocol/rest/open in new window</a>)</p>
<p><img src="https://files.catbox.moe/w7gdx4.png"></p>
<p>像 Protobuf、 ProtoStuff、hessian 这类都是跨语言的序列化方式，如果有跨语言需求的话可以考虑使用。</p>
<p>除了我上面介绍到的序列化方式的话，还有像 Thrift，Avro 这些。</p>
<h1 id="Java-反射机制详解"><a href="#Java-反射机制详解" class="headerlink" title="Java 反射机制详解"></a>Java 反射机制详解</h1><h2 id="何为反射？"><a href="#何为反射？" class="headerlink" title="何为反射？"></a>何为反射？</h2><p>如果说大家研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。</p>
<p>反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。</p>
<p>通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</p>
<h2 id="反射的应用场景了解么？"><a href="#反射的应用场景了解么？" class="headerlink" title="反射的应用场景了解么？"></a>反射的应用场景了解么？</h2><p>像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。</p>
<p>但是，这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring&#x2F;Spring Boot、MyBatis 等等框架中都大量使用了反射机制。</p>
<p><strong>这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。</strong></p>
<p>比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 <code>Method</code> 来调用指定的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类中的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DebugInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，像 Java 中的一大利器 <strong>注解</strong> 的实现也用到了反射。</p>
<p>为什么你使用 Spring 的时候 ，一个<code>@Component</code>注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 <code>@Value</code>注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？</p>
<p>这些都是因为你可以基于反射分析类，然后获取到类&#x2F;属性&#x2F;方法&#x2F;方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。</p>
<h2 id="谈谈反射机制的优缺点"><a href="#谈谈反射机制的优缺点" class="headerlink" title="谈谈反射机制的优缺点"></a>谈谈反射机制的优缺点</h2><p><strong>优点</strong> ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</p>
<p><strong>缺点</strong> ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。相关阅读：<a href="https://stackoverflow.com/questions/1392351/java-reflection-why-is-it-so-slow">Java Reflection: Why is it so slow?open in new window</a></p>
<h2 id="反射实战"><a href="#反射实战" class="headerlink" title="反射实战"></a>反射实战</h2><h3 id="获取-Class-对象的四种方式"><a href="#获取-Class-对象的四种方式" class="headerlink" title="获取 Class 对象的四种方式"></a>获取 Class 对象的四种方式</h3><p>如果我们动态获取到这些信息，我们需要依靠 Class 对象。Class 类对象将一个类的方法、变量等信息告诉运行的程序。Java 提供了四种方式获取 Class 对象:</p>
<p><strong>1. 知道具体类的情况下可以使用：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass</span> <span class="operator">=</span> TargetObject.class;</span><br></pre></td></tr></table></figure>

<p>但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方式获取 Class 对象不会进行初始化</p>
<p><strong>2. 通过 Class.forName()传入类的全路径获取：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>3. 通过对象实例instance.getClass()获取：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TargetObject</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TargetObject</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass2</span> <span class="operator">=</span> o.getClass();</span><br></pre></td></tr></table></figure>

<p><strong>4. 通过类加载器xxxClassLoader.loadClass()传入类路径获取:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>通过类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一系列步骤，静态代码块和静态对象不会得到执行</p>
<h3 id="反射的一些基本操作"><a href="#反射的一些基本操作" class="headerlink" title="反射的一些基本操作"></a>反射的一些基本操作</h3><ol>
<li>创建一个我们要使用反射操作的类 <code>TargetObject</code>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javaguide;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TargetObject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TargetObject</span><span class="params">()</span> &#123;</span><br><span class="line">        value = <span class="string">&quot;JavaGuide&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publicMethod</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I love &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">privateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;value is &quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用反射操作这个类的方法以及参数</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javaguide;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchFieldException &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取 TargetObject 类的 Class 对象并且创建 TargetObject 类实例</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class&lt;?&gt; targetClass = Class.forName(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br><span class="line">        <span class="type">TargetObject</span> <span class="variable">targetObject</span> <span class="operator">=</span> (TargetObject) targetClass.newInstance();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取 TargetObject 类中定义的所有方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Method[] methods = targetClass.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(method.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取指定方法并调用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">publicMethod</span> <span class="operator">=</span> targetClass.getDeclaredMethod(<span class="string">&quot;publicMethod&quot;</span>,</span><br><span class="line">                String.class);</span><br><span class="line"></span><br><span class="line">        publicMethod.invoke(targetObject, <span class="string">&quot;JavaGuide&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取指定参数并对参数进行修改</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> targetClass.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">        <span class="comment">//为了对类中的参数进行修改我们取消安全检查</span></span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(targetObject, <span class="string">&quot;JavaGuide&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用 private 方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">privateMethod</span> <span class="operator">=</span> targetClass.getDeclaredMethod(<span class="string">&quot;privateMethod&quot;</span>);</span><br><span class="line">        <span class="comment">//为了调用private方法我们取消安全检查</span></span><br><span class="line">        privateMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        privateMethod.invoke(targetObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">publicMethod</span><br><span class="line">privateMethod</span><br><span class="line">I love JavaGuide</span><br><span class="line">value is JavaGuide</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> : 有读者提到上面代码运行会抛出 <code>ClassNotFoundException</code> 异常,具体原因是你没有下面把这段代码的包名替换成自己创建的 <code>TargetObject</code> 所在的包 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; targetClass = Class.forName(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="Java-代理模式详解"><a href="#Java-代理模式详解" class="headerlink" title="Java 代理模式详解"></a>Java 代理模式详解</h1><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式是一种比较好理解的设计模式。简单来说就是 <strong>我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</strong></p>
<p><strong>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。</strong></p>
<p>举个例子：新娘找来了自己的姨妈来代替自己处理新郎的提问，新娘收到的提问都是经过姨妈处理过滤之后的。姨妈在这里就可以看作是代理你的代理对象，代理的行为（方法）是接收和回复新郎的提问。</p>
<p><img src="https://files.catbox.moe/av210c.png"></p>
<p>代理模式有静态代理和动态代理两种实现方式，我们 先来看一下静态代理模式的实现。</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p><strong>静态代理中，我们对目标对象的每个方法的增强都是手动完成的（后面会具体演示代码），非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改）且麻烦(需要对每个目标类都单独写一个代理类)。</strong> 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。</p>
<p>上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， <strong>静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</strong></p>
<p>静态代理实现步骤:</p>
<ol>
<li>定义一个接口及其实现类；</li>
<li>创建一个代理类同样实现这个接口</li>
<li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li>
</ol>
<p>下面通过代码展示！</p>
<p><strong>1.定义发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    String <span class="title function_">send</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.创建代理类并同样实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsProxy</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SmsService smsService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmsProxy</span><span class="params">(SmsService smsService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.smsService = smsService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method send()&quot;</span>);</span><br><span class="line">        smsService.send(message);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method send()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.实际使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SmsService</span> <span class="variable">smsService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsServiceImpl</span>();</span><br><span class="line">        <span class="type">SmsProxy</span> <span class="variable">smsProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsProxy</span>(smsService);</span><br><span class="line">        smsProxy.send(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上述代码之后，控制台打印出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">before method <span class="title function_">send</span><span class="params">()</span></span><br><span class="line">send message:java</span><br><span class="line">after method <span class="title function_">send</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<p>可以输出结果看出，我们已经增加了 <code>SmsServiceImpl</code> 的<code>send()</code>方法。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( <em>CGLIB 动态代理机制</em>)。</p>
<p><strong>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</strong></p>
<p>说到动态代理，Spring AOP、RPC 框架应该是两个不得不提的，它们的实现都依赖了动态代理。</p>
<p><strong>动态代理在我们日常开发中使用的相对较少，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。</strong></p>
<p>就 Java 来说，动态代理的实现方式有很多种，比如 <strong>JDK 动态代理</strong>、<strong>CGLIB 动态代理</strong>等等。</p>
<p><a href="https://github.com/Snailclimb/guide-rpc-framework">guide-rpc-frameworkopen in new window</a> 使用的是 JDK 动态代理，我们先来看看 JDK 动态代理的使用。</p>
<p>另外，虽然 <a href="https://github.com/Snailclimb/guide-rpc-framework">guide-rpc-frameworkopen in new window</a> 没有用到 <strong>CGLIB 动态代理</strong> ，我们这里还是简单介绍一下其使用以及和<strong>JDK 动态代理</strong>的对比。</p>
<h3 id="JDK-动态代理机制"><a href="#JDK-动态代理机制" class="headerlink" title="JDK 动态代理机制"></a>JDK 动态代理机制</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><strong>在 Java 动态代理机制中 InvocationHandler 接口和 Proxy 类是核心。</strong></p>
<p><code>Proxy</code> 类中使用频率最高的方法是：<code>newProxyInstance()</code> ，这个方法主要用来生成一个代理对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">                                      InvocationHandler h)</span></span><br><span class="line">    <span class="keyword">throws</span> IllegalArgumentException</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法一共有 3 个参数：</p>
<ol>
<li><strong>loader</strong> :类加载器，用于加载代理对象。</li>
<li><strong>interfaces</strong> : 被代理类实现的一些接口；</li>
<li><strong>h</strong> : 实现了 <code>InvocationHandler</code> 接口的对象；</li>
</ol>
<p>要实现动态代理的话，还必须需要实现<code>InvocationHandler</code> 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时，这个方法的调用就会被转发到实现<code>InvocationHandler</code> 接口类的 <code>invoke</code> 方法来调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当你使用代理对象调用方法的时候实际会调用到这个方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>invoke()</code> 方法有下面三个参数：</p>
<ol>
<li><strong>proxy</strong> :动态生成的代理类</li>
<li><strong>method</strong> : 与代理类对象调用的方法相对应</li>
<li><strong>args</strong> : 当前 method 方法的参数</li>
</ol>
<p>也就是说：<strong>你通过Proxy 类的 newProxyInstance() 创建的代理对象在调用方法的时候，实际会调用到实现InvocationHandler 接口的类的 invoke()方法。</strong> 你可以在 <code>invoke()</code> 方法中自定义处理逻辑，比如在方法执行前后做什么事情。</p>
<h4 id="JDK-动态代理类使用步骤"><a href="#JDK-动态代理类使用步骤" class="headerlink" title="JDK 动态代理类使用步骤"></a>JDK 动态代理类使用步骤</h4><ol>
<li>定义一个接口及其实现类；</li>
<li>自定义 <code>InvocationHandler</code> 并重写<code>invoke</code>方法，在 <code>invoke</code> 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li>
<li>通过 <code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code> 方法创建代理对象；</li>
</ol>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><p>这样说可能会有点空洞和难以理解，我上个例子，大家感受一下吧！</p>
<p><strong>1.定义发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    String <span class="title function_">send</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.定义一个 JDK 动态代理类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020年05月11日 11:23:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类中的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DebugInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>invoke()</code> 方法: 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是 <code>invoke()</code> 方法，然后 <code>invoke()</code> 方法代替我们去调用了被代理对象的原生方法。</p>
<p><strong>4.获取代理对象的工厂类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(), <span class="comment">// 目标类的类加载</span></span><br><span class="line">                target.getClass().getInterfaces(),  <span class="comment">// 代理需要实现的接口，可指定多个</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DebugInvocationHandler</span>(target)   <span class="comment">// 代理对象对应的自定义 InvocationHandler</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getProxy()</code> ：主要通过<code>Proxy.newProxyInstance（）</code>方法获取某个类的代理对象</p>
<p><strong>5.实际使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SmsService</span> <span class="variable">smsService</span> <span class="operator">=</span> (SmsService) JdkProxyFactory.getProxy(<span class="keyword">new</span> <span class="title class_">SmsServiceImpl</span>());</span><br><span class="line">smsService.send(<span class="string">&quot;java&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>运行上述代码之后，控制台打印出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">before method send</span><br><span class="line">send message:java</span><br><span class="line">after method send</span><br></pre></td></tr></table></figure>

<h3 id="CGLIB-动态代理机制"><a href="#CGLIB-动态代理机制" class="headerlink" title="CGLIB 动态代理机制"></a>CGLIB 动态代理机制</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p><strong>JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。</strong></p>
<p><strong>为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。</strong></p>
<p><a href="https://github.com/cglib/cglib">CGLIBopen in new window</a>(<em>Code Generation Library</em>)是一个基于<a href="http://www.baeldung.com/java-asm">ASMopen in new window</a>的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了<a href="https://github.com/cglib/cglib">CGLIBopen in new window</a>， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p>
<p><strong>在 CGLIB 动态代理机制中 MethodInterceptor 接口和 Enhancer 类是核心。</strong></p>
<p>你需要自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MethodInterceptor</span></span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">Callback</span>&#123;</span><br><span class="line">    <span class="comment">// 拦截被代理类中的方法</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, java.lang.reflect.Method method, Object[] args,MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>obj</strong> : 动态生成的代理对象</li>
<li><strong>method</strong> : 被拦截的方法（需要增强的方法）</li>
<li><strong>args</strong> : 方法入参</li>
<li><strong>proxy</strong> : 用于调用原始方法</li>
</ol>
<p>你可以通过 <code>Enhancer</code>类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 <code>MethodInterceptor</code> 中的 <code>intercept</code> 方法。</p>
<h4 id="CGLIB-动态代理类使用步骤"><a href="#CGLIB-动态代理类使用步骤" class="headerlink" title="CGLIB 动态代理类使用步骤"></a>CGLIB 动态代理类使用步骤</h4><ol>
<li>定义一个类；</li>
<li>自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法，和 JDK 动态代理中的 <code>invoke</code> 方法类似；</li>
<li>通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类；</li>
</ol>
<h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><p>不同于 JDK 动态代理不需要额外的依赖。<a href="https://github.com/cglib/cglib">CGLIBopen in new window</a>(<em>Code Generation Library</em>) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">3.3</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>1.实现一个使用阿里云发送短信的类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> github.javaguide.dynamicProxy.cglibDynamicProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliSmsService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.自定义 MethodInterceptor（方法拦截器）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义MethodInterceptor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o           代理对象（增强的对象）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method      被拦截的方法（需要增强的方法）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args        方法入参</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 用于调用原始方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> methodProxy.invokeSuper(o, args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.获取代理类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建动态代理增强类</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">// 设置类加载器</span></span><br><span class="line">        enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class="line">        <span class="comment">// 设置被代理类</span></span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        <span class="comment">// 设置方法拦截器</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">DebugMethodInterceptor</span>());</span><br><span class="line">        <span class="comment">// 创建代理类</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.实际使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AliSmsService</span> <span class="variable">aliSmsService</span> <span class="operator">=</span> (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);</span><br><span class="line">aliSmsService.send(<span class="string">&quot;java&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>运行上述代码之后，控制台打印出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">before method send</span><br><span class="line">send message:java</span><br><span class="line">after method send</span><br></pre></td></tr></table></figure>

<h3 id="JDK-动态代理和-CGLIB-动态代理对比"><a href="#JDK-动态代理和-CGLIB-动态代理对比" class="headerlink" title="JDK 动态代理和 CGLIB 动态代理对比"></a>JDK 动态代理和 CGLIB 动态代理对比</h3><ol>
<li><strong>JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。</strong> 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</li>
<li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</li>
</ol>
<h2 id="静态代理和动态代理的对比"><a href="#静态代理和动态代理的对比" class="headerlink" title="静态代理和动态代理的对比"></a>静态代理和动态代理的对比</h2><ol>
<li><strong>灵活性</strong> ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li>
<li><strong>JVM 层面</strong> ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li>
</ol>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>这篇文章中主要介绍了代理模式的两种实现：静态代理以及动态代理。涵盖了静态代理和动态代理实战、静态代理和动态代理的区别、JDK 动态代理和 Cglib 动态代理区别等内容。</p>
<p>文中涉及到的所有源码，你可以在这里找到：<a href="https://github.com/Snailclimb/guide-rpc-framework-learning/tree/master/src/main/java/github/javaguide/proxy">https://github.com/Snailclimb/guide-rpc-framework-learning/tree/master/src/main/java/github/javaguide/proxyopen in new window</a> 。</p>
<h1 id="BigDecimal-详解"><a href="#BigDecimal-详解" class="headerlink" title="BigDecimal 详解"></a>BigDecimal 详解</h1><p>《阿里巴巴 Java 开发手册》中提到：“为了避免精度丢失，可以使用 <code>BigDecimal</code> 来进行浮点数的运算”。</p>
<p>浮点数的运算竟然还会有精度丢失的风险吗？确实会！</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float a = 2.0f - 1.9f;</span><br><span class="line">float b = 1.8f - 1.7f;</span><br><span class="line">System.out.println(a);// 0.100000024</span><br><span class="line">System.out.println(b);// 0.099999905</span><br><span class="line">System.out.println(a == b);// false</span><br></pre></td></tr></table></figure>

<p><strong>为什么浮点数 float 或 double 运算的时候会有精度丢失的风险呢？</strong></p>
<p>这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。</p>
<p>就比如说十进制下的 0.2 就没办法精确转换成二进制小数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，</span></span><br><span class="line"><span class="comment">// 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">0.4</span> * <span class="number">2</span> = <span class="number">0.8</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">0.8</span> * <span class="number">2</span> = <span class="number">1.6</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">0.6</span> * <span class="number">2</span> = <span class="number">1.2</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span> -&gt; <span class="number">0</span>（发生循环）</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>关于浮点数的更多内容，建议看一下<a href="http://kaito-kidd.com/2018/08/08/computer-system-float-point/">计算机系统基础（四）浮点数open in new window</a>这篇文章。</p>
<h2 id="BigDecimal-介绍"><a href="#BigDecimal-介绍" class="headerlink" title="BigDecimal 介绍"></a>BigDecimal 介绍</h2><p><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。</p>
<p>通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 <code>BigDecimal</code> 来做的。</p>
<p>《阿里巴巴 Java 开发手册》中提到：<strong>浮点数之间的等值判断，基本数据类型不能用 &#x3D;&#x3D; 来比较，包装数据类型不能用 equals 来判断。</strong></p>
<p><img src="https://files.catbox.moe/u5cfgc.png"></p>
<p>具体原因我们在上面已经详细介绍了，这里就不多提了。</p>
<p>想要解决浮点数运算精度丢失这个问题，可以直接使用 <code>BigDecimal</code> 来定义浮点数的值，然后再进行浮点数的运算操作即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.subtract(b);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> b.subtract(c);</span><br><span class="line"></span><br><span class="line">System.out.println(x.compareTo(y));<span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h2 id="BigDecimal-常见方法"><a href="#BigDecimal-常见方法" class="headerlink" title="BigDecimal 常见方法"></a>BigDecimal 常见方法</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>我们在使用 <code>BigDecimal</code> 时，为了防止精度丢失，推荐使用它的<code>BigDecimal(String val)</code>构造方法或者 <code>BigDecimal.valueOf(double val)</code> 静态方法来创建对象。</p>
<p>《阿里巴巴 Java 开发手册》对这部分内容也有提到，如下图所示。</p>
<p><img src="https://files.catbox.moe/9yulce.png"></p>
<h3 id="加减乘除"><a href="#加减乘除" class="headerlink" title="加减乘除"></a>加减乘除</h3><p><code>add</code> 方法用于将两个 <code>BigDecimal</code> 对象相加，<code>subtract</code> 方法用于将两个 <code>BigDecimal</code> 对象相减。<code>multiply</code> 方法用于将两个 <code>BigDecimal</code> 对象相乘，<code>divide</code> 方法用于将两个 <code>BigDecimal</code> 对象相除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">System.out.println(a.add(b));<span class="comment">// 1.9</span></span><br><span class="line">System.out.println(a.subtract(b));<span class="comment">// 0.1</span></span><br><span class="line">System.out.println(a.multiply(b));<span class="comment">// 0.90</span></span><br><span class="line">System.out.println(a.divide(b));<span class="comment">// 无法除尽，抛出 ArithmeticException 异常</span></span><br><span class="line">System.out.println(a.divide(b, <span class="number">2</span>, RoundingMode.HALF_UP));<span class="comment">// 1.11</span></span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，在我们使用 <code>divide</code> 方法的时候尽量使用 3 个参数版本，并且<code>RoundingMode</code> 不要选择 <code>UNNECESSARY</code>，否则很可能会遇到 <code>ArithmeticException</code>（无法除尽出现无限循环小数的时候），其中 <code>scale</code> 表示要保留几位小数，<code>roundingMode</code> 代表保留规则。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">divide</span><span class="params">(BigDecimal divisor, <span class="type">int</span> scale, RoundingMode roundingMode)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> divide(divisor, scale, roundingMode.oldMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保留规则非常多，这里列举几种:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RoundingMode</span> &#123;</span><br><span class="line">   <span class="comment">// 2.5 -&gt; 3 , 1.6 -&gt; 2</span></span><br><span class="line">   <span class="comment">// -1.6 -&gt; -2 , -2.5 -&gt; -3</span></span><br><span class="line">			 UP(BigDecimal.ROUND_UP),</span><br><span class="line">   <span class="comment">// 2.5 -&gt; 2 , 1.6 -&gt; 1</span></span><br><span class="line">   <span class="comment">// -1.6 -&gt; -1 , -2.5 -&gt; -2</span></span><br><span class="line">			 DOWN(BigDecimal.ROUND_DOWN),</span><br><span class="line">			 <span class="comment">// 2.5 -&gt; 3 , 1.6 -&gt; 2</span></span><br><span class="line">   <span class="comment">// -1.6 -&gt; -1 , -2.5 -&gt; -2</span></span><br><span class="line">			 CEILING(BigDecimal.ROUND_CEILING),</span><br><span class="line">			 <span class="comment">// 2.5 -&gt; 2 , 1.6 -&gt; 1</span></span><br><span class="line">   <span class="comment">// -1.6 -&gt; -2 , -2.5 -&gt; -3</span></span><br><span class="line">			 FLOOR(BigDecimal.ROUND_FLOOR),</span><br><span class="line">   	<span class="comment">// 2.5 -&gt; 3 , 1.6 -&gt; 2</span></span><br><span class="line">   <span class="comment">// -1.6 -&gt; -2 , -2.5 -&gt; -3</span></span><br><span class="line">			 HALF_UP(BigDecimal.ROUND_HALF_UP),</span><br><span class="line">   <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="大小比较"><a href="#大小比较" class="headerlink" title="大小比较"></a>大小比较</h3><p><code>a.compareTo(b)</code> : 返回 -1 表示 <code>a</code> 小于 <code>b</code>，0 表示 <code>a</code> 等于 <code>b</code> ， 1 表示 <code>a</code> 大于 <code>b</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">System.out.println(a.compareTo(b));<span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="几位小数"><a href="#几位小数" class="headerlink" title="几位小数"></a>几位小数</h3><p>通过 <code>setScale</code>方法设置保留几位小数以及保留规则。保留规则有挺多种，不需要记，IDEA 会提示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BigDecimal m = new BigDecimal(&quot;1.255433&quot;);</span><br><span class="line">BigDecimal n = m.setScale(3,RoundingMode.HALF_DOWN);</span><br><span class="line">System.out.println(n);// 1.255</span><br></pre></td></tr></table></figure>

<h2 id="BigDecimal-等值比较问题"><a href="#BigDecimal-等值比较问题" class="headerlink" title="BigDecimal 等值比较问题"></a>BigDecimal 等值比较问题</h2><p>《阿里巴巴 Java 开发手册》中提到：</p>
<p><img src="https://files.catbox.moe/nsfa2u.png"><code>BigDecimal</code> 使用 <code>equals()</code> 方法进行等值比较出现问题的代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">System.out.println(a.equals(b));<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>这是因为 <code>equals()</code> 方法不仅仅会比较值的大小（value）还会比较精度（scale），而 <code>compareTo()</code> 方法比较的时候会忽略精度。</p>
<p>1.0 的 scale 是 1，1 的 scale 是 0，因此 <code>a.equals(b)</code> 的结果是 false。</p>
<p><img src="https://files.catbox.moe/ujagly.png"></p>
<p><code>compareTo()</code> 方法可以比较两个 <code>BigDecimal</code> 的值，如果相等就返回 0，如果第 1 个数比第 2 个数大则返回 1，反之返回-1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">System.out.println(a.compareTo(b));<span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<h2 id="BigDecimal-工具类分享"><a href="#BigDecimal-工具类分享" class="headerlink" title="BigDecimal 工具类分享"></a>BigDecimal 工具类分享</h2><p>网上有一个使用人数比较多的 <code>BigDecimal</code> 工具类，提供了多个静态方法来简化 <code>BigDecimal</code> 的操作。</p>
<p>我对其进行了简单改进，分享一下源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.math.RoundingMode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简化BigDecimal计算的小工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigDecimalUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认除法运算精度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEF_DIV_SCALE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BigDecimalUtil</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供精确的加法运算。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 被加数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 加数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 两个参数的和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> v1, <span class="type">double</span> v2)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> BigDecimal.valueOf(v1);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b2</span> <span class="operator">=</span> BigDecimal.valueOf(v2);</span><br><span class="line">        <span class="keyword">return</span> b1.add(b2).doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供精确的减法运算。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 被减数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 减数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 两个参数的差</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">subtract</span><span class="params">(<span class="type">double</span> v1, <span class="type">double</span> v2)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> BigDecimal.valueOf(v1);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b2</span> <span class="operator">=</span> BigDecimal.valueOf(v2);</span><br><span class="line">        <span class="keyword">return</span> b1.subtract(b2).doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供精确的乘法运算。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 被乘数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 乘数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 两个参数的积</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">multiply</span><span class="params">(<span class="type">double</span> v1, <span class="type">double</span> v2)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> BigDecimal.valueOf(v1);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b2</span> <span class="operator">=</span> BigDecimal.valueOf(v2);</span><br><span class="line">        <span class="keyword">return</span> b1.multiply(b2).doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供（相对）精确的除法运算，当发生除不尽的情况时，精确到</span></span><br><span class="line"><span class="comment">     * 小数点以后10位，以后的数字四舍五入。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 被除数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 除数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 两个参数的商</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">divide</span><span class="params">(<span class="type">double</span> v1, <span class="type">double</span> v2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> divide(v1, v2, DEF_DIV_SCALE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指</span></span><br><span class="line"><span class="comment">     * 定精度，以后的数字四舍五入。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1    被除数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2    除数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> scale 表示表示需要精确到小数点以后几位。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 两个参数的商</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">divide</span><span class="params">(<span class="type">double</span> v1, <span class="type">double</span> v2, <span class="type">int</span> scale)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (scale &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    <span class="string">&quot;The scale must be a positive integer or zero&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> BigDecimal.valueOf(v1);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b2</span> <span class="operator">=</span> BigDecimal.valueOf(v2);</span><br><span class="line">        <span class="keyword">return</span> b1.divide(b2, scale, RoundingMode.HALF_UP).doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供精确的小数位四舍五入处理。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v     需要四舍五入的数字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> scale 小数点后保留几位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 四舍五入后的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">round</span><span class="params">(<span class="type">double</span> v, <span class="type">int</span> scale)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (scale &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    <span class="string">&quot;The scale must be a positive integer or zero&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> BigDecimal.valueOf(v);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">one</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> b.divide(one, scale, RoundingMode.HALF_UP).doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供精确的类型转换(Float)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v 需要被转换的数字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回转换结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">convertToFloat</span><span class="params">(<span class="type">double</span> v)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(v);</span><br><span class="line">        <span class="keyword">return</span> b.floatValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供精确的类型转换(Int)不进行四舍五入</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v 需要被转换的数字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回转换结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">convertsToInt</span><span class="params">(<span class="type">double</span> v)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(v);</span><br><span class="line">        <span class="keyword">return</span> b.intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供精确的类型转换(Long)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v 需要被转换的数字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回转换结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">convertsToLong</span><span class="params">(<span class="type">double</span> v)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(v);</span><br><span class="line">        <span class="keyword">return</span> b.longValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回两个数中大的一个值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 需要被对比的第一个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 需要被对比的第二个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回两个数中大的一个值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">returnMax</span><span class="params">(<span class="type">double</span> v1, <span class="type">double</span> v2)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(v1);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(v2);</span><br><span class="line">        <span class="keyword">return</span> b1.max(b2).doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回两个数中小的一个值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 需要被对比的第一个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 需要被对比的第二个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回两个数中小的一个值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">returnMin</span><span class="params">(<span class="type">double</span> v1, <span class="type">double</span> v2)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(v1);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(v2);</span><br><span class="line">        <span class="keyword">return</span> b1.min(b2).doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 精确对比两个数字</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 需要被对比的第一个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 需要被对比的第二个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果两个数一样则返回0，如果第一个数比第二个数大则返回1，反之返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(<span class="type">double</span> v1, <span class="type">double</span> v2)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> BigDecimal.valueOf(v1);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b2</span> <span class="operator">=</span> BigDecimal.valueOf(v2);</span><br><span class="line">        <span class="keyword">return</span> b1.compareTo(b2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>浮点数没有办法用二进制精确表示，因此存在精度丢失的风险。</p>
<p>不过，Java 提供了<code>BigDecimal</code> 来操作浮点数。<code>BigDecimal</code> 的实现利用到了 <code>BigInteger</code> （用来操作大整数）, 所不同的是 <code>BigDecimal</code> 加入了小数位的概念。</p>
<h1 id="Java-魔法类-Unsafe-详解"><a href="#Java-魔法类-Unsafe-详解" class="headerlink" title="Java 魔法类 Unsafe 详解"></a>Java 魔法类 Unsafe 详解</h1><p>阅读过 JUC 源码的同学，一定会发现很多并发工具类都调用了一个叫做 <code>Unsafe</code> 的类。</p>
<p>那这个类主要是用来干什么的呢？有什么使用场景呢？这篇文章就带你搞清楚！</p>
<p>JUC是java.util.concurrent包的简称，在Java5.0添加，目的就是为了更好的支持<a href="https://so.csdn.net/so/search?q=%E9%AB%98%E5%B9%B6%E5%8F%91&spm=1001.2101.3001.7020">高并发</a>任务。让开发者进行多线程编程时减少竞争条件和死锁的问题！</p>
<h2 id="Unsafe-介绍"><a href="#Unsafe-介绍" class="headerlink" title="Unsafe 介绍"></a>Unsafe 介绍</h2><p><code>Unsafe</code> 是位于 <code>sun.misc</code> 包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升 Java 运行效率、增强 Java 语言底层资源操作能力方面起到了很大的作用。但由于 <code>Unsafe</code> 类使 Java 语言拥有了类似 C 语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用 <code>Unsafe</code> 类会使得程序出错的概率变大，使得 Java 这种安全的语言变得不再“安全”，因此对 <code>Unsafe</code> 的使用一定要慎重。</p>
<p>另外，<code>Unsafe</code> 提供的这些功能的实现需要依赖本地方法（Native Method）。你可以将本地方法看作是 Java 中使用其他编程语言编写的方法。本地方法使用 <strong>native</strong> 关键字修饰，Java 代码中只是声明方法头，具体的实现则交给 <strong>本地代码</strong>。</p>
<p><img src="https://files.catbox.moe/anm0ou.png"></p>
<p><strong>为什么要使用本地方法呢？</strong></p>
<ol>
<li>需要用到 Java 中不具备的依赖于操作系统的特性，Java 在实现跨平台的同时要实现对底层的控制，需要借助其他语言发挥作用。</li>
<li>对于其他语言已经完成的一些现成功能，可以使用 Java 直接调用。</li>
<li>程序对时间敏感或对性能要求非常高时，有必要使用更加底层的语言，例如 C&#x2F;C++甚至是汇编。</li>
</ol>
<p>在 JUC 包的很多并发工具类在实现并发机制时，都调用了本地方法，通过它们打破了 Java 运行时的界限，能够接触到操作系统底层的某些功能。对于同一本地方法，不同的操作系统可能会通过不同的方式来实现，但是对于使用者来说是透明的，最终都会得到相同的结果。</p>
<h2 id="Unsafe-创建"><a href="#Unsafe-创建" class="headerlink" title="Unsafe 创建"></a>Unsafe 创建</h2><p><code>sun.misc.Unsafe</code> 部分源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Unsafe</span> &#123;</span><br><span class="line">  <span class="comment">// 单例对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe theUnsafe;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Unsafe</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@CallerSensitive</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">var0</span> <span class="operator">=</span> Reflection.getCallerClass();</span><br><span class="line">    <span class="comment">// 仅在引导类加载器`BootstrapClassLoader`加载时才合法</span></span><br><span class="line">    <span class="keyword">if</span>(!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;Unsafe&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> theUnsafe;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Unsafe</code> 类为一单例实现，提供静态方法 <code>getUnsafe</code> 获取 <code>Unsafe</code>实例。这个看上去貌似可以用来获取 <code>Unsafe</code> 实例。但是，当我们直接调用这个静态方法的时候，会抛出 <code>SecurityException</code> 异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.SecurityException: Unsafe</span><br><span class="line"> at sun.misc.Unsafe.getUnsafe(Unsafe.java:<span class="number">90</span>)</span><br><span class="line"> at com.cn.test.GetUnsafeTest.main(GetUnsafeTest.java:<span class="number">12</span>)</span><br></pre></td></tr></table></figure>

<p><strong>为什么 public static 方法无法被直接调用呢？</strong></p>
<p>这是因为在<code>getUnsafe</code>方法中，会对调用者的<code>classLoader</code>进行检查，判断当前类是否由<code>Bootstrap classLoader</code>加载，如果不是的话那么就会抛出一个<code>SecurityException</code>异常。也就是说，只有启动类加载器加载的类才能够调用 Unsafe 类中的方法，来防止这些方法在不可信的代码中被调用。</p>
<p><strong>为什么要对 Unsafe 类进行这么谨慎的使用限制呢?</strong></p>
<p><code>Unsafe</code> 提供的功能过于底层（如直接访问系统内存资源、自主管理内存资源等），安全隐患也比较大，使用不当的话，很容易出现很严重的问题。</p>
<p><strong>如若想使用 Unsafe 这个类的话，应该如何获取其实例呢？</strong></p>
<p>这里介绍两个可行的方案。</p>
<p>1、利用反射获得 Unsafe 类中已经实例化完成的单例对象 <code>theUnsafe</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Unsafe <span class="title function_">reflectGetUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">      field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">      <span class="keyword">return</span> (Unsafe) field.get(<span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      log.error(e.getMessage(), e);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、从<code>getUnsafe</code>方法的使用限制条件出发，通过 Java 命令行命令<code>-Xbootclasspath/a</code>把调用 Unsafe 相关方法的类 A 所在 jar 包路径追加到默认的 bootstrap 路径中，使得 A 被引导类加载器加载，从而通过<code>Unsafe.getUnsafe</code>方法安全的获取 Unsafe 实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -Xbootclasspath/a: $&#123;path&#125;   <span class="comment">// 其中path为调用Unsafe相关方法的类所在jar包路径</span></span><br></pre></td></tr></table></figure>

<h2 id="Unsafe-功能"><a href="#Unsafe-功能" class="headerlink" title="Unsafe 功能"></a>Unsafe 功能</h2><p>概括的来说，<code>Unsafe</code> 类实现功能可以被分为下面 8 类：</p>
<ol>
<li>内存操作</li>
<li>内存屏障</li>
<li>对象操作</li>
<li>数据操作</li>
<li>CAS 操作</li>
<li>线程调度</li>
<li>Class 操作</li>
<li>系统信息</li>
</ol>
<h3 id="内存操作"><a href="#内存操作" class="headerlink" title="内存操作"></a>内存操作</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>如果你是一个写过 C 或者 C++ 的程序员，一定对内存操作不会陌生，而在 Java 中是不允许直接对内存进行操作的，对象内存的分配和回收都是由 JVM 自己实现的。但是在 <code>Unsafe</code> 中，提供的下列接口可以直接进行内存操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分配新的本地空间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">allocateMemory</span><span class="params">(<span class="type">long</span> bytes)</span>;</span><br><span class="line"><span class="comment">//重新调整内存空间的大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">reallocateMemory</span><span class="params">(<span class="type">long</span> address, <span class="type">long</span> bytes)</span>;</span><br><span class="line"><span class="comment">//将内存设置为指定值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">setMemory</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">long</span> bytes, <span class="type">byte</span> value)</span>;</span><br><span class="line"><span class="comment">//内存拷贝</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">copyMemory</span><span class="params">(Object srcBase, <span class="type">long</span> srcOffset,Object destBase, <span class="type">long</span> destOffset,<span class="type">long</span> bytes)</span>;</span><br><span class="line"><span class="comment">//清除内存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">freeMemory</span><span class="params">(<span class="type">long</span> address)</span>;</span><br></pre></td></tr></table></figure>

<p>使用下面的代码进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">memoryTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">addr</span> <span class="operator">=</span> unsafe.allocateMemory(size);</span><br><span class="line">    <span class="type">long</span> <span class="variable">addr3</span> <span class="operator">=</span> unsafe.reallocateMemory(addr, size * <span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;addr: &quot;</span>+addr);</span><br><span class="line">    System.out.println(<span class="string">&quot;addr3: &quot;</span>+addr3);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        unsafe.setMemory(<span class="literal">null</span>,addr ,size,(<span class="type">byte</span>)<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            unsafe.copyMemory(<span class="literal">null</span>,addr,<span class="literal">null</span>,addr3+size*i,<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(unsafe.getInt(addr));</span><br><span class="line">        System.out.println(unsafe.getLong(addr3));</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        unsafe.freeMemory(addr);</span><br><span class="line">        unsafe.freeMemory(addr3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看结果输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">addr: <span class="number">2433733895744</span></span><br><span class="line">addr3: <span class="number">2433733894944</span></span><br><span class="line"><span class="number">16843009</span></span><br><span class="line"><span class="number">72340172838076673</span></span><br></pre></td></tr></table></figure>

<p>分析一下运行结果，首先使用<code>allocateMemory</code>方法申请 4 字节长度的内存空间，在循环中调用<code>setMemory</code>方法向每个字节写入内容为<code>byte</code>类型的 1，当使用 Unsafe 调用<code>getInt</code>方法时，因为一个<code>int</code>型变量占 4 个字节，会一次性读取 4 个字节，组成一个<code>int</code>的值，对应的十进制结果为 16843009。</p>
<p>你可以通过下图理解这个过程：</p>
<p><img src="https://files.catbox.moe/eo9ubr.png"></p>
<p>在代码中调用<code>reallocateMemory</code>方法重新分配了一块 8 字节长度的内存空间，通过比较<code>addr</code>和<code>addr3</code>可以看到和之前申请的内存地址是不同的。在代码中的第二个 for 循环里，调用<code>copyMemory</code>方法进行了两次内存的拷贝，每次拷贝内存地址<code>addr</code>开始的 4 个字节，分别拷贝到以<code>addr3</code>和<code>addr3+4</code>开始的内存空间上：</p>
<p><img src="https://files.catbox.moe/imsxf2.png"></p>
<p>拷贝完成后，使用<code>getLong</code>方法一次性读取 8 个字节，得到<code>long</code>类型的值为 72340172838076673。</p>
<p>需要注意，通过这种方式分配的内存属于 堆外内存 ，是无法进行垃圾回收的，需要我们把这些内存当做一种资源去手动调用<code>freeMemory</code>方法进行释放，否则会产生内存泄漏。通用的操作内存方式是在<code>try</code>中执行对内存的操作，最终在<code>finally</code>块中进行内存的释放。</p>
<p><strong>为什么要使用堆外内存？</strong></p>
<ul>
<li>对垃圾回收停顿的改善。由于堆外内存是直接受操作系统管理而不是 JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模。从而在 GC 时减少回收停顿对于应用的影响。</li>
<li>提升程序 I&#x2F;O 操作的性能。通常在 I&#x2F;O 通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存。</li>
</ul>
<h4 id="典型应用"><a href="#典型应用" class="headerlink" title="典型应用"></a>典型应用</h4><p><code>DirectByteBuffer</code> 是 Java 用于实现堆外内存的一个重要类，通常用在通信过程中做缓冲池，如在 Netty、MINA 等 NIO 框架中应用广泛。<code>DirectByteBuffer</code> 对于堆外内存的创建、使用、销毁等逻辑均由 Unsafe 提供的堆外内存 API 来实现。</p>
<p>下图为 <code>DirectByteBuffer</code> 构造函数，创建 <code>DirectByteBuffer</code> 的时候，通过 <code>Unsafe.allocateMemory</code> 分配内存、<code>Unsafe.setMemory</code> 进行内存初始化，而后构建 <code>Cleaner</code> 对象用于跟踪 <code>DirectByteBuffer</code> 对象的垃圾回收，以实现当 <code>DirectByteBuffer</code> 被垃圾回收时，分配的堆外内存一起被释放。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DirectByteBuffer(<span class="type">int</span> cap) &#123;                   <span class="comment">// package-private</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">pa</span> <span class="operator">=</span> VM.isDirectMemoryPageAligned();</span><br><span class="line">    <span class="type">int</span> <span class="variable">ps</span> <span class="operator">=</span> Bits.pageSize();</span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> Math.max(<span class="number">1L</span>, (<span class="type">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 分配内存并返回基地址</span></span><br><span class="line">        base = unsafe.allocateMemory(size);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内存初始化</span></span><br><span class="line">    unsafe.setMemory(base, size, (<span class="type">byte</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Round up to page boundary</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 跟踪 DirectByteBuffer 对象的垃圾回收，以实现堆外内存释放</span></span><br><span class="line">    cleaner = Cleaner.create(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">Deallocator</span>(base, size, cap));</span><br><span class="line">    att = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p>在介绍内存屏障前，需要知道编译器和 CPU 会在保证程序输出结果一致的情况下，会对代码进行重排序，从指令优化角度提升性能。而指令重排序可能会带来一个不好的结果，导致 CPU 的高速缓存和内存中数据的不一致，而内存屏障（<code>Memory Barrier</code>）就是通过组织屏障两边的指令重排序从而避免编译器和硬件的不正确优化情况。</p>
<p>在硬件层面上，内存屏障是 CPU 为了防止代码进行重排序而提供的指令，不同的硬件平台上实现内存屏障的方法可能并不相同。在 Java8 中，引入了 3 个内存屏障的函数，它屏蔽了操作系统底层的差异，允许在代码中定义、并统一由 JVM 来生成内存屏障指令，来实现内存屏障的功能。</p>
<p><code>Unsafe</code> 中提供了下面三个内存屏障相关方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">loadFence</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">storeFence</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//内存屏障，禁止load、store操作重排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">fullFence</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>内存屏障可以看做对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。以<code>loadFence</code>方法为例，它会禁止读操作重排序，保证在这个屏障之前的所有读操作都已经完成，并且将缓存数据设为无效，重新从主存中进行加载。</p>
<p>看到这估计很多小伙伴们会想到<code>volatile</code>关键字了，如果在字段上添加了<code>volatile</code>关键字，就能够实现字段在多线程下的可见性。基于读内存屏障，我们也能实现相同的功能。下面定义一个线程方法，在线程中去修改<code>flag</code>标志位，注意这里的<code>flag</code>是没有被<code>volatile</code>修饰的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChangeThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">/**volatile**/</span> <span class="type">boolean</span> flag=<span class="literal">false</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;subThread change flag to:&quot;</span> + flag);</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在主线程的<code>while</code>循环中，加入内存屏障，测试是否能够感知到<code>flag</code>的修改变化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">ChangeThread</span> <span class="variable">changeThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChangeThread</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(changeThread).start();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> changeThread.isFlag();</span><br><span class="line">        unsafe.loadFence(); <span class="comment">//加入读内存屏障</span></span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;detected flag changed&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;main thread end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">subThread change flag to:<span class="literal">false</span></span><br><span class="line">detected flag changed</span><br><span class="line">main thread end</span><br></pre></td></tr></table></figure>

<p>而如果删掉上面代码中的<code>loadFence</code>方法，那么主线程将无法感知到<code>flag</code>发生的变化，会一直在<code>while</code>中循环。可以用图来表示上面的过程：</p>
<p><img src="https://files.catbox.moe/g0hwgp.png"></p>
<p>了解 Java 内存模型（<code>JMM</code>）的小伙伴们应该清楚，运行中的线程不是直接读取主内存中的变量的，只能操作自己工作内存中的变量，然后同步到主内存中，并且线程的工作内存是不能共享的。上面的图中的流程就是子线程借助于主内存，将修改后的结果同步给了主线程，进而修改主线程中的工作空间，跳出循环。</p>
<h4 id="典型应用-1"><a href="#典型应用-1" class="headerlink" title="典型应用"></a>典型应用</h4><p>在 Java 8 中引入了一种锁的新机制——<code>StampedLock</code>，它可以看成是读写锁的一个改进版本。<code>StampedLock</code> 提供了一种乐观读锁的实现，这种乐观读锁类似于无锁的操作，完全不会阻塞写线程获取写锁，从而缓解读多写少时写线程“饥饿”现象。由于 <code>StampedLock</code> 提供的乐观读锁不阻塞写线程获取读锁，当线程共享变量从主内存 load 到线程工作内存时，会存在数据不一致问题。</p>
<p>为了解决这个问题，<code>StampedLock</code> 的 <code>validate</code> 方法会通过 <code>Unsafe</code> 的 <code>loadFence</code> 方法加入一个 <code>load</code> 内存屏障。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validate</span><span class="params">(<span class="type">long</span> stamp)</span> &#123;</span><br><span class="line">   U.loadFence();</span><br><span class="line">   <span class="keyword">return</span> (stamp &amp; SBITS) == (state &amp; SBITS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象操作"><a href="#对象操作" class="headerlink" title="对象操作"></a>对象操作</h3><h4 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h4><p><strong>对象属性</strong></p>
<p>对象成员属性的内存偏移量获取，以及字段属性值的修改，在上面的例子中我们已经测试过了。除了前面的<code>putInt</code>、<code>getInt</code>方法外，Unsafe 提供了全部 8 种基础数据类型以及<code>Object</code>的<code>put</code>和<code>get</code>方法，并且所有的<code>put</code>方法都可以越过访问权限，直接修改内存中的数据。阅读 openJDK 源码中的注释发现，基础数据类型和<code>Object</code>的读写稍有不同，基础数据类型是直接操作的属性值（<code>value</code>），而<code>Object</code>的操作则是基于引用值（<code>reference value</code>）。下面是<code>Object</code>的读写方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在对象的指定偏移地址获取一个对象引用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title function_">getObject</span><span class="params">(Object o, <span class="type">long</span> offset)</span>;</span><br><span class="line"><span class="comment">//在对象指定偏移地址写入一个对象引用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">putObject</span><span class="params">(Object o, <span class="type">long</span> offset, Object x)</span>;</span><br></pre></td></tr></table></figure>

<p>除了对象属性的普通读写外，<code>Unsafe</code> 还提供了 <strong>volatile 读写</strong>和<strong>有序写入</strong>方法。<code>volatile</code>读写方法的覆盖范围与普通读写相同，包含了全部基础数据类型和<code>Object</code>类型，以<code>int</code>类型为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在对象的指定偏移地址处读取一个int值，支持volatile load语义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">getIntVolatile</span><span class="params">(Object o, <span class="type">long</span> offset)</span>;</span><br><span class="line"><span class="comment">//在对象指定偏移地址处写入一个int，支持volatile store语义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">putIntVolatile</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> x)</span>;</span><br></pre></td></tr></table></figure>

<p>相对于普通读写来说，<code>volatile</code>读写具有更高的成本，因为它需要保证可见性和有序性。在执行<code>get</code>操作时，会强制从主存中获取属性值，在使用<code>put</code>方法设置属性值时，会强制将值更新到主存中，从而保证这些变更对其他线程是可见的。</p>
<p>有序写入的方法有以下三个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">putOrderedObject</span><span class="params">(Object o, <span class="type">long</span> offset, Object x)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">putOrderedInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> x)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">putOrderedLong</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">long</span> x)</span>;</span><br></pre></td></tr></table></figure>

<p>有序写入的成本相对<code>volatile</code>较低，因为它只保证写入时的有序性，而不保证可见性，也就是一个线程写入的值不能保证其他线程立即可见。为了解决这里的差异性，需要对内存屏障的知识点再进一步进行补充，首先需要了解两个指令的概念：</p>
<ul>
<li><code>Load</code>：将主内存中的数据拷贝到处理器的缓存中</li>
<li><code>Store</code>：将处理器缓存的数据刷新到主内存中</li>
</ul>
<p>顺序写入与<code>volatile</code>写入的差别在于，在顺序写时加入的内存屏障类型为<code>StoreStore</code>类型，而在<code>volatile</code>写入时加入的内存屏障是<code>StoreLoad</code>类型，如下图所示：</p>
<p><img src="https://files.catbox.moe/dajo3e.png"></p>
<p>在有序写入方法中，使用的是<code>StoreStore</code>屏障，该屏障确保<code>Store1</code>立刻刷新数据到内存，这一操作先于<code>Store2</code>以及后续的存储指令操作。而在<code>volatile</code>写入中，使用的是<code>StoreLoad</code>屏障，该屏障确保<code>Store1</code>立刻刷新数据到内存，这一操作先于<code>Load2</code>及后续的装载指令，并且，<code>StoreLoad</code>屏障会使该屏障之前的所有内存访问指令，包括存储指令和访问指令全部完成之后，才执行该屏障之后的内存访问指令。</p>
<p>综上所述，在上面的三类写入方法中，在写入效率方面，按照<code>put</code>、<code>putOrder</code>、<code>putVolatile</code>的顺序效率逐渐降低。</p>
<p><strong>对象实例化</strong></p>
<p>使用 <code>Unsafe</code> 的 <code>allocateInstance</code> 方法，允许我们使用非常规的方式进行对象的实例化，首先定义一个实体类，并且在构造函数中对其成员变量进行赋值操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> b;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.b =<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别基于构造函数、反射以及 <code>Unsafe</code> 方法的不同方式创建对象进行比较：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">objTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    A a1=<span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    System.out.println(a1.getB());</span><br><span class="line">    <span class="type">A</span> <span class="variable">a2</span> <span class="operator">=</span> A.class.newInstance();</span><br><span class="line">    System.out.println(a2.getB());</span><br><span class="line">    A a3= (A) unsafe.allocateInstance(A.class);</span><br><span class="line">    System.out.println(a3.getB());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果分别为 1、1、0，说明通过<code>allocateInstance</code>方法创建对象过程中，不会调用类的构造方法。使用这种方式创建对象时，只用到了<code>Class</code>对象，所以说如果想要跳过对象的初始化阶段或者跳过构造器的安全检查，就可以使用这种方法。在上面的例子中，如果将 A 类的构造函数改为<code>private</code>类型，将无法通过构造函数和反射创建对象，但<code>allocateInstance</code>方法仍然有效。</p>
<h4 id="典型应用-2"><a href="#典型应用-2" class="headerlink" title="典型应用"></a>典型应用</h4><ul>
<li><strong>常规对象实例化方式</strong>：我们通常所用到的创建对象的方式，从本质上来讲，都是通过 new 机制来实现对象的创建。但是，new 机制有个特点就是当类只提供有参的构造函数且无显示声明无参构造函数时，则必须使用有参构造函数进行对象构造，而使用有参构造函数时，必须传递相应个数的参数才能完成对象实例化。</li>
<li><strong>非常规的实例化方式</strong>：而 Unsafe 中提供 allocateInstance 方法，仅通过 Class 对象就可以创建此类的实例对象，而且不需要调用其构造函数、初始化代码、JVM 安全检查等。它抑制修饰符检测，也就是即使构造器是 private 修饰的也能通过此方法实例化，只需提类对象即可创建相应的对象。由于这种特性，allocateInstance 在 java.lang.invoke、Objenesis（提供绕过类构造器的对象生成方式）、Gson（反序列化时用到）中都有相应的应用。</li>
</ul>
<h3 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h3><h4 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h4><p><code>arrayBaseOffset</code> 与 <code>arrayIndexScale</code> 这两个方法配合起来使用，即可定位数组中每个元素在内存中的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回数组中第一个元素的偏移地址</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">arrayBaseOffset</span><span class="params">(Class&lt;?&gt; arrayClass)</span>;</span><br><span class="line"><span class="comment">//返回数组中一个元素占用的大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">arrayIndexScale</span><span class="params">(Class&lt;?&gt; arrayClass)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="典型应用-3"><a href="#典型应用-3" class="headerlink" title="典型应用"></a>典型应用</h4><p>这两个与数据操作相关的方法，在 <code>java.util.concurrent.atomic</code> 包下的 <code>AtomicIntegerArray</code>（可以实现对 <code>Integer</code> 数组中每个元素的原子性操作）中有典型的应用，如下图 <code>AtomicIntegerArray</code> 源码所示，通过 <code>Unsafe</code> 的 <code>arrayBaseOffset</code> 、<code>arrayIndexScale</code> 分别获取数组首元素的偏移地址 <code>base</code> 及单个元素大小因子 <code>scale</code> 。后续相关原子性操作，均依赖于这两个值进行数组中元素的定位，如下图二所示的 <code>getAndAdd</code> 方法即通过 <code>checkedByteOffset</code> 方法获取某数组元素的偏移地址，而后通过 CAS 实现原子性操作。</p>
<p><img src="https://files.catbox.moe/z4js5w.png"></p>
<h3 id="CAS-操作"><a href="#CAS-操作" class="headerlink" title="CAS 操作"></a>CAS 操作</h3><h4 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h4><p>这部分主要为 CAS 相关操作的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	*  CAS</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> o         包含要修改field的对象</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> offset    对象中某field的偏移量</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> expected  期望值</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> update    更新值</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span>          true | false</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapObject</span><span class="params">(Object o, <span class="type">long</span> offset,  Object expected, Object update)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> expected,<span class="type">int</span> update)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">long</span> expected, <span class="type">long</span> update)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>什么是 CAS?</strong> CAS 即比较并替换（Compare And Swap)，是实现并发算法时常用到的一种技术。CAS 操作包含三个操作数——内存位置、预期原值及新值。执行 CAS 操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。我们都知道，CAS 是一条 CPU 的原子指令（cmpxchg 指令），不会造成所谓的数据不一致问题，<code>Unsafe</code> 提供的 CAS 方法（如 <code>compareAndSwapXXX</code>）底层实现即为 CPU 指令 <code>cmpxchg</code> 。</p>
<h4 id="典型应用-4"><a href="#典型应用-4" class="headerlink" title="典型应用"></a>典型应用</h4><p>在 JUC 包的并发工具类中大量地使用了 CAS 操作，像在前面介绍<code>synchronized</code>和<code>AQS</code>的文章中也多次提到了 CAS，其作为乐观锁在并发工具类中广泛发挥了作用。在 <code>Unsafe</code> 类中，提供了<code>compareAndSwapObject</code>、<code>compareAndSwapInt</code>、<code>compareAndSwapLong</code>方法来实现的对<code>Object</code>、<code>int</code>、<code>long</code>类型的 CAS 操作。以<code>compareAndSwapInt</code>方法为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object o, <span class="type">long</span> offset,<span class="type">int</span> expected,<span class="type">int</span> x)</span>;</span><br></pre></td></tr></table></figure>

<p>参数中<code>o</code>为需要更新的对象，<code>offset</code>是对象<code>o</code>中整形字段的偏移量，如果这个字段的值与<code>expected</code>相同，则将字段的值设为<code>x</code>这个新值，并且此更新是不可被中断的，也就是一个原子操作。下面是一个使用<code>compareAndSwapInt</code>的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    CasTest casTest=<span class="keyword">new</span> <span class="title class_">CasTest</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            casTest.increment(i);</span><br><span class="line">            System.out.print(casTest.a+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">5</span> ; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            casTest.increment(i);</span><br><span class="line">            System.out.print(casTest.a+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">fieldOffset</span> <span class="operator">=</span> unsafe.objectFieldOffset(CasTest.class.getDeclaredField(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">            <span class="keyword">if</span> (unsafe.compareAndSwapInt(<span class="built_in">this</span>,fieldOffset,x-<span class="number">1</span>,x))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行代码会依次输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，使用两个线程去修改<code>int</code>型属性<code>a</code>的值，并且只有在<code>a</code>的值等于传入的参数<code>x</code>减一时，才会将<code>a</code>的值变为<code>x</code>，也就是实现对<code>a</code>的加一的操作。流程如下所示：</p>
<p><img src="https://files.catbox.moe/lr0bhw.png"></p>
<p>需要注意的是，在调用<code>compareAndSwapInt</code>方法后，会直接返回<code>true</code>或<code>false</code>的修改结果，因此需要我们在代码中手动添加自旋的逻辑。在<code>AtomicInteger</code>类的设计中，也是采用了将<code>compareAndSwapInt</code>的结果作为循环条件，直至修改成功才退出死循环的方式来实现的原子性的自增操作。</p>
<h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><h4 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h4><p><code>Unsafe</code> 类中提供了<code>park</code>、<code>unpark</code>、<code>monitorEnter</code>、<code>monitorExit</code>、<code>tryMonitorEnter</code>方法进行线程调度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取消阻塞线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">unpark</span><span class="params">(Object thread)</span>;</span><br><span class="line"><span class="comment">//阻塞线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">park</span><span class="params">(<span class="type">boolean</span> isAbsolute, <span class="type">long</span> time)</span>;</span><br><span class="line"><span class="comment">//获得对象锁（可重入锁）</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">monitorEnter</span><span class="params">(Object o)</span>;</span><br><span class="line"><span class="comment">//释放对象锁</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">monitorExit</span><span class="params">(Object o)</span>;</span><br><span class="line"><span class="comment">//尝试获取对象锁</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">tryMonitorEnter</span><span class="params">(Object o)</span>;</span><br></pre></td></tr></table></figure>

<p>方法 <code>park</code>、<code>unpark</code> 即可实现线程的挂起与恢复，将一个线程进行挂起是通过 <code>park</code> 方法实现的，调用 <code>park</code> 方法后，线程将一直阻塞直到超时或者中断等条件出现；<code>unpark</code> 可以终止一个挂起的线程，使其恢复正常。</p>
<p>此外，<code>Unsafe</code> 源码中<code>monitor</code>相关的三个方法已经被标记为<code>deprecated</code>，不建议被使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得对象锁</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">monitorEnter</span><span class="params">(Object var1)</span>;</span><br><span class="line"><span class="comment">//释放对象锁</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">monitorExit</span><span class="params">(Object var1)</span>;</span><br><span class="line"><span class="comment">//尝试获得对象锁</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">tryMonitorEnter</span><span class="params">(Object var1)</span>;</span><br></pre></td></tr></table></figure>

<p><code>monitorEnter</code>方法用于获得对象锁，<code>monitorExit</code>用于释放对象锁，如果对一个没有被<code>monitorEnter</code>加锁的对象执行此方法，会抛出<code>IllegalMonitorStateException</code>异常。<code>tryMonitorEnter</code>方法尝试获取对象锁，如果成功则返回<code>true</code>，反之返回<code>false</code>。</p>
<h4 id="典型应用-5"><a href="#典型应用-5" class="headerlink" title="典型应用"></a>典型应用</h4><p>Java 锁和同步器框架的核心类 <code>AbstractQueuedSynchronizer</code> (AQS)，就是通过调用<code>LockSupport.park()</code>和<code>LockSupport.unpark()</code>实现线程的阻塞和唤醒的，而 <code>LockSupport</code> 的 <code>park</code> 、<code>unpark</code> 方法实际是调用 <code>Unsafe</code> 的 <code>park</code> 、<code>unpark</code> 方式实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">park</span><span class="params">(Object blocker)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    setBlocker(t, blocker);</span><br><span class="line">    UNSAFE.park(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    setBlocker(t, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unpark</span><span class="params">(Thread thread)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (thread != <span class="literal">null</span>)</span><br><span class="line">        UNSAFE.unpark(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>LockSupport</code> 的<code>park</code>方法调用了 <code>Unsafe</code> 的<code>park</code>方法来阻塞当前线程，此方法将线程阻塞后就不会继续往后执行，直到有其他线程调用<code>unpark</code>方法唤醒当前线程。下面的例子对 <code>Unsafe</code> 的这两个方法进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">mainThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;subThread try to unpark mainThread&quot;</span>);</span><br><span class="line">            unsafe.unpark(mainThread);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;park main mainThread&quot;</span>);</span><br><span class="line">    unsafe.park(<span class="literal">false</span>,<span class="number">0L</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;unpark mainThread success&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">park main mainThread</span><br><span class="line">subThread <span class="keyword">try</span> to unpark mainThread</span><br><span class="line">unpark mainThread success</span><br></pre></td></tr></table></figure>

<p>程序运行的流程也比较容易看懂，子线程开始运行后先进行睡眠，确保主线程能够调用<code>park</code>方法阻塞自己，子线程在睡眠 5 秒后，调用<code>unpark</code>方法唤醒主线程，使主线程能继续向下执行。整个流程如下图所示：</p>
<p><img src="https://files.catbox.moe/ugupcs.png"></p>
<h3 id="Class-操作"><a href="#Class-操作" class="headerlink" title="Class 操作"></a>Class 操作</h3><h4 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍"></a>介绍</h4><p><code>Unsafe</code> 对<code>Class</code>的相关操作主要包括类加载和静态变量的操作方法。</p>
<p><strong>静态属性读取相关的方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取静态属性的偏移量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">staticFieldOffset</span><span class="params">(Field f)</span>;</span><br><span class="line"><span class="comment">//获取静态属性的对象指针</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title function_">staticFieldBase</span><span class="params">(Field f)</span>;</span><br><span class="line"><span class="comment">//判断类是否需要实例化（用于获取类的静态属性前进行检测）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">shouldBeInitialized</span><span class="params">(Class&lt;?&gt; c)</span>;</span><br></pre></td></tr></table></figure>

<p>创建一个包含静态属性的类，进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String name=<span class="string">&quot;Hydra&quot;</span>;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">staticTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    User user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    System.out.println(unsafe.shouldBeInitialized(User.class));</span><br><span class="line">    <span class="type">Field</span> <span class="variable">sexField</span> <span class="operator">=</span> User.class.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">fieldOffset</span> <span class="operator">=</span> unsafe.staticFieldOffset(sexField);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">fieldBase</span> <span class="operator">=</span> unsafe.staticFieldBase(sexField);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> unsafe.getObject(fieldBase, fieldOffset);</span><br><span class="line">    System.out.println(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">falseHydra</span><br></pre></td></tr></table></figure>

<p>在 <code>Unsafe</code> 的对象操作中，我们学习了通过<code>objectFieldOffset</code>方法获取对象属性偏移量并基于它对变量的值进行存取，但是它不适用于类中的静态属性，这时候就需要使用<code>staticFieldOffset</code>方法。在上面的代码中，只有在获取<code>Field</code>对象的过程中依赖到了<code>Class</code>，而获取静态变量的属性时不再依赖于<code>Class</code>。</p>
<p>在上面的代码中首先创建一个<code>User</code>对象，这是因为如果一个类没有被实例化，那么它的静态属性也不会被初始化，最后获取的字段属性将是<code>null</code>。所以在获取静态属性前，需要调用<code>shouldBeInitialized</code>方法，判断在获取前是否需要初始化这个类。如果删除创建 User 对象的语句，运行结果会变为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">truenull</span><br></pre></td></tr></table></figure>

<p><strong>使用defineClass方法允许程序在运行时动态地创建一个类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass(String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len, ClassLoader loader,ProtectionDomain protectionDomain);</span><br></pre></td></tr></table></figure>

<p>在实际使用过程中，可以只传入字节数组、起始字节的下标以及读取的字节长度，默认情况下，类加载器（<code>ClassLoader</code>）和保护域（<code>ProtectionDomain</code>）来源于调用此方法的实例。下面的例子中实现了反编译生成后的 class 文件的功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">defineTest</span><span class="params">()</span> &#123;</span><br><span class="line">    String fileName=<span class="string">&quot;F:\\workspace\\unsafe-test\\target\\classes\\com\\cn\\model\\User.class&quot;</span>;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(fileName);</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file)) &#123;</span><br><span class="line">        <span class="type">byte</span>[] content=<span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>)file.length()];</span><br><span class="line">        fis.read(content);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> unsafe.defineClass(<span class="literal">null</span>, content, <span class="number">0</span>, content.length, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">age</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;getAge&quot;</span>).invoke(o, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，首先读取了一个<code>class</code>文件并通过文件流将它转化为字节数组，之后使用<code>defineClass</code>方法动态的创建了一个类，并在后续完成了它的实例化工作，流程如下图所示，并且通过这种方式创建的类，会跳过 JVM 的所有安全检查。</p>
<p><img src="https://files.catbox.moe/vxnih5.png"></p>
<p>除了<code>defineClass</code>方法外，Unsafe 还提供了一个<code>defineAnonymousClass</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Class&lt;?&gt; defineAnonymousClass(Class&lt;?&gt; hostClass, <span class="type">byte</span>[] data, Object[] cpPatches);</span><br></pre></td></tr></table></figure>

<p>使用该方法可以用来动态的创建一个匿名类，在<code>Lambda</code>表达式中就是使用 ASM 动态生成字节码，然后利用该方法定义实现相应的函数式接口的匿名类。在 JDK 15 发布的新特性中，在隐藏类（<code>Hidden classes</code>）一条中，指出将在未来的版本中弃用 <code>Unsafe</code> 的<code>defineAnonymousClass</code>方法。</p>
<h4 id="典型应用-6"><a href="#典型应用-6" class="headerlink" title="典型应用"></a>典型应用</h4><p>Lambda 表达式实现需要依赖 <code>Unsafe</code> 的 <code>defineAnonymousClass</code> 方法定义实现相应的函数式接口的匿名类。</p>
<h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h3><h4 id="介绍-9"><a href="#介绍-9" class="headerlink" title="介绍"></a>介绍</h4><p>这部分包含两个获取系统相关信息的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回系统指针的大小。返回值为4（32位系统）或 8（64位系统）。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">addressSize</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//内存页的大小，此值为2的幂次方。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">pageSize</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<h4 id="典型应用-7"><a href="#典型应用-7" class="headerlink" title="典型应用"></a>典型应用</h4><p>这两个方法的应用场景比较少，在<code>java.nio.Bits</code>类中，在使用<code>pageCount</code>计算所需的内存页的数量时，调用了<code>pageSize</code>方法获取内存页的大小。另外，在使用<code>copySwapMemory</code>方法拷贝内存时，调用了<code>addressSize</code>方法，检测 32 位系统的情况。</p>
<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>在本文中，我们首先介绍了 <code>Unsafe</code> 的基本概念、工作原理，并在此基础上，对它的 API 进行了说明与实践。相信大家通过这一过程，能够发现 <code>Unsafe</code> 在某些场景下，确实能够为我们提供编程中的便利。但是回到开头的话题，在使用这些便利时，确实存在着一些安全上的隐患，在我看来，一项技术具有不安全因素并不可怕，可怕的是它在使用过程中被滥用。尽管之前有传言说会在 Java9 中移除 <code>Unsafe</code> 类，不过它还是照样已经存活到了 Java16。按照存在即合理的逻辑，只要使用得当，它还是能给我们带来不少的帮助，因此最后还是建议大家，在使用 <code>Unsafe</code> 的过程中一定要做到使用谨慎使用、避免滥用。</p>
<h1 id="Java-SPI-机制详解"><a href="#Java-SPI-机制详解" class="headerlink" title="Java SPI 机制详解"></a>Java SPI 机制详解</h1><p>在面向对象的设计原则中，一般推荐模块之间基于接口编程，通常情况下调用方模块是不会感知到被调用方模块的内部具体实现。一旦代码里面涉及具体实现类，就违反了开闭原则。如果需要替换一种实现，就需要修改代码。</p>
<p>为了实现在模块装配的时候不用在程序里面动态指明，这就需要一种服务发现机制。Java SPI 就是提供了这样一个机制：<strong>为某个接口寻找服务实现的机制。这有点类似 IoC 的思想，将装配的控制权移交到了程序之外。</strong></p>
<h2 id="SPI-介绍"><a href="#SPI-介绍" class="headerlink" title="SPI 介绍"></a>SPI 介绍</h2><h3 id="何谓-SPI"><a href="#何谓-SPI" class="headerlink" title="何谓 SPI?"></a>何谓 SPI?</h3><p>SPI 即 Service Provider Interface ，字面意思就是：“服务提供者的接口”，我的理解是：专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。</p>
<p>SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。</p>
<p>很多框架都使用了 Java 的 SPI 机制，比如：Spring 框架、数据库加载驱动、日志接口、以及 Dubbo 的扩展实现等等。</p>
<p><img src="https://files.catbox.moe/0as5e1.png"></p>
<h3 id="SPI-和-API-有什么区别？"><a href="#SPI-和-API-有什么区别？" class="headerlink" title="SPI 和 API 有什么区别？"></a>SPI 和 API 有什么区别？</h3><p><strong>那 SPI 和 API 有啥区别？</strong></p>
<p>说到 SPI 就不得不说一下 API 了，从广义上来说它们都属于接口，而且很容易混淆。下面先用一张图说明一下：<img src="https://files.catbox.moe/6que5f.png"></p>
<p>一般模块之间都是通过通过接口进行通讯，那我们在服务调用方和服务实现方（也称服务提供者）之间引入一个“接口”。</p>
<p>当实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 API ，这种接口和实现都是放在实现方的。</p>
<p>当接口存在于调用方这边时，就是 SPI ，由接口调用方确定接口规则，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务。</p>
<p>举个通俗易懂的例子：公司 H 是一家科技公司，新设计了一款芯片，然后现在需要量产了，而市面上有好几家芯片制造业公司，这个时候，只要 H 公司指定好了这芯片生产的标准（定义好了接口标准），那么这些合作的芯片公司（服务提供者）就按照标准交付自家特色的芯片（提供不同方案的实现，但是给出来的结果是一样的）。</p>
<h2 id="实战演示"><a href="#实战演示" class="headerlink" title="实战演示"></a>实战演示</h2><p>Spring 框架提供的日志服务 SLF4J 其实只是一个日志门面（接口），但是 SLF4J 的具体实现可以有几种，比如：Logback、Log4j、Log4j2 等等，而且还可以切换，在切换日志具体实现的时候我们是不需要更改项目代码的，只需要在 Maven 依赖里面修改一些 pom 依赖就好了。</p>
<p><img src="https://files.catbox.moe/m6hgrx.png"></p>
<p>这就是依赖 SPI 机制实现的，那我们接下来就实现一个简易版本的日志框架。</p>
<h3 id="Service-Provider-Interface"><a href="#Service-Provider-Interface" class="headerlink" title="Service Provider Interface"></a>Service Provider Interface</h3><p>新建一个 Java 项目 <code>service-provider-interface</code> 目录结构如下：（注意直接新建 Java 项目就好了，不用新建 Maven 项目，Maven 项目会涉及到一些编译配置，如果有私服的话，直接 deploy 会比较方便，但是没有的话，在过程中可能会遇到一些奇怪的问题。）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">│  service-provider-interface.iml</span><br><span class="line">│</span><br><span class="line">├─.idea</span><br><span class="line">│  │  .gitignore</span><br><span class="line">│  │  misc.xml</span><br><span class="line">│  │  modules.xml</span><br><span class="line">│  └─ workspace.xml</span><br><span class="line">│</span><br><span class="line">└─src</span><br><span class="line">    └─edu</span><br><span class="line">        └─jiangxuan</span><br><span class="line">            └─up</span><br><span class="line">                └─spi</span><br><span class="line">                        Logger.java</span><br><span class="line">                        LoggerService.java</span><br><span class="line">                        Main.class</span><br></pre></td></tr></table></figure>

<p>新建 <code>Logger</code> 接口，这个就是 SPI ， 服务提供者接口，后面的服务提供者就要针对这个接口进行实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> edu.jiangxuan.up.spi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">info</span><span class="params">(String msg)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String msg)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是 <code>LoggerService</code> 类，这个主要是为服务使用者（调用方）提供特定功能的。这个类也是实现 Java SPI 机制的关键所在，如果存在疑惑的话可以先往后面继续看。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> edu.jiangxuan.up.spi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ServiceLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggerService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">LoggerService</span> <span class="variable">SERVICE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoggerService</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Logger&gt; loggerList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LoggerService</span><span class="params">()</span> &#123;</span><br><span class="line">        ServiceLoader&lt;Logger&gt; loader = ServiceLoader.load(Logger.class);</span><br><span class="line">        List&lt;Logger&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Logger log : loader) &#123;</span><br><span class="line">            list.add(log);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// LoggerList 是所有 ServiceProvider</span></span><br><span class="line">        loggerList = list;</span><br><span class="line">        <span class="keyword">if</span> (!list.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// Logger 只取一个</span></span><br><span class="line">            logger = list.get(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LoggerService <span class="title function_">getService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SERVICE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;info 中没有发现 Logger 服务提供者&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.info(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (loggerList.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;debug 中没有发现 Logger 服务提供者&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        loggerList.forEach(log -&gt; log.debug(msg));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建 <code>Main</code> 类（服务使用者，调用方），启动程序查看结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.spi.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LoggerService</span> <span class="variable">service</span> <span class="operator">=</span> LoggerService.getService();</span><br><span class="line"></span><br><span class="line">        service.info(<span class="string">&quot;Hello SPI&quot;</span>);</span><br><span class="line">        service.debug(<span class="string">&quot;Hello SPI&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序结果：</p>
<blockquote>
<p>info 中没有发现 Logger 服务提供者 debug 中没有发现 Logger 服务提供者</p>
</blockquote>
<p>此时我们只是空有接口，并没有为 <code>Logger</code> 接口提供任何的实现，所以输出结果中没有按照预期打印相应的结果。</p>
<p>你可以使用命令或者直接使用 IDEA 将整个程序直接打包成 jar 包。</p>
<h3 id="Service-Provider"><a href="#Service-Provider" class="headerlink" title="Service Provider"></a>Service Provider</h3><p>接下来新建一个项目用来实现 <code>Logger</code> 接口</p>
<p>新建项目 <code>service-provider</code> 目录结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">│  service-provider.iml</span><br><span class="line">│</span><br><span class="line">├─.idea</span><br><span class="line">│  │  .gitignore</span><br><span class="line">│  │  misc.xml</span><br><span class="line">│  │  modules.xml</span><br><span class="line">│  └─ workspace.xml</span><br><span class="line">│</span><br><span class="line">├─lib</span><br><span class="line">│      service-provider-interface.jar</span><br><span class="line">|</span><br><span class="line">└─src</span><br><span class="line">    ├─edu</span><br><span class="line">    │  └─jiangxuan</span><br><span class="line">    │      └─up</span><br><span class="line">    │          └─spi</span><br><span class="line">    │              └─service</span><br><span class="line">    │                      Logback.java</span><br><span class="line">    │</span><br><span class="line">    └─META-INF</span><br><span class="line">        └─services</span><br><span class="line">                edu.jiangxuan.up.spi.Logger</span><br></pre></td></tr></table></figure>

<p>新建 <code>Logback</code> 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> edu.jiangxuan.up.spi.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> edu.jiangxuan.up.spi.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logback</span> <span class="keyword">implements</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Logback info 打印日志：&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Logback debug 打印日志：&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将 <code>service-provider-interface</code> 的 jar 导入项目中。</p>
<p>新建 lib 目录，然后将 jar 包拷贝过来，再添加到项目中。</p>
<p><img src="https://files.catbox.moe/damxc8.png"></p>
<p>接下来就可以在项目中导入 jar 包里面的一些类和方法了，就像 JDK 工具类导包一样的。</p>
<p>实现 <code>Logger</code> 接口，在 <code>src</code> 目录下新建 <code>META-INF/services</code> 文件夹，然后新建文件 <code>edu.jiangxuan.up.spi.Logger</code> （SPI 的全类名），文件里面的内容是：<code>edu.jiangxuan.up.spi.service.Logback</code> （Logback 的全类名，即 SPI 的实现类的包名 + 类名）。</p>
<p><strong>这是 JDK SPI 机制 ServiceLoader 约定好的标准。</strong></p>
<p>这里先大概解释一下：Java 中的 SPI 机制就是在每次类加载的时候会先去找到 class 相对目录下的 <code>META-INF</code> 文件夹下的 services 文件夹下的文件，将这个文件夹下面的所有文件先加载到内存中，然后根据这些文件的文件名和里面的文件内容找到相应接口的具体实现类，找到实现类后就可以通过反射去生成对应的对象，保存在一个 list 列表里面，所以可以通过迭代或者遍历的方式拿到对应的实例对象，生成不同的实现。</p>
<p>所以会提出一些规范要求：文件名一定要是接口的全类名，然后里面的内容一定要是实现类的全类名，实现类可以有过个，直接换行就好了，多个实现类的时候，会一个一个的迭代加载。</p>
<p>接下来同样将 <code>service-provider</code> 项目打包成 jar 包，这个 jar 包就是服务提供方的实现。通常我们导入 maven 的 pom 依赖就有点类似这种，只不过我们现在没有将这个 jar 包发布到 maven 公共仓库中，所以在需要使用的地方只能手动的添加到项目中。</p>
<h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><p>为了更直观的展示效果，我这里再新建一个专门用来测试的工程项目：<code>java-spi-test</code></p>
<p>然后先导入 <code>Logger</code> 的接口 jar 包，再导入具体的实现类的 jar 包。</p>
<p><img src="https://files.catbox.moe/tlz7oe.png"></p>
<p>新建 Main 方法测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> edu.jiangxuan.up.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> edu.jiangxuan.up.spi.LoggerService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJavaSPI</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LoggerService</span> <span class="variable">loggerService</span> <span class="operator">=</span> LoggerService.getService();</span><br><span class="line">        loggerService.info(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">        loggerService.debug(<span class="string">&quot;测试Java SPI 机制&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<blockquote>
<p>Logback info 打印日志：你好 Logback debug 打印日志：测试 Java SPI 机制</p>
</blockquote>
<p>说明导入 jar 包中的实现类生效了。</p>
<p>如果我们不导入具体的实现类的 jar 包，那么此时程序运行的结果就会是：</p>
<blockquote>
<p>info 中没有发现 Logger 服务提供者 debug 中没有发现 Logger 服务提供者</p>
</blockquote>
<p>通过使用 SPI 机制，可以看出服务（<code>LoggerService</code>）和 服务提供者两者之间的耦合度非常低，如果说我们想要换一种实现，那么其实只需要修改 <code>service-provider</code> 项目中针对 <code>Logger</code> 接口的具体实现就可以了，只需要换一个 jar 包即可，也可以有在一个项目里面有多个实现，这不就是 SLF4J 原理吗？</p>
<p>如果某一天需求变更了，此时需要将日志输出到消息队列，或者做一些别的操作，这个时候完全不需要更改 Logback 的实现，只需要新增一个服务实现（service-provider）可以通过在本项目里面新增实现也可以从外部引入新的服务实现 jar 包。我们可以在服务(LoggerService)中选择一个具体的 服务实现(service-provider) 来完成我们需要的操作。</p>
<p>那么接下来我们具体来说说 Java SPI 工作的重点原理—— <strong>ServiceLoader</strong> 。</p>
<h2 id="ServiceLoader"><a href="#ServiceLoader" class="headerlink" title="ServiceLoader"></a>ServiceLoader</h2><h3 id="ServiceLoader-具体实现"><a href="#ServiceLoader-具体实现" class="headerlink" title="ServiceLoader 具体实现"></a>ServiceLoader 具体实现</h3><p>想要使用 Java 的 SPI 机制是需要依赖 <code>ServiceLoader</code> 来实现的，那么我们接下来看看 <code>ServiceLoader</code> 具体是怎么做的：</p>
<p><code>ServiceLoader</code> 是 JDK 提供的一个工具类， 位于<code>package java.util;</code>包下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A facility to load implementations of a service.</span><br></pre></td></tr></table></figure>

<p>这是 JDK 官方给的注释：<strong>一种加载服务实现的工具。</strong></p>
<p>再往下看，我们发现这个类是一个 <code>final</code> 类型的，所以是不可被继承修改，同时它实现了 <code>Iterable</code> 接口。之所以实现了迭代器，是为了方便后续我们能够通过迭代的方式得到对应的服务实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ServiceLoader</span>&lt;S&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;S&gt;&#123; xxx...&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到一个熟悉的常量定义：</p>
<p><code>private static final String PREFIX = &quot;META-INF/services/&quot;;</code></p>
<p>下面是 <code>load</code> 方法：可以发现 <code>load</code> 方法支持两种重载后的入参；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="title function_">load</span><span class="params">(Class&lt;S&gt; service)</span> &#123;</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="title function_">load</span><span class="params">(Class&lt;S&gt; service,</span></span><br><span class="line"><span class="params">                                        ClassLoader loader)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServiceLoader</span>&lt;&gt;(service, loader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">ServiceLoader</span><span class="params">(Class&lt;S&gt; svc, ClassLoader cl)</span> &#123;</span><br><span class="line">    service = Objects.requireNonNull(svc, <span class="string">&quot;Service interface cannot be null&quot;</span>);</span><br><span class="line">    loader = (cl == <span class="literal">null</span>) ? ClassLoader.getSystemClassLoader() : cl;</span><br><span class="line">    acc = (System.getSecurityManager() != <span class="literal">null</span>) ? AccessController.getContext() : <span class="literal">null</span>;</span><br><span class="line">    reload();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reload</span><span class="params">()</span> &#123;</span><br><span class="line">    providers.clear();</span><br><span class="line">    lookupIterator = <span class="keyword">new</span> <span class="title class_">LazyIterator</span>(service, loader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据代码的调用顺序，在 <code>reload()</code> 方法中是通过一个内部类 <code>LazyIterator</code> 实现的。先继续往下面看。</p>
<p><code>ServiceLoader</code> 实现了 <code>Iterable</code> 接口的方法后，具有了迭代的能力，在这个 <code>iterator</code> 方法被调用时，首先会在 <code>ServiceLoader</code> 的 <code>Provider</code> 缓存中进行查找，如果缓存中没有命中那么则在 <code>LazyIterator</code> 中进行查找。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;S&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;S&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Map.Entry&lt;String, S&gt;&gt; knownProviders</span><br><span class="line">                = providers.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (knownProviders.hasNext())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> lookupIterator.hasNext(); <span class="comment">// 调用 LazyIterator</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> S <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (knownProviders.hasNext())</span><br><span class="line">                <span class="keyword">return</span> knownProviders.next().getValue();</span><br><span class="line">            <span class="keyword">return</span> lookupIterator.next(); <span class="comment">// 调用 LazyIterator</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用 <code>LazyIterator</code> 时，具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (acc == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> hasNextService();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        PrivilegedAction&lt;Boolean&gt; action = <span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Boolean&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> Boolean <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> hasNextService();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasNextService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextName != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (configs == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过PREFIX（META-INF/services/）和类名 获取对应的配置文件，得到具体的实现类</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fullName</span> <span class="operator">=</span> PREFIX + service.getName();</span><br><span class="line">            <span class="keyword">if</span> (loader == <span class="literal">null</span>)</span><br><span class="line">                configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                configs = loader.getResources(fullName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">            fail(service, <span class="string">&quot;Error locating configuration files&quot;</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((pending == <span class="literal">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pending = parse(service, configs.nextElement());</span><br><span class="line">    &#125;</span><br><span class="line">    nextName = pending.next();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> S <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (acc == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nextService();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        PrivilegedAction&lt;S&gt; action = <span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;S&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> S <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nextService();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> S <span class="title function_">nextService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasNextService())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">cn</span> <span class="operator">=</span> nextName;</span><br><span class="line">    nextName = <span class="literal">null</span>;</span><br><span class="line">    Class&lt;?&gt; c = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        c = Class.forName(cn, <span class="literal">false</span>, loader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">                <span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; not found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">                <span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; not a subtype&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">S</span> <span class="variable">p</span> <span class="operator">=</span> service.cast(c.newInstance());</span><br><span class="line">        providers.put(cn, p);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">                <span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; could not be instantiated&quot;</span>,</span><br><span class="line">                x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();          <span class="comment">// This cannot happen</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能很多人看这个会觉得有点复杂，没关系，我这边实现了一个简单的 <code>ServiceLoader</code> 的小模型，流程和原理都是保持一致的，可以先从自己实现一个简易版本的开始学：</p>
<h3 id="自己实现一个-ServiceLoader"><a href="#自己实现一个-ServiceLoader" class="headerlink" title="自己实现一个 ServiceLoader"></a>自己实现一个 ServiceLoader</h3><p>我先把代码贴出来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> edu.jiangxuan.up.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLConnection;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServiceLoader</span>&lt;S&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应的接口 Class 模板</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;S&gt; service;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应实现类的 可以有多个，用 List 进行封装</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;S&gt; providers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类加载器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader classLoader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴露给外部使用的方法，通过调用这个方法可以开始加载自己定制的实现流程。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; MyServiceLoader&lt;S&gt; <span class="title function_">load</span><span class="params">(Class&lt;S&gt; service)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyServiceLoader</span>&lt;&gt;(service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">MyServiceLoader</span><span class="params">(Class&lt;S&gt; service)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.service = service;</span><br><span class="line">        <span class="built_in">this</span>.classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        doLoad();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键方法，加载具体实现类的逻辑</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doLoad</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 读取所有 jar 包里面 META-INF/services 包下面的文件，这个文件名就是接口名，然后文件里面的内容就是具体的实现类的路径加全类名</span></span><br><span class="line">            Enumeration&lt;URL&gt; urls = classLoader.getResources(<span class="string">&quot;META-INF/services/&quot;</span> + service.getName());</span><br><span class="line">            <span class="comment">// 挨个遍历取到的文件</span></span><br><span class="line">            <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">                <span class="comment">// 取出当前的文件</span></span><br><span class="line">                <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> urls.nextElement();</span><br><span class="line">                System.out.println(<span class="string">&quot;File = &quot;</span> + url.getPath());</span><br><span class="line">                <span class="comment">// 建立链接</span></span><br><span class="line">                <span class="type">URLConnection</span> <span class="variable">urlConnection</span> <span class="operator">=</span> url.openConnection();</span><br><span class="line">                urlConnection.setUseCaches(<span class="literal">false</span>);</span><br><span class="line">                <span class="comment">// 获取文件输入流</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> urlConnection.getInputStream();</span><br><span class="line">                <span class="comment">// 从文件输入流获取缓存</span></span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream));</span><br><span class="line">                <span class="comment">// 从文件内容里面得到实现类的全类名</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> bufferedReader.readLine();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (className != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 通过反射拿到实现类的实例</span></span><br><span class="line">                    Class&lt;?&gt; clazz = Class.forName(className, <span class="literal">false</span>, classLoader);</span><br><span class="line">                    <span class="comment">// 如果声明的接口跟这个具体的实现类是属于同一类型，（可以理解为Java的一种多态，接口跟实现类、父类和子类等等这种关系。）则构造实例</span></span><br><span class="line">                    <span class="keyword">if</span> (service.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                        Constructor&lt;? <span class="keyword">extends</span> <span class="title class_">S</span>&gt; constructor = (Constructor&lt;? <span class="keyword">extends</span> <span class="title class_">S</span>&gt;) clazz.getConstructor();</span><br><span class="line">                        <span class="type">S</span> <span class="variable">instance</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line">                        <span class="comment">// 把当前构造的实例对象添加到 Provider的列表里面</span></span><br><span class="line">                        providers.add(instance);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 继续读取下一行的实现类，可以有多个实现类，只需要换行就可以了。</span></span><br><span class="line">                    className = bufferedReader.readLine();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;读取文件异常。。。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回spi接口对应的具体实现类列表</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;S&gt; <span class="title function_">getProviders</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> providers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键信息基本已经通过代码注释描述出来了，</p>
<p>主要的流程就是：</p>
<ol>
<li>通过 URL 工具类从 jar 包的 <code>/META-INF/services</code> 目录下面找到对应的文件，</li>
<li>读取这个文件的名称找到对应的 spi 接口，</li>
<li>通过 <code>InputStream</code> 流将文件里面的具体实现类的全类名读取出来，</li>
<li>根据获取到的全类名，先判断跟 spi 接口是否为同一类型，如果是的，那么就通过反射的机制构造对应的实例对象，</li>
<li>将构造出来的实例对象添加到 <code>Providers</code> 的列表中。</li>
</ol>
<h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>其实不难发现，SPI 机制的具体实现本质上还是通过反射完成的。即：<strong>我们按照规定将要暴露对外使用的具体实现类在 META-INF&#x2F;services&#x2F; 文件下声明。</strong></p>
<p>另外，SPI 机制在很多框架中都有应用：Spring 框架的基本原理也是类似的反射。还有 Dubbo 框架提供同样的 SPI 扩展机制，只不过 Dubbo 和 spring 框架中的 SPI 机制具体实现方式跟咱们今天学得这个有些细微的区别，不过整体的原理都是一致的，相信大家通过对 JDK 中 SPI 机制的学习，能够一通百通，加深对其他高深框的理解。</p>
<p>通过 SPI 机制能够大大地提高接口设计的灵活性，但是 SPI 机制也存在一些缺点，比如：</p>
<ol>
<li>遍历加载所有的实现类，这样效率还是相对较低的；</li>
<li>当多个 <code>ServiceLoader</code> 同时 <code>load</code> 时，会有并发问题。</li>
</ol>
<h1 id="Java-语法糖详解"><a href="#Java-语法糖详解" class="headerlink" title="Java 语法糖详解"></a>Java 语法糖详解</h1><p>语法糖是大厂 Java 面试常问的一个知识点。</p>
<p>本文从 Java 编译原理角度，深入字节码及 class 文件，抽丝剥茧，了解 Java 中的语法糖原理及用法，帮助大家在学会如何使用 Java 语法糖的同时，了解这些语法糖背后的原理。</p>
<h2 id="什么是语法糖？"><a href="#什么是语法糖？" class="headerlink" title="什么是语法糖？"></a>什么是语法糖？</h2><p><strong>语法糖（Syntactic Sugar）</strong> 也称糖衣语法，是英国计算机学家 Peter.J.Landin 发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。简而言之，语法糖让程序更加简洁，有更高的可读性。</p>
<p><img src="https://files.catbox.moe/zvllwl.png"></p>
<blockquote>
<p>有意思的是，在编程领域，除了语法糖，还有语法盐和语法糖精的说法，篇幅有限这里不做扩展了。</p>
</blockquote>
<p>我们所熟知的编程语言中几乎都有语法糖。作者认为，语法糖的多少是评判一个语言够不够牛逼的标准之一。很多人说 Java 是一个“低糖语言”，其实从 Java 7 开始 Java 语言层面上一直在添加各种糖，主要是在“Project Coin”项目下研发。尽管现在 Java 有人还是认为现在的 Java 是低糖，未来还会持续向着“高糖”的方向发展。</p>
<h2 id="Java-中有哪些常见的语法糖？"><a href="#Java-中有哪些常见的语法糖？" class="headerlink" title="Java 中有哪些常见的语法糖？"></a>Java 中有哪些常见的语法糖？</h2><p>前面提到过，语法糖的存在主要是方便开发人员使用。但其实， <strong>Java 虚拟机并不支持这些语法糖。这些语法糖在编译阶段就会被还原成简单的基础语法结构，这个过程就是解语法糖。</strong></p>
<p>说到编译，大家肯定都知道，Java 语言中，<code>javac</code>命令可以将后缀名为<code>.java</code>的源文件编译为后缀名为<code>.class</code>的可以运行于 Java 虚拟机的字节码。如果你去看<code>com.sun.tools.javac.main.JavaCompiler</code>的源码，你会发现在<code>compile()</code>中有一个步骤就是调用<code>desugar()</code>，这个方法就是负责解语法糖的实现的。</p>
<p>Java 中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。本文主要来分析下这些语法糖背后的原理。一步一步剥去糖衣，看看其本质。</p>
<p>我们这里会用到<a href="https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&mid=2650120609&idx=1&sn=5659f96310963ad57d55b48cee63c788&chksm=f36bbc80c41c3596a1e4bf9501c6280481f1b9e06d07af354474e6f3ed366fef016df673a7ba&scene=21#wechat_redirect">反编译open in new window</a>，你可以通过 <a href="http://www.javadecompilers.com/">Decompilers onlineopen in new window</a> 对 Class 文件进行在线反编译。</p>
<h3 id="switch-支持-String-与枚举"><a href="#switch-支持-String-与枚举" class="headerlink" title="switch 支持 String 与枚举"></a>switch 支持 String 与枚举</h3><p>前面提到过，从 Java 7 开始，Java 语言中的语法糖在逐渐丰富，其中一个比较重要的就是 Java 7 中<code>switch</code>开始支持<code>String</code>。</p>
<p>在开始之前先科普下，Java 中的<code>switch</code>自身原本就支持基本类型。比如<code>int</code>、<code>char</code>等。对于<code>int</code>类型，直接进行数值的比较。对于<code>char</code>类型则是比较其 ascii 码。所以，对于编译器来说，<code>switch</code>中其实只能使用整型，任何类型的比较都要转换成整型。比如<code>byte</code>。<code>short</code>，<code>char</code>(ackii 码是整型)以及<code>int</code>。</p>
<p>那么接下来看下<code>switch</code>对<code>String</code>得支持，有以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">switchDemoString</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (str) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;hello&quot;</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;world&quot;</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译后内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">switchDemoString</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">switchDemoString</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">switch</span>((s = str).hashCode())</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">99162322</span>:</span><br><span class="line">            <span class="keyword">if</span>(s.equals(<span class="string">&quot;hello&quot;</span>))</span><br><span class="line">                System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">113318802</span>:</span><br><span class="line">            <span class="keyword">if</span>(s.equals(<span class="string">&quot;world&quot;</span>))</span><br><span class="line">                System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这个代码，你知道原来 <strong>字符串的 switch 是通过equals()和hashCode()方法来实现的。</strong> 还好<code>hashCode()</code>方法返回的是<code>int</code>，而不是<code>long</code>。</p>
<p>仔细看下可以发现，进行<code>switch</code>的实际是哈希值，然后通过使用<code>equals</code>方法比较进行安全检查，这个检查是必要的，因为哈希可能会发生碰撞。因此它的性能是不如使用枚举进行 <code>switch</code> 或者使用纯整数常量，但这也不是很差。</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>我们都知道，很多语言都是支持泛型的，但是很多人不知道的是，不同的编译器对于泛型的处理方式是不同的，通常情况下，一个编译器处理泛型有两种方式：<code>Code specialization</code>和<code>Code sharing</code>。C++和 C#是使用<code>Code specialization</code>的处理机制，而 Java 使用的是<code>Code sharing</code>的机制。</p>
<blockquote>
<p>Code sharing 方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（<code>type erasue</code>）实现的。</p>
</blockquote>
<p>也就是说，<strong>对于 Java 虚拟机来说，他根本不认识Map&lt;String, String&gt; map这样的语法。需要在编译阶段通过类型擦除的方式进行解语法糖。</strong></p>
<p>类型擦除的主要过程如下： 1.将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。 2.移除所有的类型参数。</p>
<p>以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hollis&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;wechat&quot;</span>, <span class="string">&quot;Hollis&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;blog&quot;</span>, <span class="string">&quot;www.hollischuang.com&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>解语法糖之后会变成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hollis&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;wechat&quot;</span>, <span class="string">&quot;Hollis&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;blog&quot;</span>, <span class="string">&quot;www.hollischuang.com&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;A <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;A&gt;&gt; A <span class="title function_">max</span><span class="params">(Collection&lt;A&gt; xs)</span> &#123;</span><br><span class="line">    Iterator&lt;A&gt; xi = xs.iterator();</span><br><span class="line">    <span class="type">A</span> <span class="variable">w</span> <span class="operator">=</span> xi.next();</span><br><span class="line">    <span class="keyword">while</span> (xi.hasNext()) &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">x</span> <span class="operator">=</span> xi.next();</span><br><span class="line">        <span class="keyword">if</span> (w.compareTo(x) &lt; <span class="number">0</span>)</span><br><span class="line">            w = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型擦除后会变成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Comparable <span class="title function_">max</span><span class="params">(Collection xs)</span>&#123;</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">xi</span> <span class="operator">=</span> xs.iterator();</span><br><span class="line">    <span class="type">Comparable</span> <span class="variable">w</span> <span class="operator">=</span> (Comparable)xi.next();</span><br><span class="line">    <span class="keyword">while</span>(xi.hasNext())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Comparable</span> <span class="variable">x</span> <span class="operator">=</span> (Comparable)xi.next();</span><br><span class="line">        <span class="keyword">if</span>(w.compareTo(x) &lt; <span class="number">0</span>)</span><br><span class="line">            w = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>虚拟机中没有泛型，只有普通类和普通方法，所有泛型类的类型参数在编译时都会被擦除，泛型类并没有自己独有的Class类对象。比如并不存在List<String>.class或是List<Integer>.class，而只有List.class。</strong></p>
<h3 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h3><p>自动装箱就是 Java 自动将原始类型值转换成对应的对象，比如将 int 的变量转换成 Integer 对象，这个过程叫做装箱，反之将 Integer 对象转换成 int 类型值，这个过程叫做拆箱。因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。原始类型 byte, short, char, int, long, float, double 和 boolean 对应的封装类为 Byte, Short, Character, Integer, Long, Float, Double, Boolean。</p>
<p>先来看个自动装箱的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译后代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> Integer.valueOf(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看个自动拆箱的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译后代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="number">10</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i.intValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从反编译得到内容可以看出，在装箱的时候自动调用的是<code>Integer</code>的<code>valueOf(int)</code>方法。而在拆箱的时候自动调用的是<code>Integer</code>的<code>intValue</code>方法。</p>
<p>所以，<strong>装箱过程是通过调用包装器的 valueOf 方法实现的，而拆箱过程是通过调用包装器的 xxxValue 方法实现的。</strong></p>
<h3 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h3><p>可变参数(<code>variable arguments</code>)是在 Java 1.5 中引入的一个特性。它允许一个方法把任意数量的值作为参数。</p>
<p>看下以下可变参数代码，其中 <code>print</code> 方法接收可变参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        print(<span class="string">&quot;Holis&quot;</span>, <span class="string">&quot;公众号:Hollis&quot;</span>, <span class="string">&quot;博客：www.hollischuang.com&quot;</span>, <span class="string">&quot;QQ：907607222&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String... strs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(strs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译后代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="keyword">new</span> <span class="title class_">String</span>[] &#123;</span><br><span class="line">        <span class="string">&quot;Holis&quot;</span>, <span class="string">&quot;\u516C\u4F17\u53F7:Hollis&quot;</span>, <span class="string">&quot;\u535A\u5BA2\uFF1Awww.hollischuang.com&quot;</span>, <span class="string">&quot;QQ\uFF1A907607222&quot;</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">transient</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String strs[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs.length; i++)</span><br><span class="line">        System.out.println(strs[i]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从反编译后代码可以看出，可变参数在被使用的时候，他首先会创建一个数组，数组的长度就是调用该方法是传递的实参的个数，然后再把参数值全部放到这个数组当中，然后再把这个数组作为参数传递到被调用的方法中。</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>Java SE5 提供了一种新的类型-Java 的枚举类型，关键字<code>enum</code>可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用，这是一种非常有用的功能。</p>
<p>要想看源码，首先得有一个类吧，那么枚举类型到底是什么类呢？是<code>enum</code>吗？答案很明显不是，<code>enum</code>就和<code>class</code>一样，只是一个关键字，他并不是一个类，那么枚举是由什么类维护的呢，我们简单的写一个枚举：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">t</span> &#123;</span><br><span class="line">    SPRING,SUMMER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们使用反编译，看看这段代码到底是怎么实现的，反编译后代码内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Enum</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">T</span><span class="params">(String s, <span class="type">int</span> i)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T[] values()</span><br><span class="line">    &#123;</span><br><span class="line">        T at[];</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        T at1[];</span><br><span class="line">        System.arraycopy(at = ENUM$VALUES, <span class="number">0</span>, at1 = <span class="keyword">new</span> <span class="title class_">T</span>[i = at.length], <span class="number">0</span>, i);</span><br><span class="line">        <span class="keyword">return</span> at1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T <span class="title function_">valueOf</span><span class="params">(String s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (T)Enum.valueOf(demo/T, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> T SPRING;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> T SUMMER;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> T ENUM$VALUES[];</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        SPRING = <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;SPRING&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        SUMMER = <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;SUMMER&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        ENUM$VALUES = (<span class="keyword">new</span> <span class="title class_">T</span>[] &#123;</span><br><span class="line">            SPRING, SUMMER</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过反编译后代码我们可以看到，<code>public final class T extends Enum</code>，说明，该类是继承了<code>Enum</code>类的，同时<code>final</code>关键字告诉我们，这个类也是不能被继承的。</p>
<p><strong>当我们使用enum来定义一个枚举类型的时候，编译器会自动帮我们创建一个final类型的类继承Enum类，所以枚举类型不能被继承。</strong></p>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类又称为嵌套类，可以把内部类理解为外部类的一个普通成员。</p>
<p><strong>内部类之所以也是语法糖，是因为它仅仅是一个编译时的概念，outer.java里面定义了一个内部类inner，一旦编译成功，就会生成两个完全不同的.class文件了，分别是outer.class和outer$inner.class。所以内部类的名字完全可以和它的外部类名字相同。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutterClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserName</span><span class="params">(String userName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerClass</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码编译后会生成两个 class 文件：<code>OutterClass$InnerClass.class</code> 、<code>OutterClass.class</code> 。当我们尝试对<code>OutterClass.class</code>文件进行反编译的时候，命令行会打印以下内容：<code>Parsing OutterClass.class...Parsing inner class OutterClass$InnerClass.class... Generating OutterClass.jad</code> 。他会把两个文件全部进行反编译，然后一起生成一个<code>OutterClass.jad</code>文件。文件内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutterClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerClass</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">final</span> OutterClass <span class="built_in">this</span>$<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        InnerClass()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">this</span>.<span class="built_in">this</span>$<span class="number">0</span> = OutterClass.<span class="built_in">this</span>;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OutterClass</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserName</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserName</span><span class="params">(String userName)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args1[])</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><p>—般情况下，程序中的每一行代码都要参加编译。但有时候出于对程序代码优化的考虑，希望只对其中一部分内容进行编译，此时就需要在程序中加上条件，让编译器只对满足条件的代码进行编译，将不满足条件的代码舍弃，这就是条件编译。</p>
<p>如在 C 或 CPP 中，可以通过预处理语句来实现条件编译。其实在 Java 中也可实现条件编译。我们先来看一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionalCompilation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">DEBUG</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(DEBUG) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, DEBUG!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">ONLINE</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ONLINE)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, ONLINE!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译后代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionalCompilation</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConditionalCompilation</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">DEBUG</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, DEBUG!&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ONLINE</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，我们发现，在反编译后的代码中没有<code>System.out.println(&quot;Hello, ONLINE!&quot;);</code>，这其实就是条件编译。当<code>if(ONLINE)</code>为 false 的时候，编译器就没有对其内的代码进行编译。</p>
<p>所以，<strong>Java 语法的条件编译，是通过判断条件为常量的 if 语句实现的。其原理也是 Java 语言的语法糖。根据 if 判断条件的真假，编译器直接把分支为 false 的代码块消除。通过该方式实现的条件编译，必须在方法体内实现，而无法在正整个 Java 类的结构或者类的属性上进行条件编译，这与 C&#x2F;C++的条件编译相比，确实更有局限性。在 Java 语言设计之初并没有引入条件编译的功能，虽有局限，但是总比没有更强。</strong></p>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>在 Java 中，<code>assert</code>关键字是从 JAVA SE 1.4 引入的，为了避免和老版本的 Java 代码中使用了<code>assert</code>关键字导致错误，Java 在执行的时候默认是不启动断言检查的（这个时候，所有的断言语句都将忽略！），如果要开启断言检查，则需要用开关<code>-enableassertions</code>或<code>-ea</code>来开启。</p>
<p>看一段包含断言的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AssertTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">assert</span> <span class="variable">a</span> <span class="operator">=</span>= b;</span><br><span class="line">        System.out.println(<span class="string">&quot;公众号：Hollis&quot;</span>);</span><br><span class="line">        <span class="keyword">assert</span> a != b : <span class="string">&quot;Hollis&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;博客：www.hollischuang.com&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译后代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AssertTest</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">AssertTest</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!$assertionsDisabled &amp;&amp; a != b)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;\u516C\u4F17\u53F7\uFF1AHollis&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!$assertionsDisabled &amp;&amp; a == b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;Hollis&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\u535A\u5BA2\uFF1Awww.hollischuang.com&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">$assertionsDisabled</span> <span class="operator">=</span> !com/hollis/suguar/AssertTest.desiredAssertionStatus();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显，反编译之后的代码要比我们自己的代码复杂的多。所以，使用了 assert 这个语法糖我们节省了很多代码。<strong>其实断言的底层实现就是 if 语言，如果断言结果为 true，则什么都不做，程序继续执行，如果断言结果为 false，则程序抛出 AssertError 来打断程序的执行。</strong><code>-enableassertions</code>会设置$assertionsDisabled 字段的值。</p>
<h3 id="数值字面量"><a href="#数值字面量" class="headerlink" title="数值字面量"></a>数值字面量</h3><p>在 java 7 中，数值字面量，不管是整数还是浮点数，都允许在数字之间插入任意多个下划线。这些下划线不会对字面量的数值产生影响，目的就是方便阅读。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10_000</span>;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译后就是把<code>_</code>删除了。也就是说 <strong>编译器并不认识在数字字面量中的_，需要在编译阶段把他去掉。</strong></p>
<h3 id="for-each"><a href="#for-each" class="headerlink" title="for-each"></a>for-each</h3><p>增强 for 循环（<code>for-each</code>）相信大家都不陌生，日常开发经常会用到的，他会比 for 循环要少写很多代码，那么这个语法糖背后是如何实现的呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">    String[] strs = &#123;<span class="string">&quot;Hollis&quot;</span>, <span class="string">&quot;公众号：Hollis&quot;</span>, <span class="string">&quot;博客：www.hollischuang.com&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (String s : strs) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; strList = ImmutableList.of(<span class="string">&quot;Hollis&quot;</span>, <span class="string">&quot;公众号：Hollis&quot;</span>, <span class="string">&quot;博客：www.hollischuang.com&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : strList) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译后代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">transient</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">&#123;</span><br><span class="line">    String strs[] = &#123;</span><br><span class="line">        <span class="string">&quot;Hollis&quot;</span>, <span class="string">&quot;\u516C\u4F17\u53F7\uFF1AHollis&quot;</span>, <span class="string">&quot;\u535A\u5BA2\uFF1Awww.hollischuang.com&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    String args1[] = strs;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> args1.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> args1[j];</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">List</span> <span class="variable">strList</span> <span class="operator">=</span> ImmutableList.of(<span class="string">&quot;Hollis&quot;</span>, <span class="string">&quot;\u516C\u4F17\u53F7\uFF1AHollis&quot;</span>, <span class="string">&quot;\u535A\u5BA2\uFF1Awww.hollischuang.com&quot;</span>);</span><br><span class="line">    String s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> strList.iterator(); iterator.hasNext(); System.out.println(s))</span><br><span class="line">        s = (String)iterator.next();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，<strong>for-each 的实现原理其实就是使用了普通的 for 循环和迭代器。</strong></p>
<h3 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a>try-with-resource</h3><p>Java 里，对于文件操作 IO 流、数据库连接等开销非常昂贵的资源，用完之后必须及时通过 close 方法将其关闭，否则资源会一直处于打开状态，可能会导致内存泄露等问题。</p>
<p>关闭资源的常用方式就是在<code>finally</code>块里是释放，即调用<code>close</code>方法。比如，我们经常会写这样的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String line;</span><br><span class="line">        br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;d:\\hollischuang.xml&quot;</span>));</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// handle exception</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (br != <span class="literal">null</span>) &#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="comment">// handle exception</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 Java 7 开始，jdk 提供了一种更好的方式关闭资源，使用<code>try-with-resources</code>语句，改写一下上面的代码，效果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;d:\\ hollischuang.xml&quot;</span>))) &#123;</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// handle exception</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看，这简直是一大福音啊，虽然我之前一般使用<code>IOUtils</code>去关闭流，并不会使用在<code>finally</code>中写很多代码的方式，但是这种新的语法糖看上去好像优雅很多呢。看下他的背后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">transient</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">    &#123;</span><br><span class="line">        BufferedReader br;</span><br><span class="line">        Throwable throwable;</span><br><span class="line">        br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;d:\\ hollischuang.xml&quot;</span>));</span><br><span class="line">        throwable = <span class="literal">null</span>;</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>((line = br.readLine()) != <span class="literal">null</span>)</span><br><span class="line">                System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Throwable throwable2)</span><br><span class="line">        &#123;</span><br><span class="line">            throwable = throwable2;</span><br><span class="line">            <span class="keyword">throw</span> throwable2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(br != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">if</span>(throwable != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span>(Throwable throwable1)</span><br><span class="line">                &#123;</span><br><span class="line">                    throwable.addSuppressed(throwable1);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                br.close();</span><br><span class="line">            <span class="keyword">break</span> MISSING_BLOCK_LABEL_113;</span><br><span class="line">            Exception exception;</span><br><span class="line">            exception;</span><br><span class="line">            <span class="keyword">if</span>(br != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">if</span>(throwable != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        br.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span>(Throwable throwable3)</span><br><span class="line">                      &#123;</span><br><span class="line">                        throwable.addSuppressed(throwable3);</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    br.close();</span><br><span class="line">        <span class="keyword">throw</span> exception;</span><br><span class="line">        IOException ioexception;</span><br><span class="line">        ioexception;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其实背后的原理也很简单，那些我们没有做的关闭资源的操作，编译器都帮我们做了。所以，再次印证了，语法糖的作用就是方便程序员的使用，但最终还是要转成编译器认识的语言。</strong></p>
<h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><p>关于 lambda 表达式，有人可能会有质疑，因为网上有人说他并不是语法糖。其实我想纠正下这个说法。<strong>Labmda 表达式不是匿名内部类的语法糖，但是他也是一个语法糖。实现方式其实是依赖了几个 JVM 底层提供的 lambda 相关 api。</strong></p>
<p>先来看一个简单的 lambda 表达式。遍历一个 list：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; strList = ImmutableList.of(<span class="string">&quot;Hollis&quot;</span>, <span class="string">&quot;公众号：Hollis&quot;</span>, <span class="string">&quot;博客：www.hollischuang.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    strList.forEach( s -&gt; &#123; System.out.println(s); &#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为啥说他并不是内部类的语法糖呢，前面讲内部类我们说过，内部类在编译之后会有两个 class 文件，但是，包含 lambda 表达式的类编译后只有一个文件。</p>
<p>反编译后代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="comment">/* varargs */</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String ... args)</span> &#123;</span><br><span class="line">    <span class="type">ImmutableList</span> <span class="variable">strList</span> <span class="operator">=</span> ImmutableList.of((Object)<span class="string">&quot;Hollis&quot;</span>, (Object)<span class="string">&quot;\u516c\u4f17\u53f7\uff1aHollis&quot;</span>, (Object)<span class="string">&quot;\u535a\u5ba2\uff1awww.hollischuang.com&quot;</span>);</span><br><span class="line">    strList.forEach((Consumer&lt;String&gt;)LambdaMetafactory.metafactory(<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, (Ljava/lang/Object;)V, lambda$main$<span class="number">0</span>(java.lang.String ), (Ljava/lang/String;)V)());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="comment">/* synthetic */</span> <span class="keyword">void</span> lambda$main$<span class="number">0</span>(String s) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在<code>forEach</code>方法中，其实是调用了<code>java.lang.invoke.LambdaMetafactory#metafactory</code>方法，该方法的第四个参数 <code>implMethod</code> 指定了方法实现。可以看到这里其实是调用了一个<code>lambda$main$0</code>方法进行了输出。</p>
<p>再来看一个稍微复杂一点的，先对 List 进行过滤，然后再输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; strList = ImmutableList.of(<span class="string">&quot;Hollis&quot;</span>, <span class="string">&quot;公众号：Hollis&quot;</span>, <span class="string">&quot;博客：www.hollischuang.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">List</span> <span class="variable">HollisList</span> <span class="operator">=</span> strList.stream().filter(string -&gt; string.contains(<span class="string">&quot;Hollis&quot;</span>)).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    HollisList.forEach( s -&gt; &#123; System.out.println(s); &#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译后代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="comment">/* varargs */</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String ... args)</span> &#123;</span><br><span class="line">    <span class="type">ImmutableList</span> <span class="variable">strList</span> <span class="operator">=</span> ImmutableList.of((Object)<span class="string">&quot;Hollis&quot;</span>, (Object)<span class="string">&quot;\u516c\u4f17\u53f7\uff1aHollis&quot;</span>, (Object)<span class="string">&quot;\u535a\u5ba2\uff1awww.hollischuang.com&quot;</span>);</span><br><span class="line">    List&lt;Object&gt; HollisList = strList.stream().filter((Predicate&lt;String&gt;)LambdaMetafactory.metafactory(<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, (Ljava/lang/Object;)Z, lambda$main$<span class="number">0</span>(java.lang.String ), (Ljava/lang/String;)Z)()).collect(Collectors.toList());</span><br><span class="line">    HollisList.forEach((Consumer&lt;Object&gt;)LambdaMetafactory.metafactory(<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, (Ljava/lang/Object;)V, lambda$main$<span class="number">1</span>(java.lang.Object ), (Ljava/lang/Object;)V)());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="comment">/* synthetic */</span> <span class="keyword">void</span> lambda$main$<span class="number">1</span>(Object s) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="comment">/* synthetic */</span> <span class="type">boolean</span> lambda$main$<span class="number">0</span>(String string) &#123;</span><br><span class="line">    <span class="keyword">return</span> string.contains(<span class="string">&quot;Hollis&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个 lambda 表达式分别调用了<code>lambda$main$1</code>和<code>lambda$main$0</code>两个方法。</p>
<p><strong>所以，lambda 表达式的实现其实是依赖了一些底层的 api，在编译阶段，编译器会把 lambda 表达式进行解糖，转换成调用内部 api 的方式。</strong></p>
<h2 id="可能遇到的坑"><a href="#可能遇到的坑" class="headerlink" title="可能遇到的坑"></a>可能遇到的坑</h2><h3 id="泛型-1"><a href="#泛型-1" class="headerlink" title="泛型"></a>泛型</h3><p><strong>一、当泛型遇到重载</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericTypes</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;invoke method(List&lt;String&gt; list)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;invoke method(List&lt;Integer&gt; list)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码，有两个重载的函数，因为他们的参数类型不同，一个是<code>List&lt;String&gt;</code>另一个是<code>List&lt;Integer&gt;</code> ，但是，这段代码是编译通不过的。因为我们前面讲过，参数<code>List&lt;Integer&gt;</code>和<code>List&lt;String&gt;</code>编译之后都被擦除了，变成了一样的原生类型 List，擦除动作导致这两个方法的特征签名变得一模一样。</p>
<p><strong>二、当泛型遇到 catch</strong></p>
<p>泛型的类型参数不能用在 Java 异常处理的 catch 语句中。因为异常处理是由 JVM 在运行时刻来进行的。由于类型信息被擦除，JVM 是无法区分两个异常类型<code>MyException&lt;String&gt;</code>和<code>MyException&lt;Integer&gt;</code>的</p>
<p><strong>三、当泛型内包含静态变量</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        GT&lt;Integer&gt; gti = <span class="keyword">new</span> <span class="title class_">GT</span>&lt;Integer&gt;();</span><br><span class="line">        gti.<span class="keyword">var</span>=<span class="number">1</span>;</span><br><span class="line">        GT&lt;String&gt; gts = <span class="keyword">new</span> <span class="title class_">GT</span>&lt;String&gt;();</span><br><span class="line">        gts.<span class="keyword">var</span>=<span class="number">2</span>;</span><br><span class="line">        System.out.println(gti.<span class="keyword">var</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GT</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="keyword">var</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nothing</span><span class="params">(T x)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码输出结果为：2！</p>
<p>由于经过类型擦除，所有的泛型类实例都关联到同一份字节码上，泛型类的所有静态变量是共享的。</p>
<h3 id="自动装箱与拆箱-1"><a href="#自动装箱与拆箱-1" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h3><p><strong>对象相等比较</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;a == b is &quot;</span> + (a == b));</span><br><span class="line">    System.out.println((<span class="string">&quot;c == d is &quot;</span> + (c == d)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a == b is <span class="type">false</span></span><br><span class="line"><span class="variable">c</span> <span class="operator">=</span>= d is <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>在 Java 5 中，在 Integer 的操作上引入了一个新功能来节省内存和提高性能。整型对象通过使用相同的对象引用实现了缓存和重用。</p>
<blockquote>
<p>适用于整数值区间-128 至 +127。</p>
<p>只适用于自动装箱。使用构造函数创建对象不适用。</p>
</blockquote>
<h3 id="增强-for-循环"><a href="#增强-for-循环" class="headerlink" title="增强 for 循环"></a>增强 for 循环</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Student stu : students) &#123;</span><br><span class="line">    <span class="keyword">if</span> (stu.getId() == <span class="number">2</span>)</span><br><span class="line">        students.remove(stu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会抛出<code>ConcurrentModificationException</code>异常。</p>
<p>Iterator 是工作在一个独立的线程中，并且拥有一个 mutex 锁。 Iterator 被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 Iterator 会马上抛出<code>java.util.ConcurrentModificationException</code>异常。</p>
<p>所以 <code>Iterator</code> 在工作的时候是不允许被迭代的对象被改变的。但你可以使用 <code>Iterator</code> 本身的方法<code>remove()</code>来删除对象，<code>Iterator.remove()</code> 方法会在删除当前迭代对象的同时维护索引的一致性。</p>
<p><img src="https://files.catbox.moe/njpo1e.png"></p>
<h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><p>前面介绍了 12 种 Java 中常用的语法糖。所谓语法糖就是提供给开发人员便于开发的一种语法而已。但是这种语法只有开发人员认识。要想被执行，需要进行解糖，即转成 JVM 认识的语法。当我们把语法糖解糖之后，你就会发现其实我们日常使用的这些方便的语法，其实都是一些其他更简单的语法构成的。</p>
<p>有了这些语法糖，我们在日常开发的时候可以大大提升效率，但是同时也要避免过渡使用。使用之前最好了解下原理，避免掉坑。</p>
]]></content>
  </entry>
  <entry>
    <title>Java面试</title>
    <url>/2022/08/22/Java%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h1 id="Java基础常见面试题总结-上"><a href="#Java基础常见面试题总结-上" class="headerlink" title="Java基础常见面试题总结(上)"></a>Java基础常见面试题总结(上)</h1><h2 id="基础概念与常识"><a href="#基础概念与常识" class="headerlink" title="基础概念与常识"></a>基础概念与常识</h2><h3 id="Java-语言有哪些特点"><a href="#Java-语言有哪些特点" class="headerlink" title="Java 语言有哪些特点?"></a>Java 语言有哪些特点?</h3><ol>
<li>简单易学；</li>
<li>面向对象（封装，继承，多态）；</li>
<li>平台无关性（ Java 虚拟机实现平台无关性）；</li>
<li>支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；</li>
<li>可靠性；</li>
<li>安全性；</li>
<li>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；</li>
<li>编译与解释并存；</li>
</ol>
<blockquote>
<p><strong>🐛 修正（参见： issue#544open in new window）</strong> ：C++11 开始（2011 年的时候）,C++就引入了多线程库，在 windows、linux、macos 都可以使用<code>std::thread</code>和<code>std::async</code>来创建线程。参考链接：<a href="http://www.cplusplus.com/reference/thread/thread/?kw=thread">http://www.cplusplus.com/reference/thread/thread/?kw=thread</a></p>
</blockquote>
<p>“Write Once, Run Anywhere（一次编写，随处运行）”这句宣传口号，真心经典，流传了好多年！以至于，直到今天，依然有很多人觉得跨平台是 Java 语言最大的优势。实际上，跨平台已经不是 Java 最大的卖点了，各种 JDK 新特性也不是。目前市面上虚拟化技术已经非常成熟，比如你通过 Docker 就很容易实现跨平台了。在我看来，Java 强大的生态才是！</p>
<h3 id="JVM-vs-JDK-vs-JRE"><a href="#JVM-vs-JDK-vs-JRE" class="headerlink" title="JVM vs JDK vs JRE"></a>JVM vs JDK vs JRE</h3><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a><a href="https://javaguide.cn/java/basis/java-basic-questions-01.html#jvm"></a>JVM</h4><p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p>
<p><strong>JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。</strong> 也就是说我们平时接触到的 HotSpot VM 仅仅是是 JVM 规范的一种实现而已。</p>
<p>除了我们平时最常用的 HotSpot VM 外，还有 J9 VM、Zing VM、JRockit VM 等 JVM 。维基百科上就有常见 JVM 的对比：<a href="https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines">Comparison of Java virtual machinesopen in new window</a> ，感兴趣的可以去看看。并且，你可以在 <a href="https://docs.oracle.com/javase/specs/index.html">Java SE Specificationsopen in new window</a> 上找到各个版本的 JDK 对应的 JVM 规范。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/JavaSeSpecifications.jpg" alt="img"></p>
<h4 id="JDK-和-JRE"><a href="#JDK-和-JRE" class="headerlink" title="JDK 和 JRE"></a>JDK 和 JRE</h4><p>JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p>
<p>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p>
<p>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。</p>
<h3 id="什么是字节码-采用字节码的好处是什么"><a href="#什么是字节码-采用字节码的好处是什么" class="headerlink" title="什么是字节码?采用字节码的好处是什么?"></a>什么是字节码?采用字节码的好处是什么?</h3><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为\ <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的（不过，和 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
<p><strong>Java 程序从源代码到运行的过程如下图所示：</strong></p>
<p><img src="https://files.catbox.moe/bo7syi.png"></p>
<p>我们需要格外注意的是 <code>.class-&gt;机器码</code> 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong> 。</p>
<blockquote>
<p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。</p>
</blockquote>
<h3 id="为什么不全部使用-AOT-呢？"><a href="#为什么不全部使用-AOT-呢？" class="headerlink" title="为什么不全部使用 AOT 呢？"></a>为什么不全部使用 AOT 呢？</h3><p>AOT 可以提前编译节省启动时间，那为什么不全部使用这种编译方式呢？</p>
<p>长话短说，这和 Java 语言的动态特性有千丝万缕的联系了。举个例子，CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 <code>.class</code> 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。</p>
<h3 id="为什么说-Java-语言“编译与解释并存”？"><a href="#为什么说-Java-语言“编译与解释并存”？" class="headerlink" title="为什么说 Java 语言“编译与解释并存”？"></a>为什么说 Java 语言“编译与解释并存”？</h3><p>其实这个问题我们讲字节码的时候已经提到过，因为比较重要，所以我们这里再提一下。</p>
<p>我们可以将高级编程语言按照程序的执行方式分为两种：</p>
<ul>
<li><strong>编译型</strong> ：<a href="https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E8%AA%9E%E8%A8%80">编译型语言open in new window</a> 会通过<a href="https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E5%99%A8">编译器open in new window</a>将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。</li>
<li><strong>解释型</strong> ：<a href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E8%AA%9E%E8%A8%80">解释型语言open in new window</a>会通过<a href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E5%99%A8">解释器open in new window</a>一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。</li>
</ul>
<p><img src="https://files.catbox.moe/t9pgw1.png"></p>
<p>根据维基百科介绍：</p>
<blockquote>
<p>为了改善编译语言的效率而发展出的<a href="https://zh.wikipedia.org/wiki/%E5%8D%B3%E6%99%82%E7%B7%A8%E8%AD%AF">即时编译open in new window</a>技术，已经缩小了这两种语言间的差距。这种技术混合了编译语言与解释型语言的优点，它像编译语言一样，先把程序源代码编译成<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E7%A0%81">字节码open in new window</a>。到执行期时，再将字节码直译，之后执行。<a href="https://zh.wikipedia.org/wiki/Java">Javaopen in new window</a>与<a href="https://zh.wikipedia.org/wiki/LLVM">LLVMopen in new window</a>是这种技术的代表产物。</p>
<p>相关阅读：<a href="https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html">基本功 | Java 即时编译器原理解析及实践open in new window</a></p>
</blockquote>
<p><strong>为什么说 Java 语言“编译与解释并存”？</strong></p>
<p>这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。</p>
<h3 id="Oracle-JDK-vs-OpenJDK"><a href="#Oracle-JDK-vs-OpenJDK" class="headerlink" title="Oracle JDK vs OpenJDK"></a>Oracle JDK vs OpenJDK</h3><p>可能在看这个问题之前很多人和我一样并没有接触和使用过 OpenJDK 。那么 Oracle JDK 和 OpenJDK 之间是否存在重大差异？下面我通过收集到的一些资料，为你解答这个被很多人忽视的问题。</p>
<p>对于 Java 7，没什么关键的地方。OpenJDK 项目主要基于 Sun 捐赠的 HotSpot 源代码。此外，OpenJDK 被选为 Java 7 的参考实现，由 Oracle 工程师维护。关于 JVM，JDK，JRE 和 OpenJDK 之间的区别，Oracle 博客帖子在 2012 年有一个更详细的答案：</p>
<blockquote>
<p>问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？</p>
<p>答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些闭源的第三方组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。</p>
</blockquote>
<p><strong>总结：</strong>（提示：下面括号内的内容是基于原文补充说明的，因为原文太过于晦涩难懂，用人话重新解释了下，如果你看得懂里面的术语，可以忽略括号解释的内容）</p>
<ol>
<li>Oracle JDK 大概每 6 个月发一次主要版本（从 2014 年 3 月 JDK 8 LTS 发布到 2017 年 9 月 JDK 9 发布经历了长达 3 年多的时间，所以并不总是 6 个月），而 OpenJDK 版本大概每三个月发布一次。但这不是固定的，我觉得了解这个没啥用处。详情参见：<a href="https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence">https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadenceopen in new window</a> 。</li>
<li>OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的；（个人观点：众所周知，JDK 原来是 SUN 公司开发的，后来 SUN 公司又卖给了 Oracle 公司，Oracle 公司以 Oracle 数据库而著名，而 Oracle 数据库又是闭源的，这个时候 Oracle 公司就不想完全开源了，但是原来的 SUN 公司又把 JDK 给开源了，如果这个时候 Oracle 收购回来之后就把他给闭源，必然会引其很多 Java 开发者的不满，导致大家对 Java 失去信心，那 Oracle 公司收购回来不就把 Java 烂在手里了吗！然后，Oracle 公司就想了个骚操作，这样吧，我把一部分核心代码开源出来给你们玩，并且我要和你们自己搞的 JDK 区分下，你们叫 OpenJDK，我叫 Oracle JDK，我发布我的，你们继续玩你们的，要是你们搞出来什么好玩的东西，我后续发布 Oracle JDK 也会拿来用一下，一举两得！）OpenJDK 开源项目：<a href="https://github.com/openjdk/jdk">https://github.com/openjdk/jdkopen in new window</a></li>
<li>Oracle JDK 比 OpenJDK 更稳定（肯定啦，Oracle JDK 由 Oracle 内部团队进行单独研发的，而且发布时间比 OpenJDK 更长，质量更有保障）。OpenJDK 和 Oracle JDK 的代码几乎相同（OpenJDK 的代码是从 Oracle JDK 代码派生出来的，可以理解为在 Oracle JDK 分支上拉了一条新的分支叫 OpenJDK，所以大部分代码相同），但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业&#x2F;商业软件，我建议您选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题；</li>
<li>在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能；</li>
<li>Oracle JDK 不会为即将发布的版本提供长期支持（如果是 LTS 长期支持版本的话也会，比如 JDK 8，但并不是每个版本都是 LTS 版本），用户每次都必须通过更新到最新版本获得支持来获取最新版本；</li>
<li>Oracle JDK 使用 BCL&#x2F;OTN 协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。</li>
</ol>
<blockquote>
<p>既然 Oracle JDK 这么好，那为什么还要有 OpenJDK？</p>
<p>答：</p>
<ol>
<li>OpenJDK 是开源的，开源意味着你可以对它根据你自己的需要进行修改、优化，比如 Alibaba 基于 OpenJDK 开发了 Dragonwell8：<a href="https://github.com/alibaba/dragonwell8">https://github.com/alibaba/dragonwell8open in new window</a></li>
<li>OpenJDK 是商业免费的（这也是为什么通过 yum 包管理器上默认安装的 JDK 是 OpenJDK 而不是 Oracle JDK）。虽然 Oracle JDK 也是商业免费（比如 JDK 8），但并不是所有版本都是免费的。</li>
<li>OpenJDK 更新频率更快。Oracle JDK 一般是每 6 个月发布一个新版本，而 OpenJDK 一般是每 3 个月发布一个新版本。（现在你知道为啥 Oracle JDK 更稳定了吧，先在 OpenJDK 试试水，把大部分问题都解决掉了才在 Oracle JDK 上发布）</li>
</ol>
<p>基于以上这些原因，OpenJDK 还是有存在的必要的！</p>
</blockquote>
<p><img src="https://files.catbox.moe/ulxgmx.png"></p>
<ul>
<li><p>BCL 协议（Oracle Binary Code License Agreement）： 可以使用 JDK（支持商用），但是不能进行修改。</p>
</li>
<li><p>OTN 协议（Oracle Technology Network License Agreement）： 11 及之后新发布的 JDK 用的都是这个协议，可以自己私下用，但是商用需要付费。</p>
<p>​</p>
</li>
</ul>
<p><img src="https://files.catbox.moe/ewfngq.png"></p>
<h3 id="Java-和-C-的区别"><a href="#Java-和-C-的区别" class="headerlink" title="Java 和 C++ 的区别?"></a>Java 和 C++ 的区别?</h3><p>我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过 C++，也要记下来。</p>
<p>虽然，Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但是，它们还是有挺多不相同的地方：</p>
<ul>
<li>Java 不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li>
<li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li>
<li>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li>
<li>……</li>
</ul>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="注释有哪几种形式？"><a href="#注释有哪几种形式？" class="headerlink" title="注释有哪几种形式？"></a>注释有哪几种形式？</h3><p>Java 中的注释有三种：</p>
<ol>
<li><strong>单行注释</strong> ：通常用于解释方法内某单行代码的作用。</li>
<li><strong>多行注释</strong> ：通常用于解释一段代码的作用。</li>
<li><strong>文档注释</strong> ：通常用于生成 Java 开发文档。</li>
</ol>
<p>用的比较多的还是单行注释和文档注释，多行注释在实际开发中使用的相对较少。</p>
<p>在我们编写代码的时候，如果代码量比较少，我们自己或者团队其他成员还可以很轻易地看懂代码，但是当项目结构一旦复杂起来，我们就需要用到注释了。注释并不会执行(编译器在编译代码之前会把代码中的所有注释抹掉,字节码中不保留注释)，是我们程序员写给自己看的，注释是你的代码说明书，能够帮助看代码的人快速地理清代码之间的逻辑关系。因此，在写程序的时候随手加上注释是一个非常好的习惯。</p>
<p>《Clean Code》这本书明确指出：</p>
<blockquote>
<p><strong>代码的注释不是越详细越好。实际上好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。</strong></p>
<p><strong>若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述。</strong></p>
<p>举个例子：</p>
<p>去掉下面复杂的注释，只需要创建一个与注释所言同一事物的函数即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// check to see if the employee is eligible for full benefits</span></span><br><span class="line"><span class="keyword">if</span> ((employee.flags &amp; HOURLY_FLAG) &amp;&amp; (employee.age &gt; <span class="number">65</span>))</span><br></pre></td></tr></table></figure>

<p>1<br>2</p>
<p>应替换为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (employee.isEligibleForFullBenefits())</span><br></pre></td></tr></table></figure>

<p>1</p>
</blockquote>
<h3 id="标识符和关键字的区别是什么？"><a href="#标识符和关键字的区别是什么？" class="headerlink" title="标识符和关键字的区别是什么？"></a>标识符和关键字的区别是什么？</h3><p>在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了 <strong>标识符</strong> 。简单来说， <strong>标识符就是一个名字</strong> 。</p>
<p>有一些标识符，Java 语言已经赋予了其特殊的含义，只能用于特定的地方，这些特殊的标识符就是 <strong>关键字</strong> 。简单来说，<strong>关键字是被赋予特殊含义的标识</strong>符 。比如，在我们的日常生活中，如果我们想要开一家店，则要给这个店起一个名字，起的这个“名字”就叫标识符。但是我们店的名字不能叫“警察局”，因为“警察局”这个名字已经被赋予了特殊的含义，而“警察局”就是我们日常生活中的关键字。</p>
<h3 id="Java-语言关键字有哪些？"><a href="#Java-语言关键字有哪些？" class="headerlink" title="Java 语言关键字有哪些？"></a>Java 语言关键字有哪些？</h3><table>
<thead>
<tr>
<th>分类</th>
<th>关键字</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>访问控制</td>
<td>private</td>
<td>protected</td>
<td>public</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>类，方法和变量修饰符</td>
<td>abstract</td>
<td>class</td>
<td>extends</td>
<td>final</td>
<td>implements</td>
<td>interface</td>
<td>native</td>
</tr>
<tr>
<td></td>
<td>new</td>
<td>static</td>
<td>strictfp</td>
<td>synchronized</td>
<td>transient</td>
<td>volatile</td>
<td>enum</td>
</tr>
<tr>
<td>程序控制</td>
<td>break</td>
<td>continue</td>
<td>return</td>
<td>do</td>
<td>while</td>
<td>if</td>
<td>else</td>
</tr>
<tr>
<td></td>
<td>for</td>
<td>instanceof</td>
<td>switch</td>
<td>case</td>
<td>default</td>
<td>assert</td>
<td></td>
</tr>
<tr>
<td>错误处理</td>
<td>try</td>
<td>catch</td>
<td>throw</td>
<td>throws</td>
<td>finally</td>
<td></td>
<td></td>
</tr>
<tr>
<td>包相关</td>
<td>import</td>
<td>package</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>基本类型</td>
<td>boolean</td>
<td>byte</td>
<td>char</td>
<td>double</td>
<td>float</td>
<td>int</td>
<td>long</td>
</tr>
<tr>
<td></td>
<td>short</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>变量引用</td>
<td>super</td>
<td>this</td>
<td>void</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>保留字</td>
<td>goto</td>
<td>const</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>Tips：所有的关键字都是小写的，在 IDE 中会以特殊颜色显示。</p>
<p><code>default</code> 这个关键字很特殊，既属于程序控制，也属于类，方法和变量修饰符，还属于访问控制。</p>
<ul>
<li>在程序控制中，当在 <code>switch</code> 中匹配不到任何情况时，可以使用 <code>default</code> 来编写默认匹配的情况。</li>
<li>在类，方法和变量修饰符中，从 JDK8 开始引入了默认方法，可以使用 <code>default</code> 关键字来定义一个方法的默认实现。</li>
<li>在访问控制中，如果一个方法前没有任何修饰符，则默认会有一个修饰符 <code>default</code>，但是这个修饰符加上了就会报错。</li>
</ul>
</blockquote>
<p>⚠️ 注意 ：虽然 <code>true</code>, <code>false</code>, 和 <code>null</code> 看起来像关键字但实际上他们是字面值，同时你也不可以作为标识符来使用。</p>
<h3 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h3><p>在写代码的过程中，常见的一种情况是需要某个整数类型变量增加 1 或减少 1，Java 提供了一种特殊的运算符，用于这种表达式，叫做自增运算符（++)和自减运算符（–）。</p>
<p>++ 和 – 运算符可以放在变量之前，也可以放在变量之后，当运算符放在变量之前时(前缀)，先自增&#x2F;减，再赋值；当运算符放在变量之后时(后缀)，先赋值，再自增&#x2F;减。例如，当 <code>b = ++a</code> 时，先自增（自己增加 1），再赋值（赋值给 b）；当 <code>b = a++</code> 时，先赋值(赋值给 b)，再自增（自己增加 1）。也就是，++a 输出的是 a+1 的值，a++输出的是 a 值。用一句口诀就是：“符号在前就先加&#x2F;减，符号在后就后加&#x2F;减”。</p>
<h3 id="continue、break-和-return-的区别是什么？"><a href="#continue、break-和-return-的区别是什么？" class="headerlink" title="continue、break 和 return 的区别是什么？"></a>continue、break 和 return 的区别是什么？</h3><p>在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词：</p>
<ol>
<li><code>continue</code> ：指跳出当前的这一次循环，继续下一次循环。</li>
<li><code>break</code> ：指跳出整个循环体，继续执行循环下面的语句。</li>
</ol>
<p><code>return</code> 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：</p>
<ol>
<li><code>return;</code> ：直接使用 return 结束方法执行，用于没有返回值函数的方法</li>
<li><code>return value;</code> ：return 一个特定值，用于有返回值函数的方法</li>
</ol>
<p>思考一下：下列语句的运行结果是什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">4</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;xixi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;heihei&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line">xixi</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">xixi</span><br><span class="line"><span class="number">3</span></span><br><span class="line">haha</span><br></pre></td></tr></table></figure>

<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="成员变量与局部变量的区别？"><a href="#成员变量与局部变量的区别？" class="headerlink" title="成员变量与局部变量的区别？"></a>成员变量与局部变量的区别？</h4><ul>
<li><strong>语法形式</strong> ：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</li>
<li><strong>存储方式</strong> ：从变量在内存中的存储方式来看,如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li>
<li><strong>生存时间</strong> ：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</li>
<li><strong>默认值</strong> ：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li>
</ul>
<h4 id="静态变量有什么作用？"><a href="#静态变量有什么作用？" class="headerlink" title="静态变量有什么作用？"></a>静态变量有什么作用？</h4><p>静态变量可以被类的所有实例共享。无论一个类创建了多少个对象，它们都共享同一份静态变量。</p>
<p>通常情况下，静态变量会被 <code>final</code> 关键字修饰成为常量。</p>
<h4 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别?"></a>字符型常量和字符串常量的区别?</h4><ol>
<li><strong>形式</strong> : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。</li>
<li><strong>含义</strong> : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。</li>
<li><strong>占内存大小</strong> ： 字符常量只占 2 个字节; 字符串常量占若干个字节。</li>
</ol>
<p>(<strong>注意： char 在 Java 中占两个字节</strong>)</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="什么是方法的返回值-方法有哪几种类型？"><a href="#什么是方法的返回值-方法有哪几种类型？" class="headerlink" title="什么是方法的返回值?方法有哪几种类型？"></a>什么是方法的返回值?方法有哪几种类型？</h4><p><strong>方法的返回值</strong> 是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用是接收出结果，使得它可以用于其他的操作！</p>
<p>我们可以按照方法的返回值和参数类型将方法分为下面这几种：</p>
<p><strong>1.无参数无返回值的方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下面这个方法也没有返回值，虽然用到了 return</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (...) &#123;</span><br><span class="line">        <span class="comment">// 表示结束方法的执行,下方的输出语句不会执行</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.有参数无返回值的方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">(Parameter <span class="number">1</span>, ..., Parameter n)</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.有返回值无参数的方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.有返回值有参数的方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f4</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="静态方法为什么不能调用非静态成员"><a href="#静态方法为什么不能调用非静态成员" class="headerlink" title="静态方法为什么不能调用非静态成员?"></a>静态方法为什么不能调用非静态成员?</h4><p>这个需要结合 JVM 的相关知识，主要原因如下：</p>
<ol>
<li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li>
<li>在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li>
</ol>
<h4 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h4><p><strong>1、调用方式</strong></p>
<p>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象.方法名</code> 的方式，而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong> 。</p>
<p>不过，需要注意的是一般不建议使用 <code>对象.方法名</code> 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。</p>
<p>因此，一般建议使用 <code>类名.方法名</code> 的方式来调用静态方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staicMethod</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="comment">// 调用实例方法</span></span><br><span class="line">        person.method();</span><br><span class="line">        <span class="comment">// 调用静态方法</span></span><br><span class="line">        Person.staicMethod()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、访问类成员是否存在限制</strong></p>
<p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p>
<h4 id="重载和重写有什么区别？"><a href="#重载和重写有什么区别？" class="headerlink" title="重载和重写有什么区别？"></a>重载和重写有什么区别？</h4><blockquote>
<p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p>
<p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p>
</blockquote>
<p><strong>重载</strong></p>
<p>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p>
<p>《Java 核心技术》这本书是这样介绍重载的：</p>
<blockquote>
<p>如果多个方法(比如 <code>StringBuilder</code> 的构造方法)有相同的名字、不同的参数， 便产生了重载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;HelloWorld&quot;</span>);</span><br></pre></td></tr></table></figure>



<p>编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。 如果编译器找不到匹配的参数， 就会产生编译时错误， 因为根本不存在匹配， 或者没有一个比其他的更好(这个过程被称为重载解析(overloading resolution))。</p>
<p>Java 允许重载任何方法， 而不只是构造器方法。</p>
</blockquote>
<p>综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</p>
<p><strong>重写</strong></p>
<p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
<ol>
<li>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>
<li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</li>
<li>构造方法无法被重写</li>
</ol>
<p>综上：<strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p>
<table>
<thead>
<tr>
<th>区别点</th>
<th>重载方法</th>
<th>重写方法</th>
</tr>
</thead>
<tbody><tr>
<td>发生范围</td>
<td>同一个类</td>
<td>子类</td>
</tr>
<tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可修改</td>
<td>子类方法返回值类型应比父类方法返回值类型更小或相等</td>
</tr>
<tr>
<td>异常</td>
<td>可修改</td>
<td>子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>可修改</td>
<td>一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td>发生阶段</td>
<td>编译期</td>
<td>运行期</td>
</tr>
</tbody></table>
<p><strong>方法的重写要遵循“两同两小一大”</strong>：</p>
<ul>
<li>“两同”即方法名相同、形参列表相同；</li>
<li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li>
<li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li>
</ul>
<p> 关于 <strong>重写的返回值类型</strong> 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;超级英雄&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperMan</span> <span class="keyword">extends</span> <span class="title class_">Hero</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;超人&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Hero <span class="title function_">hero</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperSuperMan</span> <span class="keyword">extends</span> <span class="title class_">SuperMan</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;超级超级英雄&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> SuperMan <span class="title function_">hero</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SuperMan</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="什么是可变长参数？"><a href="#什么是可变长参数？" class="headerlink" title="什么是可变长参数？"></a>什么是可变长参数？</h4><p>从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面的这个 <code>printVariable</code> 方法就可以接受 0 个或者多个参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">   <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(String arg1, String... args)</span> &#123;</span><br><span class="line">   <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？</strong></p>
<p>答案是会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。</p>
<p>我们通过下面这个例子来证明一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 微信搜 JavaGuide 回复&quot;面试突击&quot;即可免费领取个人原创的 Java 面试手册</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Guide哥</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/12/13 16:52</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VariableLengthArgument</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printVariable</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String s : args) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printVariable</span><span class="params">(String arg1, String arg2)</span> &#123;</span><br><span class="line">        System.out.println(arg1 + arg2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        printVariable(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">        printVariable(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ab</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br></pre></td></tr></table></figure>

<p>另外，Java 的可变参数编译后实际会被转换成一个数组，我们看编译后生成的 <code>class</code>文件就可以看出来了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VariableLengthArgument</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printVariable</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">        String[] var1 = args;</span><br><span class="line">        <span class="type">int</span> <span class="variable">var2</span> <span class="operator">=</span> args.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var3</span> <span class="operator">=</span> <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> var1[var3];</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="Java-中的几种基本数据类型了解么？"><a href="#Java-中的几种基本数据类型了解么？" class="headerlink" title="Java 中的几种基本数据类型了解么？"></a>Java 中的几种基本数据类型了解么？</h3><p>Java 中有 8 种基本数据类型，分别为：</p>
<ul>
<li>6 种数字类型：<ul>
<li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li>
<li>2 种浮点型：<code>float</code>、<code>double</code></li>
</ul>
</li>
<li>1 种字符类型：<code>char</code></li>
<li>1 种布尔型：<code>boolean</code>。</li>
</ul>
<p>这 8 种基本数据类型的默认值以及所占空间的大小如下：</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>位数</th>
<th>字节</th>
<th>默认值</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td><code>byte</code></td>
<td>8</td>
<td>1</td>
<td>0</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td><code>short</code></td>
<td>16</td>
<td>2</td>
<td>0</td>
<td>-32768 ~ 32767</td>
</tr>
<tr>
<td><code>int</code></td>
<td>32</td>
<td>4</td>
<td>0</td>
<td>-2147483648 ~ 2147483647</td>
</tr>
<tr>
<td><code>long</code></td>
<td>64</td>
<td>8</td>
<td>0L</td>
<td>-9223372036854775808 ~ 9223372036854775807</td>
</tr>
<tr>
<td><code>char</code></td>
<td>16</td>
<td>2</td>
<td>‘u0000’</td>
<td>0 ~ 65535</td>
</tr>
<tr>
<td><code>float</code></td>
<td>32</td>
<td>4</td>
<td>0f</td>
<td>1.4E-45 ~ 3.4028235E38</td>
</tr>
<tr>
<td><code>double</code></td>
<td>64</td>
<td>8</td>
<td>0d</td>
<td>4.9E-324 ~ 1.7976931348623157E308</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td>1</td>
<td></td>
<td>false</td>
<td>true、false</td>
</tr>
</tbody></table>
<p>对于 <code>boolean</code>，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。</p>
<p>另外，Java 的每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一（《Java 编程思想》2.2 节有提到）。</p>
<p><strong>注意：</strong></p>
<ol>
<li>Java 里使用 <code>long</code> 类型的数据一定要在数值后面加上 <strong>L</strong>，否则将作为整型解析。</li>
<li><code>char a = &#39;h&#39;</code>char :单引号，<code>String a = &quot;hello&quot;</code> :双引号。</li>
</ol>
<p>这八种基本类型都有对应的包装类分别为：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code> 。</p>
<h3 id="基本类型和包装类型的区别？"><a href="#基本类型和包装类型的区别？" class="headerlink" title="基本类型和包装类型的区别？"></a>基本类型和包装类型的区别？</h3><ul>
<li>成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</li>
<li>包装类型可用于泛型，而基本类型不可以。</li>
<li>基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</li>
<li>相比于对象类型， 基本数据类型占用的空间非常小。</li>
</ul>
<p><strong>为什么说是几乎所有对象实例呢？</strong> 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存</p>
<p>⚠️ 注意 ： <strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的成员变量如果没有被 <code>static</code> 修饰的话（不建议这么使用，应该要使用基本数据类型对应的包装类型），就存放在堆中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BasicTypeVar</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="包装类型的缓存机制了解么？"><a href="#包装类型的缓存机制了解么？" class="headerlink" title="包装类型的缓存机制了解么？"></a>包装类型的缓存机制了解么？</h3><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</p>
<p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
<p><strong>Integer 缓存源码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Character 缓存源码:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Character <span class="title function_">valueOf</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">      <span class="keyword">return</span> CharacterCache.cache[(<span class="type">int</span>)c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Character</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CharacterCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">CharacterCache</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Character cache[] = <span class="keyword">new</span> <span class="title class_">Character</span>[<span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> <span class="title class_">Character</span>((<span class="type">char</span>)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Boolean 缓存源码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">valueOf</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p>
<p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现缓存机制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">33</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">33</span>;</span><br><span class="line">System.out.println(i1 == i2);<span class="comment">// 输出 true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Float</span> <span class="variable">i11</span> <span class="operator">=</span> <span class="number">333f</span>;</span><br><span class="line"><span class="type">Float</span> <span class="variable">i22</span> <span class="operator">=</span> <span class="number">333f</span>;</span><br><span class="line">System.out.println(i11 == i22);<span class="comment">// 输出 false</span></span><br><span class="line"></span><br><span class="line"><span class="type">Double</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">1.2</span>;</span><br><span class="line"><span class="type">Double</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">1.2</span>;</span><br><span class="line">System.out.println(i3 == i4);<span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure>

<p>下面我们来看一下问题。下面的代码的输出结果是 <code>true</code> 还是 <code>false</code> 呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line">System.out.println(i1==i2);</span><br></pre></td></tr></table></figure>

<p><code>Integer i1=40</code> 这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i1=Integer.valueOf(40)</code> 。因此，<code>i1</code> 直接使用的是缓存中的对象。而<code>Integer i2 = new Integer(40)</code> 会直接创建新的对象。</p>
<p>因此，答案是 <code>false</code> 。你答对了吗？</p>
<p>记住：<strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong>。</p>
<p><img src="https://files.catbox.moe/nxm7qa.png"></p>
<h3 id="自动装箱与拆箱了解吗？原理是什么？"><a href="#自动装箱与拆箱了解吗？原理是什么？" class="headerlink" title="自动装箱与拆箱了解吗？原理是什么？"></a>自动装箱与拆箱了解吗？原理是什么？</h3><p><strong>什么是自动拆装箱？</strong></p>
<ul>
<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>

<p>上面这两行代码对应的字节码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">L1</span><br><span class="line"></span><br><span class="line"> LINENUMBER <span class="number">8</span> L1</span><br><span class="line"></span><br><span class="line"> ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> BIPUSH <span class="number">10</span></span><br><span class="line"></span><br><span class="line"> INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line"> PUTFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line">L2</span><br><span class="line"></span><br><span class="line"> LINENUMBER <span class="number">9</span> L2</span><br><span class="line"></span><br><span class="line"> ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> GETFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line"> INVOKEVIRTUAL java/lang/Integer.intValue ()I</span><br><span class="line"></span><br><span class="line"> PUTFIELD AutoBoxTest.n : I</span><br><span class="line"></span><br><span class="line"> RETURN</span><br></pre></td></tr></table></figure>

<p>从字节码中，我们发现装箱其实就是调用了 包装类的<code>valueOf()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法。</p>
<p>因此，</p>
<ul>
<li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li>
<li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code>;</li>
</ul>
<p>注意：<strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 应该使用 long 而不是 Long</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++)</span><br><span class="line">        sum += i;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为什么浮点数运算的时候会有精度丢失的风险？"><a href="#为什么浮点数运算的时候会有精度丢失的风险？" class="headerlink" title="为什么浮点数运算的时候会有精度丢失的风险？"></a>为什么浮点数运算的时候会有精度丢失的风险？</h3><p>浮点数运算精度丢失代码演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2.0f</span> - <span class="number">1.9f</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1.8f</span> - <span class="number">1.7f</span>;</span><br><span class="line">System.out.println(a);<span class="comment">// 0.100000024</span></span><br><span class="line">System.out.println(b);<span class="comment">// 0.099999905</span></span><br><span class="line">System.out.println(a == b);<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>为什么会出现这个问题呢？</p>
<p>这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。</p>
<p>就比如说十进制下的 0.2 就没办法精确转换成二进制小数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，</span></span><br><span class="line"><span class="comment">// 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">0.4</span> * <span class="number">2</span> = <span class="number">0.8</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">0.8</span> * <span class="number">2</span> = <span class="number">1.6</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">0.6</span> * <span class="number">2</span> = <span class="number">1.2</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span> -&gt; <span class="number">0</span>（发生循环）</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>关于浮点数的更多内容，建议看一下<a href="http://kaito-kidd.com/2018/08/08/computer-system-float-point/">计算机系统基础（四）浮点数open in new window</a>这篇文章。</p>
<h3 id="如何解决浮点数运算的精度丢失问题？"><a href="#如何解决浮点数运算的精度丢失问题？" class="headerlink" title="如何解决浮点数运算的精度丢失问题？"></a>如何解决浮点数运算的精度丢失问题？</h3><p><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 <code>BigDecimal</code> 来做的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.subtract(b);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> b.subtract(c);</span><br><span class="line"></span><br><span class="line">System.out.println(x); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(y); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(Objects.equals(x, y)); <span class="comment">/* true */</span></span><br></pre></td></tr></table></figure>

<p>关于 <code>BigDecimal</code> 的详细介绍，可以看看我写的这篇文章：<a href="https://javaguide.cn/java/basis/bigdecimal.html">BigDecimal 详解</a>。</p>
<h3 id="超过-long-整型的数据应该如何表示？"><a href="#超过-long-整型的数据应该如何表示？" class="headerlink" title="超过 long 整型的数据应该如何表示？"></a>超过 long 整型的数据应该如何表示？</h3><p>基本数值类型都有一个表达范围，如果超过这个范围就会有数值溢出的风险。</p>
<p>在 Java 中，64 位 long 整型是最大的整数类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line">System.out.println(l + <span class="number">1</span>); <span class="comment">// -9223372036854775808</span></span><br><span class="line">System.out.println(l + <span class="number">1</span> == Long.MIN_VALUE); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>BigInteger</code> 内部使用 <code>int[]</code> 数组来存储任意大小的整形数据。</p>
<p>相对于常规整数类型的运算来说，<code>BigInteger</code> 运算的效率会相对较低。</p>
<h1 id="Java基础常见面试题总结-中"><a href="#Java基础常见面试题总结-中" class="headerlink" title="Java基础常见面试题总结(中)"></a>Java基础常见面试题总结(中)</h1><h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h2><h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h3><p>两者的主要区别在于解决问题的方式不同：</p>
<ul>
<li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li>
<li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li>
</ul>
<p>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</p>
<h3 id="创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a>创建一个对象用什么运算符?对象实体与对象引用有何不同?</h3><p>new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。</p>
<p>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</p>
<h3 id="对象的相等和引用相等的区别"><a href="#对象的相等和引用相等的区别" class="headerlink" title="对象的相等和引用相等的区别"></a>对象的相等和引用相等的区别</h3><ul>
<li>对象的相等一般比较的是内存中存放的内容是否相等。</li>
<li>引用相等一般比较的是他们指向的内存地址是否相等。</li>
</ul>
<h3 id="类的构造方法的作用是什么"><a href="#类的构造方法的作用是什么" class="headerlink" title="类的构造方法的作用是什么?"></a>类的构造方法的作用是什么?</h3><p>构造方法是一种特殊的方法，主要作用是完成对象的初始化工作。</p>
<h3 id="如果一个类没有声明构造方法，该程序能正确执行吗"><a href="#如果一个类没有声明构造方法，该程序能正确执行吗" class="headerlink" title="如果一个类没有声明构造方法，该程序能正确执行吗?"></a>如果一个类没有声明构造方法，该程序能正确执行吗?</h3><p>如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。</p>
<h3 id="构造方法有哪些特点？是否可被-override"><a href="#构造方法有哪些特点？是否可被-override" class="headerlink" title="构造方法有哪些特点？是否可被 override?"></a>构造方法有哪些特点？是否可被 override?</h3><p>构造方法特点如下：</p>
<ul>
<li>名字与类名相同。</li>
<li>没有返回值，但不能用 void 声明构造函数。</li>
<li>生成类的对象时自动执行，无需调用。</li>
</ul>
<p>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p>
<h3 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;<span class="comment">//id属性私有化</span></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//name属性私有化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取id的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置id的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取name的方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置name的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p>
<p><strong>关于继承如下 3 点请记住：</strong></p>
<ol>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li>
</ol>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p>
<p><strong>多态的特点:</strong></p>
<ul>
<li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li>
<li>多态不能调用“只在子类存在但在父类不存在”的方法；</li>
<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>
</ul>
<h3 id="接口和抽象类有什么共同点和区别？"><a href="#接口和抽象类有什么共同点和区别？" class="headerlink" title="接口和抽象类有什么共同点和区别？"></a>接口和抽象类有什么共同点和区别？</h3><p><strong>共同点</strong> ：</p>
<ul>
<li>都不能被实例化。</li>
<li>都可以包含抽象方法。</li>
<li>都可以有默认实现的方法（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）。</li>
</ul>
<p><strong>区别</strong> ：</p>
<ul>
<li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</li>
<li>一个类只能继承一个类，但是可以实现多个接口。</li>
<li>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</li>
</ul>
<h3 id="深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"><a href="#深拷贝和浅拷贝区别了解吗？什么是引用拷贝？" class="headerlink" title="深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"></a>深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</h3><p>关于深拷贝和浅拷贝区别，我这里先给结论：</p>
<ul>
<li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li>
<li><strong>深拷贝</strong> ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li>
</ul>
<p>上面的结论没有完全理解的话也没关系，我们来看一个具体的案例！</p>
<p><strong>浅拷贝</strong></p>
<p>浅拷贝的示例代码如下，我们这里实现了 <code>Cloneable</code> 接口，并重写了 <code>clone()</code> 方法。</p>
<p><code>clone()</code> 方法的实现很简单，直接调用的是父类 <code>Object</code> 的 <code>clone()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Address <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Address) <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">            <span class="keyword">return</span> person;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;武汉&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">person1Copy</span> <span class="operator">=</span> person1.clone();</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure>

<p>从输出结构就可以看出， <code>person1</code> 的克隆对象和 <code>person1</code> 使用的仍然是同一个 <code>Address</code> 对象。</p>
<p><strong>深拷贝</strong></p>
<p>这里我们简单对 <code>Person</code> 类的 <code>clone()</code> 方法进行修改，连带着要把 <code>Person</code> 对象内部的 <code>Address</code> 对象一起复制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">        person.setAddress(person.getAddress().clone());</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;武汉&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">person1Copy</span> <span class="operator">=</span> person1.clone();</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure>

<p>从输出结构就可以看出，虽然 <code>person1</code> 的克隆对象和 <code>person1</code> 包含的 <code>Address</code> 对象已经是不同的了。</p>
<p><strong>那什么是引用拷贝呢？</strong> 简单来说，引用拷贝就是两个不同的引用指向同一个对象。</p>
<p>我专门画了一张图来描述浅拷贝、深拷贝、引用拷贝：</p>
<p><img src="https://files.catbox.moe/4xspj5.png"></p>
<h2 id="Java-常见类"><a href="#Java-常见类" class="headerlink" title="Java 常见类"></a>Java 常见类</h2><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><h4 id="Object-类的常见方法有哪些？"><a href="#Object-类的常见方法有哪些？" class="headerlink" title="Object 类的常见方法有哪些？"></a>Object 类的常见方法有哪些？</h4><p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * naitive 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="x3D-x3D-和-equals-的区别"><a href="#x3D-x3D-和-equals-的区别" class="headerlink" title="&#x3D;&#x3D; 和 equals() 的区别"></a>&#x3D;&#x3D; 和 equals() 的区别</h4><p><strong>&#x3D;&#x3D;</strong> 对于基本类型和引用类型的作用效果是不同的：</p>
<ul>
<li>对于基本数据类型来说，<code>==</code> 比较的是值。</li>
<li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li>
</ul>
<blockquote>
<p>因为 Java 只有值传递，所以，对于 &#x3D;&#x3D; 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>
</blockquote>
<p><strong>equals()</strong> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类，因此所有的类都有<code>equals()</code>方法。</p>
<p><code>Object</code> 类 <code>equals()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>equals()</code> 方法存在两种使用情况：</p>
<ul>
<li><strong>类没有重写 equals()方法</strong> ：通过<code>equals()</code>比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li>
<li><strong>类重写了 equals()方法</strong> ：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li>
</ul>
<p>举个例子（这里只是为了举例。实际上，你按照下面这种写法的话，像 IDEA 这种比较智能的 IDE 都会提示你将 <code>==</code> 换成 <code>equals()</code> ）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line"><span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">System.out.println(aa == bb);<span class="comment">// true</span></span><br><span class="line">System.out.println(a == b);<span class="comment">// false</span></span><br><span class="line">System.out.println(a.equals(b));<span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="number">42</span> == <span class="number">42.0</span>);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，因为 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是对象的值。</p>
<p>当创建 <code>String</code> 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 <code>String</code> 对象。</p>
<p><code>String</code>类<code>equals()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="type">char</span> v1[] = value;</span><br><span class="line">            <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="hashCode-有什么用？"><a href="#hashCode-有什么用？" class="headerlink" title="hashCode() 有什么用？"></a>hashCode() 有什么用？</h4><p><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p>
<p><code>hashCode()</code>定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是： <code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>1</p>
<p>散列表存储的是键值对(key-value)，它的特点是：<strong>能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</strong></p>
<h4 id="为什么要有-hashCode？"><a href="#为什么要有-hashCode？" class="headerlink" title="为什么要有 hashCode？"></a>为什么要有 hashCode？</h4><p>我们以“<code>HashSet</code> 如何检查重复”为例子来说明为什么要有 <code>hashCode</code>？</p>
<p>下面这段内容摘自我的 Java 启蒙书《Head First Java》:</p>
<blockquote>
<p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode</code> 值作比较，如果没有相符的 <code>hashCode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 <code>equals</code> 的次数，相应就大大提高了执行速度。</p>
</blockquote>
<p>其实， <code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等。</p>
<p><strong>那为什么 JDK 还要同时提供这两个方法呢？</strong></p>
<p>这是因为在一些容器（比如 <code>HashMap</code>、<code>HashSet</code>）中，有了 <code>hashCode()</code> 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进<code>HashSet</code>的过程）！</p>
<p>我们在前面也提到了添加元素进<code>HashSet</code>的过程，如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</p>
<p><strong>那为什么不只提供 hashCode() 方法呢？</strong></p>
<p>这是因为两个对象的<code>hashCode</code> 值相等并不代表两个对象就相等。</p>
<p><strong>那为什么两个对象有相同的 hashCode 值，它们也不一定是相等的？</strong></p>
<p>因为 <code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p>
<p>总结下来就是 ：</p>
<ul>
<li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</li>
<li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</li>
<li>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li>
</ul>
<p>相信大家看了我前面对 <code>hashCode()</code> 和 <code>equals()</code> 的介绍之后，下面这个问题已经难不倒你们了。</p>
<h4 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 时必须重写 hashCode() 方法？"></a>为什么重写 equals() 时必须重写 hashCode() 方法？</h4><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p>
<p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p>
<p><strong>思考</strong> ：重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话，使用 <code>HashMap</code> 可能会出现什么问题。</p>
<p><strong>总结</strong> ：</p>
<ul>
<li><code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</li>
<li>两个对象有相同的 <code>hashCode</code> 值，他们也不一定是相等的（哈希碰撞）。</li>
</ul>
<p>更多关于 <code>hashCode()</code> 和 <code>equals()</code> 的内容可以查看：<a href="https://www.cnblogs.com/skywang12345/p/3324958.html">Java hashCode() 和 equals()的若干问题解答open in new window</a></p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="String、StringBuffer、StringBuilder-的区别？"><a href="#String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="String、StringBuffer、StringBuilder 的区别？"></a>String、StringBuffer、StringBuilder 的区别？</h4><p><strong>可变性</strong></p>
<p><code>String</code> 是不可变的（后面会详细分析原因）。</p>
<p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="type">char</span>[] value;</span><br><span class="line">    <span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> appendNull();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">        ensureCapacityInternal(count + len);</span><br><span class="line">        str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">        count += len;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程安全性</strong></p>
<p><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p>
<p><strong>性能</strong></p>
<p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p><strong>对于三者使用的总结：</strong></p>
<ol>
<li>操作少量的数据: 适用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>
</ol>
<h4 id="String-为什么是不可变的"><a href="#String-为什么是不可变的" class="headerlink" title="String 为什么是不可变的?"></a>String 为什么是不可变的?</h4><p><code>String</code> 类中使用 <code>final</code> 关键字修饰字符数组来保存字符串，所以<code>String</code> 对象是不可变的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>修正 ： 我们知道被 <code>final</code> 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，<code>final</code> 关键字修饰的数组保存字符串并不是 <code>String</code> 不可变的根本原因，因为这个数组保存的字符串是可变的（<code>final</code> 修饰引用类型变量的情况）。</p>
<p><code>String</code> 真正不可变有下面几点原因：</p>
<ol>
<li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供&#x2F;暴露修改这个字符串的方法。</li>
<li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li>
</ol>
<p>相关阅读：<a href="https://www.zhihu.com/question/20618891/answer/114125846">如何理解 String 类型值的不可变？ - 知乎提问open in new window</a></p>
<p>补充（来自<a href="https://github.com/Snailclimb/JavaGuide/issues/675">issue 675open in new window</a>）：在 Java 9 之后，<code>String</code> 、<code>StringBuilder</code> 与 <code>StringBuffer</code> 的实现改用 <code>byte</code> 数组存储字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable,Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">// @Stable 注解表示变量最多被修改一次，称为“稳定的”。</span></span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="type">byte</span>[] value;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Java 9 为何要将 String 的底层实现由 char[] 改成了 byte[] ?</strong></p>
<p>新版的 String 其实支持两个编码方案： Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下，<code>byte</code> 占一个字节(8 位)，<code>char</code> 占用 2 个字节（16），<code>byte</code> 相较 <code>char</code> 节省一半的内存空间。</p>
<p>JDK 官方就说了绝大部分字符串对象只包含 Latin-1 可表示的字符。</p>
</blockquote>
<p><img src="https://files.catbox.moe/0og4qd.png"></p>
<blockquote>
<p>如果字符串中包含的汉字超过 Latin-1 可表示范围内的字符，<code>byte</code> 和 <code>char</code> 所占用的空间是一样的。</p>
<p>这是官方的介绍：<a href="https://openjdk.java.net/jeps/254">https://openjdk.java.net/jeps/254</a> 。</p>
</blockquote>
<h4 id="字符串拼接用“-”-还是-StringBuilder"><a href="#字符串拼接用“-”-还是-StringBuilder" class="headerlink" title="字符串拼接用“+” 还是 StringBuilder?"></a>字符串拼接用“+” 还是 StringBuilder?</h4><p>Java 语言本身并不支持运算符重载，“+”和“+&#x3D;”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;he&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;llo&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2 + str3;</span><br></pre></td></tr></table></figure>

<p>上面的代码对应的字节码如下：</p>
<p><img src="https://files.catbox.moe/q9guh3.png"></p>
<p>可以看出，字符串对象通过“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p>
<p>不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：<strong>编译器不会创建单个 StringBuilder 以复用，会导致创建过多的 StringBuilder 对象</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;he&quot;</span>, <span class="string">&quot;llo&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    s += arr[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>

<p><code>StringBuilder</code> 对象是在循环内部被创建的，这意味着每循环一次就会创建一个 <code>StringBuilder</code> 对象。</p>
<p><img src="https://files.catbox.moe/kc1ibc.png"></p>
<p>如果直接使用 <code>StringBuilder</code> 对象进行字符串拼接的话，就不会存在这个问题了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;he&quot;</span>, <span class="string">&quot;llo&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span> (String value : arr) &#123;</span><br><span class="line">    s.append(value);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>

<p><img src="https://files.catbox.moe/kpo6is.png"></p>
<p>如果你使用 IDEA 的话，IDEA 自带的代码检查机制也会提示你修改代码。</p>
<h4 id="String-equals-和-Object-equals-有何区别？"><a href="#String-equals-和-Object-equals-有何区别？" class="headerlink" title="String.equals() 和 Object.equals() 有何区别？"></a>String.equals() 和 Object.equals() 有何区别？</h4><p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，比较的是 String 字符串的值是否相等。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址。</p>
<h4 id="字符串常量池的作用了解吗？"><a href="#字符串常量池的作用了解吗？" class="headerlink" title="字符串常量池的作用了解吗？"></a>字符串常量池的作用了解吗？</h4><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”ab“</span></span><br><span class="line"><span class="comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">System.out.println(aa==bb);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>更多关于字符串常量池的介绍可以看一下 <a href="https://javaguide.cn/java/jvm/memory-area.html">Java 内存区域详解open in new window</a> 这篇文章。</p>
<h4 id="String-s1-x3D-new-String-“abc”-这句话创建了几个字符串对象？"><a href="#String-s1-x3D-new-String-“abc”-这句话创建了几个字符串对象？" class="headerlink" title="String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？"></a>String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？</h4><p>会创建 1 或 2 个字符串对象。</p>
<p>1、如果字符串常量池中不存在字符串对象“abc”的引用，那么会在堆中创建 2 个字符串对象“abc”。</p>
<p>示例代码（JDK 1.8）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>对应的字节码：</p>
<p><img src="https://files.catbox.moe/fnnhcq.png"></p>
<p><code>ldc</code> 命令用于判断字符串常量池中是否保存了对应的字符串对象的引用，如果保存了的话直接返回，如果没有保存的话，会在堆中创建对应的字符串对象并将该字符串对象的引用保存到字符串常量池中。</p>
<p>2、如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。</p>
<p>示例代码（JDK 1.8）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串常量池中已存在字符串对象“abc”的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="comment">// 下面这段代码只会在堆中创建 1 个字符串对象“abc”</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>对应的字节码：</p>
<p><img src="https://files.catbox.moe/i4vndf.png"></p>
<p>这里就不对上面的字节码进行详细注释了，7 这个位置的 <code>ldc</code> 命令不会在堆中创建新的字符串对象“abc”，这是因为 0 这个位置已经执行了一次 <code>ldc</code> 命令，已经在堆中创建过一次字符串对象“abc”了。7 这个位置执行 <code>ldc</code> 命令会直接返回字符串常量池中字符串对象“abc”对应的引用。</p>
<h4 id="intern-方法有什么作用"><a href="#intern-方法有什么作用" class="headerlink" title="intern 方法有什么作用?"></a>intern 方法有什么作用?</h4><p><code>String.intern()</code> 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：</p>
<ul>
<li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li>
<li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</li>
</ul>
<p>示例代码（JDK 1.8） :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”Java“</span></span><br><span class="line"><span class="comment">// 将字符串对象”Java“的引用保存在字符串常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();</span><br><span class="line"><span class="comment">// 会在堆中在单独创建一个字符串对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s3.intern();</span><br><span class="line"><span class="comment">// s1 和 s2 指向的是堆中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// s3 和 s4 指向的是堆中不同的对象</span></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// s1 和 s4 指向的是堆中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s4); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h4 id="String-类型的变量和常量做“-”运算时发生了什么？"><a href="#String-类型的变量和常量做“-”运算时发生了什么？" class="headerlink" title="String 类型的变量和常量做“+”运算时发生了什么？"></a>String 类型的变量和常量做“+”运算时发生了什么？</h4><p>先来看字符串不加 <code>final</code> 关键字拼接的情况（JDK1.8）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2;</span><br><span class="line"><span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;</span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong> ：比较 String 字符串的值是否相等，可以使用 <code>equals()</code> 方法。 <code>String</code> 中的 <code>equals</code> 方法是被重写过的。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是字符串的值是否相等。如果你使用 <code>==</code> 比较两个字符串是否相等的话，IDEA 还是提示你使用 <code>equals()</code> 方法替换。</p>
</blockquote>
<p><img src="https://files.catbox.moe/jghthz.png"></p>
<p><strong>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。</strong></p>
<p>在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 <strong>常量折叠(Constant Folding)</strong> 的代码优化。《深入理解 Java 虚拟机》中是也有介绍到：</p>
<p><img src="https://files.catbox.moe/zdgi6e.png"></p>
<p>常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。</p>
<p>对于 <code>String str3 = &quot;str&quot; + &quot;ing&quot;;</code> 编译器会给你优化成 <code>String str3 = &quot;string&quot;;</code> 。</p>
<p>并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：</p>
<ul>
<li>基本数据类型( <code>byte</code>、<code>boolean</code>、<code>short</code>、<code>char</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code>)以及字符串常量。</li>
<li><code>final</code> 修饰的基本数据类型和字符串变量</li>
<li>字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</li>
</ul>
<p><strong>引用的值在程序编译期是无法确定的，编译器无法对其进行优化。</strong></p>
<p>对象引用和“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(str1).append(str2).toString();</span><br></pre></td></tr></table></figure>

<p>我们在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 <code>StringBuilder</code> 或者 <code>StringBuffer</code>。</p>
<p>不过，字符串使用 <code>final</code> 关键字声明之后，可以让编译器当做常量来处理。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="comment">// 下面两个表达式其实是等价的</span></span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">// 常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> str1 + str2; <span class="comment">// 常量池中的对象</span></span><br><span class="line">System.out.println(c == d);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>被 <code>final</code> 关键字修改之后的 <code>String</code> 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。</p>
<p>如果 ，编译器在运行时才能知道其确切值的话，就无法对其优化。</p>
<p>示例代码（<code>str2</code> 在运行时才能确定其值）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> getStr();</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">// 常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> str1 + str2; <span class="comment">// 在堆上创建的新的对象</span></span><br><span class="line">System.out.println(c == d);<span class="comment">// false</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getStr</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Java基础常见面试题总结-下"><a href="#Java基础常见面试题总结-下" class="headerlink" title="Java基础常见面试题总结(下)"></a>Java基础常见面试题总结(下)</h1><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><strong>Java 异常类层次结构图概览</strong> ：</p>
<p><img src="https://files.catbox.moe/34p40i.png"></p>
<h3 id="Exception-和-Error-有什么区别？"><a href="#Exception-和-Error-有什么区别？" class="headerlink" title="Exception 和 Error 有什么区别？"></a>Exception 和 Error 有什么区别？</h3><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p>
<ul>
<li><strong>Exception</strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li>
<li><strong>Error</strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li>
</ul>
<h3 id="Checked-Exception-和-Unchecked-Exception-有什么区别？"><a href="#Checked-Exception-和-Unchecked-Exception-有什么区别？" class="headerlink" title="Checked Exception 和 Unchecked Exception 有什么区别？"></a>Checked Exception 和 Unchecked Exception 有什么区别？</h3><p><strong>Checked Exception</strong> 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>或者<code>throws</code> 关键字处理的话，就没办法通过编译。</p>
<p>比如下面这段 IO 操作的代码：</p>
<p><img src="https://files.catbox.moe/tgktho.png"></p>
<p>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、<code>ClassNotFoundException</code> 、<code>SQLException</code>…。</p>
<p><strong>Unchecked Exception</strong> 即 <strong>不受检查异常</strong> ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p>
<p><code>RuntimeException</code> 及其子类都统称为非受检查异常，常见的有（建议记下来，日常开发中会经常用到）：</p>
<ul>
<li><p><code>NullPointerException</code>(空指针错误)</p>
</li>
<li><p><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</p>
</li>
<li><p><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类）</p>
</li>
<li><p><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</p>
</li>
<li><p><code>ClassCastException</code>（类型转换错误）</p>
</li>
<li><p><code>ArithmeticException</code>（算术错误）</p>
</li>
<li><p><code>SecurityException</code> （安全错误比如权限不够）</p>
</li>
<li><p><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</p>
</li>
<li><p>……</p>
<p>​</p>
</li>
</ul>
<p><img src="https://files.catbox.moe/2ai3t6.png"></p>
<h3 id="Throwable-类常用方法有哪些？"><a href="#Throwable-类常用方法有哪些？" class="headerlink" title="Throwable 类常用方法有哪些？"></a>Throwable 类常用方法有哪些？</h3><ul>
<li><code>String getMessage()</code>: 返回异常发生时的简要描述</li>
<li><code>String toString()</code>: 返回异常发生时的详细信息</li>
<li><code>String getLocalizedMessage()</code>: 返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</li>
<li><code>void printStackTrace()</code>: 在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li>
</ul>
<h3 id="try-catch-finally-如何使用？"><a href="#try-catch-finally-如何使用？" class="headerlink" title="try-catch-finally 如何使用？"></a>try-catch-finally 如何使用？</h3><ul>
<li><code>try</code>块 ： 用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li>
<li><code>catch</code>块 ： 用于处理 try 捕获到的异常。</li>
<li><code>finally</code> 块 ： 无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Try to do something&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;RuntimeException&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Catch Exception -&gt; &quot;</span> + e.getMessage());</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Finally&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Try to <span class="keyword">do</span> something</span><br><span class="line">Catch Exception -&gt; RuntimeException</span><br><span class="line">Finally</span><br></pre></td></tr></table></figure>

<p><strong>注意：不要在 finally 语句块中使用 return!</strong> 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</p>
<blockquote>
<p>If the <code>try</code> clause executes a <em>return</em>, the compiled code does the following:</p>
<ol>
<li>Saves the return value (if any) in a local variable.</li>
<li>Executes a <em>jsr</em> to the code for the <code>finally</code> clause.</li>
<li>Upon return from the <code>finally</code> clause, returns the value saved in the local variable.</li>
</ol>
</blockquote>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(f(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value * value;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="finally-中的代码一定会执行吗？"><a href="#finally-中的代码一定会执行吗？" class="headerlink" title="finally 中的代码一定会执行吗？"></a>finally 中的代码一定会执行吗？</h3><p>不一定的！在某些情况下，finally 中的代码不会被执行。</p>
<p>就比如说 finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Try to do something&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;RuntimeException&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Catch Exception -&gt; &quot;</span> + e.getMessage());</span><br><span class="line">    <span class="comment">// 终止当前正在运行的Java虚拟机</span></span><br><span class="line">    System.exit(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Finally&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Try to <span class="keyword">do</span> something</span><br><span class="line">Catch Exception -&gt; RuntimeException</span><br></pre></td></tr></table></figure>

<p>另外，在以下 2 种特殊情况下，<code>finally</code> 块的代码也不会被执行：</p>
<ol>
<li>程序所在的线程死亡。</li>
<li>关闭 CPU。</li>
</ol>
<p>进阶一下：从字节码角度分析<code>try catch finally</code>这个语法糖背后的实现原理。</p>
<h3 id="如何使用-try-with-resources-代替try-catch-finally？"><a href="#如何使用-try-with-resources-代替try-catch-finally？" class="headerlink" title="如何使用 try-with-resources 代替try-catch-finally？"></a>如何使用 <code>try-with-resources</code> 代替<code>try-catch-finally</code>？</h3><ol>
<li><strong>适用范围（资源的定义）：</strong> 任何实现 <code>java.lang.AutoCloseable</code>或者 <code>java.io.Closeable</code> 的对象</li>
<li><strong>关闭资源和 finally 块的执行顺序：</strong> 在 <code>try-with-resources</code> 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</li>
</ol>
<p>《Effective Java》中明确指出：</p>
<blockquote>
<p>面对必须要关闭的资源，我们总是应该优先使用 <code>try-with-resources</code> 而不是<code>try-finally</code>。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。<code>try-with-resources</code>语句让我们更容易编写必须要关闭的资源的代码，若采用<code>try-finally</code>则几乎做不到这点。</p>
</blockquote>
<p>Java 中类似于<code>InputStream</code>、<code>OutputStream</code> 、<code>Scanner</code> 、<code>PrintWriter</code>等的资源都需要我们调用<code>close()</code>方法来手动关闭，一般情况下我们都是通过<code>try-catch-finally</code>语句来实现这个需求，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取文本文件的内容</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    scanner = <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://read.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (scanner != <span class="literal">null</span>) &#123;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 Java 7 之后的 <code>try-with-resources</code> 语句改造上面的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">    fnfe.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然多个资源需要关闭的时候，使用 <code>try-with-resources</code> 实现起来也非常简单，如果你还是用<code>try-catch-finally</code>可能会带来很多问题。</p>
<p>通过使用分号分隔，可以在<code>try-with-resources</code>块中声明多个资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line">     <span class="type">BufferedOutputStream</span> <span class="variable">bout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;out.txt&quot;</span>)))) &#123;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="keyword">while</span> ((b = bin.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        bout.write(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常使用有哪些需要注意的地方？"><a href="#异常使用有哪些需要注意的地方？" class="headerlink" title="异常使用有哪些需要注意的地方？"></a>异常使用有哪些需要注意的地方？</h3><ul>
<li>不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。</li>
<li>抛出的异常信息一定要有意义。</li>
<li>建议抛出更加具体的异常比如字符串转换为数字格式错误的时候应该抛出<code>NumberFormatException</code>而不是其父类<code>IllegalArgumentException</code>。</li>
<li>使用日志打印异常之后就不要再抛出异常了（两者不要同时存在一段代码逻辑中）。</li>
<li>……</li>
</ul>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="什么是泛型？有什么作用？"><a href="#什么是泛型？有什么作用？" class="headerlink" title="什么是泛型？有什么作用？"></a>什么是泛型？有什么作用？</h3><p><strong>Java 泛型（Generics）</strong> 是 JDK 5 中引入的一个新特性。使用泛型参数，可以增强代码的可读性以及稳定性。</p>
<p>编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 <code>ArrayList&lt;Persion&gt; persons = new ArrayList&lt;Persion&gt;()</code> 这行代码就指明了该 <code>ArrayList</code> 对象只能传入 <code>Persion</code> 对象，如果传入其他类型的对象就会报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>

<p>并且，原生 <code>List</code> 返回类型是 <code>Object</code> ，需要手动转换类型才能使用，使用泛型后编译器自动转换。</p>
<h3 id="泛型的使用方式有哪几种？"><a href="#泛型的使用方式有哪几种？" class="headerlink" title="泛型的使用方式有哪几种？"></a>泛型的使用方式有哪几种？</h3><p>泛型一般有三种使用方式:<strong>泛型类</strong>、<strong>泛型接口</strong>、<strong>泛型方法</strong>。</p>
<p><strong>1.泛型类</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何实例化泛型类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;Integer&gt;(<span class="number">123456</span>);</span><br></pre></td></tr></table></figure>

<p>1</p>
<p><strong>2.泛型接口</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现泛型接口，不指定类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现泛型接口，指定类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.泛型方法</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">( E[] inputArray )</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">for</span> ( E element : inputArray )&#123;</span><br><span class="line">         System.out.printf( <span class="string">&quot;%s &quot;</span>, element );</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建不同类型数组： Integer, Double 和 Character</span></span><br><span class="line">Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">String[] stringArray = &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span> &#125;;</span><br><span class="line">printArray( intArray  );</span><br><span class="line">printArray( stringArray  );</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意: <code>public static &lt; E &gt; void printArray( E[] inputArray )</code> 一般被称为静态泛型方法;在 java 中泛型只是一个占位符，必须在传递类型后才能使用。类在实例化时才能真正的传递类型参数，由于静态方法的加载先于类的实例化，也就是说类中的泛型还没有传递真正的类型参数，静态的方法的加载就已经完成了，所以静态泛型方法是没有办法使用类上声明的泛型的。只能使用自己声明的 <code>&lt;E&gt;</code></p>
</blockquote>
<h3 id="项目中哪里用到了泛型？"><a href="#项目中哪里用到了泛型？" class="headerlink" title="项目中哪里用到了泛型？"></a>项目中哪里用到了泛型？</h3><ul>
<li>自定义接口通用返回结果 <code>CommonResult&lt;T&gt;</code> 通过参数 <code>T</code> 可根据具体的返回类型动态指定结果的数据类型</li>
<li>定义 <code>Excel</code> 处理类 <code>ExcelUtil&lt;T&gt;</code> 用于动态指定 <code>Excel</code> 导出的数据类型</li>
<li>构建集合工具类（参考 <code>Collections</code> 中的 <code>sort</code>, <code>binarySearch</code> 方法）。</li>
<li>……</li>
</ul>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>关于反射的详细解读，请看这篇文章 <a href="https://javaguide.cn/java/basis/reflection.html">Java 反射机制详解</a> 。</p>
<h3 id="何谓反射？"><a href="#何谓反射？" class="headerlink" title="何谓反射？"></a>何谓反射？</h3><p>如果说大家研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</p>
<h3 id="反射的优缺点？"><a href="#反射的优缺点？" class="headerlink" title="反射的优缺点？"></a>反射的优缺点？</h3><p>反射可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。</p>
<p>不过，反射让我们在运行时有了分析操作类的能力的同时，也增加了安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</p>
<h3 id="反射的应用场景？"><a href="#反射的应用场景？" class="headerlink" title="反射的应用场景？"></a>反射的应用场景？</h3><p>像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。但是！这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring&#x2F;Spring Boot、MyBatis 等等框架中都大量使用了反射机制。</p>
<p><strong>这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。</strong></p>
<p>比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 <code>Method</code> 来调用指定的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类中的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DebugInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，像 Java 中的一大利器 <strong>注解</strong> 的实现也用到了反射。</p>
<p>为什么你使用 Spring 的时候 ，一个<code>@Component</code>注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 <code>@Value</code>注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？</p>
<p>这些都是因为你可以基于反射分析类，然后获取到类&#x2F;属性&#x2F;方法&#x2F;方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。</p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="何谓注解？"><a href="#何谓注解？" class="headerlink" title="何谓注解？"></a>何谓注解？</h3><p><code>Annotation</code> （注解） 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</p>
<p>注解本质是一个继承了<code>Annotation</code> 的特殊接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Override</span> <span class="keyword">extends</span> <span class="title class_">Annotation</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK 提供了很多内置的注解（比如 <code>@Override</code> 、<code>@Deprecated</code>），同时，我们还可以自定义注解。</p>
<h3 id="注解的解析方法有哪几种？"><a href="#注解的解析方法有哪几种？" class="headerlink" title="注解的解析方法有哪几种？"></a>注解的解析方法有哪几种？</h3><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p>
<ul>
<li><strong>编译期直接扫描</strong> ：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li>
<li><strong>运行期通过反射处理</strong> ：像框架中自带的注解(比如 Spring 框架的 <code>@Value</code> 、<code>@Component</code>)都是通过反射来进行处理的。</li>
</ul>
<h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2><p>关于 SPI 的详细解读，请看这篇文章 <a href="https://javaguide.cn/java/basis/spi.html">Java SPI 机制详解</a> 。</p>
<h3 id="何谓-SPI"><a href="#何谓-SPI" class="headerlink" title="何谓 SPI?"></a>何谓 SPI?</h3><p>SPI 即 Service Provider Interface ，字面意思就是：“服务提供者的接口”，我的理解是：专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。</p>
<p>SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。</p>
<p>很多框架都使用了 Java 的 SPI 机制，比如：Spring 框架、数据库加载驱动、日志接口、以及 Dubbo 的扩展实现等等。</p>
<p><img src="https://files.catbox.moe/era4h5.png"></p>
<h3 id="SPI-和-API-有什么区别？"><a href="#SPI-和-API-有什么区别？" class="headerlink" title="SPI 和 API 有什么区别？"></a>SPI 和 API 有什么区别？</h3><p><strong>那 SPI 和 API 有啥区别？</strong></p>
<p>说到 SPI 就不得不说一下 API 了，从广义上来说它们都属于接口，而且很容易混淆。下面先用一张图说明一下：</p>
<p><img src="https://files.catbox.moe/jweuw4.png"></p>
<p>一般模块之间都是通过通过接口进行通讯，那我们在服务调用方和服务实现方（也称服务提供者）之间引入一个“接口”。</p>
<p>当实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 API ，这种接口和实现都是放在实现方的。</p>
<p>当接口存在于调用方这边时，就是 SPI ，由接口调用方确定接口规则，然后由不同的厂商去根绝这个规则对这个接口进行实现，从而提供服务。</p>
<p>举个通俗易懂的例子：公司 H 是一家科技公司，新设计了一款芯片，然后现在需要量产了，而市面上有好几家芯片制造业公司，这个时候，只要 H 公司指定好了这芯片生产的标准（定义好了接口标准），那么这些合作的芯片公司（服务提供者）就按照标准交付自家特色的芯片（提供不同方案的实现，但是给出来的结果是一样的）。</p>
<h3 id="SPI-的优缺点？"><a href="#SPI-的优缺点？" class="headerlink" title="SPI 的优缺点？"></a>SPI 的优缺点？</h3><p>通过 SPI 机制能够大大地提高接口设计的灵活性，但是 SPI 机制也存在一些缺点，比如：</p>
<ul>
<li>需要遍历加载所有的实现类，不能做到按需加载，这样效率还是相对较低的。</li>
<li>当多个 <code>ServiceLoader</code> 同时 <code>load</code> 时，会有并发问题。</li>
</ul>
<h2 id="I-x2F-O"><a href="#I-x2F-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h2><h3 id="什么是序列化-什么是反序列化"><a href="#什么是序列化-什么是反序列化" class="headerlink" title="什么是序列化?什么是反序列化?"></a>什么是序列化?什么是反序列化?</h3><p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p>
<p>简单来说：</p>
<ul>
<li><strong>序列化</strong>： 将数据结构或对象转换成二进制字节流的过程</li>
<li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li>
</ul>
<p>对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。</p>
<p>维基百科是如是介绍序列化的：</p>
<blockquote>
<p><strong>序列化</strong>（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。</p>
</blockquote>
<p>综上：<strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中</strong></p>
<p><img src="https://files.catbox.moe/3nudqg.png"></p>
<h3 id="如果有些字段不想进行序列化怎么办？"><a href="#如果有些字段不想进行序列化怎么办？" class="headerlink" title="如果有些字段不想进行序列化怎么办？"></a>如果有些字段不想进行序列化怎么办？</h3><p>对于不想进行序列化的变量，使用 <code>transient</code> 关键字修饰。</p>
<p><code>transient</code> 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 <code>transient</code> 修饰的变量值不会被持久化和恢复。</p>
<p>关于 <code>transient</code> 还有几点注意：</p>
<ul>
<li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li>
<li><code>transient</code> 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li>
<li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li>
</ul>
<h3 id="Java-IO-流了解吗？"><a href="#Java-IO-流了解吗？" class="headerlink" title="Java IO 流了解吗？"></a>Java IO 流了解吗？</h3><p>IO 即 <code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p>
<p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>
<ul>
<li><code>InputStream</code>&#x2F;<code>Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li><code>OutputStream</code>&#x2F;<code>Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<p>相关阅读：<a href="https://javaguide.cn/java/io/io-basis.html">Java IO 基础知识总结</a>。</p>
<h3 id="I-x2F-O-流为什么要分为字节流和字符流呢"><a href="#I-x2F-O-流为什么要分为字节流和字符流呢" class="headerlink" title="I&#x2F;O 流为什么要分为字节流和字符流呢?"></a>I&#x2F;O 流为什么要分为字节流和字符流呢?</h3><p>问题本质想问：<strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I&#x2F;O 流操作要分为字节流操作和字符流操作呢？</strong></p>
<p>个人认为主要有两点原因：</p>
<ul>
<li>字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时；</li>
<li>如果我们不知道编码类型的话，使用字节流的过程中很容易出现乱码问题。</li>
</ul>
<h3 id="Java-IO-中的设计模式有哪些？"><a href="#Java-IO-中的设计模式有哪些？" class="headerlink" title="Java IO 中的设计模式有哪些？"></a>Java IO 中的设计模式有哪些？</h3><p><a href="https://javaguide.cn/java/io/io-design-patterns.html">Java IO 设计模式总结</a></p>
<h3 id="BIO、NIO-和-AIO-的区别？"><a href="#BIO、NIO-和-AIO-的区别？" class="headerlink" title="#BIO、NIO 和 AIO 的区别？"></a><a href="https://javaguide.cn/java/basis/java-basic-questions-03.html#bio%E3%80%81nio-%E5%92%8C-aio-%E7%9A%84%E5%8C%BA%E5%88%AB">#</a>BIO、NIO 和 AIO 的区别？</h3><p><a href="https://javaguide.cn/java/io/io-model.html">Java IO 模型详解</a></p>
<h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><h3 id="什么是语法糖？"><a href="#什么是语法糖？" class="headerlink" title="什么是语法糖？"></a>什么是语法糖？</h3><p><strong>语法糖（Syntactic sugar）</strong> 代指的是编程语言为了方便程序员开发程序而设计的一种特殊语法，这种语法对编程语言的功能并没有影响。实现相同的功能，基于语法糖写出来的代码往往更简单简洁且更易阅读。</p>
<p>举个例子，Java 中的 <code>for-each</code> 就是一个常用的语法糖，其原理其实就是基于普通的 for 循环和迭代器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] strs = &#123;<span class="string">&quot;JavaGuide&quot;</span>, <span class="string">&quot;公众号：JavaGuide&quot;</span>, <span class="string">&quot;博客：https://javaguide.cn/&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (String s : strs) &#123;</span><br><span class="line">  	System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过，JVM 其实并不能识别语法糖，Java 语法糖要想被正确执行，需要先通过编译器进行解糖，也就是在程序编译阶段将其转换成 JVM 认识的基本语法。这也侧面说明，Java 中真正支持语法糖的是 Java 编译器而不是 JVM。如果你去看<code>com.sun.tools.javac.main.JavaCompiler</code>的源码，你会发现在<code>compile()</code>中有一个步骤就是调用<code>desugar()</code>，这个方法就是负责解语法糖的实现的。</p>
<h3 id="Java-中有哪些常见的语法糖？"><a href="#Java-中有哪些常见的语法糖？" class="headerlink" title="Java 中有哪些常见的语法糖？"></a>Java 中有哪些常见的语法糖？</h3><p>Java 中最常用的语法糖主要有泛型、自动拆装箱、变长参数、枚举、内部类、增强 for 循环、try-with-resources 语法、lambda 表达式等。</p>
<p>关于这些语法糖的详细解读，请看这篇文章 <a href="https://javaguide.cn/java/basis/syntactic-sugar.html">Java 语法糖详解</a> 。</p>
]]></content>
  </entry>
  <entry>
    <title>Java集合面试</title>
    <url>/2022/08/23/Java%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h1 id="Java集合常见面试题总结-上"><a href="#Java集合常见面试题总结-上" class="headerlink" title="Java集合常见面试题总结(上)"></a>Java集合常见面试题总结(上)</h1><h2 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h2><h3 id="Java-集合概览"><a href="#Java-集合概览" class="headerlink" title="Java 集合概览"></a>Java 集合概览</h3><p>Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code>接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。对于<code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 和 <code>Queue</code>。</p>
<p>Java 集合框架如下图所示：</p>
<p><img src="https://files.catbox.moe/eil7yp.png"></p>
<p>注：图中只列举了主要的继承派生关系，并没有列举所有关系。比方省略了<code>AbstractList</code>, <code>NavigableSet</code>等抽象类以及其他的一些辅助类，如想深入了解，可自行查看源码。</p>
<h3 id="说说-List-Set-Queue-Map-四者的区别？"><a href="#说说-List-Set-Queue-Map-四者的区别？" class="headerlink" title="说说 List, Set, Queue, Map 四者的区别？"></a>说说 List, Set, Queue, Map 四者的区别？</h3><ul>
<li><code>List</code>(对付顺序的好帮手): 存储的元素是有序的、可重复的。</li>
<li><code>Set</code>(注重独一无二的性质): 存储的元素是无序的、不可重复的。</li>
<li><code>Queue</code>(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li>
<li><code>Map</code>(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y&#x3D;f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li>
</ul>
<h3 id="集合框架底层数据结构总结"><a href="#集合框架底层数据结构总结" class="headerlink" title="集合框架底层数据结构总结"></a>集合框架底层数据结构总结</h3><p>先来看一下 <code>Collection</code> 接口下面的集合。</p>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><ul>
<li><code>ArrayList</code>： <code>Object[]</code> 数组</li>
<li><code>Vector</code>：<code>Object[]</code> 数组</li>
<li><code>LinkedList</code>： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li>
</ul>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><ul>
<li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li>
<li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</li>
<li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)</li>
</ul>
<h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><ul>
<li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现二叉堆</li>
<li><code>ArrayQueue</code>: <code>Object[]</code> 数组 + 双指针</li>
</ul>
<p>再来看看 <code>Map</code> 接口下面的集合。</p>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><ul>
<li><code>HashMap</code>： JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li>
<li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a href="https://www.imooc.com/article/22931">《LinkedHashMap 源码详细分析（JDK1.8）》open in new window</a></li>
<li><code>Hashtable</code>： 数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的</li>
<li><code>TreeMap</code>： 红黑树（自平衡的排序二叉树）</li>
</ul>
<h3 id="如何选用集合"><a href="#如何选用集合" class="headerlink" title="如何选用集合?"></a>如何选用集合?</h3><p>主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用 <code>Map</code> 接口下的集合，需要排序时选择 <code>TreeMap</code>,不需要排序时就选择 <code>HashMap</code>,需要保证线程安全就选用 <code>ConcurrentHashMap</code>。</p>
<p>当我们只需要存放元素值时，就选择实现<code>Collection</code> 接口的集合，需要保证元素唯一时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code>，不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code>，然后再根据实现这些接口的集合的特点来选用。</p>
<h3 id="为什么要使用集合？"><a href="#为什么要使用集合？" class="headerlink" title="为什么要使用集合？"></a>为什么要使用集合？</h3><p>当我们需要保存一组类型相同的数据的时候，我们应该是用一个容器来保存，这个容器就是数组，但是，使用数组存储对象具有一定的弊端， 因为我们在实际开发中，存储的数据的类型是多种多样的，于是，就出现了“集合”，集合同样也是用来存储多个数据的。</p>
<p>数组的缺点是一旦声明之后，长度就不可变了；同时，声明数组时的数据类型也决定了该数组存储的数据的类型；而且，数组存储的数据是有序的、可重复的，特点单一。 但是集合提高了数据存储的灵活性，Java 集合不仅可以用来存储不同类型不同数量的对象，还可以保存具有映射关系的数据。</p>
<h2 id="Collection-子接口之-List"><a href="#Collection-子接口之-List" class="headerlink" title="Collection 子接口之 List"></a>Collection 子接口之 List</h2><h3 id="ArrayList-和-Vector-的区别"><a href="#ArrayList-和-Vector-的区别" class="headerlink" title="ArrayList 和 Vector 的区别?"></a>ArrayList 和 Vector 的区别?</h3><ul>
<li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[ ]</code>存储，适用于频繁的查找工作，线程不安全 ；</li>
<li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[ ]</code> 存储，线程安全的。</li>
</ul>
<h3 id="ArrayList-与-LinkedList-区别"><a href="#ArrayList-与-LinkedList-区别" class="headerlink" title="ArrayList 与 LinkedList 区别?"></a>ArrayList 与 LinkedList 区别?</h3><ul>
<li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li>
<li><strong>底层数据结构：</strong> <code>ArrayList</code> 底层使用的是 <strong>Object 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li>
<li>插入和删除是否受元素位置的影响：<ul>
<li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向前移一位的操作。</li>
<li><code>LinkedList</code> 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code> 、 <code>removeLast()</code>），时间复杂度为 O(1)，如果是要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入。</li>
</ul>
</li>
<li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li>
<li><strong>内存空间占用：</strong> <code>ArrayList</code> 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>
</ul>
<p>我们在项目中一般是不会使用到 <code>LinkedList</code> 的，需要用到 <code>LinkedList</code> 的场景几乎都可以使用 <code>ArrayList</code> 来代替，并且，性能通常会更好！就连 <code>LinkedList</code> 的作者约书亚 · 布洛克（Josh Bloch）自己都说从来不会使用 <code>LinkedList</code> 。</p>
<p><img src="https://files.catbox.moe/h0y589.png"></p>
<p>另外，不要下意识地认为 <code>LinkedList</code> 作为链表就最适合元素增删的场景。我在上面也说了，<code>LinkedList</code> 仅仅在头尾插入或者删除元素的时候时间复杂度近似 O(1)，其他情况增删元素的时间复杂度都是 O(n) 。</p>
<h4 id="补充内容-双向链表和双向循环链表"><a href="#补充内容-双向链表和双向循环链表" class="headerlink" title="补充内容:双向链表和双向循环链表"></a>补充内容:双向链表和双向循环链表</h4><p><strong>双向链表：</strong> 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。</p>
<p><img src="https://files.catbox.moe/kawnt6.png"></p>
<p><strong>双向循环链表：</strong> 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。</p>
<p><img src="https://files.catbox.moe/s37n6q.png"></p>
<h4 id="补充内容-RandomAccess-接口"><a href="#补充内容-RandomAccess-接口" class="headerlink" title="补充内容:RandomAccess 接口"></a>补充内容:RandomAccess 接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RandomAccess</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看源码我们发现实际上 <code>RandomAccess</code> 接口中什么都没有定义。所以，在我看来 <code>RandomAccess</code> 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。</p>
<p>在 <code>binarySearch（)</code> 方法中，它要判断传入的 list 是否 <code>RandomAccess</code> 的实例，如果是，调用<code>indexedBinarySearch()</code>方法，如果不是，那么调用<code>iteratorBinarySearch()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="built_in">super</span> T&gt;&gt; list, T key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class="line">        <span class="keyword">return</span> Collections.indexedBinarySearch(list, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Collections.iteratorBinarySearch(list, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口， 而 <code>LinkedList</code> 没有实现。为什么呢？我觉得还是和底层数据结构有关！<code>ArrayList</code> 底层是数组，而 <code>LinkedList</code> 底层是链表。数组天然支持随机访问，时间复杂度为 O(1)，所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O(n)，所以不支持快速随机访问。，<code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口，就表明了他具有快速随机访问功能。 <code>RandomAccess</code> 接口只是标识，并不是说 <code>ArrayList</code> 实现 <code>RandomAccess</code> 接口才具有快速随机访问功能的！</p>
<h3 id="说一说-ArrayList-的扩容机制吧"><a href="#说一说-ArrayList-的扩容机制吧" class="headerlink" title="说一说 ArrayList 的扩容机制吧"></a>说一说 ArrayList 的扩容机制吧</h3><p>详见笔主的这篇文章: <a href="https://javaguide.cn/java/collection/arraylist-source-code.html#_3-1-%E5%85%88%E4%BB%8E-arraylist-%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%B4%E8%B5%B7">ArrayList 扩容机制分析open in new window</a></p>
<h2 id="Collection-子接口之-Set"><a href="#Collection-子接口之-Set" class="headerlink" title="Collection 子接口之 Set"></a>Collection 子接口之 Set</h2><h3 id="comparable-和-Comparator-的区别"><a href="#comparable-和-Comparator-的区别" class="headerlink" title="comparable 和 Comparator 的区别"></a>comparable 和 Comparator 的区别</h3><ul>
<li><code>comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li>
<li><code>comparator</code>接口实际上是出自 java.util 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li>
</ul>
<p>一般我们需要对一个集合使用自定义排序时，我们就要重写<code>compareTo()</code>方法或<code>compare()</code>方法，当我们需要对某一个集合实现两种排序方式，比如一个 song 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写<code>compareTo()</code>方法和使用自制的<code>Comparator</code>方法或者以两个 Comparator 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 <code>Collections.sort()</code>.</p>
<h4 id="Comparator-定制排序"><a href="#Comparator-定制排序" class="headerlink" title="Comparator 定制排序"></a>Comparator 定制排序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">arrayList.add(-<span class="number">1</span>);</span><br><span class="line">arrayList.add(<span class="number">3</span>);</span><br><span class="line">arrayList.add(<span class="number">3</span>);</span><br><span class="line">arrayList.add(-<span class="number">5</span>);</span><br><span class="line">arrayList.add(<span class="number">7</span>);</span><br><span class="line">arrayList.add(<span class="number">4</span>);</span><br><span class="line">arrayList.add(-<span class="number">9</span>);</span><br><span class="line">arrayList.add(-<span class="number">7</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;原始数组:&quot;</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"><span class="comment">// void reverse(List list)：反转</span></span><br><span class="line">Collections.reverse(arrayList);</span><br><span class="line">System.out.println(<span class="string">&quot;Collections.reverse(arrayList):&quot;</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// void sort(List list),按自然排序的升序排序</span></span><br><span class="line">Collections.sort(arrayList);</span><br><span class="line">System.out.println(<span class="string">&quot;Collections.sort(arrayList):&quot;</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"><span class="comment">// 定制排序的用法</span></span><br><span class="line">Collections.sort(arrayList, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;定制排序后：&quot;</span>);</span><br><span class="line">System.out.println(arrayList);</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">原始数组:</span><br><span class="line">[-<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, -<span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, -<span class="number">9</span>, -<span class="number">7</span>]</span><br><span class="line">Collections.reverse(arrayList):</span><br><span class="line">[-<span class="number">7</span>, -<span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, -<span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>, -<span class="number">1</span>]</span><br><span class="line">Collections.sort(arrayList):</span><br><span class="line">[-<span class="number">9</span>, -<span class="number">7</span>, -<span class="number">5</span>, -<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>]</span><br><span class="line">定制排序后：</span><br><span class="line">[<span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, -<span class="number">1</span>, -<span class="number">5</span>, -<span class="number">7</span>, -<span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<h4 id="重写-compareTo-方法实现按年龄来排序"><a href="#重写-compareTo-方法实现按年龄来排序" class="headerlink" title="重写 compareTo 方法实现按年龄来排序"></a>重写 compareTo 方法实现按年龄来排序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列</span></span><br><span class="line"><span class="comment">// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他</span></span><br><span class="line"><span class="comment">// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了</span></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Person&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * T重写compareTo方法实现按年龄来排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Person o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.age &gt; o.getAge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.age &lt; o.getAge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    TreeMap&lt;Person, String&gt; pdata = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;Person, String&gt;();</span><br><span class="line">    pdata.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">30</span>), <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    pdata.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>), <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">    pdata.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">10</span>), <span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">    pdata.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小红&quot;</span>, <span class="number">5</span>), <span class="string">&quot;xiaohong&quot;</span>);</span><br><span class="line">    <span class="comment">// 得到key的值的同时得到key所对应的值</span></span><br><span class="line">    Set&lt;Person&gt; keys = pdata.keySet();</span><br><span class="line">    <span class="keyword">for</span> (Person key : keys) &#123;</span><br><span class="line">        System.out.println(key.getAge() + <span class="string">&quot;-&quot;</span> + key.getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span>-小红</span><br><span class="line"><span class="number">10</span>-王五</span><br><span class="line"><span class="number">20</span>-李四</span><br><span class="line"><span class="number">30</span>-张三</span><br></pre></td></tr></table></figure>

<h3 id="无序性和不可重复性的含义是什么"><a href="#无序性和不可重复性的含义是什么" class="headerlink" title="无序性和不可重复性的含义是什么"></a>无序性和不可重复性的含义是什么</h3><ul>
<li>无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</li>
<li>不可重复性是指添加的元素按照 <code>equals()</code> 判断时 ，返回 false，需要同时重写 <code>equals()</code> 方法和 <code>hashCode()</code> 方法。</li>
</ul>
<h3 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3><ul>
<li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li>
<li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li>
<li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li>
</ul>
<h2 id="Collection-子接口之-Queue"><a href="#Collection-子接口之-Queue" class="headerlink" title="Collection 子接口之 Queue"></a>Collection 子接口之 Queue</h2><h3 id="Queue-与-Deque-的区别"><a href="#Queue-与-Deque-的区别" class="headerlink" title="Queue 与 Deque 的区别"></a>Queue 与 Deque 的区别</h3><p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p>
<p><code>Queue</code> 扩展了 <code>Collection</code> 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p>
<table>
<thead>
<tr>
<th><code>Queue</code> 接口</th>
<th>抛出异常</th>
<th>返回特殊值</th>
</tr>
</thead>
<tbody><tr>
<td>插入队尾</td>
<td>add(E e)</td>
<td>offer(E e)</td>
</tr>
<tr>
<td>删除队首</td>
<td>remove()</td>
<td>poll()</td>
</tr>
<tr>
<td>查询队首元素</td>
<td>element()</td>
<td>peek()</td>
</tr>
</tbody></table>
<p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p>
<p><code>Deque</code> 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p>
<table>
<thead>
<tr>
<th><code>Deque</code> 接口</th>
<th>抛出异常</th>
<th>返回特殊值</th>
</tr>
</thead>
<tbody><tr>
<td>插入队首</td>
<td>addFirst(E e)</td>
<td>offerFirst(E e)</td>
</tr>
<tr>
<td>插入队尾</td>
<td>addLast(E e)</td>
<td>offerLast(E e)</td>
</tr>
<tr>
<td>删除队首</td>
<td>removeFirst()</td>
<td>pollFirst()</td>
</tr>
<tr>
<td>删除队尾</td>
<td>removeLast()</td>
<td>pollLast()</td>
</tr>
<tr>
<td>查询队首元素</td>
<td>getFirst()</td>
<td>peekFirst()</td>
</tr>
<tr>
<td>查询队尾元素</td>
<td>getLast()</td>
<td>peekLast()</td>
</tr>
</tbody></table>
<p>事实上，<code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code> 等其他方法，可用于模拟栈。</p>
<h3 id="ArrayDeque-与-LinkedList-的区别"><a href="#ArrayDeque-与-LinkedList-的区别" class="headerlink" title="ArrayDeque 与 LinkedList 的区别"></a>ArrayDeque 与 LinkedList 的区别</h3><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能，但两者有什么区别呢？</p>
<ul>
<li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li>
<li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li>
<li><code>ArrayDeque</code> 是在 JDK1.6 才被引入的，而<code>LinkedList</code> 早在 JDK1.2 时就已经存在。</li>
<li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li>
</ul>
<p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</p>
<h3 id="说一说-PriorityQueue"><a href="#说一说-PriorityQueue" class="headerlink" title="说一说 PriorityQueue"></a>说一说 PriorityQueue</h3><p><code>PriorityQueue</code> 是在 JDK1.5 中被引入的, 其与 <code>Queue</code> 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p>
<p>这里列举其相关的一些要点：</p>
<ul>
<li><code>PriorityQueue</code> 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li>
<li><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li>
<li><code>PriorityQueue</code> 是非线程安全的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</li>
<li><code>PriorityQueue</code> 默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li>
</ul>
<p><code>PriorityQueue</code> 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第K大的数、带权图的遍历等，所以需要会熟练使用才行。</p>
<h1 id="Java集合常见面试题总结-下-Map-接口"><a href="#Java集合常见面试题总结-下-Map-接口" class="headerlink" title="Java集合常见面试题总结(下)Map 接口"></a>Java集合常见面试题总结(下)Map 接口</h1><h3 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h3><ul>
<li><strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</li>
<li><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它；</li>
<li><strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</li>
<li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 <code>Hashtable</code> 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</li>
<li><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间（后文中我会结合源码对这一过程进行分析）。<code>Hashtable</code> 没有这样的机制。</li>
</ul>
<p><strong>HashMap 中带有初始容量的构造函数：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这个方法保证了 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashMap-和-HashSet-区别"><a href="#HashMap-和-HashSet-区别" class="headerlink" title="HashMap 和 HashSet 区别"></a>HashMap 和 HashSet 区别</h3><p>如果你看过 <code>HashSet</code> 源码的话就应该知道：<code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。（<code>HashSet</code> 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 <code>HashSet</code> 自己不得不实现之外，其他方法都是直接调用 <code>HashMap</code> 中的方法。</p>
<table>
<thead>
<tr>
<th><code>HashMap</code></th>
<th><code>HashSet</code></th>
</tr>
</thead>
<tbody><tr>
<td>实现了 <code>Map</code> 接口</td>
<td>实现 <code>Set</code> 接口</td>
</tr>
<tr>
<td>存储键值对</td>
<td>仅存储对象</td>
</tr>
<tr>
<td>调用 <code>put()</code>向 map 中添加元素</td>
<td>调用 <code>add()</code>方法向 <code>Set</code> 中添加元素</td>
</tr>
<tr>
<td><code>HashMap</code> 使用键（Key）计算 <code>hashcode</code></td>
<td><code>HashSet</code> 使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以<code>equals()</code>方法用来判断对象的相等性</td>
</tr>
</tbody></table>
<h3 id="HashMap-和-TreeMap-区别"><a href="#HashMap-和-TreeMap-区别" class="headerlink" title="HashMap 和 TreeMap 区别"></a>HashMap 和 TreeMap 区别</h3><p><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口。</p>
<p><img src="https://files.catbox.moe/qdg9gb.png"></p>
<p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。</p>
<p>实现<code>SortedMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020年06月15日 17:02:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TreeMap&lt;Person, String&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person person1, Person person2)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> person1.getAge() - person2.getAge();</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(num, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">3</span>), <span class="string">&quot;person1&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>), <span class="string">&quot;person2&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">35</span>), <span class="string">&quot;person3&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">16</span>), <span class="string">&quot;person4&quot;</span>);</span><br><span class="line">        treeMap.entrySet().stream().forEach(personStringEntry -&gt; &#123;</span><br><span class="line">            System.out.println(personStringEntry.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">person1</span><br><span class="line">person4</span><br><span class="line">person2</span><br><span class="line">person3</span><br></pre></td></tr></table></figure>

<p>可以看出，<code>TreeMap</code> 中的元素已经是按照 <code>Person</code> 的 age 字段的升序来排列了。</p>
<p>上面，我们是通过传入匿名内部类的方式实现的，你可以将代码替换成 Lambda 表达式实现的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeMap&lt;Person, String&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;((person1, person2) -&gt; &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> person1.getAge() - person2.getAge();</span><br><span class="line">  <span class="keyword">return</span> Integer.compare(num, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>综上，相比于HashMap来说 TreeMap 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</strong></p>
<h3 id="HashSet-如何检查重复"><a href="#HashSet-如何检查重复" class="headerlink" title="HashSet 如何检查重复?"></a>HashSet 如何检查重复?</h3><p>以下内容摘自我的 Java 启蒙书《Head first java》第二版：</p>
<blockquote>
<p>当你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p>
</blockquote>
<p>在 JDK1.8 中，<code>HashSet</code>的<code>add()</code>方法只是简单的调用了<code>HashMap</code>的<code>put()</code>方法，并且判断了一下返回值以确保是否有重复元素。直接看一下<code>HashSet</code>中的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns: true if this set did not already contain the specified element</span></span><br><span class="line"><span class="comment">// 返回值：当 set 中没有包含 add 的元素时返回真</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在<code>HashMap</code>的<code>putVal()</code>方法中也能看到如下说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns : previous value, or null if none</span></span><br><span class="line"><span class="comment">// 返回值：如果插入位置没有元素返回null，否则返回上一个元素</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，在 JDK1.8 中，实际上无论<code>HashSet</code>中是否已经存在了某元素，<code>HashSet</code>都会直接插入，只是会在<code>add()</code>方法的返回值处告诉我们插入前是否存在相同元素。</p>
<h3 id="HashMap-的底层实现"><a href="#HashMap-的底层实现" class="headerlink" title="HashMap 的底层实现"></a>HashMap 的底层实现</h3><h4 id="JDK1-8-之前"><a href="#JDK1-8-之前" class="headerlink" title="JDK1.8 之前"></a>JDK1.8 之前</h4><p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。HashMap 通过 key 的 <code>hashcode</code> 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p>
<p>所谓扰动函数指的就是 HashMap 的 <code>hash</code> 方法。使用 <code>hash</code> 方法也就是扰动函数是为了防止一些实现比较差的 <code>hashCode()</code> 方法 换句话说使用扰动函数之后可以减少碰撞。</p>
<p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p>
<p>JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">    <span class="comment">// ^ ：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比一下 JDK1.7 的 HashMap 的 hash 方法源码.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line"></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p>
<p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
<p><img src="https://files.catbox.moe/dccfp2.png"></p>
<h4 id="JDK1-8-之后"><a href="#JDK1-8-之后" class="headerlink" title="JDK1.8 之后"></a>JDK1.8 之后</h4><p>相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>
<p><img src="https://files.catbox.moe/1kc8mi.png"></p>
<blockquote>
<p>TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p>
</blockquote>
<p>我们来结合源码分析一下 <code>HashMap</code> 链表到红黑树的转换。</p>
<p><strong>1、 putVal 方法中执行链表转红黑树的判断逻辑。</strong></p>
<p>链表的长度大于 8 的时候，就执行 <code>treeifyBin</code> （转换红黑树）的逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历链表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">    <span class="comment">// 遍历到链表最后一个节点</span></span><br><span class="line">    <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">        p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 如果链表元素个数大于等于TREEIFY_THRESHOLD（8）</span></span><br><span class="line">        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">            <span class="comment">// 红黑树转换（并不会直接转换成红黑树）</span></span><br><span class="line">            treeifyBin(tab, hash);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    p = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、treeifyBin 方法中判断是否真的转换为红黑树。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 判断当前数组的长度是否小于 64</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        <span class="comment">// 如果当前数组的长度小于 64，那么会选择先进行数组扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 否则才将列表转换为红黑树</span></span><br><span class="line"></span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树。</p>
<h3 id="HashMap-的长度为什么是-2-的幂次方"><a href="#HashMap-的长度为什么是-2-的幂次方" class="headerlink" title="HashMap 的长度为什么是 2 的幂次方"></a>HashMap 的长度为什么是 2 的幂次方</h3><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ <code>(n - 1) &amp; hash</code>”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。</p>
<p><strong>这个算法应该如何设计呢？</strong></p>
<p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：<strong>“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）。”</strong> 并且 <strong>采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。</strong></p>
<h3 id="HashMap-多线程操作导致死循环问题"><a href="#HashMap-多线程操作导致死循环问题" class="headerlink" title="HashMap 多线程操作导致死循环问题"></a>HashMap 多线程操作导致死循环问题</h3><p>主要原因在于并发下的 Rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。</p>
<p>详情请查看：<a href="https://coolshell.cn/articles/9606.html">https://coolshell.cn/articles/9606.htmlopen in new window</a></p>
<h3 id="HashMap-有哪几种常见的遍历方式"><a href="#HashMap-有哪几种常见的遍历方式" class="headerlink" title="HashMap 有哪几种常见的遍历方式?"></a>HashMap 有哪几种常见的遍历方式?</h3><p><a href="https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw">HashMap 的 7 种遍历方式与性能分析！open in new window</a></p>
<h3 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别"></a>ConcurrentHashMap 和 Hashtable 的区别</h3><p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p>
<ul>
<li><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表&#x2F;红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>
<li>实现线程安全的方式（重要）：<ul>
<li>在 JDK1.7 的时候，<code>ConcurrentHashMap</code> 对整个桶数组进行了分割分段(<code>Segment</code>，分段锁)，每一把锁只锁容器其中一部分数据（下面有示意图），多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</li>
<li>到了 JDK1.8 的时候，<code>ConcurrentHashMap</code> 已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 <code>synchronized</code> 锁做了很多优化） 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</li>
<li><strong>Hashtable(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>
</ul>
</li>
</ul>
<p>下面，我们再来看看两者底层数据结构的对比图。</p>
<p><strong>Hashtable</strong> :</p>
<p><img src="https://files.catbox.moe/nip7lb.png"></p>
<p><strong>JDK1.7 的 ConcurrentHashMap</strong> ：</p>
<p><img src="https://files.catbox.moe/ioj484.png"></p>
<p><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成。</p>
<p><code>Segment</code> 数组中的每个元素包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 数组属于链表结构。</p>
<p><strong>JDK1.8 的 ConcurrentHashMap</strong> ：</p>
<p><img src="https://files.catbox.moe/7bu6ts.png"></p>
<p>JDK1.8 的 <code>ConcurrentHashMap</code> 不再是 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 &#x2F; 红黑树</strong>。不过，Node 只能用于链表的情况，红黑树的情况需要使用 <strong>TreeNode</strong>。当冲突链表达到一定长度时，链表会转换成红黑树。</p>
<p><code>TreeNode</code>是存储红黑树节点，被<code>TreeBin</code>包装。<code>TreeBin</code>通过<code>root</code>属性维护红黑树的根结点，因为红黑树在旋转的时候，根结点可能会被它原来的子节点替换掉，在这个时间点，如果有其他线程要写这棵红黑树就会发生线程不安全问题，所以在 <code>ConcurrentHashMap</code> 中<code>TreeBin</code>通过<code>waiter</code>属性维护当前使用这棵红黑树的线程，来防止其他线程的进入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeBin</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; root;</span><br><span class="line">        <span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line">        <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">int</span> lockState;</span><br><span class="line">        <span class="comment">// values for lockState</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WRITER</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// set while holding write lock</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WAITER</span> <span class="operator">=</span> <span class="number">2</span>; <span class="comment">// set when waiting for write lock</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">READER</span> <span class="operator">=</span> <span class="number">4</span>; <span class="comment">// increment value for setting read lock</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ConcurrentHashMap-线程安全的具体实现方式-x2F-底层具体实现"><a href="#ConcurrentHashMap-线程安全的具体实现方式-x2F-底层具体实现" class="headerlink" title="ConcurrentHashMap 线程安全的具体实现方式&#x2F;底层具体实现"></a>ConcurrentHashMap 线程安全的具体实现方式&#x2F;底层具体实现</h3><h4 id="JDK1-8-之前-1"><a href="#JDK1-8-之前-1" class="headerlink" title="JDK1.8 之前"></a>JDK1.8 之前</h4><p><img src="https://files.catbox.moe/t9el15.png"></p>
<p>首先将数据分为一段一段（这个“段”就是 <code>Segment</code>）的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>
<p><strong>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成</strong>。</p>
<p><code>Segment</code> 继承了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。<code>HashEntry</code> 用于存储键值对数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Segment</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组，<code>Segment</code> 的个数一旦<strong>初始化就不能改变</strong>。 <code>Segment</code> 数组的大小默认是 16，也就是说默认可以同时支持 16 个线程并发写。</p>
<p><code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。也就是说，对同一 <code>Segment</code> 的并发写入会被阻塞，不同 <code>Segment</code> 的写入是可以并发执行的。</p>
<h4 id="JDK1-8-之后-1"><a href="#JDK1-8-之后-1" class="headerlink" title="JDK1.8 之后"></a>JDK1.8 之后</h4><p><img src="https://files.catbox.moe/p3rwe7.png"></p>
<p>Java 8 几乎完全重写了 <code>ConcurrentHashMap</code>，代码量从原来 Java 7 中的 1000 多行，变成了现在的 6000 多行。</p>
<p><code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 <code>Node + CAS + synchronized</code> 来保证并发安全。数据结构跟 <code>HashMap</code> 1.8 的结构类似，数组+链表&#x2F;红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）。</p>
<p>Java 8 中，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。</p>
<h3 id="JDK-1-7-和-JDK-1-8-的-ConcurrentHashMap-实现有什么不同？"><a href="#JDK-1-7-和-JDK-1-8-的-ConcurrentHashMap-实现有什么不同？" class="headerlink" title="JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？"></a>JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？</h3><ul>
<li><strong>线程安全实现方式</strong> ：JDK 1.7 采用 <code>Segment</code> 分段锁来保证安全， <code>Segment</code> 是继承自 <code>ReentrantLock</code>。JDK1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</li>
<li><strong>Hash 碰撞解决方法</strong> : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。</li>
<li><strong>并发度</strong> ：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</li>
</ul>
<h2 id="Collections-工具类（不重要）"><a href="#Collections-工具类（不重要）" class="headerlink" title="Collections 工具类（不重要）"></a>Collections 工具类（不重要）</h2><p><strong>Collections 工具类常用方法</strong>:</p>
<ul>
<li>排序</li>
<li>查找,替换操作</li>
<li>同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)</li>
</ul>
<h3 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(List list)</span><span class="comment">//反转</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(List list)</span><span class="comment">//随机排序</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List list)</span><span class="comment">//按自然排序的升序排序</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List list, Comparator c)</span><span class="comment">//定制排序，由Comparator控制排序逻辑</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(List list, <span class="type">int</span> i , <span class="type">int</span> j)</span><span class="comment">//交换两个索引位置的元素</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(List list, <span class="type">int</span> distance)</span><span class="comment">//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面</span></span><br></pre></td></tr></table></figure>

<h3 id="查找-替换操作"><a href="#查找-替换操作" class="headerlink" title="查找,替换操作"></a>查找,替换操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(List list, Object key)</span><span class="comment">//对List进行二分查找，返回索引，注意List必须是有序的</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(Collection coll)</span><span class="comment">//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(Collection coll, Comparator c)</span><span class="comment">//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">fill</span><span class="params">(List list, Object obj)</span><span class="comment">//用指定的元素代替指定list中的所有元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">frequency</span><span class="params">(Collection c, Object o)</span><span class="comment">//统计元素出现次数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOfSubList</span><span class="params">(List list, List target)</span><span class="comment">//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">replaceAll</span><span class="params">(List list, Object oldVal, Object newVal)</span><span class="comment">//用新元素替换旧元素</span></span><br></pre></td></tr></table></figure>

<h3 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h3><p><code>Collections</code> 提供了多个<code>synchronizedXxx()</code>方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。</p>
<p>我们知道 <code>HashSet</code>，<code>TreeSet</code>，<code>ArrayList</code>,<code>LinkedList</code>,<code>HashMap</code>,<code>TreeMap</code> 都是线程不安全的。<code>Collections</code> 提供了多个静态方法可以把他们包装成线程同步的集合。</p>
<p><strong>最好不要用下面这些方法，效率非常低，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合。</strong></p>
<p>方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">synchronizedCollection(Collection&lt;T&gt;  c) <span class="comment">//返回指定 collection 支持的同步（线程安全的）collection。</span></span><br><span class="line">synchronizedList(List&lt;T&gt; list)<span class="comment">//返回指定列表支持的同步（线程安全的）List。</span></span><br><span class="line">synchronizedMap(Map&lt;K,V&gt; m) <span class="comment">//返回由指定映射支持的同步（线程安全的）Map。</span></span><br><span class="line">synchronizedSet(Set&lt;T&gt; s) <span class="comment">//返回指定 set 支持的同步（线程安全的）set。</span></span><br></pre></td></tr></table></figure>

<h1 id="Java集合使用注意事项总结"><a href="#Java集合使用注意事项总结" class="headerlink" title="Java集合使用注意事项总结"></a>Java集合使用注意事项总结</h1><p>这篇文章我根据《阿里巴巴 Java 开发手册》总结了关于集合使用常见的注意事项以及其具体原理。</p>
<p>强烈建议小伙伴们多多阅读几遍，避免自己写代码的时候出现这些低级的问题。</p>
<h2 id="集合判空"><a href="#集合判空" class="headerlink" title="集合判空"></a>集合判空</h2><p>《阿里巴巴 Java 开发手册》的描述如下：</p>
<blockquote>
<p><strong>判断所有集合内部的元素是否为空，使用 isEmpty() 方法，而不是 size()&#x3D;&#x3D;0 的方式。</strong></p>
</blockquote>
<p>这是因为 <code>isEmpty()</code> 方法的可读性更好，并且时间复杂度为 O(1)。</p>
<p>绝大部分我们使用的集合的 <code>size()</code> 方法的时间复杂度也是 O(1)，不过，也有很多复杂度不是 O(1) 的，比如 <code>java.util.concurrent</code> 包下的某些集合（<code>ConcurrentLinkedQueue</code> 、<code>ConcurrentHashMap</code>…）。</p>
<p>下面是 <code>ConcurrentHashMap</code> 的 <code>size()</code> 方法和 <code>isEmpty()</code> 方法的源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">n</span> <span class="operator">=</span> sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">            (n &gt; (<span class="type">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (<span class="type">int</span>)n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">sumCount</span><span class="params">()</span> &#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sumCount() &lt;= <span class="number">0L</span>; <span class="comment">// ignore transient negative values</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集合转-Map"><a href="#集合转-Map" class="headerlink" title="集合转 Map"></a>集合转 Map</h2><p>《阿里巴巴 Java 开发手册》的描述如下：</p>
<blockquote>
<p><strong>在使用 java.util.stream.Collectors 类的 toMap() 方法转为 Map 集合时，一定要注意当 value 为 null 时会抛 NPE 异常。</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String phoneNumber;</span><br><span class="line">     <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Person&gt; bookList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">bookList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;jack&quot;</span>,<span class="string">&quot;18163138123&quot;</span>));</span><br><span class="line">bookList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;martin&quot;</span>,<span class="literal">null</span>));</span><br><span class="line"><span class="comment">// 空指针异常</span></span><br><span class="line">bookList.stream().collect(Collectors.toMap(Person::getName, Person::getPhoneNumber));</span><br></pre></td></tr></table></figure>

<p>下面我们来解释一下原因。</p>
<p>首先，我们来看 <code>java.util.stream.Collectors</code> 类的 <code>toMap()</code> 方法 ，可以看到其内部调用了 <code>Map</code> 接口的 <code>merge()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, U, M <span class="keyword">extends</span> <span class="title class_">Map</span>&lt;K, U&gt;&gt;</span><br><span class="line">Collector&lt;T, ?, M&gt; toMap(Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">K</span>&gt; keyMapper,</span><br><span class="line">                            Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">U</span>&gt; valueMapper,</span><br><span class="line">                            BinaryOperator&lt;U&gt; mergeFunction,</span><br><span class="line">                            Supplier&lt;M&gt; mapSupplier) &#123;</span><br><span class="line">    BiConsumer&lt;M, T&gt; accumulator</span><br><span class="line">            = (map, element) -&gt; map.merge(keyMapper.apply(element),</span><br><span class="line">                                          valueMapper.apply(element), mergeFunction);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CollectorImpl</span>&lt;&gt;(mapSupplier, accumulator, mapMerger(mergeFunction), CH_ID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Map</code> 接口的 <code>merge()</code> 方法如下，这个方法是接口中的默认实现。</p>
<blockquote>
<p>如果你还不了解 Java 8 新特性的话，请看这篇文章：<a href="https://mp.weixin.qq.com/s/ojyl7B6PiHaTWADqmUq2rw">《Java8 新特性总结》open in new window</a> 。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span> V <span class="title function_">merge</span><span class="params">(K key, V value,</span></span><br><span class="line"><span class="params">        BiFunction&lt;? <span class="built_in">super</span> V, ? <span class="built_in">super</span> V, ? extends V&gt; remappingFunction)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(remappingFunction);</span><br><span class="line">    Objects.requireNonNull(value);</span><br><span class="line">    <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> get(key);</span><br><span class="line">    <span class="type">V</span> <span class="variable">newValue</span> <span class="operator">=</span> (oldValue == <span class="literal">null</span>) ? value :</span><br><span class="line">               remappingFunction.apply(oldValue, value);</span><br><span class="line">    <span class="keyword">if</span>(newValue == <span class="literal">null</span>) &#123;</span><br><span class="line">        remove(key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        put(key, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>merge()</code> 方法会先调用 <code>Objects.requireNonNull()</code> 方法判断 value 是否为空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">requireNonNull</span><span class="params">(T obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集合遍历"><a href="#集合遍历" class="headerlink" title="集合遍历"></a>集合遍历</h2><p>《阿里巴巴 Java 开发手册》的描述如下：</p>
<blockquote>
<p><strong>不要在 foreach 循环里进行元素的 remove&#x2F;add 操作。remove 元素请使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁。</strong></p>
</blockquote>
<p>通过反编译你会发现 foreach 语法底层其实还是依赖 <code>Iterator</code> 。不过， <code>remove/add</code> 操作直接调用的是集合自己的方法，而不是 <code>Iterator</code> 的 <code>remove/add</code>方法</p>
<p>这就导致 <code>Iterator</code> 莫名其妙地发现自己有元素被 <code>remove/add</code> ，然后，它就会抛出一个 <code>ConcurrentModificationException</code> 来提示用户发生了并发修改异常。这就是单线程状态下产生的 <strong>fail-fast 机制</strong>。</p>
<blockquote>
<p><strong>fail-fast 机制</strong> ：多个线程对 fail-fast 集合进行修改的时候，可能会抛出<code>ConcurrentModificationException</code>。 即使是单线程下也有可能会出现这种情况，上面已经提到过。</p>
</blockquote>
<p>Java8 开始，可以使用 <code>Collection#removeIf()</code>方法删除满足特定条件的元素,如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    list.add(i);</span><br><span class="line">&#125;</span><br><span class="line">list.removeIf(filter -&gt; filter % <span class="number">2</span> == <span class="number">0</span>); <span class="comment">/* 删除list中的所有偶数 */</span></span><br><span class="line">System.out.println(list); <span class="comment">/* [1, 3, 5, 7, 9] */</span></span><br></pre></td></tr></table></figure>

<p>除了上面介绍的直接使用 <code>Iterator</code> 进行遍历操作之外，你还可以：</p>
<ul>
<li>使用普通的 for 循环</li>
<li>使用 fail-safe 的集合类。<code>java.util</code>包下面的所有的集合类都是 fail-fast 的，而<code>java.util.concurrent</code>包下面的所有的类都是 fail-safe 的。</li>
<li>……</li>
</ul>
<h2 id="集合去重"><a href="#集合去重" class="headerlink" title="集合去重"></a>集合去重</h2><p>《阿里巴巴 Java 开发手册》的描述如下：</p>
<blockquote>
<p><strong>可以利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的 contains() 进行遍历去重或者判断包含操作。</strong></p>
</blockquote>
<p>这里我们以 <code>HashSet</code> 和 <code>ArrayList</code> 为例说明。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Set 去重代码示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Set&lt;T&gt; <span class="title function_">removeDuplicateBySet</span><span class="params">(List&lt;T&gt; data)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(data)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// List 去重代码示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">removeDuplicateByList</span><span class="params">(List&lt;T&gt; data)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(data)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;T&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(data.size());</span><br><span class="line">    <span class="keyword">for</span> (T current : data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!result.contains(current)) &#123;</span><br><span class="line">            result.add(current);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两者的核心差别在于 <code>contains()</code> 方法的实现。</p>
<p><code>HashSet</code> 的 <code>contains()</code> 方法底部依赖的 <code>HashMap</code> 的 <code>containsKey()</code> 方法，时间复杂度接近于 O（1）（没有出现哈希冲突的时候为 O（1））。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们有 N 个元素插入进 Set 中，那时间复杂度就接近是 O (n)。</p>
<p><code>ArrayList</code> 的 <code>contains()</code> 方法是通过遍历所有元素的方法来做的，时间复杂度接近是 O(n)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的 <code>List</code> 有 N 个元素，那时间复杂度就接近是 O (n^2)。</p>
<h2 id="集合转数组"><a href="#集合转数组" class="headerlink" title="集合转数组"></a>集合转数组</h2><p>《阿里巴巴 Java 开发手册》的描述如下：</p>
<blockquote>
<p><strong>使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全一致、长度为 0 的空数组。</strong></p>
</blockquote>
<p><code>toArray(T[] array)</code> 方法的参数是一个泛型数组，如果 <code>toArray</code> 方法中没有传递任何参数的话返回的是 <code>Object</code>类 型数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String [] s= <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">    <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;lazy&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;over&quot;</span>, <span class="string">&quot;jumps&quot;</span>, <span class="string">&quot;fox&quot;</span>, <span class="string">&quot;brown&quot;</span>, <span class="string">&quot;quick&quot;</span>, <span class="string">&quot;A&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(s);</span><br><span class="line">Collections.reverse(list);</span><br><span class="line"><span class="comment">//没有指定类型的话会报错</span></span><br><span class="line">s=list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<p>由于 JVM 优化，<code>new String[0]</code>作为<code>Collection.toArray()</code>方法的参数现在使用更好，<code>new String[0]</code>就是起一个模板的作用，指定了返回数组的类型，0 是为了节省空间，因为它只是为了说明返回的类型。详见：<a href="https://shipilev.net/blog/2016/arrays-wisdom-ancients/">https://shipilev.net/blog/2016/arrays-wisdom-ancients/open in new window</a></p>
<h2 id="数组转集合"><a href="#数组转集合" class="headerlink" title="数组转集合"></a>数组转集合</h2><p>《阿里巴巴 Java 开发手册》的描述如下：</p>
<blockquote>
<p><strong>使用工具类 Arrays.asList() 把数组转换成集合时，不能使用其修改集合相关的方法， 它的 add&#x2F;remove&#x2F;clear 方法会抛出 UnsupportedOperationException 异常。</strong></p>
</blockquote>
<p>我在之前的一个项目中就遇到一个类似的坑。</p>
<p><code>Arrays.asList()</code>在平时开发中还是比较常见的，我们可以使用它将一个数组转换为一个 <code>List</code> 集合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] myArray = &#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(myArray);</span><br><span class="line"><span class="comment">//上面两个语句等价于下面一条语句</span></span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(<span class="string">&quot;Apple&quot;</span>,<span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>JDK 源码对于这个方法的说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *返回由指定数组支持的固定大小的列表。此方法作为基于数组和基于集合的API之间的桥梁，</span></span><br><span class="line"><span class="comment">  * 与 Collection.toArray()结合使用。返回的List是可序列化并实现RandomAccess接口。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">asList</span><span class="params">(T... a)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们来总结一下使用注意事项。</p>
<p><strong>1、Arrays.asList()是泛型方法，传递的数组必须是对象数组，而不是基本类型。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] myArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.asList(myArray);</span><br><span class="line">System.out.println(myList.size());<span class="comment">//1</span></span><br><span class="line">System.out.println(myList.get(<span class="number">0</span>));<span class="comment">//数组地址值</span></span><br><span class="line">System.out.println(myList.get(<span class="number">1</span>));<span class="comment">//报错：ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="type">int</span>[] array = (<span class="type">int</span>[]) myList.get(<span class="number">0</span>);</span><br><span class="line">System.out.println(array[<span class="number">0</span>]);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p>当传入一个原生数据类型数组时，<code>Arrays.asList()</code> 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时 <code>List</code> 的唯一元素就是这个数组，这也就解释了上面的代码。</p>
<p>我们使用包装类型数组就可以解决这个问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] myArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>2、使用集合的修改方法: add()、remove()、clear()会抛出异常。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">myList.add(<span class="number">4</span>);<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br><span class="line">myList.remove(<span class="number">1</span>);<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br><span class="line">myList.clear();<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br></pre></td></tr></table></figure>

<p><code>Arrays.asList()</code> 方法返回的并不是 <code>java.util.ArrayList</code> ，而是 <code>java.util.Arrays</code> 的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">System.out.println(myList.getClass());<span class="comment">//class java.util.Arrays$ArrayList</span></span><br></pre></td></tr></table></figure>

<p>下图是 <code>java.util.Arrays$ArrayList</code> 的简易源码，我们可以看到这个类重写的方法有哪些。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">      <span class="keyword">implements</span> <span class="title class_">RandomAccess</span>, java.io.Serializable</span><br><span class="line">  &#123;</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">         ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; c)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>我们再看一下<code>java.util.AbstractList</code>的 <code>add/remove/clear</code> 方法就知道为什么会抛出 <code>UnsupportedOperationException</code> 了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    add(size(), e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    removeRange(<span class="number">0</span>, size());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">removeRange</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span> &#123;</span><br><span class="line">    ListIterator&lt;E&gt; it = listIterator(fromIndex);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>, n=toIndex-fromIndex; i&lt;n; i++) &#123;</span><br><span class="line">        it.next();</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>那我们如何正确的将数组转换为 ArrayList ?</strong></p>
<p>1、手动实现工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JDK1.5+</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">arrayToList</span><span class="params">(<span class="keyword">final</span> T[] array)</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> List&lt;T&gt; l = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;T&gt;(array.length);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">final</span> T s : array) &#123;</span><br><span class="line">    l.add(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Integer [] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">System.out.println(arrayToList(myArray).getClass());<span class="comment">//class java.util.ArrayList</span></span><br></pre></td></tr></table></figure>

<p>2、最简便的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>3、使用 Java8 的 <code>Stream</code>(推荐)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer [] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.stream(myArray).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//基本类型也可以实现转换（依赖boxed的装箱操作）</span></span><br><span class="line"><span class="type">int</span> [] myArray2 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.stream(myArray2).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>4、使用 Guava</p>
<p>对于不可变集合，你可以使用<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java"><code>ImmutableList</code>open in new window</a>类及其<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L101"><code>of()</code>open in new window</a>与<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L225"><code>copyOf()</code>open in new window</a>工厂方法：（参数不能为空）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; il = ImmutableList.of(<span class="string">&quot;string&quot;</span>, <span class="string">&quot;elements&quot;</span>);  <span class="comment">// from varargs</span></span><br><span class="line">List&lt;String&gt; il = ImmutableList.copyOf(aStringArray);      <span class="comment">// from array</span></span><br></pre></td></tr></table></figure>

<p>对于可变集合，你可以使用<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java"><code>Lists</code>open in new window</a>类及其<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java#L87"><code>newArrayList()</code>open in new window</a>工厂方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; l1 = Lists.newArrayList(anotherListOrCollection);    <span class="comment">// from collection</span></span><br><span class="line">List&lt;String&gt; l2 = Lists.newArrayList(aStringArray);               <span class="comment">// from array</span></span><br><span class="line">List&lt;String&gt; l3 = Lists.newArrayList(<span class="string">&quot;or&quot;</span>, <span class="string">&quot;string&quot;</span>, <span class="string">&quot;elements&quot;</span>); <span class="comment">// from varargs</span></span><br></pre></td></tr></table></figure>

<p>5、使用 Apache Commons Collections</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">CollectionUtils.addAll(list, str);</span><br></pre></td></tr></table></figure>

<p>6、 使用 Java9 的 <code>List.of()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list = List.of(array);</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Java集合源码分析</title>
    <url>/2022/08/23/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h1 id="ArrayList源码-amp-扩容机制分析"><a href="#ArrayList源码-amp-扩容机制分析" class="headerlink" title="ArrayList源码&amp;扩容机制分析"></a>ArrayList源码&amp;扩容机制分析</h1><h2 id="ArrayList-简介"><a href="#ArrayList-简介" class="headerlink" title="ArrayList 简介"></a>ArrayList 简介</h2><p><code>ArrayList</code> 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用<code>ensureCapacity</code>操作来增加 <code>ArrayList</code> 实例的容量。这可以减少递增式再分配的数量。</p>
<p><code>ArrayList</code>继承于 <strong>AbstractList</strong> ，实现了 <strong>List</strong>, <strong>RandomAccess</strong>, <strong>Cloneable</strong>, <strong>java.io.Serializable</strong> 这些接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>RandomAccess</code> 是一个标志接口，表明实现这个这个接口的 List 集合是支持<strong>快速随机访问</strong>的。在 <code>ArrayList</code> 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li>
<li><code>ArrayList</code> 实现了 <strong>Cloneable 接口</strong> ，即覆盖了函数<code>clone()</code>，能被克隆。</li>
<li><code>ArrayList</code> 实现了 <code>java.io.Serializable</code>接口，这意味着<code>ArrayList</code>支持序列化，能通过序列化去传输。</li>
</ul>
<h3 id="Arraylist-和-Vector-的区别"><a href="#Arraylist-和-Vector-的区别" class="headerlink" title="Arraylist 和 Vector 的区别?"></a>Arraylist 和 Vector 的区别?</h3><ol>
<li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[ ]</code>存储，适用于频繁的查找工作，线程不安全 ；</li>
<li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用 <code>Object[ ]</code>存储，线程安全的。</li>
</ol>
<h3 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别?"></a>Arraylist 与 LinkedList 区别?</h3><ol>
<li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li>
<li><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong>Object 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li>
<li><strong>插入和删除是否受元素位置的影响：</strong> ① <strong>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向前移一位的操作。 ② <strong>LinkedList 采用链表存储，所以对于add(E e)方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置i插入和删除元素的话（(add(int index, E element)） 时间复杂度近似为o(n))因为需要先移动到指定位置再插入。</strong></li>
<li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li>
<li><strong>内存空间占用：</strong> <code>ArrayList</code> 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 <code>LinkedList</code> 的空间花费则体现在它的每一个元素都需要消耗比 <code>ArrayList</code> 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>
</ol>
<h2 id="ArrayList-核心源码解读"><a href="#ArrayList-核心源码解读" class="headerlink" title="ArrayList 核心源码解读"></a>ArrayList 核心源码解读</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">import</span> java.util.function.UnaryOperator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认初始容量大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空数组（用于空实例）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//用于默认大小空实例的共享空数组实例。</span></span><br><span class="line">      <span class="comment">//我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存ArrayList数据的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayList 所包含的元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果传入的参数大于0，创建initialCapacity大小的数组</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果传入的参数等于0，创建空数组</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//其他情况，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *默认无参构造函数</span></span><br><span class="line"><span class="comment">     *DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="comment">//将指定集合转换为数组</span></span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="comment">//如果elementData数组的长度不为0</span></span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">                <span class="comment">//将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组</span></span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 其他情况，用空数组代替</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trimToSize</span><span class="params">()</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">            elementData = (size == <span class="number">0</span>)</span><br><span class="line">              ? EMPTY_ELEMENTDATA</span><br><span class="line">              : Arrays.copyOf(elementData, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//下面是ArrayList的扩容机制</span></span><br><span class="line"><span class="comment">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span></span><br><span class="line"><span class="comment">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   minCapacity   所需的最小容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">//如果是true，minExpand的值为0，如果是false,minExpand的值为10</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minExpand</span> <span class="operator">=</span> (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="comment">// any size if not default element table</span></span><br><span class="line">            ? <span class="number">0</span></span><br><span class="line">            <span class="comment">// larger than default for default empty table. It&#x27;s already</span></span><br><span class="line">            <span class="comment">// supposed to be at default size.</span></span><br><span class="line">            : DEFAULT_CAPACITY;</span><br><span class="line">        <span class="comment">//如果最小容量大于已有的最大容量</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">            ensureExplicitCapacity(minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//1.得到最小扩容量</span></span><br><span class="line">   <span class="comment">//2.通过最小容量扩容</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">              <span class="comment">// 获取“默认的容量”和“传入参数”两者之间的最大值</span></span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//判断是否需要扩容</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">        <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">        <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="comment">//再检查新容量是否超出了ArrayList所定义的最大容量，</span></span><br><span class="line">        <span class="comment">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span></span><br><span class="line">        <span class="comment">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比较minCapacity和 MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *返回此列表中的元素数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此列表不包含元素，则返回 true 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//注意=和==的区别</span></span><br><span class="line">        <span class="type">return</span> <span class="variable">size</span> <span class="operator">=</span>= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此列表包含指定的元素，则返回true 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">//indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span></span><br><span class="line">        <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="comment">//equals()方法比较</span></span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="built_in">super</span>.clone();</span><br><span class="line">            <span class="comment">//Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度</span></span><br><span class="line">            v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">            v.modCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="comment">// 这不应该发生，因为我们是可以克隆的</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。</span></span><br><span class="line"><span class="comment">     *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。</span></span><br><span class="line"><span class="comment">     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;</span></span><br><span class="line"><span class="comment">     *返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。</span></span><br><span class="line"><span class="comment">     *否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。</span></span><br><span class="line"><span class="comment">     *如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。</span></span><br><span class="line"><span class="comment">     *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">            <span class="comment">// 新建一个运行时类型的数组，但是ArrayList数组的内容</span></span><br><span class="line">            <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">            <span class="comment">//调用System提供的arraycopy()方法实现数组之间的复制</span></span><br><span class="line">        System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">        <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">            a[size] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Positional Access Operations</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    E <span class="title function_">elementData</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此列表中指定位置的元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用指定的元素替换此列表中指定位置的元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        <span class="comment">//对index进行界限检查</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="comment">//返回原来在这个位置的元素</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在此列表中的指定位置插入指定的元素。</span></span><br><span class="line"><span class="comment">     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class="line"><span class="comment">     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">//arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                         size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">      <span class="comment">//从列表中删除的元素</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。</span></span><br><span class="line"><span class="comment">     *返回true，如果此列表包含指定的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Private remove method that skips bounds checking and does not</span></span><br><span class="line"><span class="comment">     * return the value removed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中删除所有元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把数组中所有的元素的值设为null</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            elementData[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                             numMoved);</span><br><span class="line"></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。</span></span><br><span class="line"><span class="comment">     *将任何后续元素移动到左侧（减少其索引）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">removeRange</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - toIndex;</span><br><span class="line">        System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class="line">                         numMoved);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear to let GC do its work</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newSize</span> <span class="operator">=</span> size - (toIndex-fromIndex);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> newSize; i &lt; size; i++) &#123;</span><br><span class="line">            elementData[i] = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查给定的索引是否在范围内。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheck</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * add和addAll使用的rangeCheck的一个版本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheckForAdd</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回IndexOutOfBoundsException细节信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">outOfBoundsMsg</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Index: &quot;</span>+index+<span class="string">&quot;, Size: &quot;</span>+size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从此列表中删除指定集合中包含的所有元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="comment">//如果此列表被修改则返回true</span></span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 仅保留此列表中包含在指定集合中的元素。</span></span><br><span class="line"><span class="comment">     *换句话说，从此列表中删除其中不包含在指定集合中的所有元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。</span></span><br><span class="line"><span class="comment">     *指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。</span></span><br><span class="line"><span class="comment">     *返回的列表迭代器是fail-fast 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;Index: &quot;</span>+index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListItr</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *返回列表中的列表迭代器（按适当的顺序）。</span></span><br><span class="line"><span class="comment">     *返回的列表迭代器是fail-fast 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListItr</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *以正确的顺序返回该列表中的元素的迭代器。</span></span><br><span class="line"><span class="comment">     *返回的迭代器是fail-fast 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="ArrayList-扩容机制分析"><a href="#ArrayList-扩容机制分析" class="headerlink" title="ArrayList 扩容机制分析"></a>ArrayList 扩容机制分析</h2><h3 id="先从-ArrayList-的构造函数说起"><a href="#先从-ArrayList-的构造函数说起" class="headerlink" title="先从 ArrayList 的构造函数说起"></a>先从 ArrayList 的构造函数说起</h3><p><strong>（JDK8）ArrayList 有三种方式来初始化，构造方法源码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 默认初始容量大小</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;<span class="comment">//初始容量大于0</span></span><br><span class="line">         <span class="comment">//创建initialCapacity大小的数组</span></span><br><span class="line">         <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;<span class="comment">//初始容量等于0</span></span><br><span class="line">         <span class="comment">//创建空数组</span></span><br><span class="line">         <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;<span class="comment">//初始容量小于0，抛出异常</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class="line"><span class="comment"> *如果指定的集合为null，throws NullPointerException。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">     elementData = c.toArray();</span><br><span class="line">     <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">         <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">             elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// replace with empty array.</span></span><br><span class="line">         <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>细心的同学一定会发现 ：<strong>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong> 下面在我们分析 ArrayList 扩容时会讲到这一点内容！</p>
<blockquote>
<p>补充：JDK6 new 无参构造的 <code>ArrayList</code> 对象时，直接创建了长度是 10 的 <code>Object[]</code> 数组 elementData 。</p>
</blockquote>
<h3 id="一步一步分析-ArrayList-扩容机制"><a href="#一步一步分析-ArrayList-扩容机制" class="headerlink" title="一步一步分析 ArrayList 扩容机制"></a>一步一步分析 ArrayList 扩容机制</h3><p>这里以无参构造函数创建的 ArrayList 为例分析</p>
<h4 id="先来看-add-方法"><a href="#先来看-add-方法" class="headerlink" title="先来看 add 方法"></a>先来看 <code>add</code> 方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line"><span class="comment">//添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class="line">     ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">     <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">     elementData[size++] = e;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong> ：JDK11 移除了 <code>ensureCapacityInternal()</code> 和 <code>ensureExplicitCapacity()</code> 方法</p>
</blockquote>
<h4 id="再来看看-ensureCapacityInternal-方法"><a href="#再来看看-ensureCapacityInternal-方法" class="headerlink" title="再来看看 ensureCapacityInternal() 方法"></a>再来看看 <code>ensureCapacityInternal()</code> 方法</h4><p>（JDK7）可以看到 <code>add</code> 方法 首先调用了<code>ensureCapacityInternal(size + 1)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//得到最小扩容量</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">           <span class="comment">// 获取默认的容量和传入参数的较大值</span></span><br><span class="line">         minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ensureExplicitCapacity(minCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10。</strong></p>
<blockquote>
<p>此处和后续 JDK8 代码格式化略有不同，核心代码基本一样。</p>
</blockquote>
<h4 id="ensureExplicitCapacity-方法"><a href="#ensureExplicitCapacity-方法" class="headerlink" title="ensureExplicitCapacity() 方法"></a>ensureExplicitCapacity() 方法</h4><p>如果调用 <code>ensureCapacityInternal()</code> 方法就一定会进入（执行）这个方法，下面我们来研究一下这个方法的源码！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否需要扩容</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">      modCount++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// overflow-conscious code</span></span><br><span class="line">      <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">          <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">          grow(minCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>我们来仔细分析一下：</p>
<ul>
<li>当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 minCapacity 此时为 10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li>
<li>当 add 第 2 个元素时，minCapacity 为 2，此时 e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li>
<li>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li>
</ul>
<p>直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。</p>
<h4 id="grow-方法"><a href="#grow-方法" class="headerlink" title="grow() 方法"></a>grow() 方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">    <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">   <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class="line">   <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> 奇偶不同，比如 ：10+10&#x2F;2 &#x3D; 15, 33+33&#x2F;2&#x3D;49。如果是奇数的话会丢掉小数.</p>
<blockquote>
<p>“&gt;&gt;”（移位运算符）：&gt;&gt;1 右移一位相当于除 2，右移 n 位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了 1 位所以相当于 oldCapacity &#x2F;2。对于大数据的 2 进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源</p>
</blockquote>
<p><strong>我们再来通过例子探究一下grow() 方法 ：</strong></p>
<ul>
<li>当 add 第 1 个元素时，oldCapacity 为 0，经比较后第一个 if 判断成立，newCapacity &#x3D; minCapacity(为 10)。但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为 10，add 方法中 return true,size 增为 1。</li>
<li>当 add 第 11 个元素进入 grow 方法时，newCapacity 为 15，比 minCapacity（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。数组容量扩为 15，add 方法中 return true,size 增为 11。</li>
<li>以此类推······</li>
</ul>
<p><strong>这里补充一点比较重要，但是容易被忽视掉的知识点：</strong></p>
<ul>
<li>java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li>
<li>java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</li>
<li>java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li>
</ul>
<h4 id="hugeCapacity-方法。"><a href="#hugeCapacity-方法。" class="headerlink" title="hugeCapacity() 方法。"></a>hugeCapacity() 方法。</h4><p>从上面 <code>grow()</code> 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) <code>hugeCapacity()</code> 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果 minCapacity 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="comment">//对minCapacity和MAX_ARRAY_SIZE进行比较</span></span><br><span class="line">    <span class="comment">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span></span><br><span class="line">    <span class="comment">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span></span><br><span class="line">    <span class="comment">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="System-arraycopy-和Arrays-copyOf-96-方法"><a href="#System-arraycopy-和Arrays-copyOf-96-方法" class="headerlink" title="System.arraycopy()和Arrays.copyOf()&#96;方法"></a>System.arraycopy()<code>和</code>Arrays.copyOf()&#96;方法</h3><p>阅读源码的话，我们就会发现 ArrayList 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及<code>add(int index, E element)</code>、<code>toArray()</code> 等方法中都用到了该方法！</p>
<h4 id="System-arraycopy-方法"><a href="#System-arraycopy-方法" class="headerlink" title="System.arraycopy()方法"></a>System.arraycopy()方法</h4><p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们发现 arraycopy 是一个 native 方法,接下来我们解释一下各个参数的具体意义</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   复制数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> src 源数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> srcPos 源数组中的起始位置</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> dest 目标数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> destPos 目标数组中的起始位置</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> length 要复制的数组元素的数量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">arraycopy</span><span class="params">(Object src,  <span class="type">int</span>  srcPos,</span></span><br><span class="line"><span class="params">                                    Object dest, <span class="type">int</span> destPos,</span></span><br><span class="line"><span class="params">                                    <span class="type">int</span> length)</span>;</span><br></pre></td></tr></table></figure>

<p>场景：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在此列表中的指定位置插入指定的元素。</span></span><br><span class="line"><span class="comment"> *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class="line"><span class="comment"> *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//arraycopy()方法实现数组自己复制自己</span></span><br><span class="line">    <span class="comment">//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们写一个简单的方法测试以下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraycopyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">		a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		a[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">		a[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">		System.arraycopy(a, <span class="number">2</span>, a, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">		a[<span class="number">2</span>]=<span class="number">99</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">			System.out.print(a[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">99</span> <span class="number">2</span> <span class="number">3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="Arrays-copyOf-96-方法"><a href="#Arrays-copyOf-96-方法" class="headerlink" title="Arrays.copyOf()&#96;方法"></a>Arrays.copyOf()&#96;方法</h4><p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] copyOf(<span class="type">int</span>[] original, <span class="type">int</span> newLength) &#123;</span><br><span class="line">   	<span class="comment">// 申请一个新的数组</span></span><br><span class="line">       <span class="type">int</span>[] copy = <span class="keyword">new</span> <span class="title class_">int</span>[newLength];</span><br><span class="line"><span class="comment">// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组</span></span><br><span class="line">       System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                        Math.min(original.length, newLength));</span><br><span class="line">       <span class="keyword">return</span> copy;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>场景：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line"> <span class="comment">//elementData：要复制的数组；size：要复制的长度</span></span><br><span class="line">     <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>个人觉得使用 <code>Arrays.copyOf()</code>方法主要是为了给原有数组扩容，测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayscopyOfTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">		a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		a[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">		<span class="type">int</span>[] b = Arrays.copyOf(a, <span class="number">10</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;b.length&quot;</span>+b.length);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<h4 id="两者联系和区别"><a href="#两者联系和区别" class="headerlink" title="两者联系和区别"></a>两者联系和区别</h4><p><strong>联系：</strong></p>
<p>看两者源代码可以发现 <code>copyOf()</code>内部实际调用了 <code>System.arraycopy()</code> 方法</p>
<p><strong>区别：</strong></p>
<p><code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 <code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组。</p>
<h3 id="ensureCapacity方法"><a href="#ensureCapacity方法" class="headerlink" title="ensureCapacity方法"></a><code>ensureCapacity</code>方法</h3><p><code>ArrayList</code> 源码中有一个 <code>ensureCapacity</code> 方法不知道大家注意到没有，这个方法 <code>ArrayList</code> 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   minCapacity   所需的最小容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minExpand</span> <span class="operator">=</span> (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">        <span class="comment">// any size if not default element table</span></span><br><span class="line">        ? <span class="number">0</span></span><br><span class="line">        <span class="comment">// larger than default for default empty table. It&#x27;s already</span></span><br><span class="line">        <span class="comment">// supposed to be at default size.</span></span><br><span class="line">        : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理论上来说，最好在向 <code>ArrayList</code> 添加大量元素之前用 <code>ensureCapacity</code> 方法，以减少增量重新分配的次数</p>
<p>我们通过下面的代码实际测试以下这个方法的效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnsureCapacityTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		ArrayList&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">		<span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">10000000</span>;</span><br><span class="line">		<span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">			list.add(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;使用ensureCapacity方法前：&quot;</span>+(endTime - startTime));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">使用ensureCapacity方法前：<span class="number">2158</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnsureCapacityTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">10000000</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        list.ensureCapacity(N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;使用ensureCapacity方法后：&quot;</span>+(endTime1 - startTime1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">使用ensureCapacity方法后：<span class="number">1773</span></span><br></pre></td></tr></table></figure>

<p>通过运行结果，我们可以看出向 <code>ArrayList</code> 添加大量元素之前使用<code>ensureCapacity</code> 方法可以提升性能。不过，这个性能差距几乎可以忽略不计。而且，实际项目根本也不可能往 <code>ArrayList</code> 里面添加这么多元素。</p>
<h1 id="HashMap源码-amp-底层数据结构分析"><a href="#HashMap源码-amp-底层数据结构分析" class="headerlink" title="HashMap源码&amp;底层数据结构分析"></a>HashMap源码&amp;底层数据结构分析</h1><h2 id="HashMap-简介"><a href="#HashMap-简介" class="headerlink" title="HashMap 简介"></a>HashMap 简介</h2><p>HashMap 主要用来存放键值对，它基于哈希表的 Map 接口实现，是常用的 Java 集合之一，是非线程安全的。</p>
<p><code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个</p>
<p>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。 JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>
<p><code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。并且， <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p>
<h2 id="底层数据结构分析"><a href="#底层数据结构分析" class="headerlink" title="底层数据结构分析"></a>底层数据结构分析</h2><h3 id="JDK1-8-之前"><a href="#JDK1-8-之前" class="headerlink" title="JDK1.8 之前"></a>JDK1.8 之前</h3><p>JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。</p>
<p>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p>
<p>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</p>
<p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p>
<p>JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">    <span class="comment">// ^ ：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比一下 JDK1.7 的 HashMap 的 hash 方法源码.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line"></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p>
<p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
<p><img src="https://files.catbox.moe/r7e8dh.png"></p>
<h3 id="JDK1-8-之后"><a href="#JDK1-8-之后" class="headerlink" title="JDK1.8 之后"></a>JDK1.8 之后</h3><p>相比于之前的版本，JDK1.8 以后在解决哈希冲突时有了较大的变化。</p>
<p>当链表长度大于阈值（默认为 8）时，会首先调用 <code>treeifyBin()</code>方法。这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行 <code>resize()</code> 方法对数组扩容。相关源码这里就不贴了，重点关注 <code>treeifyBin()</code>方法即可！</p>
<p><img src="https://files.catbox.moe/fmromb.png"></p>
<p><strong>类的属性：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    <span class="comment">// 序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">362498820763181265L</span>;</span><br><span class="line">    <span class="comment">// 默认的初始容量是16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 默认的填充因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 桶中结构转化为红黑树对应的table的最小容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 存储元素的数组，总是2的幂次倍</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;k,v&gt;[] table;</span><br><span class="line">    <span class="comment">// 存放具体元素的集</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class="line">    <span class="comment">// 存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line">    <span class="comment">// 临界值(容量*填充因子) 当实际大小超过临界值时，会进行扩容</span></span><br><span class="line">    <span class="type">int</span> threshold;</span><br><span class="line">    <span class="comment">// 加载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>loadFactor 加载因子</strong></p>
<p>loadFactor 加载因子是控制数组存放数据的疏密程度，loadFactor 越趋近于 1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。</p>
<p><strong>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值</strong>。</p>
<p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 &#x3D; 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p>
</li>
<li><p><strong>threshold</strong></p>
<p><strong>threshold &#x3D; capacity * loadFactor</strong>，<strong>当 Size&gt;&#x3D;threshold</strong>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。</p>
</li>
</ul>
<p><strong>Node 节点类源码:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承自 Map.Entry&lt;K,V&gt;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">int</span> hash;<span class="comment">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span></span><br><span class="line">       <span class="keyword">final</span> K key;<span class="comment">//键</span></span><br><span class="line">       V value;<span class="comment">//值</span></span><br><span class="line">       <span class="comment">// 指向下一个节点</span></span><br><span class="line">       Node&lt;K,V&gt; next;</span><br><span class="line">       Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.hash = hash;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>        &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span>      &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line">        <span class="comment">// 重写hashCode()方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重写 equals() 方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>树节点类源码:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// 父</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;    <span class="comment">// 左</span></span><br><span class="line">        TreeNode&lt;K,V&gt; right;   <span class="comment">// 右</span></span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="type">boolean</span> red;           <span class="comment">// 判断颜色</span></span><br><span class="line">        TreeNode(<span class="type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">super</span>(hash, key, val, next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回根节点</span></span><br><span class="line">        <span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">root</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="built_in">this</span>, p;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((p = r.parent) == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                r = p;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashMap-源码分析"><a href="#HashMap-源码分析" class="headerlink" title="HashMap 源码分析"></a>HashMap 源码分析</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>HashMap 中有四个构造方法，它们分别如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all   other fields defaulted</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 包含另一个“Map”的构造函数</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">     putMapEntries(m, <span class="literal">false</span>);<span class="comment">//下面会分析到这个方法</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指定“容量大小”和“加载因子”的构造函数</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">         initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">     <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">     <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">     <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>putMapEntries 方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断table是否已经初始化</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">// 未初始化，s为m的实际元素个数</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> ((<span class="type">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                    (<span class="type">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">// 计算得到的t大于阈值，则初始化阈值</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 将m中的所有元素添加至HashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h3><p>HashMap 只提供了 put 用于添加元素，putVal 方法只是给 put 方法调用的一个方法，并没有提供给用户使用。</p>
<p><strong>对 putVal 方法添加元素的分析如下：</strong></p>
<ol>
<li>如果定位到的数组位置没有元素 就直接插入。</li>
<li>如果定位到的数组位置有元素就和要插入的 key 比较，如果 key 相同就直接覆盖，如果 key 不相同，就判断 p 是否是一个树节点，如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。</li>
</ol>
<p><img src="https://files.catbox.moe/fre1kw.png"></p>
<p>说明:上图有两个小问题：</p>
<ul>
<li>直接覆盖之后应该就会 return，不会有后续操作。参考 JDK8 HashMap.java 658 行（<a href="https://github.com/Snailclimb/JavaGuide/issues/608">issue#608open in new window</a>）。</li>
<li>当链表长度大于阈值（默认为 8）并且 HashMap 数组长度超过 64 的时候才会执行链表转红黑树的操作，否则就只是对数组扩容。参考 HashMap 的 <code>treeifyBin()</code> 方法（<a href="https://github.com/Snailclimb/JavaGuide/issues/1087">issue#1087open in new window</a>）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// table未初始化或者长度为0，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 桶中已经存在元素</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">// 将第一个元素赋值给e，用e来记录</span></span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// hash值不相等，即key不相等；为红黑树结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 为链表结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在链表最末插入结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 到达链表的尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在尾部插入新结点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法</span></span><br><span class="line">                    <span class="comment">// 这个方法会根据 HashMap 数组来决定是否转换为红黑树。</span></span><br><span class="line">                    <span class="comment">// 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">//用新值替换旧值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结构性修改</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们再来对比一下 JDK1.7 put 方法的代码</strong></p>
<p><strong>对于 put 方法的分析如下：</strong></p>
<ul>
<li>① 如果定位到的数组位置没有元素 就直接插入。</li>
<li>② 如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的 key 比较，如果 key 相同就直接覆盖，不同就采用头插法插入元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">    inflateTable(threshold);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123; <span class="comment">// 先遍历</span></span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);  <span class="comment">// 再插入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 数组元素相等</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 桶中不止一个节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在树中get</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 在链表中get</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="resize-方法"><a href="#resize-方法" class="headerlink" title="resize 方法"></a>resize 方法</h3><p>进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ? (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashMap-常用方法测试"><a href="#HashMap-常用方法测试" class="headerlink" title="HashMap 常用方法测试"></a>HashMap 常用方法测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">        <span class="comment">// 键不能重复，值可以重复</span></span><br><span class="line">        map.put(<span class="string">&quot;san&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;si&quot;</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;wu&quot;</span>, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;wang&quot;</span>, <span class="string">&quot;老王&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;wang&quot;</span>, <span class="string">&quot;老王2&quot;</span>);<span class="comment">// 老王被覆盖</span></span><br><span class="line">        map.put(<span class="string">&quot;lao&quot;</span>, <span class="string">&quot;老王&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------直接输出hashmap:-------&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 遍历HashMap</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 1.获取Map中的所有键</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-------foreach获取Map中所有的键:------&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            System.out.print(key+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();<span class="comment">//换行</span></span><br><span class="line">        <span class="comment">// 2.获取Map中所有值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-------foreach获取Map中所有的值:------&quot;</span>);</span><br><span class="line">        Collection&lt;String&gt; values = map.values();</span><br><span class="line">        <span class="keyword">for</span> (String value : values) &#123;</span><br><span class="line">            System.out.print(value+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();<span class="comment">//换行</span></span><br><span class="line">        <span class="comment">// 3.得到key的值的同时得到key所对应的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-------得到key的值的同时得到key所对应的值:-------&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; keys2 = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys2) &#123;</span><br><span class="line">            System.out.print(key + <span class="string">&quot;：&quot;</span> + map.get(key)+<span class="string">&quot;   &quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果既要遍历key又要value，那么建议这种方式，因为如果先获取keySet然后再执行map.get(key)，map内部会执行两次遍历。</span></span><br><span class="line"><span class="comment">         * 一次是在获取keySet的时候，一次是在遍历所有key的时候。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 当我调用put(key,value)方法的时候，首先会把key和value封装到</span></span><br><span class="line">        <span class="comment">// Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取</span></span><br><span class="line">        <span class="comment">// map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来</span></span><br><span class="line">        <span class="comment">// 调用Entry对象中的getKey()和getValue()方法就能获取键值对了</span></span><br><span class="line">        Set&lt;java.util.Map.Entry&lt;String, String&gt;&gt; entrys = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (java.util.Map.Entry&lt;String, String&gt; entry : entrys) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot;--&quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * HashMap其他常用方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after map.size()：&quot;</span>+map.size());</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.isEmpty()：&quot;</span>+map.isEmpty());</span><br><span class="line">        System.out.println(map.remove(<span class="string">&quot;san&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.remove()：&quot;</span>+map);</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.get(si)：&quot;</span>+map.get(<span class="string">&quot;si&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.containsKey(si)：&quot;</span>+map.containsKey(<span class="string">&quot;si&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;after containsValue(李四)：&quot;</span>+map.containsValue(<span class="string">&quot;李四&quot;</span>));</span><br><span class="line">        System.out.println(map.replace(<span class="string">&quot;si&quot;</span>, <span class="string">&quot;李四2&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.replace(si, 李四2):&quot;</span>+map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ConcurrentHashMap源码-amp-底层数据结构分析"><a href="#ConcurrentHashMap源码-amp-底层数据结构分析" class="headerlink" title="ConcurrentHashMap源码&amp;底层数据结构分析"></a>ConcurrentHashMap源码&amp;底层数据结构分析</h1><p>上一篇文章介绍了 HashMap 源码，反响不错，也有很多同学发表了自己的观点，这次又来了，这次是 <code>ConcurrentHashMap </code>了，作为线程安全的HashMap ，它的使用频率也是很高。那么它的存储结构和实现原理是怎么样的呢？</p>
<h2 id="ConcurrentHashMap-1-7"><a href="#ConcurrentHashMap-1-7" class="headerlink" title="ConcurrentHashMap 1.7"></a>ConcurrentHashMap 1.7</h2><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p><img src="https://files.catbox.moe/mi53ut.png"></p>
<p>Java 7 中 <code>ConcurrentHashMap</code> 的存储结构如上图，<code>ConcurrnetHashMap</code> 由很多个 <code>Segment</code> 组合，而每一个 <code>Segment</code> 是一个类似于 <code>HashMap</code> 的结构，所以每一个 <code>HashMap</code> 的内部可以进行扩容。但是 <code>Segment</code> 的个数一旦<strong>初始化就不能改变</strong>，默认 <code>Segment</code> 的个数是 16 个，你也可以认为 <code>ConcurrentHashMap</code> 默认支持最多 16 个线程并发。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>通过 <code>ConcurrentHashMap</code> 的无参构造探寻 <code>ConcurrentHashMap</code> 的初始化流程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new, empty map with a default initial capacity (16),</span></span><br><span class="line"><span class="comment"> * load factor (0.75) and concurrencyLevel (16).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无参构造中调用了有参构造，传入了三个参数的默认值，他们的值是。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始化容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认负载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认并发级别</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CONCURRENCY_LEVEL</span> <span class="operator">=</span> <span class="number">16</span>;</span><br></pre></td></tr></table></figure>

<p>接着看下这个有参构造函数的内部实现逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,<span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span> &#123;</span><br><span class="line">    <span class="comment">// 参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="comment">// 校验并发级别大小，大于 1&lt;&lt;16，重置为 65536</span></span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">    <span class="comment">// 2的多少次方</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sshift</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ssize</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 这个循环可以找到 concurrencyLevel 之上最近的 2的次方值</span></span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录段偏移量</span></span><br><span class="line">    <span class="built_in">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">    <span class="comment">// 记录段掩码</span></span><br><span class="line">    <span class="built_in">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 设置容量</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">// c = 容量 / ssize ，默认 16 / 16 = 1，这里是计算每个 Segment 中的类似于 HashMap 的容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> initialCapacity / ssize;</span><br><span class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">    <span class="comment">//Segment 中的类似于 HashMap 的容量至少是2或者2的倍数</span></span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// create segments and segments[0]</span></span><br><span class="line">    <span class="comment">// 创建 Segment 数组，设置 segments[0]</span></span><br><span class="line">    Segment&lt;K,V&gt; s0 = <span class="keyword">new</span> <span class="title class_">Segment</span>&lt;K,V&gt;(loadFactor, (<span class="type">int</span>)(cap * loadFactor),</span><br><span class="line">                         (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">HashEntry</span>[cap]);</span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Segment</span>[ssize];</span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">    <span class="built_in">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下在 Java 7 中 ConcurrnetHashMap 的初始化逻辑。</p>
<ol>
<li>必要参数校验。</li>
<li>校验并发级别 <code>concurrencyLevel</code> 大小，如果大于最大值，重置为最大值。无参构造<strong>默认值是 16.</strong></li>
<li>寻找并发级别 <code>concurrencyLevel</code> 之上最近的 <strong>2 的幂次方</strong>值，作为初始化容量大小，<strong>默认是 16</strong>。</li>
<li>记录 <code>segmentShift</code> 偏移量，这个值为【容量 &#x3D; 2 的N次方】中的 N，在后面 Put 时计算位置时会用到。<strong>默认是 32 - sshift &#x3D; 28</strong>.</li>
<li>记录 <code>segmentMask</code>，默认是 ssize - 1 &#x3D; 16 -1 &#x3D; 15.</li>
<li><strong>初始化 segments[0]<strong>，</strong>默认大小为 2</strong>，<strong>负载因子 0.75</strong>，<strong>扩容阀值是 2*0.75&#x3D;1.5</strong>，插入第二个值时才会进行扩容。</li>
</ol>
<h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>接着上面的初始化参数继续查看 put 方法源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Maps the specified key to the specified value in this table.</span></span><br><span class="line"><span class="comment"> * Neither the key nor the value can be null.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; The value can be retrieved by calling the &lt;tt&gt;get&lt;/tt&gt; method</span></span><br><span class="line"><span class="comment"> * with a key that is equal to the original key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified key or value is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="comment">// hash 值无符号右移 28位（初始化时获得），然后与 segmentMask=15 做与运算</span></span><br><span class="line">    <span class="comment">// 其实也就是把高4位与segmentMask（1111）做与运算</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="literal">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        <span class="comment">// 如果查找到的 Segment 为空，初始化</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the segment for the given index, creating it and</span></span><br><span class="line"><span class="comment"> * recording in segment table (via CAS) if not already present.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k the index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the segment</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title function_">ensureSegment</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="built_in">this</span>.segments;</span><br><span class="line">    <span class="type">long</span> <span class="variable">u</span> <span class="operator">=</span> (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></span><br><span class="line">    Segment&lt;K,V&gt; seg;</span><br><span class="line">    <span class="comment">// 判断 u 位置的 Segment 是否为null</span></span><br><span class="line">    <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="literal">null</span>) &#123;</span><br><span class="line">        Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>]; <span class="comment">// use segment 0 as prototype</span></span><br><span class="line">        <span class="comment">// 获取0号 segment 里的 HashEntry&lt;K,V&gt; 初始化长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> proto.table.length;</span><br><span class="line">        <span class="comment">// 获取0号 segment 里的 hash 表里的扩容负载因子，所有的 segment 的 loadFactor 是相同的</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">lf</span> <span class="operator">=</span> proto.loadFactor;</span><br><span class="line">        <span class="comment">// 计算扩容阀值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">threshold</span> <span class="operator">=</span> (<span class="type">int</span>)(cap * lf);</span><br><span class="line">        <span class="comment">// 创建一个 cap 容量的 HashEntry 数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">HashEntry</span>[cap];</span><br><span class="line">        <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="literal">null</span>) &#123; <span class="comment">// recheck</span></span><br><span class="line">            <span class="comment">// 再次检查 u 位置的 Segment 是否为null，因为这时可能有其他线程进行了操作</span></span><br><span class="line">            Segment&lt;K,V&gt; s = <span class="keyword">new</span> <span class="title class_">Segment</span>&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">            <span class="comment">// 自旋检查 u 位置的 Segment 是否为null</span></span><br><span class="line">            <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                   == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 使用CAS 赋值，只会成功一次</span></span><br><span class="line">                <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="literal">null</span>, seg = s))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的源码分析了 <code>ConcurrentHashMap</code> 在 put 一个数据时的处理流程，下面梳理下具体流程。</p>
<ol>
<li><p>计算要 put 的 key 的位置，获取指定位置的 <code>Segment</code>。</p>
</li>
<li><p>如果指定位置的 <code>Segment</code> 为空，则初始化这个 <code>Segment</code>.</p>
<p><strong>初始化 Segment 流程：</strong></p>
<ol>
<li>检查计算得到的位置的 <code>Segment</code> 是否为null.</li>
<li>为 null 继续初始化，使用 <code>Segment[0]</code> 的容量和负载因子创建一个 <code>HashEntry</code> 数组。</li>
<li>再次检查计算得到的指定位置的 <code>Segment</code> 是否为null.</li>
<li>使用创建的 <code>HashEntry</code> 数组初始化这个 Segment.</li>
<li>自旋判断计算得到的指定位置的 <code>Segment</code> 是否为null，使用 CAS 在这个位置赋值为 <code>Segment</code>.</li>
</ol>
</li>
<li><p><code>Segment.put</code> 插入 key,value 值。</p>
</li>
</ol>
<p>上面探究了获取 <code>Segment</code> 段和初始化 <code>Segment</code> 段的操作。最后一行的 <code>Segment</code> 的 put 方法还没有查看，继续分析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">put</span><span class="params">(K key, <span class="type">int</span> hash, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取 ReentrantLock 独占锁，获取不到，scanAndLockForPut 获取。</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="literal">null</span> : scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">// 计算要put的数据位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">// CAS 获取 index 坐标的值</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 检查是否 key 已经存在，如果存在，则遍历链表寻找位置，找到后替换 value</span></span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// first 有值没说明 index 位置已经有值了，有冲突，链表头插法。</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="literal">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> count + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 容量大于扩容阀值，小于最大容量，进行扩容</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// index 位置赋值 node，node 可能是一个元素，也可能是一个链表的表头</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>Segment</code> 继承了 <code>ReentrantLock</code>，所以 <code>Segment</code> 内部可以很方便的获取锁，put 流程就用到了这个功能。</p>
<ol>
<li><p><code>tryLock()</code> 获取锁，获取不到使用 <strong>scanAndLockForPut</strong> 方法继续获取。</p>
</li>
<li><p>计算 put 的数据要放入的 index 位置，然后获取这个位置上的 <code>HashEntry</code> 。</p>
</li>
<li><p>遍历 put 新元素，为什么要遍历？因为这里获取的 <code>HashEntry</code> 可能是一个空元素，也可能是链表已存在，所以要区别对待。</p>
<p>如果这个位置上的 <strong>HashEntry 不存在</strong>：</p>
<ol>
<li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li>
<li>直接头插法插入。</li>
</ol>
<p>如果这个位置上的 <strong>HashEntry 存在</strong>：</p>
<ol>
<li>判断链表当前元素 key 和 hash 值是否和要 put 的 key 和 hash 值一致。一致则替换值</li>
<li>不一致，获取链表下一个节点，直到发现相同进行值替换，或者链表表里完毕没有相同的。<ol>
<li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li>
<li>直接链表头插法插入。</li>
</ol>
</li>
</ol>
</li>
<li><p>如果要插入的位置之前已经存在，替换后返回旧值，否则返回 null.</p>
</li>
</ol>
<p>这里面的第一步中的 <code>scanAndLockForPut</code> 操作这里没有介绍，这个方法做的操作就是不断的自旋 <code>tryLock()</code> 获取锁。当自旋次数大于指定次数时，使用 <code>lock()</code> 阻塞获取锁。在自旋时顺表获取下 hash 位置的 <code>HashEntry</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title function_">scanAndLockForPut</span><span class="params">(K key, <span class="type">int</span> hash, V value)</span> &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="built_in">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">retries</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">    <span class="comment">// 自旋获取锁</span></span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                    node = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            <span class="comment">// 自旋达到指定次数后，阻塞等到只到获取到锁</span></span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 (f = entryForHash(<span class="built_in">this</span>, hash)) != first) &#123;</span><br><span class="line">            e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">            retries = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩容-rehash"><a href="#扩容-rehash" class="headerlink" title="扩容 rehash"></a>扩容 rehash</h3><p><code>ConcurrentHashMap</code> 的扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，位置要么不变，要么变为 <code>index+ oldSize</code>，参数里的 node 会在扩容之后使用链表<strong>头插法</strong>插入到指定位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="comment">// 老容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">    <span class="comment">// 新容量，扩大两倍</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 新的扩容阀值 </span></span><br><span class="line">    threshold = (<span class="type">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    <span class="comment">// 创建新的数组</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> <span class="title class_">HashEntry</span>[newCapacity];</span><br><span class="line">    <span class="comment">// 新的掩码，默认2扩容后是4，-1是3，二进制就是11。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sizeMask</span> <span class="operator">=</span> newCapacity - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        <span class="comment">// 遍历老数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">// 计算新的位置，新的位置只可能是不便或者是老的位置+老的容量。</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> e.hash &amp; sizeMask;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">null</span>)   <span class="comment">//  Single node on list</span></span><br><span class="line">                <span class="comment">// 如果当前位置还不是链表，只是一个元素，直接赋值</span></span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                <span class="comment">// 如果是链表了</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="type">int</span> <span class="variable">lastIdx</span> <span class="operator">=</span> idx;</span><br><span class="line">                <span class="comment">// 新的位置只可能是不便或者是老的位置+老的容量。</span></span><br><span class="line">                <span class="comment">// 遍历结束后，lastRun 后面的元素位置都是相同的</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next; last != <span class="literal">null</span>; last = last.next) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// ，lastRun 后面的元素位置都是相同的，直接作为链表赋值到新位置。</span></span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// Clone remaining nodes</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    <span class="comment">// 遍历剩余元素，头插法到指定 k 位置。</span></span><br><span class="line">                    <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> p.value;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> p.hash;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 头插法插入新的节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nodeIndex</span> <span class="operator">=</span> node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有些同学可能会对最后的两个 for 循环有疑惑，这里第一个 for 是为了寻找这样一个节点，这个节点后面的所有 next 节点的新位置都是相同的。然后把这个作为一个链表赋值到新位置。第二个 for 循环是为了把剩余的元素通过头插法插入到指定位置链表。这样实现的原因可能是基于概率统计，有深入研究的同学可以发表下意见。</p>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>到这里就很简单了，get 方法只需要两步即可。</p>
<ol>
<li>计算得到 key 的存放位置。</li>
<li>遍历指定位置查找相同 key 的 value 值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="type">long</span> <span class="variable">u</span> <span class="operator">=</span> (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="comment">// 计算得到 key 的存放位置</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        (tab = s.table) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                 (tab, ((<span class="type">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="comment">// 如果是链表，遍历查找到相同 key 的 value。</span></span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ConcurrentHashMap-1-8"><a href="#ConcurrentHashMap-1-8" class="headerlink" title="ConcurrentHashMap 1.8"></a>ConcurrentHashMap 1.8</h2><h3 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h3><p><img src="https://files.catbox.moe/1p81ny.png"></p>
<p>可以发现 Java8 的 ConcurrentHashMap 相对于 Java7 来说变化比较大，不再是之前的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 &#x2F; 红黑树</strong>。当冲突链表达到一定长度时，链表会转换成红黑树。</p>
<h3 id="初始化-initTable"><a href="#初始化-initTable" class="headerlink" title="初始化 initTable"></a>初始化 initTable</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//　如果 sizeCtl &lt; 0 ,说明另外的线程执行CAS 成功，正在进行初始化。</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 让出 CPU 使用权</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中可以发现 <code>ConcurrentHashMap</code> 的初始化是通过<strong>自旋和 CAS</strong> 操作完成的。里面需要注意的是变量 <code>sizeCtl</code> ，它的值决定着当前的初始化状态。</p>
<ol>
<li>-1 说明正在初始化</li>
<li>-N 说明有N-1个线程正在进行扩容</li>
<li>表示 table 初始化大小，如果 table 没有初始化</li>
<li>表示 table 容量，如果 table　已经初始化。</li>
</ol>
<h3 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h3><p>直接过一遍 put 源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="comment">// key 和 value 不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">// f = 目标位置元素</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;<span class="comment">// fh 后面存放目标位置的元素 hash 值</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 数组桶为空，初始化数组桶（自旋+CAS)</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 桶内为空，CAS 放入，不加锁，成功了就直接 break 跳出</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 使用 synchronized 加锁加入节点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 说明是链表</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 循环加入新的或者覆盖节点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">// 红黑树</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>根据 key 计算出 hashcode 。</li>
<li>判断是否需要进行初始化。</li>
<li>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li>
<li>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</li>
<li>如果都不满足，则利用 synchronized 锁写入数据。</li>
<li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要执行树化方法，在 <code>treeifyBin</code> 中会首先判断当前数组长度≥64时才会将链表转换为红黑树。</li>
</ol>
<h3 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h3><p>get 流程比较简单，直接过一遍源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">// key 所在的 hash 位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果指定位置元素存在，头结点hash值相同</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="comment">// key hash 值相等，key值相同，直接返回元素 value</span></span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 头结点hash值小于0，说明正在扩容或者是红黑树，find查找</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 是链表，遍历查找</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下 get 过程：</p>
<ol>
<li>根据 hash 值计算位置。</li>
<li>查找到指定位置，如果头节点就是要找的，直接返回它的 value.</li>
<li>如果头节点 hash 值小于 0 ，说明正在扩容或者是红黑树，查找之。</li>
<li>如果是链表，遍历查找之。</li>
</ol>
<p>总结：</p>
<p>总的来说 <code>ConcurrentHashMap</code> 在 Java8 中相对于 Java7 来说变化还是挺大的，</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java7 中 <code>ConcurrentHashMap</code> 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 <code>Segment</code> 都是一个类似 <code>HashMap</code> 数组的结构，它可以扩容，它的冲突会转化为链表。但是 <code>Segment</code> 的个数一但初始化就不能改变。</p>
<p>Java8 中的 <code>ConcurrentHashMap</code> 使用的 <code>Synchronized</code> 锁加 CAS 的机制。结构也由 Java7 中的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong> 进化成了 <strong>Node 数组 + 链表 &#x2F; 红黑树</strong>，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。</p>
<p>有些同学可能对 <code>Synchronized</code> 的性能存在疑问，其实 <code>Synchronized</code> 锁自从引入锁升级策略后，性能不再是问题，有兴趣的同学可以自己了解下 <code>Synchronized</code> 的<strong>锁升级</strong>。</p>
]]></content>
  </entry>
  <entry>
    <title>Java_IO流面试</title>
    <url>/2022/08/23/Java-IO%E6%B5%81%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h1 id="Java-IO基础知识总结"><a href="#Java-IO基础知识总结" class="headerlink" title="Java IO基础知识总结"></a>Java IO基础知识总结</h1><h2 id="IO-流简介"><a href="#IO-流简介" class="headerlink" title="IO 流简介"></a>IO 流简介</h2><p>IO 即 <code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p>
<p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>
<ul>
<li><code>InputStream</code>&#x2F;<code>Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li><code>OutputStream</code>&#x2F;<code>Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><h3 id="InputStream（字节输入流）"><a href="#InputStream（字节输入流）" class="headerlink" title="InputStream（字节输入流）"></a>InputStream（字节输入流）</h3><p><code>InputStream</code>用于从源头（通常是文件）读取数据（字节信息）到内存中，<code>java.io.InputStream</code>抽象类是所有字节输入流的父类。</p>
<p><code>InputStream</code> 常用方法 ：</p>
<ul>
<li><code>read()</code> ：返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 <code>-1</code> ，表示文件结束。</li>
<li><code>read(byte b[ ])</code> : 从输入流中读取一些字节存储到数组 <code>b</code> 中。如果数组 <code>b</code> 的长度为零，则不读取。如果没有可用字节读取，返回 <code>-1</code>。如果有可用字节读取，则最多读取的字节数最多等于 <code>b.length</code> ， 返回读取的字节数。这个方法等价于 <code>read(b, 0, b.length)</code>。</li>
<li><code>read(byte b[], int off, int len)</code> ：在<code>read(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li>
<li><code>skip(long n)</code> ：忽略输入流中的 n 个字节 ,返回实际忽略的字节数。</li>
<li><code>available()</code> ：返回输入流中可以读取的字节数。</li>
<li><code>close()</code> ：关闭输入流释放相关的系统资源。</li>
</ul>
<p>从 Java 9 开始，<code>InputStream</code> 新增加了多个实用的方法：</p>
<ul>
<li><code>readAllBytes()</code> ：读取输入流中的所有字节，返回字节数组。</li>
<li><code>readNBytes(byte[] b, int off, int len)</code> ：阻塞直到读取 <code>len</code> 个字节。</li>
<li><code>transferTo(OutputStream out)</code> ： 将所有字节从一个输入流传递到一个输出流。</li>
</ul>
<p><code>FileInputStream</code> 是一个比较常用的字节输入流对象，可直接指定文件路径，可以直接读取单字节数据，也可以读取至字节数组中。</p>
<p><code>FileInputStream</code> 代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Number of remaining bytes:&quot;</span></span><br><span class="line">            + fis.available());</span><br><span class="line">    <span class="type">int</span> content;</span><br><span class="line">    <span class="type">long</span> <span class="variable">skip</span> <span class="operator">=</span> fis.skip(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;The actual number of bytes skipped:&quot;</span> + skip);</span><br><span class="line">    System.out.print(<span class="string">&quot;The content read from file:&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ((content = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print((<span class="type">char</span>) content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>input.txt</code> 文件内容：</p>
<p><img src="https://files.catbox.moe/iyik3q.png"></p>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Number of remaining bytes:<span class="number">11</span></span><br><span class="line">The actual number of bytes skipped:<span class="number">2</span></span><br><span class="line">The content read from file:JavaGuide</span><br></pre></td></tr></table></figure>

<p>不过，一般我们是不会直接单独使用 <code>FileInputStream</code> ，通常会配合 <code>BufferedInputStream</code>（字节缓冲输入流，后文会讲到）来使用。</p>
<p>像下面这段代码在我们的项目中就比较常见，我们通过 <code>readAllBytes()</code> 读取输入流所有字节并将其直接赋值给一个 <code>String</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新建一个 BufferedInputStream 对象</span></span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 读取文件的内容并复制到 String 对象中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bufferedInputStream.readAllBytes());</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>

<p><code>DataInputStream</code> 用于读取指定类型数据，不能单独使用，必须结合 <code>FileInputStream</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>);</span><br><span class="line"><span class="comment">//必须将fileInputStream作为构造参数才能使用</span></span><br><span class="line"><span class="type">DataInputStream</span> <span class="variable">dataInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(fileInputStream);</span><br><span class="line"><span class="comment">//可以读取任意具体的类型数据</span></span><br><span class="line">dataInputStream.readBoolean();</span><br><span class="line">dataInputStream.readInt();</span><br><span class="line">dataInputStream.readUTF();</span><br></pre></td></tr></table></figure>

<p><code>ObjectInputStream</code> 用于从输入流中读取 Java 对象（反序列化），<code>ObjectOutputStream</code> 用于将对象写入到输出流(序列化)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.data&quot;</span>));</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">object</span> <span class="operator">=</span> (MyClass) input.readObject();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure>

<p>另外，用于序列化和反序列化的类必须实现 <code>Serializable</code> 接口，对象中如果有属性不想被序列化，使用 <code>transient</code> 修饰。</p>
<h3 id="OutputStream（字节输出流）"><a href="#OutputStream（字节输出流）" class="headerlink" title="OutputStream（字节输出流）"></a>OutputStream（字节输出流）</h3><p><code>OutputStream</code>用于将数据（字节信息）写入到目的地（通常是文件），<code>java.io.OutputStream</code>抽象类是所有字节输出流的父类。</p>
<p><code>OutputStream</code> 常用方法 ：</p>
<ul>
<li><code>write(int b)</code> ：将特定字节写入输出流。</li>
<li><code>write(byte b[ ])</code> : 将数组<code>b</code> 写入到输出流，等价于 <code>write(b, 0, b.length)</code> 。</li>
<li><code>write(byte[] b, int off, int len)</code> : 在<code>write(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li>
<li><code>flush()</code> ：刷新此输出流并强制写出所有缓冲的输出字节。</li>
<li><code>close()</code> ：关闭输出流释放相关的系统资源。</li>
</ul>
<p><code>FileOutputStream</code> 是最常用的字节输出流对象，可直接指定文件路径，可以直接输出单字节数据，也可以输出指定的字节数组。</p>
<p><code>FileOutputStream</code> 代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">byte</span>[] array = <span class="string">&quot;JavaGuide&quot;</span>.getBytes();</span><br><span class="line">    output.write(array);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://files.catbox.moe/hr13rm.png"></p>
<p>类似于 <code>FileInputStream</code>，<code>FileOutputStream</code> 通常也会配合 <code>BufferedOutputStream</code>（字节缓冲输出流，后文会讲到）来使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>);</span><br><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fileOutputStream)</span><br></pre></td></tr></table></figure>

<p><strong>DataOutputStream</strong> 用于写入指定类型数据，不能单独使用，必须结合 <code>FileOutputStream</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出流</span></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.txt&quot;</span>);</span><br><span class="line"><span class="type">DataOutputStream</span> <span class="variable">dataOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(fileOutputStream);</span><br><span class="line"><span class="comment">// 输出任意数据类型</span></span><br><span class="line">dataOutputStream.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">dataOutputStream.writeByte(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><code>ObjectOutputStream</code> 用于从输入流中读取 Java 对象（<code>ObjectInputStream</code>,反序列化）或者将对象写入到输出流(<code>ObjectOutputStream</code>，序列化)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file.txt&quot;</span>)</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Guide哥&quot;</span>, <span class="string">&quot;JavaGuide作者&quot;</span>);</span><br><span class="line">output.writeObject(person);</span><br></pre></td></tr></table></figure>

<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节。 <strong>那为什么 I&#x2F;O 流操作要分为字节流操作和字符流操作呢？</strong></p>
<p>个人认为主要有两点原因：</p>
<ul>
<li>字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时。</li>
<li>如果我们不知道编码类型就很容易出现乱码问题。</li>
</ul>
<p>乱码问题这个很容易就可以复现，我们只需要将上面提到的 <code>FileInputStream</code> 代码示例中的 <code>input.txt</code> 文件内容改为中文即可，原代码不需要改动。</p>
<p><img src="https://files.catbox.moe/4pndh4.png"></p>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Number of remaining bytes:<span class="number">9</span></span><br><span class="line">The actual number of bytes skipped:<span class="number">2</span></span><br><span class="line">The content read from file:§å®¶å¥½</span><br></pre></td></tr></table></figure>

<p>可以很明显地看到读取出来的内容已经变成了乱码。</p>
<p>因此，I&#x2F;O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p>
<p>字符流默认采用的是 <code>Unicode</code> 编码，我们可以通过构造方法自定义编码。顺便分享一下之前遇到的笔试题：常用字符编码所占字节数？<code>utf8</code> :英文占 1 字节，中文占 3 字节，<code>unicode</code>：任何字符都占 2 个字节，<code>gbk</code>：英文占 1 字节，中文占 2 字节。</p>
<h3 id="Reader（字符输入流）"><a href="#Reader（字符输入流）" class="headerlink" title="Reader（字符输入流）"></a>Reader（字符输入流）</h3><p><code>Reader</code>用于从源头（通常是文件）读取数据（字符信息）到内存中，<code>java.io.Reader</code>抽象类是所有字符输入流的父类。</p>
<p><code>Reader</code> 用于读取文本， <code>InputStream</code> 用于读取原始字节。</p>
<p><code>Reader</code> 常用方法 ：</p>
<ul>
<li><code>read()</code> : 从输入流读取一个字符。</li>
<li><code>read(char[] cbuf)</code> : 从输入流中读取一些字符，并将它们存储到字符数组 <code>cbuf</code>中，等价于 <code>read(cbuf, 0, cbuf.length)</code> 。</li>
<li><code>read(char[] cbuf, int off, int len)</code> ：在<code>read(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li>
<li><code>skip(long n)</code> ：忽略输入流中的 n 个字符 ,返回实际忽略的字符数。</li>
<li><code>close()</code> : 关闭输入流并释放相关的系统资源。</li>
</ul>
<p><code>InputStreamReader</code> 是字节流转换为字符流的桥梁，其子类 <code>FileReader</code> 是基于该基础上的封装，可以直接操作字符文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字节流转换为字符流的桥梁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamReader</span> <span class="keyword">extends</span> <span class="title class_">Reader</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于读取字符文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReader</span> <span class="keyword">extends</span> <span class="title class_">InputStreamReader</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FileReader</code> 代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;input.txt&quot;</span>);) &#123;</span><br><span class="line">    <span class="type">int</span> content;</span><br><span class="line">    <span class="type">long</span> <span class="variable">skip</span> <span class="operator">=</span> fileReader.skip(<span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;The actual number of bytes skipped:&quot;</span> + skip);</span><br><span class="line">    System.out.print(<span class="string">&quot;The content read from file:&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ((content = fileReader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print((<span class="type">char</span>) content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>input.txt</code> 文件内容：</p>
<p><img src="https://files.catbox.moe/0odlmx.png"></p>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">The actual number of bytes skipped:<span class="number">3</span></span><br><span class="line">The content read from file:我是Guide。</span><br></pre></td></tr></table></figure>

<h3 id="Writer（字符输出流）"><a href="#Writer（字符输出流）" class="headerlink" title="Writer（字符输出流）"></a>Writer（字符输出流）</h3><p><code>Writer</code>用于将数据（字符信息）写入到目的地（通常是文件），<code>java.io.Writer</code>抽象类是所有字节输出流的父类。</p>
<p><code>Writer</code> 常用方法 ：</p>
<ul>
<li><code>write(int c)</code> : 写入单个字符。</li>
<li><code>write(char[] cbuf)</code> ：写入字符数组 <code>cbuf</code>，等价于<code>write(cbuf, 0, cbuf.length)</code>。</li>
<li><code>write(char[] cbuf, int off, int len)</code> ：在<code>write(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li>
<li><code>write(String str)</code> ：写入字符串，等价于 <code>write(str, 0, str.length())</code> 。</li>
<li><code>write(String str, int off, int len)</code> ：在<code>write(String str)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li>
<li><code>append(CharSequence csq)</code> ：将指定的字符序列附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</li>
<li><code>append(char c)</code> ：将指定的字符附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</li>
<li><code>flush()</code> ：刷新此输出流并强制写出所有缓冲的输出字符。</li>
<li><code>close()</code>:关闭输出流释放相关的系统资源。</li>
</ul>
<p><code>OutputStreamWriter</code> 是字符流转换为字节流的桥梁，其子类 <code>FileWriter</code> 是基于该基础上的封装，可以直接将字符写入到文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符流转换为字节流的桥梁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamReader</span> <span class="keyword">extends</span> <span class="title class_">Reader</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于写入字符到文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileWriter</span> <span class="keyword">extends</span> <span class="title class_">OutputStreamWriter</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FileWriter</code> 代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Writer</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;output.txt&quot;</span>)) &#123;</span><br><span class="line">    output.write(<span class="string">&quot;你好，我是Guide。&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src="https://files.catbox.moe/si57e1.png"></p>
<h2 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h2><p>IO 操作是很消耗性能的，缓冲流将数据加载至缓冲区，一次性读取&#x2F;写入多个字节，从而避免频繁的 IO 操作，提高流的传输效率。</p>
<p>字节缓冲流这里采用了装饰器模式来增强 <code>InputStream</code> 和<code>OutputStream</code>子类对象的功能。</p>
<p>举个例子，我们可以通过 <code>BufferedInputStream</code>（字节缓冲输入流）来增强 <code>FileInputStream</code> 的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新建一个 BufferedInputStream 对象</span></span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>字节流和字节缓冲流的性能差别主要体现在我们使用两者的时候都是调用 <code>write(int b)</code> 和 <code>read()</code> 这两个一次只读取一个字节的方法的时候。由于字节缓冲流内部有缓冲区（字节数组），因此，字节缓冲流会先将读取到的字节存放在缓存区，大幅减少 IO 次数，提高读取效率。</p>
<p>我使用 <code>write(int b)</code> 和 <code>read()</code> 方法，分别通过字节流和字节缓冲流复制一个 <code>524.9 mb</code> 的 PDF 文件耗时对比如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">使用缓冲流复制PDF文件总耗时:<span class="number">15428</span> 毫秒</span><br><span class="line">使用普通字节流复制PDF文件总耗时:<span class="number">2555062</span> 毫秒</span><br></pre></td></tr></table></figure>

<p>两者耗时差别非常大，缓冲流耗费的时间是字节流的 1&#x2F;165。</p>
<p>测试代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">copy_pdf_to_another_pdf_buffer_stream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;深入理解计算机操作系统.pdf&quot;</span>));</span><br><span class="line">         <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;深入理解计算机操作系统-副本.pdf&quot;</span>))) &#123;</span><br><span class="line">        <span class="type">int</span> content;</span><br><span class="line">        <span class="keyword">while</span> ((content = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(content);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录结束时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;使用缓冲流复制PDF文件总耗时:&quot;</span> + (end - start) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">copy_pdf_to_another_pdf_stream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;深入理解计算机操作系统.pdf&quot;</span>);</span><br><span class="line">         <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;深入理解计算机操作系统-副本.pdf&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> content;</span><br><span class="line">        <span class="keyword">while</span> ((content = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(content);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录结束时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;使用普通流复制PDF文件总耗时:&quot;</span> + (end - start) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是调用 <code>read(byte b[])</code> 和 <code>write(byte b[], int off, int len)</code> 这两个写入一个字节数组的方法的话，只要字节数组的大小合适，两者的性能差距其实不大，基本可以忽略。</p>
<p>这次我们使用 <code>read(byte b[])</code> 和 <code>write(byte b[], int off, int len)</code> 方法，分别通过字节流和字节缓冲流复制一个 524.9 mb 的 PDF 文件耗时对比如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">使用缓冲流复制PDF文件总耗时:<span class="number">695</span> 毫秒</span><br><span class="line">使用普通字节流复制PDF文件总耗时:<span class="number">989</span> 毫秒</span><br></pre></td></tr></table></figure>

<p>两者耗时差别不是很大，缓冲流的性能要略微好一点点。</p>
<p>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">copy_pdf_to_another_pdf_with_byte_array_buffer_stream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;深入理解计算机操作系统.pdf&quot;</span>));</span><br><span class="line">         <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;深入理解计算机操作系统-副本.pdf&quot;</span>))) &#123;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录结束时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;使用缓冲流复制PDF文件总耗时:&quot;</span> + (end - start) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">copy_pdf_to_another_pdf_with_byte_array_stream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;深入理解计算机操作系统.pdf&quot;</span>);</span><br><span class="line">         <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;深入理解计算机操作系统-副本.pdf&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录结束时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;使用普通流复制PDF文件总耗时:&quot;</span> + (end - start) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BufferedInputStream（字节缓冲输入流）"><a href="#BufferedInputStream（字节缓冲输入流）" class="headerlink" title="BufferedInputStream（字节缓冲输入流）"></a>BufferedInputStream（字节缓冲输入流）</h3><p><code>BufferedInputStream</code> 从源头（通常是文件）读取数据（字节信息）到内存的过程中不会一个字节一个字节的读取，而是会先将读取到的字节存放在缓存区，并从内部缓冲区中单独读取字节。这样大幅减少了 IO 次数，提高了读取效率。</p>
<p><code>BufferedInputStream</code> 内部维护了一个缓冲区，这个缓冲区实际就是一个字节数组，通过阅读 <code>BufferedInputStream</code> 源码即可得到这个结论。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title class_">FilterInputStream</span> &#123;</span><br><span class="line">    <span class="comment">// 内部缓冲区数组</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="type">byte</span> buf[];</span><br><span class="line">    <span class="comment">// 缓冲区的默认大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">DEFAULT_BUFFER_SIZE</span> <span class="operator">=</span> <span class="number">8192</span>;</span><br><span class="line">    <span class="comment">// 使用默认的缓冲区大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BufferedInputStream</span><span class="params">(InputStream in)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(in, DEFAULT_BUFFER_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义缓冲区大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BufferedInputStream</span><span class="params">(InputStream in, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(in);</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Buffer size &lt;= 0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        buf = <span class="keyword">new</span> <span class="title class_">byte</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缓冲区的大小默认为 <strong>8192</strong> 字节，当然了，你也可以通过 <code>BufferedInputStream(InputStream in, int size)</code> 这个构造方法来指定缓冲区的大小。</p>
<h3 id="BufferedOutputStream（字节缓冲输出流）"><a href="#BufferedOutputStream（字节缓冲输出流）" class="headerlink" title="BufferedOutputStream（字节缓冲输出流）"></a>BufferedOutputStream（字节缓冲输出流）</h3><p><code>BufferedOutputStream</code> 将数据（字节信息）写入到目的地（通常是文件）的过程中不会一个字节一个字节的写入，而是会先将要写入的字节存放在缓存区，并从内部缓冲区中单独写入字节。这样大幅减少了 IO 次数，提高了读取效率</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">byte</span>[] array = <span class="string">&quot;JavaGuide&quot;</span>.getBytes();</span><br><span class="line">    bos.write(array);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似于 <code>BufferedInputStream</code> ，<code>BufferedOutputStream</code> 内部也维护了一个缓冲区，并且，这个缓存区的大小也是 <strong>8192</strong> 字节。</p>
<h2 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h2><p><code>BufferedReader</code> （字符缓冲输入流）和 <code>BufferedWriter</code>（字符缓冲输出流）类似于 <code>BufferedInputStream</code>（字节缓冲输入流）和<code>BufferedOutputStream</code>（字节缓冲输入流），内部都维护了一个字节数组作为缓冲区。不过，前者主要是用来操作字符信息。</p>
<h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><p>下面这段代码大家经常使用吧？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.print(<span class="string">&quot;Hello！&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Hello！&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>System.out</code> 实际是用于获取一个 <code>PrintStream</code> 对象，<code>print</code>方法实际调用的是 <code>PrintStream</code> 对象的 <code>write</code> 方法。</p>
<p><code>PrintStream</code> 属于字节打印流，与之对应的是 <code>PrintWriter</code> （字符打印流）。<code>PrintStream</code> 是 <code>OutputStream</code> 的子类，<code>PrintWriter</code> 是 <code>Writer</code> 的子类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStream</span> <span class="keyword">extends</span> <span class="title class_">FilterOutputStream</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Appendable</span>, Closeable &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintWriter</span> <span class="keyword">extends</span> <span class="title class_">Writer</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="随机访问流"><a href="#随机访问流" class="headerlink" title="随机访问流"></a>随机访问流</h2><p>这里要介绍的随机访问流指的是支持随意跳转到文件的任意位置进行读写的 <code>RandomAccessFile</code> 。</p>
<p><code>RandomAccessFile</code> 的构造方法如下，我们可以指定 <code>mode</code>（读写模式）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// openAndDelete 参数默认为 false 表示打开文件并且这个文件不会被删除</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RandomAccessFile</span><span class="params">(File file, String mode)</span></span><br><span class="line">    <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">    <span class="built_in">this</span>(file, mode, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 私有方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">RandomAccessFile</span><span class="params">(File file, String mode, <span class="type">boolean</span> openAndDelete)</span>  <span class="keyword">throws</span> FileNotFoundException&#123;</span><br><span class="line">  <span class="comment">// 省略大部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读写模式主要有下面四种：</p>
<ul>
<li><code>r</code> : 只读模式。</li>
<li><code>rw</code>: 读写模式</li>
<li><code>rws</code>: 相对于 <code>rw</code>，<code>rws</code> 同步更新对“文件的内容”或“元数据”的修改到外部存储设备。</li>
<li><code>rwd</code> : 相对于 <code>rw</code>，<code>rwd</code> 同步更新对“文件的内容”的修改到外部存储设备。</li>
</ul>
<p>文件内容指的是文件中实际保存的数据，元数据则是用来描述文件属性比如文件的大小信息、创建和修改时间。</p>
<p><code>RandomAccessFile</code> 中有一个文件指针用来表示下一个将要被写入或者读取的字节所处的位置。我们可以通过 <code>RandomAccessFile</code> 的 <code>seek(long pos)</code> 方法来设置文件指针的偏移量（距文件开头 <code>pos</code> 个字节处）。如果想要获取文件指针当前的位置的话，可以使用 <code>getFilePointer()</code> 方法。</p>
<p><code>RandomAccessFile</code> 代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">randomAccessFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;input.txt&quot;</span>), <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;读取之前的偏移量：&quot;</span> + randomAccessFile.getFilePointer() + <span class="string">&quot;,当前读取到的字符&quot;</span> + (<span class="type">char</span>) randomAccessFile.read() + <span class="string">&quot;，读取之后的偏移量：&quot;</span> + randomAccessFile.getFilePointer());</span><br><span class="line"><span class="comment">// 指针当前偏移量为 6</span></span><br><span class="line">randomAccessFile.seek(<span class="number">6</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;读取之前的偏移量：&quot;</span> + randomAccessFile.getFilePointer() + <span class="string">&quot;,当前读取到的字符&quot;</span> + (<span class="type">char</span>) randomAccessFile.read() + <span class="string">&quot;，读取之后的偏移量：&quot;</span> + randomAccessFile.getFilePointer());</span><br><span class="line"><span class="comment">// 从偏移量 7 的位置开始往后写入字节数据</span></span><br><span class="line">randomAccessFile.write(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;K&#x27;</span>&#125;);</span><br><span class="line"><span class="comment">// 指针当前偏移量为 0，回到起始位置</span></span><br><span class="line">randomAccessFile.seek(<span class="number">0</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;读取之前的偏移量：&quot;</span> + randomAccessFile.getFilePointer() + <span class="string">&quot;,当前读取到的字符&quot;</span> + (<span class="type">char</span>) randomAccessFile.read() + <span class="string">&quot;，读取之后的偏移量：&quot;</span> + randomAccessFile.getFilePointer());</span><br></pre></td></tr></table></figure>

<p><code>input.txt</code> 文件内容：</p>
<p><img src="https://files.catbox.moe/txbsre.png"></p>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">读取之前的偏移量：<span class="number">0</span>,当前读取到的字符A，读取之后的偏移量：<span class="number">1</span></span><br><span class="line">读取之前的偏移量：<span class="number">6</span>,当前读取到的字符G，读取之后的偏移量：<span class="number">7</span></span><br><span class="line">读取之前的偏移量：<span class="number">0</span>,当前读取到的字符A，读取之后的偏移量：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><code>input.txt</code> 文件内容变为 <code>ABCDEFGHIJK</code> 。</p>
<p><code>RandomAccessFile</code> 的 <code>write</code> 方法在写入对象的时候如果对应的位置已经有数据的话，会将其覆盖掉。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">randomAccessFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;input.txt&quot;</span>), <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">randomAccessFile.write(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;K&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>假设运行上面这段程序之前 <code>input.txt</code> 文件内容变为 <code>ABCD</code> ，运行之后则变为 <code>HIJK</code> 。</p>
<p><code>RandomAccessFile</code> 比较常见的一个应用就是实现大文件的 <strong>断点续传</strong> 。何谓断点续传？简单来说就是上传文件中途暂停或失败（比如遇到网络问题）之后，不需要重新上传，只需要上传那些未成功上传的文件分片即可。分片（先将文件切分成多个文件分片）上传是断点续传的基础。</p>
<p><code>RandomAccessFile</code> 可以帮助我们合并文件分片，示例代码如下：</p>
<p><img src="https://files.catbox.moe/8vb085.png"></p>
<p>我在<a href="https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html">《Java 面试指北》open in new window</a>中详细介绍了大文件的上传问题。</p>
<p><img src="https://files.catbox.moe/lb8nbs.png"></p>
<p><code>RandomAccessFile</code> 的实现依赖于 <code>FileDescriptor</code> (文件描述符) 和 <code>FileChannel</code> （内存映射文件）。</p>
<h1 id="Java-IO设计模式总结"><a href="#Java-IO设计模式总结" class="headerlink" title="Java IO设计模式总结"></a>Java IO设计模式总结</h1><p>这篇文章我们简单来看看我们从 IO 中能够学习到哪些设计模式的应用。</p>
<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p><strong>装饰器（Decorator）模式</strong> 可以在不改变原有对象的情况下拓展其功能。</p>
<p>装饰器模式通过组合替代继承来扩展原始类的功能，在一些继承关系比较复杂的场景（IO 这一场景各种类的继承关系就比较复杂）更加实用。</p>
<p>对于字节流来说， <code>FilterInputStream</code> （对应输入流）和<code>FilterOutputStream</code>（对应输出流）是装饰器模式的核心，分别用于增强 <code>InputStream</code> 和<code>OutputStream</code>子类对象的功能。</p>
<p>我们常见的<code>BufferedInputStream</code>(字节缓冲输入流)、<code>DataInputStream</code> 等等都是<code>FilterInputStream</code> 的子类，<code>BufferedOutputStream</code>（字节缓冲输出流）、<code>DataOutputStream</code>等等都是<code>FilterOutputStream</code>的子类。</p>
<p>举个例子，我们可以通过 <code>BufferedInputStream</code>（字节缓冲输入流）来增强 <code>FileInputStream</code> 的功能。</p>
<p><code>BufferedInputStream</code> 构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BufferedInputStream</span><span class="params">(InputStream in)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(in, DEFAULT_BUFFER_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BufferedInputStream</span><span class="params">(InputStream in, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(in);</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Buffer size &lt;= 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    buf = <span class="keyword">new</span> <span class="title class_">byte</span>[size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，<code>BufferedInputStream</code> 的构造函数其中的一个参数就是 <code>InputStream</code> 。</p>
<p><code>BufferedInputStream</code> 代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;input.txt&quot;))) &#123;</span><br><span class="line">    int content;</span><br><span class="line">    long skip = bis.skip(2);</span><br><span class="line">    while ((content = bis.read()) != -1) &#123;</span><br><span class="line">        System.out.print((char) content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候，你可以会想了：<strong>为啥我们直接不弄一个BufferedFileInputStream（字符缓冲文件输入流）呢？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BufferedFileInputStream</span> <span class="variable">bfis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedFileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果 <code>InputStream</code>的子类比较少的话，这样做是没问题的。不过， <code>InputStream</code>的子类实在太多，继承关系也太复杂了。如果我们为每一个子类都定制一个对应的缓冲输入流，那岂不是太麻烦了。</p>
<p>如果你对 IO 流比较熟悉的话，你会发现<code>ZipInputStream</code> 和<code>ZipOutputStream</code> 还可以分别增强 <code>BufferedInputStream</code> 和 <code>BufferedOutputStream</code> 的能力。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName));</span><br><span class="line"><span class="type">ZipInputStream</span> <span class="variable">zis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipInputStream</span>(bis);</span><br><span class="line"></span><br><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(fileName));</span><br><span class="line"><span class="type">ZipOutputStream</span> <span class="variable">zipOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipOutputStream</span>(bos);</span><br></pre></td></tr></table></figure>

<p><code>ZipInputStream</code> 和<code>ZipOutputStream</code> 分别继承自<code>InflaterInputStream</code> 和<code>DeflaterOutputStream</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InflaterInputStream</span> <span class="keyword">extends</span> <span class="title class_">FilterInputStream</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeflaterOutputStream</span> <span class="keyword">extends</span> <span class="title class_">FilterOutputStream</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这也是装饰器模式很重要的一个特征，那就是可以对原始类嵌套使用多个装饰器。</p>
<p>为了实现这一效果，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。上面介绍到的这些 IO 相关的装饰类和原始类共同的父类是 <code>InputStream</code> 和<code>OutputStream</code>。</p>
<p>对于字符流来说，<code>BufferedReader</code> 可以用来增加 <code>Reader</code> （字符输入流）子类的功能，<code>BufferedWriter</code> 可以用来增加 <code>Writer</code> （字符输出流）子类的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(fileName), <span class="string">&quot;UTF-8&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>IO 流中的装饰器模式应用的例子实在是太多了，不需要特意记忆，完全没必要哈！搞清了装饰器模式的核心之后，你在使用的时候自然就会知道哪些地方运用到了装饰器模式。</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a><a href="https://javaguide.cn/java/io/io-design-patterns.html#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"></a>适配器模式</h2><p><strong>适配器（Adapter Pattern）模式</strong> 主要用于接口互不兼容的类的协调工作，你可以将其联想到我们日常经常使用的电源适配器。</p>
<p>适配器模式中存在被适配的对象或者类称为 <strong>适配者(Adaptee)</strong> ，作用于适配者的对象或者类称为<strong>适配器(Adapter)</strong> 。适配器分为对象适配器和类适配器。类适配器使用继承关系来实现，对象适配器使用组合关系来实现。</p>
<p>IO 流中的字符流和字节流的接口不同，它们之间可以协调工作就是基于适配器模式来做的，更准确点来说是对象适配器。通过适配器，我们可以将字节流对象适配成一个字符流对象，这样我们可以直接通过字节流对象来读取或者写入字符数据。</p>
<p><code>InputStreamReader</code> 和 <code>OutputStreamWriter</code> 就是两个适配器(Adapter)， 同时，它们两个也是字节流和字符流之间的桥梁。<code>InputStreamReader</code> 使用 <code>StreamDecoder</code> （流解码器）对字节进行解码，<strong>实现字节流到字符流的转换，</strong> <code>OutputStreamWriter</code> 使用<code>StreamEncoder</code>（流编码器）对字符进行编码，实现字符流到字节流的转换。</p>
<p><code>InputStream</code> 和 <code>OutputStream</code> 的子类是被适配者， <code>InputStreamReader</code> 和 <code>OutputStreamWriter</code>是适配器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// InputStreamReader 是适配器，FileInputStream 是被适配的类</span></span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">// BufferedReader 增强 InputStreamReader 的功能（装饰器模式）</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br></pre></td></tr></table></figure>

<p><code>java.io.InputStreamReader</code> 部分源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamReader</span> <span class="keyword">extends</span> <span class="title class_">Reader</span> &#123;</span><br><span class="line">	<span class="comment">//用于解码的对象</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> StreamDecoder sd;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InputStreamReader</span><span class="params">(InputStream in)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(in);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 StreamDecoder 对象</span></span><br><span class="line">            sd = StreamDecoder.forInputStreamReader(in, <span class="built_in">this</span>, (String)<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用 StreamDecoder 对象做具体的读取工作</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> sd.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>java.io.OutputStreamWriter</code> 部分源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputStreamWriter</span> <span class="keyword">extends</span> <span class="title class_">Writer</span> &#123;</span><br><span class="line">    <span class="comment">// 用于编码的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StreamEncoder se;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OutputStreamWriter</span><span class="params">(OutputStream out)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(out);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 获取 StreamEncoder 对象</span></span><br><span class="line">            se = StreamEncoder.forOutputStreamWriter(out, <span class="built_in">this</span>, (String)<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用 StreamEncoder 对象做具体的写入工作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> c)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        se.write(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>适配器模式和装饰器模式有什么区别呢？</strong></p>
<p><strong>装饰器模式</strong> 更侧重于动态地增强原始类的功能，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。并且，装饰器模式支持对原始类嵌套使用多个装饰器。</p>
<p><strong>适配器模式</strong> 更侧重于让接口不兼容而不能交互的类可以一起工作，当我们调用适配器对应的方法时，适配器内部会调用适配者类或者和适配类相关的类的方法，这个过程透明的。就比如说 <code>StreamDecoder</code> （流解码器）和<code>StreamEncoder</code>（流编码器）就是分别基于 <code>InputStream</code> 和 <code>OutputStream</code> 来获取 <code>FileChannel</code>对象并调用对应的 <code>read</code> 方法和 <code>write</code> 方法进行字节数据的读取和写入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StreamDecoder(InputStream in, Object lock, CharsetDecoder dec) &#123;</span><br><span class="line">    <span class="comment">// 省略大部分代码</span></span><br><span class="line">    <span class="comment">// 根据 InputStream 对象获取 FileChannel 对象</span></span><br><span class="line">    ch = getChannel((FileInputStream)in);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>适配器和适配者两者不需要继承相同的抽象类或者实现相同的接口。</p>
<p>另外，<code>FutrueTask</code> 类使用了适配器模式，<code>Executors</code> 的内部类 <code>RunnableAdapter</code> 实现属于适配器，用于将 <code>Runnable</code> 适配成 <code>Callable</code>。</p>
<p><code>FutureTask</code>参数包含 <code>Runnable</code> 的一个构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Runnable runnable, V result)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用 Executors 类的 callable 方法</span></span><br><span class="line">    <span class="built_in">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="built_in">this</span>.state = NEW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Executors</code>中对应的方法和适配器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实际调用的是 Executors 的内部类 RunnableAdapter 的构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Callable&lt;T&gt; <span class="title function_">callable</span><span class="params">(Runnable task, T result)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RunnableAdapter</span>&lt;T&gt;(task, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 适配器</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">RunnableAdapter</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> Runnable task;</span><br><span class="line">    <span class="keyword">final</span> T result;</span><br><span class="line">    RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">        <span class="built_in">this</span>.task = task;</span><br><span class="line">        <span class="built_in">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        task.run();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式用于创建对象，NIO 中大量用到了工厂模式，比如 <code>Files</code> 类的 <code>newInputStream</code> 方法用于创建 <code>InputStream</code> 对象（静态工厂）、 <code>Paths</code> 类的 <code>get</code> 方法创建 <code>Path</code> 对象（静态工厂）、<code>ZipFileSystem</code> 类（<code>sun.nio</code>包下的类，属于 <code>java.nio</code> 相关的一些内部实现）的 <code>getPath</code> 的方法创建 <code>Path</code> 对象（简单工厂）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream is Files.newInputStream(Paths.get(generatorLogoPath))</span><br></pre></td></tr></table></figure>

<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>NIO 中的文件目录监听服务使用到了观察者模式。</p>
<p>NIO 中的文件目录监听服务基于 <code>WatchService</code> 接口和 <code>Watchable</code> 接口。<code>WatchService</code> 属于观察者，<code>Watchable</code> 属于被观察者。</p>
<p><code>Watchable</code> 接口定义了一个用于将对象注册到 <code>WatchService</code>（监控服务） 并绑定监听事件的方法 <code>register</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Path</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Path&gt;, Iterable&lt;Path&gt;, Watchable&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Watchable</span> &#123;</span><br><span class="line">    WatchKey <span class="title function_">register</span><span class="params">(WatchService watcher,</span></span><br><span class="line"><span class="params">                      WatchEvent.Kind&lt;?&gt;[] events,</span></span><br><span class="line"><span class="params">                      WatchEvent.Modifier... modifiers)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>WatchService</code> 用于监听文件目录的变化，同一个 <code>WatchService</code> 对象能够监听多个文件目录。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 WatchService 对象</span></span><br><span class="line"><span class="type">WatchService</span> <span class="variable">watchService</span> <span class="operator">=</span> FileSystems.getDefault().newWatchService();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个被监控文件夹的 Path 类:</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;workingDirectory&quot;</span>);</span><br><span class="line"><span class="comment">// 将这个 path 对象注册到 WatchService（监控服务） 中去</span></span><br><span class="line"><span class="type">WatchKey</span> <span class="variable">watchKey</span> <span class="operator">=</span> path.register(</span><br><span class="line">watchService, StandardWatchEventKinds...);</span><br></pre></td></tr></table></figure>

<p><code>Path</code> 类 <code>register</code> 方法的第二个参数 <code>events</code> （需要监听的事件）为可变长参数，也就是说我们可以同时监听多种事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WatchKey <span class="title function_">register</span><span class="params">(WatchService watcher,</span></span><br><span class="line"><span class="params">                  WatchEvent.Kind&lt;?&gt;... events)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>常用的监听事件有 3 种：</p>
<ul>
<li><code>StandardWatchEventKinds.ENTRY_CREATE</code> ：文件创建。</li>
<li><code>StandardWatchEventKinds.ENTRY_DELETE</code> : 文件删除。</li>
<li><code>StandardWatchEventKinds.ENTRY_MODIFY</code> : 文件修改。</li>
</ul>
<p><code>register</code> 方法返回 <code>WatchKey</code> 对象，通过<code>WatchKey</code> 对象可以获取事件的具体信息比如文件目录下是创建、删除还是修改了文件、创建、删除或者修改的文件的具体名称是什么。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WatchKey key;</span><br><span class="line"><span class="keyword">while</span> ((key = watchService.take()) != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (WatchEvent&lt;?&gt; event : key.pollEvents()) &#123;</span><br><span class="line">      <span class="comment">// 可以调用 WatchEvent 对象的方法做一些事情比如输出事件的具体上下文信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    key.reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>WatchService</code> 内部是通过一个 daemon thread（守护线程）采用定期轮询的方式来检测文件的变化，简化后的源码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PollingWatchService</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractWatchService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义一个 daemon thread（守护线程）轮询检测文件变化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService scheduledExecutor;</span><br><span class="line"></span><br><span class="line">    PollingWatchService() &#123;</span><br><span class="line">        scheduledExecutor = Executors</span><br><span class="line">            .newSingleThreadScheduledExecutor(<span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">                     <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">                     t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">                     <span class="keyword">return</span> t;</span><br><span class="line">                 &#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">enable</span><span class="params">(Set&lt;? extends WatchEvent.Kind&lt;?&gt;&gt; events, <span class="type">long</span> period)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">      <span class="comment">// 更新监听事件</span></span><br><span class="line">      <span class="built_in">this</span>.events = events;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启定期轮询</span></span><br><span class="line">      <span class="type">Runnable</span> <span class="variable">thunk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123; <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; poll(); &#125;&#125;;</span><br><span class="line">      <span class="built_in">this</span>.poller = scheduledExecutor</span><br><span class="line">        .scheduleAtFixedRate(thunk, period, period, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>Patterns in Java APIs：<a href="http://cecs.wright.edu/~tkprasad/courses/ceg860/paper/node26.html">http://cecs.wright.edu/~tkprasad/courses/ceg860/paper/node26.html</a></li>
<li>装饰器模式：通过剖析 Java IO 类库源码学习装饰器模式：<a href="https://time.geekbang.org/column/article/204845">https://time.geekbang.org/column/article/204845</a></li>
<li>sun.nio 包是什么，是 java 代码么？ - RednaxelaFX <a href="https://www.zhihu.com/question/29237781/answer/43653953">https://www.zhihu.com/question/29237781/answer/43653953</a></li>
</ul>
<h1 id="Java-IO模型详解"><a href="#Java-IO模型详解" class="headerlink" title="Java IO模型详解"></a>Java IO模型详解</h1><p>IO 模型这块确实挺难理解的，需要太多计算机底层知识。写这篇文章用了挺久，就非常希望能把我所知道的讲出来吧!希望朋友们能有收获！为了写这篇文章，还翻看了一下《UNIX 网络编程》这本书，太难了，我滴乖乖！心痛~</p>
<p><em>个人能力有限。如果文章有任何需要补充&#x2F;完善&#x2F;修改的地方，欢迎在评论区指出，共同进步！</em></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>I&#x2F;O 一直是很多小伙伴难以理解的一个知识点，这篇文章我会将我所理解的 I&#x2F;O 讲给你听，希望可以对你有所帮助。</p>
<h3 id="何为-I-x2F-O"><a href="#何为-I-x2F-O" class="headerlink" title="何为 I&#x2F;O?"></a>何为 I&#x2F;O?</h3><p>I&#x2F;O（<strong>I</strong>nput&#x2F;<strong>O</strong>utpu） 即<strong>输入／输出</strong> 。</p>
<p><strong>我们先从计算机结构的角度来解读一下 I&#x2F;O。</strong></p>
<p>根据冯.诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备。</p>
<p><img src="https://files.catbox.moe/4dqam0.png"></p>
<p>输入设备（比如键盘）和输出设备（比如显示器）都属于外部设备。网卡、硬盘这种既可以属于输入设备，也可以属于输出设备。</p>
<p>输入设备向计算机输入数据，输出设备接收计算机输出的数据。</p>
<p><strong>从计算机结构的视角来看的话， I&#x2F;O 描述了计算机系统与外部设备之间通信的过程。</strong></p>
<p><strong>我们再先从应用程序的角度来解读一下 I&#x2F;O。</strong></p>
<p>根据大学里学到的操作系统相关的知识：为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 <strong>用户空间（User space）</strong> 和 <strong>内核空间（Kernel space ）</strong> 。</p>
<p>像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。也就是说，我们想要进行 IO 操作，一定是要依赖内核空间的能力。</p>
<p>并且，用户空间的程序不能直接访问内核空间。</p>
<p>当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。</p>
<p>因此，用户进程想要执行 IO 操作的话，必须通过 <strong>系统调用</strong> 来间接访问内核空间</p>
<p>我们在平常开发过程中接触最多的就是 <strong>磁盘 IO（读写文件）</strong> 和 <strong>网络 IO（网络请求和响应）</strong>。</p>
<p><strong>从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。</strong></p>
<p>当应用程序发起 I&#x2F;O 调用后，会经历两个步骤：</p>
<ol>
<li>内核等待 I&#x2F;O 设备准备好数据</li>
<li>内核将数据从内核空间拷贝到用户空间。</li>
</ol>
<h3 id="有哪些常见的-IO-模型"><a href="#有哪些常见的-IO-模型" class="headerlink" title="有哪些常见的 IO 模型?"></a>有哪些常见的 IO 模型?</h3><p>UNIX 系统下， IO 模型一共有 5 种： <strong>同步阻塞 I&#x2F;O</strong>、<strong>同步非阻塞 I&#x2F;O</strong>、<strong>I&#x2F;O 多路复用</strong>、<strong>信号驱动 I&#x2F;O</strong> 和<strong>异步 I&#x2F;O</strong>。</p>
<p>这也是我们经常提到的 5 种 IO 模型。</p>
<h2 id="Java-中-3-种常见-IO-模型"><a href="#Java-中-3-种常见-IO-模型" class="headerlink" title="Java 中 3 种常见 IO 模型"></a>Java 中 3 种常见 IO 模型</h2><h3 id="BIO-Blocking-I-x2F-O"><a href="#BIO-Blocking-I-x2F-O" class="headerlink" title="BIO (Blocking I&#x2F;O)"></a>BIO (Blocking I&#x2F;O)</h3><p><strong>BIO 属于同步阻塞 IO 模型</strong> 。</p>
<p>同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。</p>
<p><img src="https://files.catbox.moe/dwbjd3.png"></p>
<p>在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I&#x2F;O 处理模型来应对更高的并发量。</p>
<h3 id="NIO-Non-blocking-x2F-New-I-x2F-O"><a href="#NIO-Non-blocking-x2F-New-I-x2F-O" class="headerlink" title="NIO (Non-blocking&#x2F;New I&#x2F;O)"></a>NIO (Non-blocking&#x2F;New I&#x2F;O)</h3><p>Java 中的 NIO 于 Java 1.4 中引入，对应 <code>java.nio</code> 包，提供了 <code>Channel</code> , <code>Selector</code>，<code>Buffer</code> 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它是支持面向缓冲的，基于通道的 I&#x2F;O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。</p>
<p>Java 中的 NIO 可以看作是 <strong>I&#x2F;O 多路复用模型</strong>。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。</p>
<p>跟着我的思路往下看看，相信你会得到答案！</p>
<p>我们先来看看 <strong>同步非阻塞 IO 模型</strong>。</p>
<p><img src="https://files.catbox.moe/uaynyz.png"></p>
<p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p>
<p>相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。</p>
<p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I&#x2F;O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p>
<p>这个时候，<strong>I&#x2F;O 多路复用模型</strong> 就上场了。</p>
<p><img src="https://files.catbox.moe/20qekg.png"></p>
<p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。</p>
<blockquote>
<p>目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，目前几乎在所有的操作系统上都有支持。</p>
<ul>
<li><strong>select 调用</strong> ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。</li>
<li><strong>epoll 调用</strong> ：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。</li>
</ul>
</blockquote>
<p><strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p>
<p>Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p>
<p><img src="https://files.catbox.moe/x04fq7.png"></p>
<h3 id="AIO-Asynchronous-I-x2F-O"><a href="#AIO-Asynchronous-I-x2F-O" class="headerlink" title="AIO (Asynchronous I&#x2F;O)"></a>AIO (Asynchronous I&#x2F;O)</h3><p>AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。</p>
<p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p>
<p><img src="https://files.catbox.moe/kx6z53.png"></p>
<p>目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。</p>
<p>最后，来一张图，简单总结一下 Java 中的 BIO、NIO、AIO。</p>
<p><img src="https://files.catbox.moe/ayxyu4.png"></p>
<h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《深入拆解 Tomcat &amp; Jetty》</li>
<li>如何完成一次 IO：<a href="https://llc687.top/126.html">https://llc687.top/126.html</a></li>
<li>程序员应该这样理解 IO：<a href="https://www.jianshu.com/p/fa7bdc4f3de7">https://www.jianshu.com/p/fa7bdc4f3de7open in new window</a></li>
<li>10 分钟看懂， Java NIO 底层原理：<a href="https://www.cnblogs.com/crazymakercircle/p/10225159.html">https://www.cnblogs.com/crazymakercircle/p/10225159.html</a></li>
<li>IO 模型知多少 | 理论篇：<a href="https://www.cnblogs.com/sheng-jie/p/how-much-you-know-about-io-models.html">https://www.cnblogs.com/sheng-jie/p/how-much-you-know-about-io-models.html</a></li>
<li>《UNIX 网络编程 卷 1；套接字联网 API 》6.2 节 IO 模型</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Java并发编程面试一</title>
    <url>/2022/08/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E4%B8%80/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h1 id="Java-并发常见面试题总结（上）"><a href="#Java-并发常见面试题总结（上）" class="headerlink" title="Java 并发常见面试题总结（上）"></a>Java 并发常见面试题总结（上）</h1><h2 id="什么是线程和进程"><a href="#什么是线程和进程" class="headerlink" title="什么是线程和进程?"></a>什么是线程和进程?</h2><h3 id="何为进程"><a href="#何为进程" class="headerlink" title="何为进程?"></a>何为进程?</h3><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p>
<p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p>
<p>如下图所示，在 Windows 中通过查看任务管理器的方式，我们就可以清楚看到 Windows 当前运行的进程（<code>.exe</code> 文件的运行）</p>
<p><img src="https://files.catbox.moe/38gza5.png"></p>
<h3 id="何为线程"><a href="#何为线程" class="headerlink" title="何为线程?"></a>何为线程?</h3><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<p>Java 程序天生就是多线程程序，我们可以通过 JMX 来看看一个普通的 Java 程序有哪些线程，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiThread</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 获取 Java 线程管理 MXBean</span></span><br><span class="line">	<span class="type">ThreadMXBean</span> <span class="variable">threadMXBean</span> <span class="operator">=</span> ManagementFactory.getThreadMXBean();</span><br><span class="line">		<span class="comment">// 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息</span></span><br><span class="line">		ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(<span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">		<span class="comment">// 遍历线程信息，仅打印线程 ID 和线程名称信息</span></span><br><span class="line">		<span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;[&quot;</span> + threadInfo.getThreadId() + <span class="string">&quot;] &quot;</span> + threadInfo.getThreadName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序输出如下（输出内容可能不同，不用太纠结下面每个线程的作用，只用知道 main 线程执行 main 方法即可）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">5</span>] Attach Listener <span class="comment">//添加事件</span></span><br><span class="line">[<span class="number">4</span>] Signal Dispatcher <span class="comment">// 分发处理给 JVM 信号的线程</span></span><br><span class="line">[<span class="number">3</span>] Finalizer <span class="comment">//调用对象 finalize 方法的线程</span></span><br><span class="line">[<span class="number">2</span>] Reference Handler <span class="comment">//清除 reference 线程</span></span><br><span class="line">[<span class="number">1</span>] main <span class="comment">//main 线程,程序入口</span></span><br></pre></td></tr></table></figure>

<p>从上面的输出内容可以看出：<strong>一个 Java 程序的运行是 main 线程和多个其他线程同时运行</strong>。</p>
<h2 id="请简要描述线程与进程的关系-区别及优缺点？"><a href="#请简要描述线程与进程的关系-区别及优缺点？" class="headerlink" title="请简要描述线程与进程的关系,区别及优缺点？"></a>请简要描述线程与进程的关系,区别及优缺点？</h2><p>从 JVM 角度说进程和线程之间的关系。</p>
<h3 id="图解进程和线程的关系"><a href="#图解进程和线程的关系" class="headerlink" title="图解进程和线程的关系"></a>图解进程和线程的关系</h3><p>下图是 Java 内存区域，通过下图我们从 JVM 的角度来说一下线程和进程之间的关系。</p>
<p><img src="https://files.catbox.moe/4vcvcw.png"></p>
<p>从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器</strong>、<strong>虚拟机栈</strong> 和 <strong>本地方法栈</strong>。</p>
<p><strong>总结：</strong> <strong>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</strong></p>
<p>下面是该知识点的扩展内容！</p>
<p>下面来思考这样一个问题：为什么<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>是线程私有的呢？为什么堆和方法区是线程共享的呢？</p>
<h3 id="程序计数器为什么是私有的"><a href="#程序计数器为什么是私有的" class="headerlink" title="程序计数器为什么是私有的?"></a>程序计数器为什么是私有的?</h3><p>程序计数器主要有下面两个作用：</p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ol>
<p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p>
<p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p>
<h3 id="虚拟机栈和本地方法栈为什么是私有的"><a href="#虚拟机栈和本地方法栈为什么是私有的" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的?"></a>虚拟机栈和本地方法栈为什么是私有的?</h3><ul>
<li><strong>虚拟机栈：</strong> 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li>
<li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li>
</ul>
<p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p>
<h3 id="一句话简单了解堆和方法区"><a href="#一句话简单了解堆和方法区" class="headerlink" title="一句话简单了解堆和方法区"></a>一句话简单了解堆和方法区</h3><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<h2 id="并发与并行的区别"><a href="#并发与并行的区别" class="headerlink" title="并发与并行的区别"></a>并发与并行的区别</h2><ul>
<li><strong>并发</strong>：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li>
<li><strong>并行</strong>：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li>
</ul>
<p>最关键的点是：是否是 <strong>同时</strong> 执行。</p>
<h2 id="同步和异步的区别"><a href="#同步和异步的区别" class="headerlink" title="同步和异步的区别"></a>同步和异步的区别</h2><ul>
<li><strong>同步</strong> ： 发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</li>
<li><strong>异步</strong> ：调用在发出之后，不用等待返回结果，该调用直接返回。</li>
</ul>
<h2 id="为什么要使用多线程呢"><a href="#为什么要使用多线程呢" class="headerlink" title="为什么要使用多线程呢?"></a>为什么要使用多线程呢?</h2><p>先从总体上来说：</p>
<ul>
<li><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li>
<li><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li>
</ul>
<p>再深入到计算机底层来探讨：</p>
<ul>
<li><strong>单核时代</strong>： 在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。</li>
<li><strong>多核时代</strong>: 多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间&#x2F;CPU 核心数）。</li>
</ul>
<h2 id="使用多线程可能带来什么问题"><a href="#使用多线程可能带来什么问题" class="headerlink" title="使用多线程可能带来什么问题?"></a>使用多线程可能带来什么问题?</h2><p>并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、死锁、线程不安全等等。</p>
<h2 id="说说线程的生命周期和状态"><a href="#说说线程的生命周期和状态" class="headerlink" title="说说线程的生命周期和状态?"></a>说说线程的生命周期和状态?</h2><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：</p>
<ul>
<li>NEW: 初始状态，线程被创建出来但没有被调用 <code>start()</code> 。</li>
<li>RUNNABLE: 运行状态，线程被调用了 <code>start()</code>等待运行的状态。</li>
<li>BLOCKED ：阻塞状态，需要等待锁释放。</li>
<li>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</li>
<li>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</li>
<li>TERMINATED：终止状态，表示该线程已经运行完毕。</li>
</ul>
<p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。</p>
<p>Java 线程状态变迁图(图源：<a href="https://mp.weixin.qq.com/s/UOrXql_LhOD8dhTq_EPI0w">挑错 |《Java 并发编程的艺术》中关于线程状态的三处错误open in new window</a>)：</p>
<p><img src="https://files.catbox.moe/kcqevh.png"></p>
<p>由上图可以看出：线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p>
<blockquote>
<p>在操作系统层面，线程有 READY 和 RUNNING 状态；而在 JVM 层面，只能看到 RUNNABLE 状态（图源：<a href="https://howtodoinjava.com/">HowToDoInJavaopen in new window</a>：<a href="https://howtodoinjava.com/Java/multi-threading/Java-thread-life-cycle-and-thread-states/">Java Thread Life Cycle and Thread Statesopen in new window</a>），所以 Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。</p>
<p><strong>为什么 JVM 没有区分这两种状态呢？</strong> （摘自：<a href="https://www.zhihu.com/question/56494969/answer/154053599">Java 线程运行怎么有第六种状态？ - Dawell 的回答open in new window</a> ） 现在的时分（time-sharing）多任务（multi-task）操作系统架构通常都是用所谓的“时间分片（time quantum or time slice）”方式进行抢占式（preemptive）轮转调度（round-robin 式）。这个时间分片通常是很小的，一个线程一次最多只能在 CPU 上运行比如 10-20ms 的时间（此时处于 running 状态），也即大概只有 0.01 秒这一量级，时间片用后就要被切换下来放入调度队列的末尾等待再次调度。（也即回到 ready 状态）。线程切换的如此之快，区分这两种状态就没什么意义了。</p>
</blockquote>
<p><img src="https://files.catbox.moe/98ogav.png"></p>
<ul>
<li>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态。</li>
<li><strong>TIMED_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。</li>
<li>当线程进入 <code>synchronized</code> 方法&#x2F;块或者调用 <code>wait</code> 后（被 <code>notify</code>）重新进入 <code>synchronized</code> 方法&#x2F;块，但是锁被其它线程占有，这个时候线程就会进入 <strong>BLOCKED（阻塞）</strong> 状态。</li>
<li>线程在执行完了 <code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</li>
</ul>
<p>相关阅读：<a href="https://mp.weixin.qq.com/s/R5MrTsWvk9McFSQ7bS0W2w">线程的几种状态你真的了解么？open in new window</a> 。</p>
<h2 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换?"></a>什么是上下文切换?</h2><p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p>
<ul>
<li>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</li>
<li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。</li>
<li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li>
<li>被终止或结束运行</li>
</ul>
<p>这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong>。</p>
<p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p>
<h2 id="什么是线程死锁-如何避免死锁"><a href="#什么是线程死锁-如何避免死锁" class="headerlink" title="什么是线程死锁?如何避免死锁?"></a>什么是线程死锁?如何避免死锁?</h2><h3 id="认识线程死锁"><a href="#认识线程死锁" class="headerlink" title="认识线程死锁"></a>认识线程死锁</h3><p>线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>
<p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p>
<p><img src="https://files.catbox.moe/8f4xt6.png"></p>
<p>下面通过一个例子来说明线程死锁,代码模拟了上图的死锁的情况 (代码来源于《并发编程之美》)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread[线程 <span class="number">1</span>,<span class="number">5</span>,main]get resource1</span><br><span class="line">Thread[线程 <span class="number">2</span>,<span class="number">5</span>,main]get resource2</span><br><span class="line">Thread[线程 <span class="number">1</span>,<span class="number">5</span>,main]waiting get resource2</span><br><span class="line">Thread[线程 <span class="number">2</span>,<span class="number">5</span>,main]waiting get resource1</span><br></pre></td></tr></table></figure>

<p>线程 A 通过 <code>synchronized (resource1)</code> 获得 <code>resource1</code> 的监视器锁，然后通过<code>Thread.sleep(1000);</code>让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。</p>
<p>上面的例子符合产生死锁的四个必要条件：</p>
<ol>
<li>互斥条件：该资源任意一个时刻只由一个线程占用。</li>
<li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li>循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<h3 id="如何预防和避免线程死锁"><a href="#如何预防和避免线程死锁" class="headerlink" title="如何预防和避免线程死锁?"></a>如何预防和避免线程死锁?</h3><p><strong>如何预防死锁？</strong> 破坏死锁的产生的必要条件即可：</p>
<ol>
<li><strong>破坏请求与保持条件</strong> ：一次性申请所有的资源。</li>
<li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>
</ol>
<p><strong>如何避免死锁？</strong></p>
<p>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p>
<blockquote>
<p><strong>安全状态</strong> 指的是系统能够按照某种线程推进顺序（P1、P2、P3…..Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 <code>&lt;P1、P2、P3.....Pn&gt;</code> 序列为安全序列。</p>
</blockquote>
<p>我们对线程 2 的代码修改成下面这样就不会产生死锁了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread[线程 <span class="number">1</span>,<span class="number">5</span>,main]get resource1</span><br><span class="line">Thread[线程 <span class="number">1</span>,<span class="number">5</span>,main]waiting get resource2</span><br><span class="line">Thread[线程 <span class="number">1</span>,<span class="number">5</span>,main]get resource2</span><br><span class="line">Thread[线程 <span class="number">2</span>,<span class="number">5</span>,main]get resource1</span><br><span class="line">Thread[线程 <span class="number">2</span>,<span class="number">5</span>,main]waiting get resource2</span><br><span class="line">Thread[线程 <span class="number">2</span>,<span class="number">5</span>,main]get resource2</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>我们分析一下上面的代码为什么避免了死锁的发生?</p>
<p>线程 1 首先获得到 resource1 的监视器锁,这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。</p>
<h2 id="sleep-方法和-wait-方法对比"><a href="#sleep-方法和-wait-方法对比" class="headerlink" title="sleep() 方法和 wait() 方法对比"></a>sleep() 方法和 wait() 方法对比</h2><p><strong>共同点</strong> ：两者都可以暂停线程的执行。</p>
<p><strong>区别</strong> ：</p>
<ul>
<li><strong>sleep() 方法没有释放锁，而 wait() 方法释放了锁</strong> 。</li>
<li><code>wait()</code> 通常被用于线程间交互&#x2F;通信，<code>sleep()</code>通常被用于暂停执行。</li>
<li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li>
<li><code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法。为什么这样设计呢？</li>
</ul>
<h2 id="为什么-wait-方法不定义在-Thread-中？"><a href="#为什么-wait-方法不定义在-Thread-中？" class="headerlink" title="为什么 wait() 方法不定义在 Thread 中？"></a>为什么 wait() 方法不定义在 Thread 中？</h2><p><code>wait()</code> 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（<code>Object</code>）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（<code>Object</code>）而非当前的线程（<code>Thread</code>）。</p>
<p>类似的问题：<strong>为什么 sleep() 方法定义在 Thread 中？</strong></p>
<p>因为 <code>sleep()</code> 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。</p>
<h2 id="可以直接调用-Thread-类的-run-方法吗？"><a href="#可以直接调用-Thread-类的-run-方法吗？" class="headerlink" title="可以直接调用 Thread 类的 run 方法吗？"></a>可以直接调用 Thread 类的 run 方法吗？</h2><p>这是另一个非常经典的 Java 多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！</p>
<p>new 一个 <code>Thread</code>，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p><strong>总结： 调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。</strong></p>
<h1 id="Java-并发常见面试题总结（中）"><a href="#Java-并发常见面试题总结（中）" class="headerlink" title="Java 并发常见面试题总结（中）"></a>Java 并发常见面试题总结（中）</h1><h2 id="JMM-Java-Memory-Model"><a href="#JMM-Java-Memory-Model" class="headerlink" title="JMM(Java Memory Model)"></a>JMM(Java Memory Model)</h2><p>JMM（Java 内存模型）相关的问题比较多，也比较重要，于是我单独抽了一篇文章来总结 JMM 相关的知识点和问题： <a href="https://javaguide.cn/java/concurrent/jmm.html">JMM（Java 内存模型）详解</a> 。</p>
<h2 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h2><h3 id="如何保证变量的可见性？"><a href="#如何保证变量的可见性？" class="headerlink" title="如何保证变量的可见性？"></a>如何保证变量的可见性？</h3><p>在 Java 中，<code>volatile</code> 关键字可以保证变量的可见性，如果我们将变量声明为 <strong>volatile</strong> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>
<p><img src="https://files.catbox.moe/lv729g.png"></p>
<p><img src="https://files.catbox.moe/h68ql1.png"></p>
<p><img src="https://files.catbox.moe/ref7na.png"></p>
<p><code>volatile</code> 关键字其实并非是 Java 语言特有的，在 C 语言里也有，它最原始的意义就是禁用 CPU 缓存。如果我们将一个变量使用 <code>volatile</code> 修饰，这就指示 编译器，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>
<p><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</p>
<h3 id="如何禁止指令重排序？"><a href="#如何禁止指令重排序？" class="headerlink" title="如何禁止指令重排序？"></a>如何禁止指令重排序？</h3><p><strong>在 Java 中，volatile 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。</strong> 如果我们将变量声明为 <strong>volatile</strong> ，在对这个变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序。</p>
<p>在 Java 中，<code>Unsafe</code> 类提供了三个开箱即用的内存屏障相关的方法，屏蔽了操作系统底层的差异：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">loadFence</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">storeFence</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">fullFence</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>理论上来说，你通过这个三个方法也可以实现和<code>volatile</code>禁止重排序一样的效果，只是会麻烦一些。</p>
<p>下面我以一个常见的面试题为例讲解一下 <code>volatile</code> 关键字禁止指令重排序的效果。</p>
<p>面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”</p>
<p><strong>双重校验锁实现对象单例（线程安全）</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>双重检测锁方式实现单例模式的原理(Double Check Lock)</strong></p>
<p>第一次判断是否为null：第一次判断是在Synchronized同步代码块外，理由是单例模式只会创建一个实例，并通过getInstance方法返回singleton对象，所以如果已经创建了singleton对象，就不用进入同步代码块，不用竞争锁，直接返回前面创建的实例即可，这样大大提升效率。</p>
<p>第二次判断singleton是否为null：第二次判断原因是为了保证同步，假若线程A通过了第一次判断，进入了同步代码块，但是还未执行，线程B就进来了（线程B获得CPU时间片），线程B也通过了第一次判断（线程A并未创建实例，所以B通过了第一次判断），准备进入同步代码块，假若这个时候不判断，就会存在这种情况：线程B创建了实例，此时恰好A也获得执行时间片，如果不加以判断，那么线程A也会创建一个实例，就会造成多实例的情况。</p>
<p>所以，为了满足单例模式的要求，双重校验是必不可少的。</p>
<p>单例模式(singleton pattren)，属于创建类型的一种常用的软件设计模式。传统的单例模式，保证一个类仅有一个实例，并提供一个访问它的全局访问点。(手写单例模式，饿汉，懒汉)</p>
<p><code>uniqueInstance</code> 采用 <code>volatile</code> 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p>
<ol>
<li>为 <code>uniqueInstance</code> 分配内存空间</li>
<li>初始化 <code>uniqueInstance</code></li>
<li>将 <code>uniqueInstance</code> 指向分配的内存地址</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance</code>() 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还未被初始化。</p>
<h3 id="volatile-可以保证原子性么？"><a href="#volatile-可以保证原子性么？" class="headerlink" title="volatile 可以保证原子性么？"></a>volatile 可以保证原子性么？</h3><p><strong>volatile 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。</strong></p>
<p>我们通过下面的代码即可证明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 微信搜 JavaGuide 回复&quot;面试突击&quot;即可免费领取个人原创的 Java 面试手册</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Guide哥</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/08/03 13:40</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatoleAtomicityDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="type">VolatoleAtomicityDemo</span> <span class="variable">volatoleAtomicityDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatoleAtomicityDemo</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">500</span>; j++) &#123;</span><br><span class="line">                    volatoleAtomicityDemo.increase();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等待1.5秒，保证上面程序执行完成</span></span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">        System.out.println(inc);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常情况下，运行上面的代码理应输出 <code>2500</code>。但你真正运行了上面的代码之后，你会发现每次输出结果都小于 <code>2500</code>。</p>
<p>为什么会出现这种情况呢？不是说好了，<code>volatile</code> 可以保证变量的可见性嘛！</p>
<p>也就是说，如果 <code>volatile</code> 能保证 <code>inc++</code> 操作的原子性的话。每个线程中对 <code>inc</code> 变量自增完之后，其他线程可以立即看到修改后的值。5 个线程分别进行了 500 次操作，那么最终 inc 的值应该是 5*500&#x3D;2500。</p>
<p>很多人会误认为自增操作 <code>inc++</code> 是原子性的，实际上，<code>inc++</code> 其实是一个复合操作，包括三步：</p>
<ol>
<li>读取 inc 的值。</li>
<li>对 inc 加 1。</li>
<li>将 inc 的值写回内存。</li>
</ol>
<p><code>volatile</code> 是无法保证这三个操作是具有原子性的，有可能导致下面这种情况出现：</p>
<ol>
<li>线程 1 对 <code>inc</code> 进行读取操作之后，还未对其进行修改。线程 2 又读取了 <code>inc</code>的值并对其进行修改（+1），再将<code>inc</code> 的值写回内存。</li>
<li>线程 2 操作完毕后，线程 1 对 <code>inc</code>的值进行修改（+1），再将<code>inc</code> 的值写回内存。</li>
</ol>
<p>这也就导致两个线程分别对 <code>inc</code> 进行了一次自增操作后，<code>inc</code> 实际上只增加了 1。</p>
<p>其实，如果想要保证上面的代码运行正确也非常简单，利用 <code>synchronized</code> 、<code>Lock</code>或者<code>AtomicInteger</code>都可以。</p>
<p>使用 <code>synchronized</code> 改进：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">    inc++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>AtomicInteger</code> 改进：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">AtomicInteger</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">    inc.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>ReentrantLock</code> 改进：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h2><h3 id="说一说自己对于-synchronized-关键字的了解"><a href="#说一说自己对于-synchronized-关键字的了解" class="headerlink" title="说一说自己对于 synchronized 关键字的了解"></a>说一说自己对于 synchronized 关键字的了解</h3><p><code>synchronized</code> 翻译成中文是同步的的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p>
<p>在 Java 早期版本中，<code>synchronized</code> 属于 <strong>重量级锁</strong>，效率低下。 因为监视器锁（monitor）是依赖于底层的操作系统的 <code>Mutex Lock</code> 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p>
<p>不过，在 Java 6 之后，Java 官方对从 JVM 层面对 <code>synchronized</code> 较大优化，所以现在的 <code>synchronized</code> 锁效率也优化得很不错了。JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。所以，你会发现目前的话，不论是各种开源框架还是 JDK 源码都大量使用了 <code>synchronized</code> 关键字。</p>
<h3 id="如何使用-synchronized-关键字？"><a href="#如何使用-synchronized-关键字？" class="headerlink" title="如何使用 synchronized 关键字？"></a>如何使用 synchronized 关键字？</h3><p>synchronized 关键字最主要的三种使用方式：</p>
<ol>
<li>修饰实例方法</li>
<li>修饰静态方法</li>
<li>修饰代码块</li>
</ol>
<p><strong>1、修饰实例方法</strong> （锁当前对象实例）</p>
<p>给当前对象实例加锁，进入同步代码前要获得 <strong>当前对象实例的锁</strong> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、修饰静态方法</strong> （锁当前类）</p>
<p>给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 <strong>当前 class 的锁</strong>。</p>
<p>这是因为静态成员不属于任何一个实例对象，归整个类所有，不依赖于类的特定实例，被类的所有实例共享。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态 <code>synchronized</code> 方法和非静态 <code>synchronized</code> 方法之间的调用互斥么？不互斥！如果一个线程 A 调用一个实例对象的非静态 <code>synchronized</code> 方法，而线程 B 需要调用这个实例对象所属类的静态 <code>synchronized</code> 方法，是允许的，不会发生互斥现象，因为访问静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而访问非静态 <code>synchronized</code> 方法占用的锁是当前实例对象锁。</p>
<p><strong>3、修饰代码块</strong> （锁指定对象&#x2F;类）</p>
<p>对括号里指定的对象&#x2F;类加锁：</p>
<ul>
<li><code>synchronized(object)</code> 表示进入同步代码库前要获得 <strong>给定对象的锁</strong>。</li>
<li><code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>给定 Class 的锁</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li><code>synchronized</code> 关键字加到 <code>static</code> 静态方法和 <code>synchronized(class)</code> 代码块上都是是给 Class 类上锁；</li>
<li><code>synchronized</code> 关键字加到实例方法上是给对象实例上锁；</li>
<li>尽量不要使用 <code>synchronized(String a)</code> 因为 JVM 中，字符串常量池具有缓存功能。</li>
</ul>
<h3 id="构造方法可以使用-synchronized-关键字修饰么？"><a href="#构造方法可以使用-synchronized-关键字修饰么？" class="headerlink" title="构造方法可以使用 synchronized 关键字修饰么？"></a>构造方法可以使用 synchronized 关键字修饰么？</h3><p>先说结论：<strong>构造方法不能使用 synchronized 关键字修饰。</strong></p>
<p>构造方法本身就属于线程安全的，不存在同步的构造方法一说。</p>
<h3 id="讲一下-synchronized-关键字的底层原理"><a href="#讲一下-synchronized-关键字的底层原理" class="headerlink" title="讲一下 synchronized 关键字的底层原理"></a>讲一下 synchronized 关键字的底层原理</h3><p>synchronized 关键字底层原理属于 JVM 层面。</p>
<h4 id="synchronized-同步语句块的情况"><a href="#synchronized-同步语句块的情况" class="headerlink" title="synchronized 同步语句块的情况"></a>synchronized 同步语句块的情况</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;synchronized 代码块&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 JDK 自带的 <code>javap</code> 命令查看 <code>SynchronizedDemo</code> 类的相关字节码信息：首先切换到类的对应目录执行 <code>javac SynchronizedDemo.java</code> 命令生成编译后的 .class 文件，然后执行<code>javap -c -s -v -l SynchronizedDemo.class</code>。</p>
<p><img src="https://files.catbox.moe/h5kl98.png"></p>
<p>从上面我们可以看出：<strong>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</strong></p>
<p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 monitor</strong> 的持有权。</p>
<blockquote>
<p>在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp">ObjectMonitoropen in new window</a>实现的。每个对象中都内置了一个 <code>ObjectMonitor</code>对象。</p>
<p>另外，<code>wait/notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么只有在同步的块或者方法中才能调用<code>wait/notify</code>等方法，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因。</p>
</blockquote>
<p>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p>
<p><img src="https://files.catbox.moe/2g503g.png"></p>
<p>对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。</p>
<p><img src="https://files.catbox.moe/xu13jq.png"></p>
<p>如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p>
<h4 id="synchronized-修饰方法的的情况"><a href="#synchronized-修饰方法的的情况" class="headerlink" title="synchronized 修饰方法的的情况"></a>synchronized 修饰方法的的情况</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;synchronized 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://files.catbox.moe/zqun38.png"></p>
<p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>
<p>如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p>
<p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p>
<p><strong>不过两者的本质都是对对象监视器 monitor 的获取。</strong></p>
<p>相关推荐：<a href="https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/">Java 锁与线程的那些事 - 有赞技术团队open in new window</a> 。</p>
<p>🧗🏻 进阶一下：学有余力的小伙伴可以抽时间详细研究一下对象监视器 <code>monitor</code>。</p>
<h3 id="JDK1-6-之后的-synchronized-关键字底层做了哪些优化？"><a href="#JDK1-6-之后的-synchronized-关键字底层做了哪些优化？" class="headerlink" title="JDK1.6 之后的 synchronized 关键字底层做了哪些优化？"></a>JDK1.6 之后的 synchronized 关键字底层做了哪些优化？</h3><p>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。</p>
<p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>
<p>关于这几种优化的详细信息可以查看下面这篇文章：<a href="https://www.cnblogs.com/wuqinglong/p/9945618.html">Java6 及以上版本对 synchronized 的优化open in new window</a></p>
<h3 id="synchronized-和-volatile-的区别？"><a href="#synchronized-和-volatile-的区别？" class="headerlink" title="synchronized 和 volatile 的区别？"></a>synchronized 和 volatile 的区别？</h3><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p>
<ul>
<li><code>volatile</code> 关键字是线程同步的轻量级实现，所以 <code>volatile</code>性能肯定比<code>synchronized</code>关键字要好 。但是 <code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块 。</li>
<li><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</li>
<li><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</li>
</ul>
<h3 id="synchronized-和-ReentrantLock-的区别"><a href="#synchronized-和-ReentrantLock-的区别" class="headerlink" title="synchronized 和 ReentrantLock 的区别"></a>synchronized 和 ReentrantLock 的区别</h3><h4 id="两者都是可重入锁"><a href="#两者都是可重入锁" class="headerlink" title="两者都是可重入锁"></a>两者都是可重入锁</h4><p><strong>“可重入锁”</strong> 指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。</p>
<h4 id="synchronized-依赖于-JVM-而-ReentrantLock-依赖于-API"><a href="#synchronized-依赖于-JVM-而-ReentrantLock-依赖于-API" class="headerlink" title="synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API"></a>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</h4><p><code>synchronized</code> 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 <code>synchronized</code> 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。<code>ReentrantLock</code> 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try&#x2F;finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p>
<h4 id="ReentrantLock-比-synchronized-增加了一些高级功能"><a href="#ReentrantLock-比-synchronized-增加了一些高级功能" class="headerlink" title="ReentrantLock 比 synchronized 增加了一些高级功能"></a>ReentrantLock 比 synchronized 增加了一些高级功能</h4><p>相比<code>synchronized</code>，<code>ReentrantLock</code>增加了一些高级功能。主要来说主要有三点：</p>
<ul>
<li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li>
<li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>&#x2F;<code>notifyAll()</code>方法相结合可以实现等待&#x2F;通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li>
</ul>
<blockquote>
<p><code>Condition</code>是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个<code>Lock</code>对象中可以创建多个<code>Condition</code>实例（即对象监视器），<strong>线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()&#x2F;notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是 Condition 接口默认提供的。而<code>synchronized</code>关键字就相当于整个 Lock 对象中只有一个<code>Condition</code>实例，所有的线程都注册在它一个身上。如果执行<code>notifyAll()</code>方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而<code>Condition</code>实例的<code>signalAll()</code>方法 只会唤醒注册在该<code>Condition</code>实例中的所有等待线程。</p>
</blockquote>
<p><strong>如果你想使用上述功能，那么选择 ReentrantLock 是一个不错的选择。性能已不是选择标准</strong></p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="ThreadLocal-有什么用？"><a href="#ThreadLocal-有什么用？" class="headerlink" title="ThreadLocal 有什么用？"></a>ThreadLocal 有什么用？</h3><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong></p>
<p>JDK 中自带的<code>ThreadLocal</code>类正是为了解决这样的问题。 <strong>ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong></p>
<p>如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p>
<p>再举个简单的例子：两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么 ThreadLocal 就是用来避免这两个线程竞争的。</p>
<h3 id="如何使用-ThreadLocal？"><a href="#如何使用-ThreadLocal？" class="headerlink" title="如何使用 ThreadLocal？"></a>如何使用 ThreadLocal？</h3><p>相信看了上面的解释，大家已经搞懂 <code>ThreadLocal</code> 类是个什么东西了。下面简单演示一下如何在项目中实际使用 <code>ThreadLocal</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalExample</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; formatter = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyyMMdd HHmm&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ThreadLocalExample</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalExample</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(obj, <span class="string">&quot;&quot;</span>+i);</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1000</span>));</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread Name= &quot;</span>+Thread.currentThread().getName()+<span class="string">&quot; default Formatter = &quot;</span>+formatter.get().toPattern());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//formatter pattern is changed here by thread, but it won&#x27;t reflect to other threads</span></span><br><span class="line">        formatter.set(<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Thread Name= &quot;</span>+Thread.currentThread().getName()+<span class="string">&quot; formatter = &quot;</span>+formatter.get().toPattern());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread Name= <span class="number">0</span> <span class="type">default</span> <span class="variable">Formatter</span> <span class="operator">=</span> yyyyMMdd HHmm</span><br><span class="line">Thread Name= <span class="number">0</span> formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= <span class="number">1</span> <span class="type">default</span> <span class="variable">Formatter</span> <span class="operator">=</span> yyyyMMdd HHmm</span><br><span class="line">Thread Name= <span class="number">2</span> <span class="type">default</span> <span class="variable">Formatter</span> <span class="operator">=</span> yyyyMMdd HHmm</span><br><span class="line">Thread Name= <span class="number">1</span> formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= <span class="number">3</span> <span class="type">default</span> <span class="variable">Formatter</span> <span class="operator">=</span> yyyyMMdd HHmm</span><br><span class="line">Thread Name= <span class="number">2</span> formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= <span class="number">4</span> <span class="type">default</span> <span class="variable">Formatter</span> <span class="operator">=</span> yyyyMMdd HHmm</span><br><span class="line">Thread Name= <span class="number">3</span> formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= <span class="number">4</span> formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= <span class="number">5</span> <span class="type">default</span> <span class="variable">Formatter</span> <span class="operator">=</span> yyyyMMdd HHmm</span><br><span class="line">Thread Name= <span class="number">5</span> formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= <span class="number">6</span> <span class="type">default</span> <span class="variable">Formatter</span> <span class="operator">=</span> yyyyMMdd HHmm</span><br><span class="line">Thread Name= <span class="number">6</span> formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= <span class="number">7</span> <span class="type">default</span> <span class="variable">Formatter</span> <span class="operator">=</span> yyyyMMdd HHmm</span><br><span class="line">Thread Name= <span class="number">7</span> formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= <span class="number">8</span> <span class="type">default</span> <span class="variable">Formatter</span> <span class="operator">=</span> yyyyMMdd HHmm</span><br><span class="line">Thread Name= <span class="number">9</span> <span class="type">default</span> <span class="variable">Formatter</span> <span class="operator">=</span> yyyyMMdd HHmm</span><br><span class="line">Thread Name= <span class="number">8</span> formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= <span class="number">9</span> formatter = yy-M-d ah:mm</span><br></pre></td></tr></table></figure>

<p>从输出中可以看出，虽然 <code>Thread-0</code> 已经改变了 <code>formatter</code> 的值，但 <code>Thread-1</code> 默认格式化值与初始化值相同，其他线程也一样。</p>
<p>上面有一段代码用到了创建 <code>ThreadLocal</code> 变量的那段代码用到了 Java8 的知识，它等于下面这段代码，如果你写了下面这段代码的话，IDEA 会提示你转换为 Java8 的格式(IDEA 真的不错！)。因为 ThreadLocal 类在 Java 8 中扩展，使用一个新的方法<code>withInitial()</code>，将 Supplier 功能接口作为参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; formatter = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;SimpleDateFormat&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> SimpleDateFormat <span class="title function_">initialValue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyyMMdd HHmm&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="ThreadLocal-原理了解吗？"><a href="#ThreadLocal-原理了解吗？" class="headerlink" title="ThreadLocal 原理了解吗？"></a>ThreadLocal 原理了解吗？</h3><p>从 <code>Thread</code>类源代码入手。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span></span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span></span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">inheritableThreadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面<code>Thread</code>类 源代码可以看出<code>Thread</code> 类中有一个 <code>threadLocals</code> 和 一个 <code>inheritableThreadLocals</code> 变量，它们都是 <code>ThreadLocalMap</code> 类型的变量,我们可以把 <code>ThreadLocalMap</code> 理解为<code>ThreadLocal</code> 类实现的定制化的 <code>HashMap</code>。默认情况下这两个变量都是 null，只有当前线程调用 <code>ThreadLocal</code> 类的 <code>set</code>或<code>get</code>方法时才创建它们，实际上调用这两个方法的时候，我们调用的是<code>ThreadLocalMap</code>类对应的 <code>get()</code>、<code>set()</code>方法。</p>
<p><code>ThreadLocal</code>类的<code>set()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面这些内容，我们足以通过猜测得出结论：<strong>最终的变量是放在了当前线程的 ThreadLocalMap 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。</strong> <code>ThrealLocal</code> 类中可以通过<code>Thread.currentThread()</code>获取到当前线程对象后，直接通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象。</p>
<p><strong>每个Thread中都具备一个ThreadLocalMap，而ThreadLocalMap可以存储以ThreadLocal为 key ，Object 对象为 value 的键值对。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如我们在同一个线程中声明了两个 <code>ThreadLocal</code> 对象的话， <code>Thread</code>内部都是使用仅有的那个<code>ThreadLocalMap</code> 存放数据的，<code>ThreadLocalMap</code>的 key 就是 <code>ThreadLocal</code>对象，value 就是 <code>ThreadLocal</code> 对象调用<code>set</code>方法设置的值。</p>
<p><code>ThreadLocal</code> 数据结构如下图所示：</p>
<p><img src="https://files.catbox.moe/om4q48.png"></p>
<p><code>ThreadLocalMap</code>是<code>ThreadLocal</code>的静态内部类。</p>
<p><img src="https://files.catbox.moe/o12iip.png"></p>
<h3 id="ThreadLocal-内存泄露问题是怎么导致的？"><a href="#ThreadLocal-内存泄露问题是怎么导致的？" class="headerlink" title="ThreadLocal 内存泄露问题是怎么导致的？"></a>ThreadLocal 内存泄露问题是怎么导致的？</h3><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</p>
<p>这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>弱引用介绍：</strong></p>
<blockquote>
<p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《深入理解 Java 虚拟机》</li>
<li>《实战 Java 高并发程序设计》</li>
<li>Guide to the Volatile Keyword in Java - Baeldung：<a href="https://www.baeldung.com/java-volatile">https://www.baeldung.com/java-volatile</a></li>
<li>理解 Java 中的 ThreadLocal - 技术小黑屋：<a href="https://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/">https://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/</a></li>
<li>ThreadLocal (Java Platform SE 8 ) - Oracle Help Center：<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ThreadLocal.html">https://docs.oracle.com/javase/8/docs/api/java/lang/ThreadLocal.html</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Java并发编程面试二</title>
    <url>/2022/08/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E4%BA%8C/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h1 id="Java-并发常见面试题总结（下）"><a href="#Java-并发常见面试题总结（下）" class="headerlink" title="Java 并发常见面试题总结（下）"></a>Java 并发常见面试题总结（下）</h1><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="为什么要用线程池？"><a href="#为什么要用线程池？" class="headerlink" title="为什么要用线程池？"></a>为什么要用线程池？</h3><blockquote>
<p><strong>池化技术想必大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</strong></p>
</blockquote>
<p><strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）的方式。 每个<strong>线程池</strong>还维护一些基本统计信息，例如已完成任务的数量。</p>
<p>这里借用《Java 并发编程的艺术》提到的来说一下<strong>使用线程池的好处</strong>：</p>
<ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h3 id="实现-Runnable-接口和-Callable-接口的区别"><a href="#实现-Runnable-接口和-Callable-接口的区别" class="headerlink" title="实现 Runnable 接口和 Callable 接口的区别"></a>实现 Runnable 接口和 Callable 接口的区别</h3><p><code>Runnable</code>自 Java 1.0 以来一直存在，但<code>Callable</code>仅在 Java 1.5 中引入,目的就是为了来处理<code>Runnable</code>不支持的用例。<strong>Runnable 接口</strong> 不会返回结果或抛出检查异常，但是 <strong>Callable 接口</strong> 可以。所以，如果任务不需要返回结果或抛出异常推荐使用 <strong>Runnable 接口</strong> ，这样代码看起来会更加简洁。</p>
<p>工具类 <code>Executors</code> 可以实现将 <code>Runnable</code> 对象转换成 <code>Callable</code> 对象。（<code>Executors.callable(Runnable task)</code> 或 <code>Executors.callable(Runnable task, Object result)</code>）。</p>
<p><code>Runnable.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 被线程执行，没有返回值也无法抛出异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Callable.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算结果，或在无法这样做时抛出异常。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算得出的结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> 如果无法计算结果，则抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="执行-execute-方法和-submit-方法的区别是什么呢？"><a href="#执行-execute-方法和-submit-方法的区别是什么呢？" class="headerlink" title="执行 execute()方法和 submit()方法的区别是什么呢？"></a>执行 execute()方法和 submit()方法的区别是什么呢？</h3><ol>
<li><strong>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></li>
<li><strong>submit()方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功</strong>，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get(long timeout，TimeUnit unit)</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li>
</ol>
<p>我们以 <strong>AbstractExecutorService 接口</strong> 中的一个 <code>submit</code> 方法为例子来看看源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="literal">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面方法调用的 <code>newTaskFor</code> 方法返回了一个 <code>FutureTask</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="title function_">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再来看看<code>execute()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h3><p>《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p>
<blockquote>
<p>Executors 返回线程池对象的弊端如下：</p>
<ul>
<li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM。</li>
<li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</li>
</ul>
</blockquote>
<p><strong>方式一：通过构造方法实现</strong></p>
<p><img src="https://files.catbox.moe/77rpsi.png"></p>
<p><strong>方式二：通过 Executor 框架的工具类 Executors 来实现</strong></p>
<p>我们可以创建三种类型的 ThreadPoolExecutor：</p>
<ul>
<li><strong>FixedThreadPool</strong> ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
<li><strong>SingleThreadExecutor：</strong> 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
<li><strong>CachedThreadPool：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li>
</ul>
<p>对应 Executors 工具类中的方法如图所示：</p>
<p><img src="https://files.catbox.moe/ge1cwg.png"></p>
<h3 id="ThreadPoolExecutor-类分析"><a href="#ThreadPoolExecutor-类分析" class="headerlink" title="ThreadPoolExecutor 类分析"></a>ThreadPoolExecutor 类分析</h3><p><code>ThreadPoolExecutor</code> 类中提供的四个构造方法。我们来看最长的那个，其余三个都是在这个构造方法的基础上产生（其他几个构造方法说白点都是给定某些默认参数的构造方法比如默认制定拒绝策略是什么），这里就不贴代码讲了，比较简单。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                      <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                      <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                      TimeUnit unit,</span></span><br><span class="line"><span class="params">                      BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                      ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                      RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>下面这些对创建 非常重要，在后面使用线程池的过程中你一定会用到！所以，务必拿着小本本记清楚。</strong></p>
<h4 id="ThreadPoolExecutor构造函数重要参数分析"><a href="#ThreadPoolExecutor构造函数重要参数分析" class="headerlink" title="ThreadPoolExecutor构造函数重要参数分析"></a><code>ThreadPoolExecutor</code>构造函数重要参数分析</h4><p><strong>ThreadPoolExecutor 3 个最重要的参数：</strong></p>
<ul>
<li><strong>corePoolSize :</strong> 核心线程数定义了最小可以同时运行的线程数量。</li>
<li><strong>maximumPoolSize :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li><strong>workQueue:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
</ul>
<p><code>ThreadPoolExecutor</code>其他常见参数:</p>
<ol>
<li><strong>keepAliveTime</strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li>
<li><strong>unit</strong> : <code>keepAliveTime</code> 参数的时间单位。</li>
<li><strong>threadFactory</strong> :executor 创建新线程的时候会用到。</li>
<li><strong>handler</strong> :饱和策略。关于饱和策略下面单独介绍一下。</li>
</ol>
<h4 id="ThreadPoolExecutor-饱和策略"><a href="#ThreadPoolExecutor-饱和策略" class="headerlink" title="ThreadPoolExecutor 饱和策略"></a><code>ThreadPoolExecutor</code> 饱和策略</h4><p><strong>ThreadPoolExecutor 饱和策略定义:</strong></p>
<p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p>
<ul>
<li><strong>ThreadPoolExecutor.AbortPolicy：</strong> 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>
<li><strong>ThreadPoolExecutor.CallerRunsPolicy：</strong> 调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li>
<li><strong>ThreadPoolExecutor.DiscardPolicy：</strong> 不处理新任务，直接丢弃掉。</li>
<li><strong>ThreadPoolExecutor.DiscardOldestPolicy：</strong> 此策略将丢弃最早的未处理的任务请求。</li>
</ul>
<p>举个例子： Spring 通过 <code>ThreadPoolTaskExecutor</code> 或者我们直接通过 <code>ThreadPoolExecutor</code> 的构造函数创建线程池的时候，当我们不指定 <code>RejectedExecutionHandler</code> 饱和策略的话来配置线程池的时候默认使用的是 <code>ThreadPoolExecutor.AbortPolicy</code>。在默认情况下，<code>ThreadPoolExecutor</code> 将抛出 <code>RejectedExecutionException</code> 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。 对于可伸缩的应用程序，建议使用 <code>ThreadPoolExecutor.CallerRunsPolicy</code>。当最大池被填满时，此策略为我们提供可伸缩队列。（这个直接查看 <code>ThreadPoolExecutor</code> 的构造函数源码就可以看出，比较简单的原因，这里就不贴代码了）</p>
<h3 id="一个简单的线程池-Demo"><a href="#一个简单的线程池-Demo" class="headerlink" title="一个简单的线程池 Demo"></a>一个简单的线程池 Demo</h3><p>为了让大家更清楚上面的面试题中的一些概念，我写了一个简单的线程池 Demo。</p>
<p>首先创建一个 <code>Runnable</code> 接口的实现类（当然也可以是 <code>Callable</code> 接口，我们上面也说了两者的区别。）</p>
<p><code>MyRunnable.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String command;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyRunnable</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Start. Time = &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        processCommand();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; End. Time = &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processCommand</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.command;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试程序，我们这里以阿里巴巴推荐的使用 <code>ThreadPoolExecutor</code> 构造函数自定义参数的方式来创建线程池。</p>
<p><code>ThreadPoolExecutorDemo.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CORE_POOL_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_POOL_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">QUEUE_CAPACITY</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">KEEP_ALIVE_TIME</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">        <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//创建 MyRunnable 对象（MyRunnable 类实现了Runnable 接口）</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">            <span class="comment">//执行Runnable</span></span><br><span class="line">            executor.execute(worker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终止线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Finished all threads&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到我们上面的代码指定了：</p>
<ol>
<li><code>corePoolSize</code>: 核心线程数为 5。</li>
<li><code>maximumPoolSize</code> ：最大线程数 10</li>
<li><code>keepAliveTime</code> : 等待时间为 1L。</li>
<li><code>unit</code>: 等待时间的单位为 TimeUnit.SECONDS。</li>
<li><code>workQueue</code>：任务队列为 <code>ArrayBlockingQueue</code>，并且容量为 100;</li>
<li><code>handler</code>:饱和策略为 <code>CallerRunsPolicy</code>。</li>
</ol>
<p><strong>Output：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">37</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">37</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">37</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">37</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">37</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">47</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">47</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">47</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">47</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">47</span> CST <span class="number">2020</span></span><br></pre></td></tr></table></figure>

<h3 id="线程池原理分析"><a href="#线程池原理分析" class="headerlink" title="线程池原理分析"></a>线程池原理分析</h3><p>承接 4.6 节，我们通过代码输出结果可以看出：<strong>线程池首先会先执行 5 个任务，然后这些任务有任务被执行完的话，就会去拿新的任务执行。</strong> 大家可以先通过上面讲解的内容，分析一下到底是咋回事？（自己独立思考一会）</p>
<p>现在，我们就分析上面的输出内容来简单分析一下线程池原理。</p>
<p><strong>为了搞懂线程池的原理，我们需要首先分析一下 execute方法。</strong> 在 4.6 节中的 Demo 中我们使用 <code>executor.execute(worker)</code>来提交一个任务到线程池中去，这个方法非常重要，下面我们来看看它的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c &amp; CAPACITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果任务为null，则抛出异常。</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// ctl 中保存的线程池当前的一些状态信息</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  下面会涉及到 3 步 操作</span></span><br><span class="line">    <span class="comment">// 1.首先判断当前线程池中执行的任务数量是否小于 corePoolSize</span></span><br><span class="line">    <span class="comment">// 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.如果当前执行的任务数量大于等于 corePoolSize 的时候就会走到这里</span></span><br><span class="line">    <span class="comment">// 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态并且队列可以加入任务，该任务才会被加入进去</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</span></span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">            <span class="comment">// 如果当前线程池为空就新创建一个线程并执行。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">    <span class="comment">//如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>通过下图可以更好的对上面这 3 步做一个展示，下图是我为了省事直接从网上找到，原地址不明。</p>
<p><img src="https://files.catbox.moe/x6radf.png"></p>
<p>现在，让我们在回到 4.6 节我们写的 Demo， 现在是不是很容易就可以搞懂它的原理了呢？</p>
<p>没搞懂的话，也没关系，可以看看我的分析：</p>
<blockquote>
<p>我们在代码中模拟了 10 个任务，我们配置的核心线程数为 5 、等待队列容量为 100 ，所以每次只可能存在 5 个任务同时执行，剩下的 5 个任务会被放到等待队列中去。当前的5个任务中如果有任务被执行完了，线程池就会去拿新的任务执行。</p>
</blockquote>
<h2 id="Atomic-原子类"><a href="#Atomic-原子类" class="headerlink" title="Atomic 原子类"></a>Atomic 原子类</h2><h3 id="介绍一下-Atomic-原子类"><a href="#介绍一下-Atomic-原子类" class="headerlink" title="介绍一下 Atomic 原子类"></a>介绍一下 Atomic 原子类</h3><p><code>Atomic</code> 翻译成中文是原子的意思。在化学上，我们知道原子是构成一般物质的最小单位，在化学反应中是不可分割的。在我们这里 Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。</p>
<p>所以，所谓原子类说简单点就是具有原子&#x2F;原子操作特征的类。</p>
<p>并发包 <code>java.util.concurrent</code> 的原子类都存放在<code>java.util.concurrent.atomic</code>下,如下图所示。</p>
<p><img src="https://files.catbox.moe/q439ar.png"></p>
<h3 id="JUC-包中的原子类是哪-4-类"><a href="#JUC-包中的原子类是哪-4-类" class="headerlink" title="JUC 包中的原子类是哪 4 类?"></a>JUC 包中的原子类是哪 4 类?</h3><p><strong>基本类型</strong></p>
<p>使用原子的方式更新基本类型</p>
<ul>
<li><code>AtomicInteger</code>：整型原子类</li>
<li><code>AtomicLong</code>：长整型原子类</li>
<li><code>AtomicBoolean</code>：布尔型原子类</li>
</ul>
<p><strong>数组类型</strong></p>
<p>使用原子的方式更新数组里的某个元素</p>
<ul>
<li><code>AtomicIntegerArray</code>：整型数组原子类</li>
<li><code>AtomicLongArray</code>：长整型数组原子类</li>
<li><code>AtomicReferenceArray</code>：引用类型数组原子类</li>
</ul>
<p><strong>引用类型</strong></p>
<ul>
<li><code>AtomicReference</code>：引用类型原子类</li>
<li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li>
<li><code>AtomicMarkableReference</code> ：原子更新带有标记位的引用类型</li>
</ul>
<p><strong>对象的属性修改类型</strong></p>
<ul>
<li><code>AtomicIntegerFieldUpdater</code>：原子更新整型字段的更新器</li>
<li><code>AtomicLongFieldUpdater</code>：原子更新长整型字段的更新器</li>
<li><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型字段的更新器</li>
</ul>
<h3 id="讲讲-AtomicInteger-的使用"><a href="#讲讲-AtomicInteger-的使用" class="headerlink" title="讲讲 AtomicInteger 的使用"></a>讲讲 AtomicInteger 的使用</h3><p><strong>AtomicInteger 类常用方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lazySet</span><span class="params">(<span class="type">int</span> newValue)</span><span class="comment">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span><br></pre></td></tr></table></figure>

<p><strong>AtomicInteger 类的使用示例</strong></p>
<p>使用 <code>AtomicInteger</code> 之后，不用对 <code>increment()</code> 方法加锁也可以保证线程安全。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicIntegerTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="comment">//使用AtomicInteger之后，不需要对该方法加锁，也可以实现线程安全。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="能不能给我简单介绍一下-AtomicInteger-类的原理"><a href="#能不能给我简单介绍一下-AtomicInteger-类的原理" class="headerlink" title="能不能给我简单介绍一下 AtomicInteger 类的原理"></a>能不能给我简单介绍一下 AtomicInteger 类的原理</h3><ul>
<li><a href="https://github.com/summerHearts/JavaArchitecture/blob/master/Concurrent/%E6%B5%85%E8%B0%88AtomicInteger%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.md">浅谈AtomicInteger实现原理open in new window</a></li>
<li><a href="https://tobebetterjavaer.com/thread/cas.html">Java实现CAS的原理open in new window</a></li>
</ul>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h3 id="AQS-介绍"><a href="#AQS-介绍" class="headerlink" title="AQS 介绍"></a>AQS 介绍</h3><p>AQS 的全称为（<code>AbstractQueuedSynchronizer</code>），这个类在<code>java.util.concurrent.locks</code>包下面。</p>
<p><img src="https://files.catbox.moe/poj3s0.png"></p>
<p>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出大量应用广泛的同步器，比如我们提到的 <code>ReentrantLock</code>，<code>Semaphore</code>，其他的诸如 <code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>，<code>FutureTask</code> 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。</p>
<h3 id="AQS-原理分析"><a href="#AQS-原理分析" class="headerlink" title="AQS 原理分析"></a>AQS 原理分析</h3><p>AQS 原理这部分参考了部分博客，在 6.2 节末尾放了链接。</p>
<blockquote>
<p>在面试中被问到并发知识的时候，大多都会被问到“请你说一下自己对于 AQS 原理的理解”。下面给大家一个示例供大家参加，面试不是背题，大家一定要加入自己的思想，即使加入不了自己的思想也要保证自己能够通俗的讲出来而不是背出来。</p>
</blockquote>
<p>下面大部分内容其实在 AQS 类注释上已经给出了，不过是英语看着比较吃力一点，感兴趣的话可以看看源码。</p>
<h4 id="AQS-原理概览"><a href="#AQS-原理概览" class="headerlink" title="AQS 原理概览"></a>AQS 原理概览</h4><p><strong>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p>
<blockquote>
<p>CLH(Craig,Landin and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p>
</blockquote>
<p>看个 AQS(AbstractQueuedSynchronizer)原理图：</p>
<p><img src="https://files.catbox.moe/udywse.png"></p>
<p>AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;<span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure>

<p>状态信息通过 protected 类型的 getState，setState，compareAndSetState 进行操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置同步状态的值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AQS-对资源的共享方式"><a href="#AQS-对资源的共享方式" class="headerlink" title="AQS 对资源的共享方式"></a>AQS 对资源的共享方式</h4><p><strong>AQS 定义两种资源共享方式</strong></p>
<ul>
<li><p>Exclusive</p>
<p>（独占）：只有一个线程能执行，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantLock</span><br></pre></td></tr></table></figure>

<p>。又可分为公平锁和非公平锁：</p>
<ul>
<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li>
<li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li>
</ul>
</li>
<li><p><strong>Share</strong>（共享）：多个线程可同时执行，如<code> CountDownLatch</code>、<code>Semaphore</code>、 <code>CyclicBarrier</code>、<code>ReadWriteLock</code> 我们都会在后面讲到。</p>
</li>
</ul>
<p><code>ReentrantReadWriteLock</code> 可以看成是组合式，因为 <code>ReentrantReadWriteLock</code> 也就是读写锁允许多个线程同时对某一资源进行读。</p>
<p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS 已经在顶层实现好了。</p>
<h4 id="AQS-底层使用了模板方法模式"><a href="#AQS-底层使用了模板方法模式" class="headerlink" title="AQS 底层使用了模板方法模式"></a>AQS 底层使用了模板方法模式</h4><p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p>
<ol>
<li>使用者继承 <code>AbstractQueuedSynchronizer</code> 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）</li>
<li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li>
</ol>
<p>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。</p>
<p><strong>AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的钩子方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span>)</span><span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span>)</span><span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span>)</span><span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span>)</span><span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span><span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br></pre></td></tr></table></figure>

<p><strong>什么是钩子方法呢？</strong> 钩子方法是一种被声明在抽象类中的方法，它可以是空方法（由子类实现），也可以是默认实现的方法。模板设计模式通过钩子方法控制固定步骤的实现。</p>
<p>除了上面提到的钩子方法之外，AQS 类中的其他方法都是 <code>final</code> ，所以无法被其他类重写。</p>
<p>以 <code>ReentrantLock</code> 为例，state 初始化为 0，表示未锁定状态。A 线程 <code>lock()</code> 时，会调用 <code>tryAcquire()</code> 独占该锁并将 <code>state+1</code> 。此后，其他线程再 <code>tryAcquire()</code> 时就会失败，直到 A 线程 <code>unlock()</code> 到 <code>state=</code>0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多少次，这样才能保证 state 是能回到零态的。</p>
<p>再以 <code>CountDownLatch</code> 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后<code> countDown()</code> 一次，state 会 CAS(Compare and Swap) 减 1。等到所有子线程都执行完后(即 <code>state=0</code> )，会 <code>unpark()</code> 主调用线程，然后主调用线程就会从 <code>await()</code> 函数返回，继续后余动作。</p>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p>
<p>推荐两篇 AQS 原理和相关源码分析的文章：</p>
<ul>
<li><a href="https://www.cnblogs.com/waterystone/p/4920797.html">https://www.cnblogs.com/waterystone/p/4920797.html</a></li>
<li><a href="https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html">https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html</a></li>
</ul>
<h3 id="AQS-组件总结"><a href="#AQS-组件总结" class="headerlink" title="AQS 组件总结"></a>AQS 组件总结</h3><ul>
<li><strong>Semaphore(信号量)-允许多个线程同时访问：</strong> <code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，<code>Semaphore</code>(信号量)可以指定多个线程同时访问某个资源。</li>
<li><strong>CountDownLatch （倒计时器）：</strong> <code>CountDownLatch</code> 是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li>
<li><strong>CyclicBarrier(循环栅栏)：</strong> <code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 非常类似，它也可以实现线程间的技术等待，但是它的功能比 <code>CountDownLatch</code> 更加复杂和强大。主要应用场景和 <code>CountDownLatch</code> 类似。<code>CyclicBarrier</code> 的字面意思是可循环使用（<code>Cyclic</code>）的屏障（<code>Barrier</code>）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。<code>CyclicBarrier</code> 默认的构造方法是 <code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用 <code>await()</code> 方法告诉 <code>CyclicBarrier</code> 我已经到达了屏障，然后当前线程被阻塞。</li>
</ul>
<h3 id="用过-CountDownLatch-么？什么场景下用的？"><a href="#用过-CountDownLatch-么？什么场景下用的？" class="headerlink" title="用过 CountDownLatch 么？什么场景下用的？"></a>用过 CountDownLatch 么？什么场景下用的？</h3><p><code>CountDownLatch</code> 的作用就是 允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。之前在项目中，有一个使用多线程读取多个文件处理的场景，我用到了 <code>CountDownLatch</code> 。具体场景是下面这样的：</p>
<p>我们要读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。</p>
<p>为此我们定义了一个线程池和 count 为 6 的<code>CountDownLatch</code>对象 。使用线程池处理读取任务，每一个线程处理完之后就将 count-1，调用<code>CountDownLatch</code>对象的 <code>await()</code>方法，直到所有文件读取完之后，才会接着执行后面的逻辑。</p>
<p>伪代码是下面这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchExample1</span> &#123;</span><br><span class="line">    <span class="comment">// 处理文件的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建一个具有固定线程数量的线程池对象（推荐使用构造方法创建）</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadnum</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//处理文件的业务操作</span></span><br><span class="line">                    <span class="comment">//......</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//表示一个文件已经被完成</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>有没有可以改进的地方呢？</strong></p>
<p>可以使用 <code>CompletableFuture</code> 类来改进！Java8 的 <code>CompletableFuture</code> 提供了很多对多线程友好的方法，使用它可以很方便地为我们编写多线程程序，什么异步、串行、并行或者等待所有线程执行完任务什么的都非常方便。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; task1 =</span><br><span class="line">    CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">        <span class="comment">//自定义业务操作</span></span><br><span class="line">    &#125;);</span><br><span class="line">......</span><br><span class="line">CompletableFuture&lt;Void&gt; task6 =</span><br><span class="line">    CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">    <span class="comment">//自定义业务操作</span></span><br><span class="line">    &#125;);</span><br><span class="line">......</span><br><span class="line">CompletableFuture&lt;Void&gt; headerFuture=CompletableFuture.allOf(task1,.....,task6);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    headerFuture.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;all done. &quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面的代码还可以继续优化，当任务过多的时候，把每一个 task 都列出来不太现实，可以考虑通过循环来添加任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//文件夹位置</span></span><br><span class="line">List&lt;String&gt; filePaths = Arrays.asList(...)</span><br><span class="line"><span class="comment">// 异步处理所有文件</span></span><br><span class="line">List&lt;CompletableFuture&lt;String&gt;&gt; fileFutures = filePaths.stream()</span><br><span class="line">    .map(filePath -&gt; doSomeThing(filePath))</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line"><span class="comment">// 将他们合并起来</span></span><br><span class="line">CompletableFuture&lt;Void&gt; allFutures = CompletableFuture.allOf(</span><br><span class="line">    fileFutures.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[fileFutures.size()])</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《深入理解 Java 虚拟机》</li>
<li>《实战 Java 高并发程序设计》</li>
<li>Java并发之AQS详解：<a href="https://www.cnblogs.com/waterystone/p/4920797.html">https://www.cnblogs.com/waterystone/p/4920797.html</a></li>
<li>Java并发包基石-AQS详解：<a href="https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html">https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html</a></li>
</ul>
<h1 id="JMM（Java-内存模型）详解"><a href="#JMM（Java-内存模型）详解" class="headerlink" title="JMM（Java 内存模型）详解"></a>JMM（Java 内存模型）详解</h1><h2 id="从-CPU-缓存模型说起"><a href="#从-CPU-缓存模型说起" class="headerlink" title="从 CPU 缓存模型说起"></a>从 CPU 缓存模型说起</h2><p><strong>为什么要弄一个 CPU 高速缓存呢？</strong> 类比我们开发网站后台系统使用的缓存（比如 Redis）是为了解决程序处理速度和访问常规关系型数据库速度不对等的问题。 <strong>CPU 缓存则是为了解决 CPU 处理速度和内存处理速度不对等的问题。</strong></p>
<p>我们甚至可以把 <strong>内存可以看作外存的高速缓存</strong>，程序运行的时候我们把外存的数据复制到内存，由于内存的处理速度远远高于外存，这样提高了处理速度。</p>
<p>总结：<strong>CPU Cache 缓存的是内存数据用于解决 CPU 处理速度和内存不匹配的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题。</strong></p>
<p>为了更好地理解，我画了一个简单的 CPU Cache 示意图如下（实际上，现代的 CPU Cache 通常分为三层，分别叫 L1,L2,L3 Cache）:</p>
<p><img src="https://files.catbox.moe/lbfkqf.png"></p>
<p><strong>CPU Cache 的工作方式：</strong> 先复制一份数据到 CPU Cache 中，当 CPU 需要用到的时候就可以直接从 CPU Cache 中读取数据，当运算完成后，再将运算得到的数据写回 Main Memory 中。但是，这样存在 <strong>内存缓存不一致性的问题</strong> ！比如我执行一个 i++ 操作的话，如果两个线程同时执行的话，假设两个线程从 CPU Cache 中读取的 i&#x3D;1，两个线程做了 1++ 运算完之后再写回 Main Memory 之后 i&#x3D;2，而正确结果应该是 i&#x3D;3。</p>
<p><strong>CPU 为了解决内存缓存不一致性问题可以通过制定缓存一致协议（比如 MESI 协议open in new window）或者其他手段来解决。</strong> 这个缓存缓存一致性协议指的是在 CPU 高速缓存与主内存交互的时候需要准守的原则和规范。不同的 CPU 中，使用的缓存一致性协议通常也会有所不同。</p>
<p><img src="https://files.catbox.moe/yu0yx8.png"></p>
<p>我们的程序运行在操作系统之上，操作系统屏蔽了底层硬件的操作细节，将各种硬件资源虚拟化。于是，操作系统也就同样需要解决内存缓存不一致性问题。</p>
<p>操作系统通过 <strong>内存模型（Memory Model）</strong> 定义一系列规范来解决这个问题。无论是 Windows 系统，还是 Linux 系统，它们都有特定的内存模型。</p>
<h2 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h2><p>说完了 CPU 缓存模型，我们再来看看另外一个比较重要的概念 <strong>指令重排序</strong> 。</p>
<p>为了提升执行速度&#x2F;性能，计算机在执行程序代码的时候，会对指令进行重排序。</p>
<p><strong>什么是指令重排序？</strong> 简单来说就是系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行。</p>
<p>常见的指令重排序有下面 2 种情况：</p>
<ul>
<li><strong>编译器优化重排</strong> ：编译器（包括 JVM、JIT 编译器等）在不改变单线程程序语义的前提下，重新安排语句的执行顺序。</li>
<li><strong>指令并行重排</strong> ：现代处理器采用了指令级并行技术(Instruction-Level Parallelism，ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
</ul>
<p>另外，内存系统也会有“重排序”，但有不是真正意义上的重排序。在 JMM 里表现为主存和本地内存的内容可能不一致，进而导致程序在多线程下执行可能出现问题。</p>
<p>Java 源代码会经历 <strong>编译器优化重排 —&gt; 指令并行重排 —&gt; 内存系统重排</strong> 的过程，最终才变成操作系统可执行的指令序列。</p>
<p><strong>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong> ，所以在多线程下，指令重排序可能会导致一些问题。</p>
<p>编译器和处理器的指令重排序的处理方式不一样。对于编译器，通过禁止特定类型的编译器的当时来禁止重排序。对于处理器，通过插入内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）的方式来禁止特定类型的处理器重排序。指令并行重排和内存系统重排都属于是处理器级别的指令重排序。</p>
<blockquote>
<p>内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种 CPU 指令，用来禁止处理器指令发生重排序（像屏障一样），从而保障指令执行的有序性。另外，为了达到屏障的效果，它也会使处理器写入、读取值之前，将主内存的值写入高速缓存，清空无效队列，从而保障变量的可见性。</p>
</blockquote>
<h2 id="JMM-Java-Memory-Model"><a href="#JMM-Java-Memory-Model" class="headerlink" title="JMM(Java Memory Model)"></a>JMM(Java Memory Model)</h2><h3 id="什么是-JMM？为什么需要-JMM？"><a href="#什么是-JMM？为什么需要-JMM？" class="headerlink" title="什么是 JMM？为什么需要 JMM？"></a>什么是 JMM？为什么需要 JMM？</h3><p>Java 是最早尝试提供内存模型的编程语言。由于早期内存模型存在一些缺陷（比如非常容易削弱编译器的优化能力），从 Java5 开始，Java 开始使用新的内存模型 <a href="http://www.cs.umd.edu/~pugh/java/memoryModel/CommunityReview.pdf">《JSR-133：Java Memory Model and Thread Specification》open in new window</a> 。</p>
<p>一般来说，编程语言也可以直接复用操作系统层面的内存模型。不过，不同的操作系统内存模型不同。如果直接复用操作系统层面的内存模型，就可能会导致同样一套代码换了一个操作系统就无法执行了。Java 语言是跨平台的，它需要自己提供一套内存模型以屏蔽系统差异。</p>
<p>这只是 JMM 存在的其中一个原因。实际上，对于 Java 来说，你可以把 JMM 看作是 Java 定义的并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。</p>
<p><strong>为什么要遵守这些并发相关的原则和规范呢？</strong> 这是因为并发编程下，像 CPU 多级缓存和指令重排这类设计可能会导致程序运行出现一些问题。就比如说我们上面提到的指令重排序就可能会让多线程程序的执行出现问题，为此，JMM 抽象了 happens-before 原则（后文会详细介绍到）来解决这个指令重排序问题。</p>
<p>JMM 说白了就是定义了一些规范来解决这些问题，开发发者可以利用这些规范更方便地开发多线程程序。对于 Java 开发者说，你不需要了解底层原理，直接使用并发相关的一些关键字和类（比如 <code>volatile</code>、<code>synchronized</code>、各种 <code>Lock</code>）即可开发出并发安全的程序。</p>
<h3 id="JMM-是如何抽象线程和主内存之间的关系？"><a href="#JMM-是如何抽象线程和主内存之间的关系？" class="headerlink" title="JMM 是如何抽象线程和主内存之间的关系？"></a>JMM 是如何抽象线程和主内存之间的关系？</h3><p><strong>Java 内存模型（JMM）</strong> 抽象了线程和主内存之间的关系，就比如说线程之间的共享变量必须存储在主内存中。</p>
<p>在 JDK1.2 之前，Java 的内存模型实现总是从 <strong>主存</strong> （即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存 <strong>本地内存</strong> （比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。</p>
<p>这和我们上面讲到的 CPU 缓存模型非常相似。</p>
<p><strong>什么是主内存？什么是本地内存？</strong></p>
<ul>
<li><strong>主内存</strong> ：所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)</li>
<li><strong>本地内存</strong> ：每个线程都有一个私有的本地内存来存储共享变量的副本，并且，每个线程只能访问自己的本地内存，无法访问其他线程的本地内存。本地内存是 JMM 抽象出来的一个概念，存储了主内存中的共享变量副本。</li>
</ul>
<p>Java 内存模型的抽象示意图如下：</p>
<p> <img src="https://files.catbox.moe/0csepd.png"></p>
<p>从上图来看，线程 1 与线程 2 之间如果要进行通信的话，必须要经历下面 2 个步骤：</p>
<ol>
<li>线程 1 把本地内存中修改过的共享变量副本的值同步到主内存中去。</li>
<li>线程 2 到主存中读取对应的共享变量的值。</li>
</ol>
<p>也就是说，JMM 为共享变量提供了可见性的保障。</p>
<p>不过，多线程下，对主内存中的一个共享变量进行操作有可能诱发线程安全问题。举个例子：</p>
<ol>
<li>线程 1 和线程 2 分别对同一个共享变量进行操作，一个执行修改，一个执行读取。</li>
<li>线程 2 读取到的是线程 1 修改之前的值还是修改后的值并不确定，都有可能，因为线程 1 和线程 2 都是先将共享变量从主内存拷贝到对应线程的工作内存中。</li>
</ol>
<p>关于主内存与工作内存直接的具体交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步到主内存之间的实现细节，Java 内存模型定义来以下八种同步操作（了解即可，无需死记硬背）：</p>
<ul>
<li><strong>锁定（lock）</strong>: 作用于主内存中的变量，将他标记为一个线程独享变量。</li>
<li><strong>解锁（unlock）</strong>: 作用于主内存中的变量，解除变量的锁定状态，被解除锁定状态的变量才能被其他线程锁定。</li>
<li><strong>read（读取）</strong>：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用。</li>
<li>**load(载入)**：把 read 操作从主内存中得到的变量值放入工作内存的变量的副本中。</li>
<li>**use(使用)**：把工作内存中的一个变量的值传给执行引擎，每当虚拟机遇到一个使用到变量的指令时都会使用该指令。</li>
<li><strong>assign（赋值）</strong>：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li><strong>store（存储）</strong>：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的 write 操作使用。</li>
<li><strong>write（写入）</strong>：作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中。</li>
</ul>
<p>除了这 8 种同步操作之外，还规定了下面这些同步规则来保证这些同步操作的正确执行（了解即可，无需死记硬背）：</p>
<ul>
<li>不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从线程的工作内存同步回主内存中。</li>
<li>一个新的变量只能在主内存中 “诞生”，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量，换句话说就是对一个变量实施 use 和 store 操作之前，必须先执行过了 assign 和 load 操作。</li>
<li>一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。</li>
<li>如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。</li>
<li>如果一个变量事先没有被 lock 操作锁定，则不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定住的变量。</li>
<li>……</li>
</ul>
<h3 id="Java-内存区域和-JMM-有何区别？"><a href="#Java-内存区域和-JMM-有何区别？" class="headerlink" title="Java 内存区域和 JMM 有何区别？"></a>Java 内存区域和 JMM 有何区别？</h3><p>这是一个比较常见的问题，很多初学者非常容易搞混。 <strong>Java 内存区域和内存模型是完全不一样的两个东西</strong> ：</p>
<ul>
<li>JVM 内存结构和 Java 虚拟机的运行时区域相关，定义了 JVM 在运行时如何分区存储程序数据，就比如说堆主要用于存放对象实例。</li>
<li>Java 内存模型和 Java 的并发编程相关，抽象了线程和主内存之间的关系就比如说线程之间的共享变量必须存储在主内存中，规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。</li>
</ul>
<h3 id="happens-before-原则是什么？"><a href="#happens-before-原则是什么？" class="headerlink" title="happens-before 原则是什么？"></a>happens-before 原则是什么？</h3><p>happens-before 这个概念最早诞生于 Leslie Lamport 于 1978 年发表的论文<a href="https://lamport.azurewebsites.net/pubs/time-clocks.pdf">《Time，Clocks and the Ordering of Events in a Distributed System》open in new window</a>。在这篇论文中，Leslie Lamport 提出了<a href="https://writings.sh/post/logical-clocks">逻辑时钟open in new window</a>的概念，这也成了第一个逻辑时钟算法 。在分布式环境中，通过一系列规则来定义逻辑时钟的变化，从而能通过逻辑时钟来对分布式系统中的事件的先后顺序进行判断。<strong>逻辑时钟并不度量时间本身，仅区分事件发生的前后顺序，其本质就是定义了一种 happens-before 关系。</strong></p>
<p>上面提到的 happens-before 这个概念诞生的背景并不是重点，简单了解即可。</p>
<p>JSR 133 引入了 happens-before 这个概念来描述两个操作之间的内存可见性。</p>
<p><strong>为什么需要 happens-before 原则？</strong> happens-before 原则的诞生是为了程序员和编译器、处理器之间的平衡。程序员追求的是易于理解和编程的强内存模型，遵守既定规则编码即可。编译器和处理器追求的是较少约束的弱内存模型，让它们尽己所能地去优化性能，让性能最大化。happens-before 原则的设计思想其实非常简单：</p>
<ul>
<li>为了对编译器和处理器的约束尽可能少，只要不改变程序的执行结果（单线程程序和正确执行的多线程程序），编译器和处理器怎么进行重排序优化都行。</li>
<li>对于会改变程序执行结果的重排序，JMM 要求编译器和处理器必须禁止这种重排序。</li>
</ul>
<p>下面这张是 《Java 并发编程的艺术》这本书中的一张 JMM 设计思想的示意图，非常清晰。</p>
<p><img src="https://files.catbox.moe/ve9b5e.png"></p>
<p>了解了 happens-before 原则的设计思想，我们再来看看 JSR-133 对 happens-before 原则的定义：</p>
<ul>
<li>如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，并且第一个操作的执行顺序排在第二个操作之前。</li>
<li>两个操作之间存在 happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 happens-before 关系指定的顺序来执行。如果重排序之后的执行结果，与按 happens-before 关系来执行的结果一致，那么 JMM 也允许这样的重排序。</li>
</ul>
<p>我们看下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">userNum</span> <span class="operator">=</span> getUserNum(); 	<span class="comment">// 1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">teacherNum</span> <span class="operator">=</span> getTeacherNum();	 <span class="comment">// 2</span></span><br><span class="line"><span class="type">int</span> <span class="variable">totalNum</span> <span class="operator">=</span> userNum + teacherNum;	<span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>1 happens-before 2</li>
<li>2 happens-before 3</li>
<li>1 happens-before 3</li>
</ul>
<p>虽然 1 happens-before 2，但对 1 和 2 进行重排序不会影响代码的执行结果，所以 JMM 是允许编译器和处理器执行这种重排序的。但 1 和 2 必须是在 3 执行之前，也就是说 1,2 happens-before 3 。</p>
<p><strong>happens-before 原则表达的意义其实并不是一个操作发生在另外一个操作的前面，虽然这从程序员的角度上来说也并无大碍。更准确地来说，它更想表达的意义是前一个操作的结果对于后一个操作是可见的，无论这两个操作是否在同一个线程里。</strong></p>
<p>举个例子：操作 1 happens-before 操作 2，即使操作 1 和操作 2 不在同一个线程内，JMM 也会保证操作 1 的结果对操作 2 是可见的。</p>
<h3 id="happens-before-常见规则有哪些？谈谈你的理解？"><a href="#happens-before-常见规则有哪些？谈谈你的理解？" class="headerlink" title="happens-before 常见规则有哪些？谈谈你的理解？"></a>happens-before 常见规则有哪些？谈谈你的理解？</h3><p>happens-before 的规则就 8 条，说多不多，重点了解下面列举的 5 条即可。全记是不可能的，很快就忘记了，意义不大，随时查阅即可。</p>
<ol>
<li><strong>程序顺序规则</strong> ：一个线程内，按照代码顺序，书写在前面的操作 happens-before 于书写在后面的操作；</li>
<li><strong>解锁规则</strong> ：解锁 happens-before 于加锁；</li>
<li><strong>volatile 变量规则</strong> ：对一个 volatile 变量的写操作 happens-before 于后面对这个 volatile 变量的读操作。说白了就是对 volatile 变量的写操作的结果对于发生于其后的任何操作都是可见的。</li>
<li><strong>传递规则</strong> ：如果 A happens-before B，且 B happens-before C，那么 A happens-before C；</li>
<li><strong>线程启动规则</strong> ：Thread 对象的 <code>start（）</code>方法 happens-before 于此线程的每一个动作。</li>
</ol>
<p>如果两个操作不满足上述任意一个 happens-before 规则，那么这两个操作就没有顺序的保障，JVM 可以对这两个操作进行重排序。</p>
<h3 id="happens-before-和-JMM-什么关系？"><a href="#happens-before-和-JMM-什么关系？" class="headerlink" title="happens-before 和 JMM 什么关系？"></a>happens-before 和 JMM 什么关系？</h3><p>happens-before 与 JMM 的关系用《Java 并发编程的艺术》这本书中的一张图就可以非常好的解释清楚。</p>
<p><img src="https://files.catbox.moe/a2jru7.png"></p>
<h2 id="再看并发编程三个重要特性"><a href="#再看并发编程三个重要特性" class="headerlink" title="再看并发编程三个重要特性"></a>再看并发编程三个重要特性</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。</p>
<p>在 Java 中，可以借助<code>synchronized</code> 、各种 <code>Lock</code> 以及各种原子类实现原子性。</p>
<p><code>synchronized</code> 和各种 <code>Lock</code> 可以保证任一时刻只有一个线程访问该代码块，因此可以保障原子性。各种原子类是利用 CAS (compare and swap) 操作（可能也会用到 <code>volatile</code>或者<code>final</code>关键字）来保证原子操作。</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。</p>
<p>在 Java 中，可以借助<code>synchronized</code> 、<code>volatile</code> 以及各种 <code>Lock</code> 实现可见性。</p>
<p>如果我们将变量声明为 <code>volatile</code> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>由于指令重排序问题，代码的执行顺序未必就是编写代码时候的顺序。</p>
<p>我们上面讲重排序的时候也提到过：</p>
<blockquote>
<p><strong>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong> ，所以在多线程下，指令重排序可能会导致一些问题。</p>
</blockquote>
<p>在 Java 中，<code>volatile</code> 关键字可以禁止指令进行重排序优化。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Java 是最早尝试提供内存模型的语言，其主要目的是为了简化多线程编程，增强程序可移植性的。</li>
<li>CPU 可以通过制定缓存一致协议（比如 <a href="https://zh.wikipedia.org/wiki/MESI%E5%8D%8F%E8%AE%AE">MESI 协议open in new window</a>）来解决内存缓存不一致性问题。</li>
<li>为了提升执行速度&#x2F;性能，计算机在执行程序代码的时候，会对指令进行重排序。 简单来说就是系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行。<strong>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong> ，所以在多线程下，指令重排序可能会导致一些问题。</li>
<li>你可以把 JMM 看作是 Java 定义的并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。</li>
<li>JSR 133 引入了 happens-before 这个概念来描述两个操作之间的内存可见性。</li>
</ul>
<h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《Java 并发编程的艺术》第三章 Java 内存模型</li>
<li>《深入浅出 Java 多线程》：<a href="http://concurrent.redspider.group/RedSpider.html">http://concurrent.redspider.group/RedSpider.html</a></li>
<li>Java 内存访问重排序的研究：<a href="https://tech.meituan.com/2014/09/23/java-memory-reordering.html">https://tech.meituan.com/2014/09/23/java-memory-reordering.html</a></li>
<li>嘿，同学，你要的 Java 内存模型 (JMM) 来了：<a href="https://xie.infoq.cn/article/739920a92d0d27e2053174ef2">https://xie.infoq.cn/article/739920a92d0d27e2053174ef2</a></li>
<li>JSR 133 (Java Memory Model) FAQ：<a href="https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html">https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Java并发编程面试三</title>
    <url>/2022/08/24/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E4%B8%89/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h1 id="Java-线程池详解"><a href="#Java-线程池详解" class="headerlink" title="Java 线程池详解"></a>Java 线程池详解</h1><h2 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h2><blockquote>
<p><strong>池化技术想必大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</strong></p>
</blockquote>
<p><strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）的方式。 每个<strong>线程池</strong>还维护一些基本统计信息，例如已完成任务的数量。</p>
<p>这里借用《Java 并发编程的艺术》提到的来说一下<strong>使用线程池的好处</strong>：</p>
<ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h2 id="Executor-框架"><a href="#Executor-框架" class="headerlink" title="Executor 框架"></a>Executor 框架</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>Executor</code> 框架是 Java5 之后引进的，在 Java 5 之后，通过 <code>Executor</code> 来启动线程比使用 <code>Thread</code> 的 <code>start</code> 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题。</p>
<blockquote>
<p>补充：this 逃逸是指在构造函数返回之前其他线程就持有该对象的引用. 调用尚未构造完全的对象的方法可能引发令人疑惑的错误。</p>
</blockquote>
<p><code>Executor</code> 框架不仅包括了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，<code>Executor</code> 框架让并发编程变得更加简单。</p>
<h3 id="Executor-框架结构-主要由三大部分组成"><a href="#Executor-框架结构-主要由三大部分组成" class="headerlink" title="Executor 框架结构(主要由三大部分组成)"></a>Executor 框架结构(主要由三大部分组成)</h3><h4 id="任务-Runnable-x2F-Callable"><a href="#任务-Runnable-x2F-Callable" class="headerlink" title="任务(Runnable &#x2F;Callable)"></a>任务(<code>Runnable</code> &#x2F;<code>Callable</code>)</h4><p>执行任务需要实现的 <strong>Runnable 接口</strong> 或 <strong>Callable接口</strong>。<strong>Runnable 接口</strong>或 <strong>Callable 接口</strong> 实现类都可以被 <strong>ThreadPoolExecutor</strong> 或 <strong>ScheduledThreadPoolExecutor</strong> 执行。</p>
<h4 id="任务的执行-Executor"><a href="#任务的执行-Executor" class="headerlink" title="任务的执行(Executor)"></a>任务的执行(<code>Executor</code>)</h4><p>如下图所示，包括任务执行机制的核心接口 <strong>Executor</strong> ，以及继承自 <code>Executor</code> 接口的 <strong>ExecutorService 接口。ThreadPoolExecutor</strong> 和 <strong>ScheduledThreadPoolExecutor</strong> 这两个关键类实现了 <strong>ExecutorService 接口</strong>。</p>
<p><strong>这里提了很多底层的类关系，但是，实际上我们需要更多关注的是 ThreadPoolExecutor 这个类，这个类在我们实际使用线程池的过程中，使用频率还是非常高的。</strong></p>
<blockquote>
<p><strong>注意：</strong> 通过查看 <code>ScheduledThreadPoolExecutor</code> 源代码我们发现 <code>ScheduledThreadPoolExecutor</code> 实际上是继承了 <code>ThreadPoolExecutor</code> 并实现了 ScheduledExecutorService ，而 <code>ScheduledExecutorService</code> 又实现了 <code>ExecutorService</code>，正如我们下面给出的类关系图显示的一样。</p>
</blockquote>
<p><strong>ThreadPoolExecutor 类描述:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AbstractExecutorService实现了ExecutorService接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title class_">AbstractExecutorService</span></span><br></pre></td></tr></table></figure>

<p><strong>ScheduledThreadPoolExecutor 类描述:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ScheduledExecutorService继承ExecutorService接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledThreadPoolExecutor</span></span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">ThreadPoolExecutor</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">ScheduledExecutorService</span></span><br></pre></td></tr></table></figure>

<p><img src="https://files.catbox.moe/kyv5hx.png"></p>
<h4 id="异步计算的结果-Future"><a href="#异步计算的结果-Future" class="headerlink" title="异步计算的结果(Future)"></a>异步计算的结果(<code>Future</code>)</h4><p><strong>Future</strong> 接口以及 <code>Future</code> 接口的实现类 <strong>FutureTask</strong> 类都可以代表异步计算的结果。</p>
<p>当我们把 <strong>Runnable接口</strong> 或 <strong>Callable 接口</strong> 的实现类提交给 <strong>ThreadPoolExecutor</strong> 或 <strong>ScheduledThreadPoolExecutor</strong> 执行。（调用 <code>submit()</code> 方法时会返回一个 <strong>FutureTask</strong> 对象）</p>
<h3 id="Executor-框架的使用示意图"><a href="#Executor-框架的使用示意图" class="headerlink" title="Executor 框架的使用示意图"></a>Executor 框架的使用示意图</h3><p><img src="https://files.catbox.moe/djxjeq.png"></p>
<ol>
<li><strong>主线程首先要创建实现 Runnable 或者 Callable 接口的任务对象。</strong></li>
<li><strong>把创建完成的实现 Runnable&#x2F;Callable接口的 对象直接交给 ExecutorService 执行</strong>: <code>ExecutorService.execute（Runnable command）</code>）或者也可以把 <code>Runnable</code> 对象或<code>Callable</code> 对象提交给 <code>ExecutorService</code> 执行（<code>ExecutorService.submit（Runnable task）</code>或 <code>ExecutorService.submit（Callable &lt;T&gt; task）</code>）。</li>
<li><strong>如果执行 ExecutorService.submit（…），ExecutorService 将返回一个实现Future接口的对象</strong>（我们刚刚也提到过了执行 <code>execute()</code>方法和 <code>submit()</code>方法的区别，<code>submit()</code>会返回一个 <code>FutureTask 对象）。由于 FutureTask</code> 实现了 <code>Runnable</code>，我们也可以创建 <code>FutureTask</code>，然后直接交给 <code>ExecutorService</code> 执行。</li>
<li><strong>最后，主线程可以执行 FutureTask.get()方法来等待任务执行完成。主线程也可以执行 FutureTask.cancel（boolean mayInterruptIfRunning）来取消此任务的执行。</strong></li>
</ol>
<h2 id="重要-ThreadPoolExecutor-类简单介绍"><a href="#重要-ThreadPoolExecutor-类简单介绍" class="headerlink" title="(重要)ThreadPoolExecutor 类简单介绍"></a>(重要)ThreadPoolExecutor 类简单介绍</h2><p><strong>线程池实现类 ThreadPoolExecutor 是 Executor 框架最核心的类。</strong></p>
<h3 id="ThreadPoolExecutor-类分析"><a href="#ThreadPoolExecutor-类分析" class="headerlink" title="ThreadPoolExecutor 类分析"></a>ThreadPoolExecutor 类分析</h3><p><code>ThreadPoolExecutor</code> 类中提供的四个构造方法。我们来看最长的那个，其余三个都是在这个构造方法的基础上产生（其他几个构造方法说白点都是给定某些默认参数的构造方法比如默认制定拒绝策略是什么）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,//线程池的核心线程数量</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,//线程池的最大线程数</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></span><br><span class="line"><span class="params">                          TimeUnit unit,//时间单位</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></span><br><span class="line"><span class="params">                           )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这些对创建非常重要，在后面使用线程池的过程中你一定会用到！所以，务必拿着小本本记清楚。</p>
<p><strong>ThreadPoolExecutor 3 个最重要的参数：</strong></p>
<ul>
<li><strong>corePoolSize :</strong> 核心线程数线程数定义了最小可以同时运行的线程数量。</li>
<li><strong>maximumPoolSize :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li><strong>workQueue:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
</ul>
<p><code>ThreadPoolExecutor</code>其他常见参数 :</p>
<ol>
<li><strong>keepAliveTime</strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li>
<li><strong>unit</strong> : <code>keepAliveTime</code> 参数的时间单位。</li>
<li><strong>threadFactory</strong> :executor 创建新线程的时候会用到。</li>
<li><strong>handler</strong> :饱和策略。关于饱和策略下面单独介绍一下。</li>
</ol>
<p>下面这张图可以加深你对线程池中各个参数的相互关系的理解（图片来源：《Java 性能调优实战》）：</p>
<p><img src="https://files.catbox.moe/3m1r9b.png"></p>
<p><strong>ThreadPoolExecutor 饱和策略定义:</strong></p>
<p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p>
<ul>
<li><strong>ThreadPoolExecutor.AbortPolicy</strong> ：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>
<li><strong>ThreadPoolExecutor.CallerRunsPolicy</strong> ：调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li>
<li><strong>ThreadPoolExecutor.DiscardPolicy</strong> ：不处理新任务，直接丢弃掉。</li>
<li><strong>ThreadPoolExecutor.DiscardOldestPolicy</strong> ： 此策略将丢弃最早的未处理的任务请求。</li>
</ul>
<p>举个例子：</p>
<blockquote>
<p>Spring 通过 <code>ThreadPoolTaskExecutor</code> 或者我们直接通过 <code>ThreadPoolExecutor</code> 的构造函数创建线程池的时候，当我们不指定 <code>RejectedExecutionHandler</code> 饱和策略的话来配置线程池的时候默认使用的是 <code>ThreadPoolExecutor.AbortPolicy</code>。在默认情况下，<code>ThreadPoolExecutor</code> 将抛出 <code>RejectedExecutionException</code> 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。 对于可伸缩的应用程序，建议使用 <code>ThreadPoolExecutor.CallerRunsPolicy</code>。当最大池被填满时，此策略为我们提供可伸缩队列。（这个直接查看 <code>ThreadPoolExecutor</code> 的构造函数源码就可以看出，比较简单的原因，这里就不贴代码了。）</p>
</blockquote>
<h3 id="推荐使用-ThreadPoolExecutor-构造函数创建线程池"><a href="#推荐使用-ThreadPoolExecutor-构造函数创建线程池" class="headerlink" title="推荐使用 ThreadPoolExecutor 构造函数创建线程池"></a>推荐使用 <code>ThreadPoolExecutor</code> 构造函数创建线程池</h3><p>在《阿里巴巴 Java 开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</p>
<p><strong>为什么呢？</strong></p>
<blockquote>
<p>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p>
</blockquote>
<p>另外，《阿里巴巴 Java 开发手册》中强制线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p>
<blockquote>
<p><code>Executors</code> 返回线程池对象的弊端如下(后文会详细介绍到)：</p>
<ul>
<li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
<li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</li>
</ul>
</blockquote>
<p><strong>方式一：通过ThreadPoolExecutor构造函数实现（推荐）</strong></p>
<p><img src="https://files.catbox.moe/iyi5l0.png"></p>
<p><strong>方式二：通过 Executor 框架的工具类 Executors 来实现</strong> 我们可以创建三种类型的 <code>ThreadPoolExecutor</code>：</p>
<ul>
<li><code>FixedThreadPool</code></li>
<li><code>SingleThreadExecutor</code></li>
<li>CachedThreadPool</li>
</ul>
<p>对应 Executors 工具类中的方法如图所示：</p>
<p><img src="https://files.catbox.moe/ttqhgt.png"></p>
<h2 id="ThreadPoolExecutor-使用-原理分析"><a href="#ThreadPoolExecutor-使用-原理分析" class="headerlink" title="ThreadPoolExecutor 使用+原理分析"></a>ThreadPoolExecutor 使用+原理分析</h2><p>我们上面讲解了 <code>Executor</code>框架以及 <code>ThreadPoolExecutor</code> 类，下面让我们实战一下，来通过写一个 <code>ThreadPoolExecutor</code> 的小 Demo 来回顾上面的内容。</p>
<h3 id="示例代码-Runnable-ThreadPoolExecutor"><a href="#示例代码-Runnable-ThreadPoolExecutor" class="headerlink" title="示例代码:Runnable+ThreadPoolExecutor"></a>示例代码:<code>Runnable</code>+<code>ThreadPoolExecutor</code></h3><p>首先创建一个 <code>Runnable</code> 接口的实现类（当然也可以是 <code>Callable</code> 接口，我们上面也说了两者的区别。）</p>
<p><code>MyRunnable.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String command;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyRunnable</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Start. Time = &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        processCommand();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; End. Time = &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processCommand</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.command;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试程序，我们这里以阿里巴巴推荐的使用 <code>ThreadPoolExecutor</code> 构造函数自定义参数的方式来创建线程池。</p>
<p><code>ThreadPoolExecutorDemo.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CORE_POOL_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_POOL_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">QUEUE_CAPACITY</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">KEEP_ALIVE_TIME</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">        <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">            <span class="comment">//执行Runnable</span></span><br><span class="line">            executor.execute(worker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终止线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Finished all threads&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到我们上面的代码指定了：</p>
<ol>
<li><code>corePoolSize</code>: 核心线程数为 5。</li>
<li><code>maximumPoolSize</code> ：最大线程数 10</li>
<li><code>keepAliveTime</code> : 等待时间为 1L。</li>
<li><code>unit</code>: 等待时间的单位为 TimeUnit.SECONDS。</li>
<li><code>workQueue</code>：任务队列为 <code>ArrayBlockingQueue</code>，并且容量为 100;</li>
<li><code>handler</code>:饱和策略为 <code>CallerRunsPolicy</code>。</li>
</ol>
<p><strong>Output：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">37</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">37</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">37</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">37</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">37</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">47</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">47</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">47</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">47</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">47</span> CST <span class="number">2020</span></span><br></pre></td></tr></table></figure>

<h3 id="线程池原理分析"><a href="#线程池原理分析" class="headerlink" title="线程池原理分析"></a>线程池原理分析</h3><p>承接 4.1 节，我们通过代码输出结果可以看出：<strong>线程池首先会先执行 5 个任务，然后这些任务有任务被执行完的话，就会去拿新的任务执行。</strong> 大家可以先通过上面讲解的内容，分析一下到底是咋回事？（自己独立思考一会）</p>
<p>现在，我们就分析上面的输出内容来简单分析一下线程池原理。</p>
<p><strong>为了搞懂线程池的原理，我们需要首先分析一下 execute方法。</strong> 在 4.1 节中的 Demo 中我们使用 <code>executor.execute(worker)</code>来提交一个任务到线程池中去，这个方法非常重要，下面我们来看看它的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> c &amp; CAPACITY;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//任务队列</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">     <span class="comment">// 如果任务为null，则抛出异常。</span></span><br><span class="line">     <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">     <span class="comment">// ctl 中保存的线程池当前的一些状态信息</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line"></span><br><span class="line">     <span class="comment">//  下面会涉及到 3 步 操作</span></span><br><span class="line">     <span class="comment">// 1.首先判断当前线程池中之行的任务数量是否小于 corePoolSize</span></span><br><span class="line">     <span class="comment">// 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">     <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">         <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         c = ctl.get();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 2.如果当前之行的任务数量大于等于 corePoolSize 的时候就会走到这里</span></span><br><span class="line">     <span class="comment">// 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态并且队列可以加入任务，该任务才会被加入进去</span></span><br><span class="line">     <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">         <span class="comment">// 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</span></span><br><span class="line">         <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">             reject(command);</span><br><span class="line">             <span class="comment">// 如果当前线程池为空就新创建一个线程并执行。</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">             addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">     <span class="comment">//如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。</span></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">         reject(command);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>通过下图可以更好的对上面这 3 步做一个展示，下图是我为了省事直接从网上找到，原地址不明。</p>
<p><img src="https://files.catbox.moe/zm1cs9.png"></p>
<p><strong>addWorker 这个方法主要用来创建新的工作线程，如果返回 true 说明创建和启动工作线程成功，否则的话返回的就是 false。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 全局锁，并发操作必备</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"> <span class="comment">// 跟踪线程池的最大大小，只有在持有全局锁mainLock的前提下才能访问此集合</span></span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> largestPoolSize;</span><br><span class="line"> <span class="comment">// 工作线程集合，存放线程池中所有的（活跃的）工作线程，只有在持有全局锁mainLock的前提下才能访问此集合</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"> <span class="comment">//获取线程池状态</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">runStateOf</span><span class="params">(<span class="type">int</span> c)</span>     &#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"> <span class="comment">//判断线程池的状态是否为 Running</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isRunning</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 添加新的工作线程到线程池</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> firstTask 要执行</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> core参数为true的话表示使用线程池的基本大小，为false使用线程池最大大小</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 添加成功就返回true否则返回false</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">     retry:</span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">         <span class="comment">//这两句用来获取线程池的状态</span></span><br><span class="line">         <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">         <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">         <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">             ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                firstTask == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                ! workQueue.isEmpty()))</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取线程池中工作的线程的数量</span></span><br><span class="line">             <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">             <span class="comment">// core参数为true的话表明队列也满了，线程池大小变为 maximumPoolSize</span></span><br><span class="line">             <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                 wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                 <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//原子操作将workcount的数量加1</span></span><br><span class="line">             <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                 <span class="keyword">break</span> retry;</span><br><span class="line">             <span class="comment">// 如果线程的状态改变了就再次执行上述操作</span></span><br><span class="line">             c = ctl.get();</span><br><span class="line">             <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                 <span class="keyword">continue</span> retry;</span><br><span class="line">             <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 标记工作线程是否启动成功</span></span><br><span class="line">     <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">     <span class="comment">// 标记工作线程是否创建成功</span></span><br><span class="line">     <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">     <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">         w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">         <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">         <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 加锁</span></span><br><span class="line">             <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">             mainLock.lock();</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取线程池状态</span></span><br><span class="line">                 <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());</span><br><span class="line">                <span class="comment">//rs &lt; SHUTDOWN 如果线程池状态依然为RUNNING,并且线程的状态是存活的话，就会将工作线程添加到工作线程集合中</span></span><br><span class="line">               <span class="comment">//(rs=SHUTDOWN &amp;&amp; firstTask == null)如果线程池状态小于STOP，也就是RUNNING或者SHUTDOWN状态下，同时传入的任务实例firstTask为null，则需要添加到工作线程集合和启动新的Worker</span></span><br><span class="line">                <span class="comment">// firstTask == null证明只新建线程而不执行任务</span></span><br><span class="line">                 <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                     (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;</span><br><span class="line">                     <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">                     workers.add(w);</span><br><span class="line">                    <span class="comment">//更新当前工作线程的最大容量</span></span><br><span class="line">                     <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                     <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                         largestPoolSize = s;</span><br><span class="line">                   <span class="comment">// 工作线程是否启动成功</span></span><br><span class="line">                     workerAdded = <span class="literal">true</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                 <span class="comment">// 释放锁</span></span><br><span class="line">                 mainLock.unlock();</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//// 如果成功添加工作线程，则调用Worker内部的线程实例t的Thread#start()方法启动真实的线程实例</span></span><br><span class="line">             <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                 t.start();</span><br><span class="line">               <span class="comment">/// 标记线程启动成功</span></span><br><span class="line">                 workerStarted = <span class="literal">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 线程启动失败，需要从工作线程中移除对应的Worker</span></span><br><span class="line">         <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">             addWorkerFailed(w);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> workerStarted;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>更多关于线程池源码分析的内容推荐这篇文章：硬核干货：<a href="https://www.throwx.cn/2020/08/23/java-concurrency-thread-pool-executor/">4W字从源码上分析JUC线程池ThreadPoolExecutor的实现原理open in new window</a></p>
<p>现在，让我们在回到 4.1 节我们写的 Demo， 现在应该是不是很容易就可以搞懂它的原理了呢？</p>
<p>没搞懂的话，也没关系，可以看看我的分析：</p>
<blockquote>
<p>我们在代码中模拟了 10 个任务，我们配置的核心线程数为 5 、等待队列容量为 100 ，所以每次只可能存在 5 个任务同时执行，剩下的 5 个任务会被放到等待队列中去。当前的 5 个任务中如果有任务被执行完了，线程池就会去拿新的任务执行。</p>
</blockquote>
<h3 id="几个常见的对比"><a href="#几个常见的对比" class="headerlink" title="几个常见的对比"></a>几个常见的对比</h3><h4 id="Runnable-vs-Callable"><a href="#Runnable-vs-Callable" class="headerlink" title="Runnable vs Callable"></a><code>Runnable</code> vs <code>Callable</code></h4><p><code>Runnable</code>自 Java 1.0 以来一直存在，但<code>Callable</code>仅在 Java 1.5 中引入,目的就是为了来处理<code>Runnable</code>不支持的用例。<strong>Runnable 接口</strong>不会返回结果或抛出检查异常，但是 <strong>Callable 接口</strong>可以。所以，如果任务不需要返回结果或抛出异常推荐使用 <strong>Runnable 接口</strong>，这样代码看起来会更加简洁。</p>
<p>工具类 <code>Executors</code> 可以实现将 <code>Runnable</code> 对象转换成 <code>Callable</code> 对象。（<code>Executors.callable(Runnable task)</code> 或 <code>Executors.callable(Runnable task, Object result)</code>）。</p>
<p><code>Runnable.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 被线程执行，没有返回值也无法抛出异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Callable.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算结果，或在无法这样做时抛出异常。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算得出的结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> 如果无法计算结果，则抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="execute-vs-submit"><a href="#execute-vs-submit" class="headerlink" title="execute() vs submit()"></a><code>execute()</code> vs <code>submit()</code></h4><ul>
<li><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</li>
<li><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get（long timeout，TimeUnit unit）</code>方法的话，如果在 <code>timeout</code> 时间内任务还没有执行完，就会抛出 <code>java.util.concurrent.TimeoutException</code>。</li>
</ul>
<p>这里只是为了演示使用，推荐使用 <code>ThreadPoolExecutor</code> 构造方法来创建线程池。</p>
<p>示例1：使用 <code>get() </code>方法获取返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">Future&lt;String&gt; submit = executorService.submit(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">5000L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> submit.get();</span><br><span class="line">System.out.println(s);</span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">abc</span><br></pre></td></tr></table></figure>

<p>示例2：使用 <code>get（long timeout，TimeUnit unit） </code>方法获取返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">Future&lt;String&gt; submit = executorService.submit(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">5000L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> submit.get(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">System.out.println(s);</span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.util.concurrent.TimeoutException</span><br><span class="line">	at java.util.concurrent.FutureTask.get(FutureTask.java:<span class="number">205</span>)</span><br></pre></td></tr></table></figure>

<h4 id="shutdown-VSshutdownNow"><a href="#shutdown-VSshutdownNow" class="headerlink" title="shutdown()VSshutdownNow()"></a><code>shutdown()</code>VS<code>shutdownNow()</code></h4><ul>
<li><strong>shutdown（）</strong> :关闭线程池，线程池的状态变为 <code>SHUTDOWN</code>。线程池不再接受新任务了，但是队列里的任务得执行完毕。</li>
<li><strong>shutdownNow（）</strong> :关闭线程池，线程的状态变为 <code>STOP</code>。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。</li>
</ul>
<h4 id="isTerminated-VS-isShutdown"><a href="#isTerminated-VS-isShutdown" class="headerlink" title="isTerminated() VS isShutdown()"></a><code>isTerminated()</code> VS <code>isShutdown()</code></h4><ul>
<li><strong>isShutDown</strong> 当调用 <code>shutdown()</code> 方法后返回为 true。</li>
<li><strong>isTerminated</strong> 当调用 <code>shutdown()</code> 方法后，并且所有提交的任务完成后返回为 true</li>
</ul>
<h3 id="加餐-Callable-ThreadPoolExecutor示例代码"><a href="#加餐-Callable-ThreadPoolExecutor示例代码" class="headerlink" title="加餐:Callable+ThreadPoolExecutor示例代码"></a>加餐:<code>Callable</code>+<code>ThreadPoolExecutor</code>示例代码</h3><p><code>MyCallable.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//返回执行当前 Callable 的线程名字</span></span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CallableDemo.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CORE_POOL_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_POOL_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">QUEUE_CAPACITY</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">KEEP_ALIVE_TIME</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">        <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        List&lt;Future&lt;String&gt;&gt; futureList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Callable&lt;String&gt; callable = <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//提交任务到线程池</span></span><br><span class="line">            Future&lt;String&gt; future = executor.submit(callable);</span><br><span class="line">            <span class="comment">//将返回值 future 添加到 list，我们可以通过 future 获得 执行 Callable 得到的返回值</span></span><br><span class="line">            futureList.add(future);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;String&gt; fut : futureList) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;::&quot;</span> + fut.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Wed Nov <span class="number">13</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">41</span> CST <span class="number">2019</span>::pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">Wed Nov <span class="number">13</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">42</span> CST <span class="number">2019</span>::pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br><span class="line">Wed Nov <span class="number">13</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">42</span> CST <span class="number">2019</span>::pool-<span class="number">1</span>-thread-<span class="number">3</span></span><br><span class="line">Wed Nov <span class="number">13</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">42</span> CST <span class="number">2019</span>::pool-<span class="number">1</span>-thread-<span class="number">4</span></span><br><span class="line">Wed Nov <span class="number">13</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">42</span> CST <span class="number">2019</span>::pool-<span class="number">1</span>-thread-<span class="number">5</span></span><br><span class="line">Wed Nov <span class="number">13</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">42</span> CST <span class="number">2019</span>::pool-<span class="number">1</span>-thread-<span class="number">3</span></span><br><span class="line">Wed Nov <span class="number">13</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">43</span> CST <span class="number">2019</span>::pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br><span class="line">Wed Nov <span class="number">13</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">43</span> CST <span class="number">2019</span>::pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">Wed Nov <span class="number">13</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">43</span> CST <span class="number">2019</span>::pool-<span class="number">1</span>-thread-<span class="number">4</span></span><br><span class="line">Wed Nov <span class="number">13</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">43</span> CST <span class="number">2019</span>::pool-<span class="number">1</span>-thread-<span class="number">5</span></span><br></pre></td></tr></table></figure>

<h2 id="几种常见的线程池详解"><a href="#几种常见的线程池详解" class="headerlink" title="几种常见的线程池详解"></a>几种常见的线程池详解</h2><h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><code>FixedThreadPool</code> 被称为可重用固定线程数的线程池。通过 Executors 类中的相关源代码来看一下相关实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 创建一个可重用固定数量线程的线程池</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                   <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                   <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                   threadFactory);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>另外还有一个 <code>FixedThreadPool</code> 的实现方法，和上面的类似，所以这里不多做阐述：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>从上面源代码可以看出新创建的 FixedThreadPool 的 corePoolSize 和 maximumPoolSize 都被设置为 nThreads，这个 nThreads 参数是我们使用的时候自己传递的。</strong></p>
<h4 id="执行任务过程介绍"><a href="#执行任务过程介绍" class="headerlink" title="执行任务过程介绍"></a>执行任务过程介绍</h4><p><code>FixedThreadPool</code> 的 <code>execute()</code> 方法运行示意图（该图片来源：《Java 并发编程的艺术》）：</p>
<p><img src="https://files.catbox.moe/kncmxg.png"></p>
<p><strong>上图说明：</strong></p>
<ol>
<li>如果当前运行的线程数小于 corePoolSize， 如果再来新任务的话，就创建新的线程来执行任务；</li>
<li>当前运行的线程数等于 corePoolSize 后， 如果再来新任务的话，会将任务加入 <code>LinkedBlockingQueue</code>；</li>
<li>线程池中的线程执行完 手头的任务后，会在循环中反复从 <code>LinkedBlockingQueue</code> 中获取任务来执行；</li>
</ol>
<h4 id="为什么不推荐使用FixedThreadPool？"><a href="#为什么不推荐使用FixedThreadPool？" class="headerlink" title="为什么不推荐使用FixedThreadPool？"></a>为什么不推荐使用<code>FixedThreadPool</code>？</h4><p><strong>FixedThreadPool 使用无界队列 LinkedBlockingQueue（队列的容量为 Integer.MAX_VALUE）作为线程池的工作队列会对线程池带来如下影响 ：</strong></p>
<ol>
<li>当线程池中的线程数达到 <code>corePoolSize</code> 后，新任务将在无界队列中等待，因此线程池中的线程数不会超过 corePoolSize；</li>
<li>由于使用无界队列时 <code>maximumPoolSize</code> 将是一个无效参数，因为不可能存在任务队列满的情况。所以，通过创建 <code>FixedThreadPool</code>的源码可以看出创建的 <code>FixedThreadPool</code> 的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 被设置为同一个值。</li>
<li>由于 1 和 2，使用无界队列时 <code>keepAliveTime</code> 将是一个无效参数；</li>
<li>运行中的 <code>FixedThreadPool</code>（未执行 <code>shutdown()</code>或 <code>shutdownNow()</code>）不会拒绝任务，在任务比较多的时候会导致 OOM（内存溢出）。</li>
</ol>
<h3 id="SingleThreadExecutor-详解"><a href="#SingleThreadExecutor-详解" class="headerlink" title="SingleThreadExecutor 详解"></a>SingleThreadExecutor 详解</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p><code>SingleThreadExecutor</code> 是只有一个线程的线程池。下面看看<strong>SingleThreadExecutor 的实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *返回只有一个线程的线程池</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">         (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                 <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                 <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                 threadFactory));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">         (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                 <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                 <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>从上面源代码可以看出新创建的 <code>SingleThreadExecutor</code> 的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 都被设置为 1.其他参数和 <code>FixedThreadPool</code> 相同。</p>
<h4 id="执行任务过程介绍-1"><a href="#执行任务过程介绍-1" class="headerlink" title="执行任务过程介绍"></a>执行任务过程介绍</h4><p><code>SingleThreadExecutor</code> 的运行示意图（该图片来源：《Java 并发编程的艺术》）：</p>
<p><img src="https://files.catbox.moe/2tegjn.png"></p>
<p><strong>上图说明</strong> :</p>
<ol>
<li>如果当前运行的线程数少于 <code>corePoolSize</code>，则创建一个新的线程执行任务；</li>
<li>当前线程池中有一个运行的线程后，将任务加入 <code>LinkedBlockingQueue</code></li>
<li>线程执行完当前的任务后，会在循环中反复从<code>LinkedBlockingQueue</code> 中获取任务来执行；</li>
</ol>
<h4 id="为什么不推荐使用SingleThreadExecutor？"><a href="#为什么不推荐使用SingleThreadExecutor？" class="headerlink" title="为什么不推荐使用SingleThreadExecutor？"></a>为什么不推荐使用<code>SingleThreadExecutor</code>？</h4><p><code>SingleThreadExecutor</code> 使用无界队列 <code>LinkedBlockingQueue</code> 作为线程池的工作队列（队列的容量为 Intger.MAX_VALUE）。<code>SingleThreadExecutor</code> 使用无界队列作为线程池的工作队列会对线程池带来的影响与 <code>FixedThreadPool</code> 相同。说简单点就是可能会导致 OOM，</p>
<h3 id="CachedThreadPool-详解"><a href="#CachedThreadPool-详解" class="headerlink" title="CachedThreadPool 详解"></a>CachedThreadPool 详解</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p><code>CachedThreadPool</code> 是一个会根据需要创建新线程的线程池。下面通过源码来看看 <code>CachedThreadPool</code> 的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个线程池，根据需要创建新线程，但会在先前构建的线程可用时重用它。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CachedThreadPool</code> 的<code>corePoolSize</code> 被设置为空（0），<code>maximumPoolSize</code>被设置为 <code>Integer.MAX.VALUE</code>，即它是无界的，这也就意味着如果主线程提交任务的速度高于 <code>maximumPool</code> 中线程处理任务的速度时，<code>CachedThreadPool</code> 会不断创建新的线程。极端情况下，这样会导致耗尽 cpu 和内存资源。</p>
<h4 id="执行任务过程介绍-2"><a href="#执行任务过程介绍-2" class="headerlink" title="执行任务过程介绍"></a>执行任务过程介绍</h4><p><code>CachedThreadPool</code> 的 <code>execute()</code> 方法的执行示意图（该图片来源：《Java 并发编程的艺术》）：</p>
<p><img src="https://files.catbox.moe/c7bwot.png"></p>
<p><strong>上图说明：</strong></p>
<ol>
<li>首先执行 <code>SynchronousQueue.offer(Runnable task)</code> 提交任务到任务队列。如果当前 <code>maximumPool</code> 中有闲线程正在执行 <code>SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)</code>，那么主线程执行 offer 操作与空闲线程执行的 <code>poll</code> 操作配对成功，主线程把任务交给空闲线程执行，<code>execute()</code>方法执行完成，否则执行下面的步骤 2；</li>
<li>当初始 <code>maximumPool</code> 为空，或者 <code>maximumPool</code> 中没有空闲线程时，将没有线程执行 <code>SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)</code>。这种情况下，步骤 1 将失败，此时 <code>CachedThreadPool</code> 会创建新线程执行任务，execute 方法执行完成；</li>
</ol>
<h4 id="为什么不推荐使用CachedThreadPool？"><a href="#为什么不推荐使用CachedThreadPool？" class="headerlink" title="为什么不推荐使用CachedThreadPool？"></a>为什么不推荐使用<code>CachedThreadPool</code>？</h4><p><code>CachedThreadPool</code>允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</p>
<h2 id="ScheduledThreadPoolExecutor-详解"><a href="#ScheduledThreadPoolExecutor-详解" class="headerlink" title="[ScheduledThreadPoolExecutor 详解"></a>[ScheduledThreadPoolExecutor 详解</h2><p><strong>ScheduledThreadPoolExecutor 主要用来在给定的延迟后运行任务，或者定期执行任务。</strong> 这个在实际项目中基本不会被用到，也不推荐使用，大家只需要简单了解一下它的思想即可。</p>
<h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p><code>ScheduledThreadPoolExecutor</code> 使用的任务队列 <code>DelayQueue</code> 封装了一个 <code>PriorityQueue</code>，<code>PriorityQueue</code> 会对队列中的任务进行排序，执行所需时间短的放在前面先被执行(<code>ScheduledFutureTask</code> 的 <code>time</code> 变量小的先执行)，如果执行所需时间相同则先提交的任务将被先执行(<code>ScheduledFutureTask</code> 的 <code>squenceNumber</code> 变量小的先执行)。</p>
<p><strong>ScheduledThreadPoolExecutor 和 Timer 的比较：</strong></p>
<ul>
<li><code>Timer</code> 对系统时钟的变化敏感，<code>ScheduledThreadPoolExecutor</code>不是；</li>
<li><code>Timer</code> 只有一个执行线程，因此长时间运行的任务可以延迟其他任务。 <code>ScheduledThreadPoolExecutor</code> 可以配置任意数量的线程。 此外，如果你想（通过提供 ThreadFactory），你可以完全控制创建的线程;</li>
<li>在<code>TimerTask</code> 中抛出的运行时异常会杀死一个线程，从而导致 <code>Timer</code> 死机:-( …即计划任务将不再运行。<code>ScheduledThreadExecutor</code> 不仅捕获运行时异常，还允许您在需要时处理它们（通过重写 <code>afterExecute</code> 方法<code>ThreadPoolExecutor</code>）。抛出异常的任务将被取消，但其他任务将继续运行。</li>
</ul>
<p><strong>综上，在 JDK1.5 之后，你没有理由再使用 Timer 进行任务调度了。</strong></p>
<blockquote>
<p>关于定时任务的详细介绍，小伙伴们可以在 JavaGuide 的项目首页搜索“定时任务”找到对应的原创内容。</p>
</blockquote>
<h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><p><img src="https://files.catbox.moe/cw5qso.png"></p>
<p><strong>ScheduledThreadPoolExecutor 的执行主要分为两大部分：</strong></p>
<ol>
<li>当调用 <code>ScheduledThreadPoolExecutor</code> 的 <strong>scheduleAtFixedRate()</strong> 方法或者 <strong>scheduleWithFixedDelay()</strong> 方法时，会向 <code>ScheduledThreadPoolExecutor</code> 的 <strong>DelayQueue</strong> 添加一个实现了 <strong>RunnableScheduledFuture</strong> 接口的 <strong>ScheduledFutureTask</strong> 。</li>
<li>线程池中的线程从 <code>DelayQueue</code> 中获取 <code>ScheduledFutureTask</code>，然后执行任务。</li>
</ol>
<p><strong>ScheduledThreadPoolExecutor 为了实现周期性的执行任务，对 ThreadPoolExecutor做了如下修改：</strong></p>
<ul>
<li>使用 <strong>DelayQueue</strong> 作为任务队列；</li>
<li>获取任务的方不同</li>
<li>执行周期任务后，增加了额外的处理</li>
</ul>
<h3 id="ScheduledThreadPoolExecutor-执行周期任务的步骤"><a href="#ScheduledThreadPoolExecutor-执行周期任务的步骤" class="headerlink" title="ScheduledThreadPoolExecutor 执行周期任务的步骤"></a>ScheduledThreadPoolExecutor 执行周期任务的步骤</h3><p><img src="https://files.catbox.moe/gnaoe2.png"></p>
<ol>
<li>线程 1 从 <code>DelayQueue</code> 中获取已到期的 <code>ScheduledFutureTask（DelayQueue.take()）</code>。到期任务是指 <code>ScheduledFutureTask</code>的 time 大于等于当前系统的时间；</li>
<li>线程 1 执行这个 <code>ScheduledFutureTask</code>；</li>
<li>线程 1 修改 <code>ScheduledFutureTask</code> 的 time 变量为下次将要被执行的时间；</li>
<li>线程 1 把这个修改 time 之后的 <code>ScheduledFutureTask</code> 放回 <code>DelayQueue</code> 中（<code>DelayQueue.add()</code>)。</li>
</ol>
<h2 id="线程池大小确定"><a href="#线程池大小确定" class="headerlink" title="线程池大小确定"></a>线程池大小确定</h2><p><strong>线程池数量的确定一直是困扰着程序员的一个难题，大部分程序员在设定线程池大小的时候就是随心而定。</strong></p>
<p>很多人甚至可能都会觉得把线程池配置过大一点比较好！我觉得这明显是有问题的。就拿我们生活中非常常见的一例子来说：<strong>并不是人多就能把事情做好，增加了沟通交流成本。你本来一件事情只需要 3 个人做，你硬是拉来了 6 个人，会提升做事效率嘛？我想并不会。</strong> 线程数量过多的影响也是和我们分配多少人做事情一样，对于多线程这个场景来说主要是增加了<strong>上下文切换</strong>成本。不清楚什么是上下文切换的话，可以看我下面的介绍。</p>
<blockquote>
<p>上下文切换：</p>
<p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>
<p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>
<p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p>
</blockquote>
<p><strong>类比于现实世界中的人类通过合作做某件事情，我们可以肯定的一点是线程池大小设置过大或者过小都会有问题，合适的才是最好。</strong></p>
<p><strong>如果我们设置的线程池数量太小的话，如果同一时间有大量任务&#x2F;请求需要处理，可能会导致大量的请求&#x2F;任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务&#x2F;请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的！ CPU 根本没有得到充分利用。</strong></p>
<p><strong>但是，如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</strong></p>
<p>有一个简单并且适用面比较广的公式：</p>
<ul>
<li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li>
<li><strong>I&#x2F;O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I&#x2F;O 交互，而线程在处理 I&#x2F;O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I&#x2F;O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li>
</ul>
<p><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong></p>
<p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《Java 并发编程的艺术》</li>
<li><a href="https://www.journaldev.com/2340/java-scheduler-scheduledexecutorservice-scheduledthreadpoolexecutor-example">Java Scheduler ScheduledExecutorService ScheduledThreadPoolExecutor Exampleopen in new window</a></li>
<li><a href="https://examples.javacodegeeks.com/core-java/util/concurrent/scheduledthreadpoolexecutor/java-util-concurrent-scheduledthreadpoolexecutor-example/">java.util.concurrent.ScheduledThreadPoolExecutor Exampleopen in new window</a></li>
<li><a href="https://www.journaldev.com/1069/threadpoolexecutor-java-thread-pool-example-executorservice">ThreadPoolExecutor – Java Thread Pool Exampleopen in new window</a></li>
</ul>
<h2 id="其他推荐阅读"><a href="#其他推荐阅读" class="headerlink" title="其他推荐阅读"></a>其他推荐阅读</h2><ul>
<li><a href="https://www.cnblogs.com/warehouse/p/10720781.html">Java 并发（三）线程池原理open in new window</a></li>
<li><a href="https://github.com/crossoverJie/JCSprout/blob/master/MD/ThreadPoolExecutor.md">如何优雅的使用和理解线程池</a></li>
</ul>
<h1 id="Java-线程池最佳实践"><a href="#Java-线程池最佳实践" class="headerlink" title="Java 线程池最佳实践"></a>Java 线程池最佳实践</h1><p>这篇文章篇幅虽短，但是绝对是干货。标题稍微有点夸张，嘿嘿，实际都是自己使用线程池的时候总结的一些个人感觉比较重要的点。</p>
<h2 id="线程池知识回顾"><a href="#线程池知识回顾" class="headerlink" title="线程池知识回顾"></a>线程池知识回顾</h2><p>开始这篇文章之前还是简单介绍线程池，之前写的<a href="https://javaguide.cn/java/concurrent/java-thread-pool-summary.html">《新手也能看懂的线程池学习总结》</a>这篇文章介绍的很详细了。</p>
<h3 id="为什么要使用线程池？"><a href="#为什么要使用线程池？" class="headerlink" title="为什么要使用线程池？"></a>为什么要使用线程池？</h3><blockquote>
<p><strong>池化技术想必大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</strong></p>
</blockquote>
<p><strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）的方式。 每个<strong>线程池</strong>还维护一些基本统计信息，例如已完成任务的数量。</p>
<p>这里借用《Java 并发编程的艺术》提到的来说一下<strong>使用线程池的好处</strong>：</p>
<ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h3 id="线程池在实际项目的使用场景"><a href="#线程池在实际项目的使用场景" class="headerlink" title="线程池在实际项目的使用场景"></a>线程池在实际项目的使用场景</h3><p><strong>线程池一般用于执行多个不相关联的耗时任务，没有多线程的情况下，任务顺序执行，使用了线程池的话可让多个不相关联的任务同时执行。</strong></p>
<p>假设我们要执行三个不相关的耗时任务，Guide 画图给大家展示了使用线程池前后的区别。</p>
<p>注意：<strong>下面三个任务可能做的是同一件事情，也可能是不一样的事情。</strong></p>
<blockquote>
<p>使用多线程前应为：任务 1 –&gt; 任务 2 –&gt; 任务 3（图中把任务 3 画错为 任务 2）</p>
</blockquote>
<p><img src="https://files.catbox.moe/m3a0xp.png"></p>
<h3 id="如何使用线程池？"><a href="#如何使用线程池？" class="headerlink" title="如何使用线程池？"></a>如何使用线程池？</h3><p>一般是通过 <code>ThreadPoolExecutor</code> 的构造函数来创建线程池，然后提交任务给线程池执行就可以了。</p>
<p><code>ThreadPoolExecutor</code>构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,//线程池的核心线程数量</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,//线程池的最大线程数</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></span><br><span class="line"><span class="params">                          TimeUnit unit,//时间单位</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></span><br><span class="line"><span class="params">                           )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单演示一下如何使用线程池，更详细的介绍，请看：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485808&idx=1&sn=1013253533d73450cef673aee13267ab&chksm=cea246bbf9d5cfad1c21316340a0ef1609a7457fea4113a1f8d69e8c91e7d9cd6285f5ee1490&token=510053261&lang=zh_CN&scene=21#wechat_redirect">《新手也能看懂的线程池学习总结》open in new window</a> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CORE_POOL_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_POOL_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">QUEUE_CAPACITY</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">KEEP_ALIVE_TIME</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">    <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">    <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            CORE_POOL_SIZE,</span><br><span class="line">            MAX_POOL_SIZE,</span><br><span class="line">            KEEP_ALIVE_TIME,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;CurrentThread name:&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;date：&quot;</span> + Instant.now());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//终止线程池</span></span><br><span class="line">    executor.shutdown();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        executor.awaitTermination(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;Finished all threads&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CurrentThread name:pool-<span class="number">1</span>-thread-5date：<span class="number">2020</span>-<span class="number">06</span>-06T11:<span class="number">45</span>:<span class="number">31.</span>639Z</span><br><span class="line">CurrentThread name:pool-<span class="number">1</span>-thread-3date：<span class="number">2020</span>-<span class="number">06</span>-06T11:<span class="number">45</span>:<span class="number">31.</span>639Z</span><br><span class="line">CurrentThread name:pool-<span class="number">1</span>-thread-1date：<span class="number">2020</span>-<span class="number">06</span>-06T11:<span class="number">45</span>:<span class="number">31.</span>636Z</span><br><span class="line">CurrentThread name:pool-<span class="number">1</span>-thread-4date：<span class="number">2020</span>-<span class="number">06</span>-06T11:<span class="number">45</span>:<span class="number">31.</span>639Z</span><br><span class="line">CurrentThread name:pool-<span class="number">1</span>-thread-2date：<span class="number">2020</span>-<span class="number">06</span>-06T11:<span class="number">45</span>:<span class="number">31.</span>639Z</span><br><span class="line">CurrentThread name:pool-<span class="number">1</span>-thread-2date：<span class="number">2020</span>-<span class="number">06</span>-06T11:<span class="number">45</span>:<span class="number">33.</span>656Z</span><br><span class="line">CurrentThread name:pool-<span class="number">1</span>-thread-4date：<span class="number">2020</span>-<span class="number">06</span>-06T11:<span class="number">45</span>:<span class="number">33.</span>656Z</span><br><span class="line">CurrentThread name:pool-<span class="number">1</span>-thread-1date：<span class="number">2020</span>-<span class="number">06</span>-06T11:<span class="number">45</span>:<span class="number">33.</span>656Z</span><br><span class="line">CurrentThread name:pool-<span class="number">1</span>-thread-3date：<span class="number">2020</span>-<span class="number">06</span>-06T11:<span class="number">45</span>:<span class="number">33.</span>656Z</span><br><span class="line">CurrentThread name:pool-<span class="number">1</span>-thread-5date：<span class="number">2020</span>-<span class="number">06</span>-06T11:<span class="number">45</span>:<span class="number">33.</span>656Z</span><br><span class="line">Finished all threads</span><br></pre></td></tr></table></figure>

<h2 id="线程池最佳实践"><a href="#线程池最佳实践" class="headerlink" title="线程池最佳实践"></a>线程池最佳实践</h2><p>简单总结一下我了解的使用线程池的时候应该注意的东西，网上似乎还没有专门写这方面的文章。</p>
<p>因为 Guide 还比较菜，有补充和完善的地方，可以在评论区告知或者在微信上与我交流。</p>
<h3 id="使用-ThreadPoolExecutor-的构造函数声明线程池"><a href="#使用-ThreadPoolExecutor-的构造函数声明线程池" class="headerlink" title="使用 ThreadPoolExecutor 的构造函数声明线程池"></a>使用 <code>ThreadPoolExecutor</code> 的构造函数声明线程池</h3><p><strong>1. 线程池必须手动通过 ThreadPoolExecutor 的构造函数来声明，避免使用Executors 类的 newFixedThreadPool 和 newCachedThreadPool ，因为可能会有 OOM 的风险。</strong></p>
<blockquote>
<p>Executors 返回线程池对象的弊端如下：</p>
<ul>
<li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
<li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</li>
</ul>
</blockquote>
<p>说白了就是：<strong>使用有界队列，控制线程创建数量。</strong></p>
<p>除了避免 OOM 的原因之外，不推荐使用 <code>Executors</code>提供的两种快捷的线程池的原因还有：</p>
<ol>
<li>实际使用中需要根据自己机器的性能、业务场景来手动配置线程池的参数比如核心线程数、使用的任务队列、饱和策略等等。</li>
<li>我们应该显示地给我们的线程池命名，这样有助于我们定位问题。</li>
</ol>
<h3 id="监测线程池运行状态"><a href="#监测线程池运行状态" class="headerlink" title="监测线程池运行状态"></a>监测线程池运行状态</h3><p>你可以通过一些手段来检测线程池的运行状态比如 SpringBoot 中的 Actuator 组件。</p>
<p>除此之外，我们还可以利用 <code>ThreadPoolExecutor</code> 的相关 API 做一个简陋的监控。从下图可以看出， <code>ThreadPoolExecutor</code>提供了获取线程池当前的线程数和活跃线程数、已经执行完成的任务数、正在排队中的任务数等等。</p>
<p><img src="https://files.catbox.moe/fsum5b.png"></p>
<p>下面是一个简单的 Demo。<code>printThreadPoolStatus()</code>会每隔一秒打印出线程池的线程数、活跃线程数、完成的任务数、以及队列中的任务数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印线程池的状态</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadPool 线程池对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printThreadPoolStatus</span><span class="params">(ThreadPoolExecutor threadPool)</span> &#123;</span><br><span class="line">    <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledExecutorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">1</span>, createThreadFactory(<span class="string">&quot;print-images/thread-pool-status&quot;</span>, <span class="literal">false</span>));</span><br><span class="line">    scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">&quot;=========================&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;ThreadPool Size: [&#123;&#125;]&quot;</span>, threadPool.getPoolSize());</span><br><span class="line">        log.info(<span class="string">&quot;Active Threads: &#123;&#125;&quot;</span>, threadPool.getActiveCount());</span><br><span class="line">        log.info(<span class="string">&quot;Number of Tasks : &#123;&#125;&quot;</span>, threadPool.getCompletedTaskCount());</span><br><span class="line">        log.info(<span class="string">&quot;Number of Tasks in Queue: &#123;&#125;&quot;</span>, threadPool.getQueue().size());</span><br><span class="line">        log.info(<span class="string">&quot;=========================&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="建议不同类别的业务用不同的线程池"><a href="#建议不同类别的业务用不同的线程池" class="headerlink" title="建议不同类别的业务用不同的线程池"></a>建议不同类别的业务用不同的线程池</h3><p>很多人在实际项目中都会有类似这样的问题：<strong>我的项目中多个业务需要用到线程池，是为每个线程池都定义一个还是说定义一个公共的线程池呢？</strong></p>
<p>一般建议是不同的业务使用不同的线程池，配置线程池的时候根据当前业务的情况对当前线程池进行配置，因为不同的业务的并发以及对资源的使用情况都不同，重心优化系统性能瓶颈相关的业务。</p>
<p><strong>我们再来看一个真实的事故案例！</strong> (本案例来源自：<a href="https://club.perfma.com/article/646639">《线程池运用不当的一次线上事故》open in new window</a> ，很精彩的一个案例)</p>
<p><img src="https://files.catbox.moe/rgqc39.png"></p>
<p>上面的代码可能会存在死锁的情况，为什么呢？画个图给大家捋一捋。</p>
<p>试想这样一种极端情况：假如我们线程池的核心线程数为 <strong>n</strong>，父任务（扣费任务）数量为 <strong>n</strong>，父任务下面有两个子任务（扣费任务下的子任务），其中一个已经执行完成，另外一个被放在了任务队列中。由于父任务把线程池核心线程资源用完，所以子任务因为无法获取到线程资源无法正常执行，一直被阻塞在队列中。父任务等待子任务执行完成，而子任务等待父任务释放线程池资源，这也就造成了 **”死锁”**。</p>
<p><img src="https://files.catbox.moe/1hxru8.png"></p>
<p>解决方法也很简单，就是新增加一个用于执行子任务的线程池专门为其服务。</p>
<h3 id="别忘记给线程池命名"><a href="#别忘记给线程池命名" class="headerlink" title="别忘记给线程池命名"></a>别忘记给线程池命名</h3><p>初始化线程池的时候需要显示命名（设置线程池名称前缀），有利于定位问题。</p>
<p>默认情况下创建的线程名字类似 pool-1-thread-n 这样的，没有业务含义，不利于我们定位问题。</p>
<p>给线程池里的线程命名通常有下面两种方式：</p>
<p>**1.利用 guava 的 <code>ThreadFactoryBuilder</code> **</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>()</span><br><span class="line">                        .setNameFormat(threadNamePrefix + <span class="string">&quot;-%d&quot;</span>)</span><br><span class="line">                        .setDaemon(<span class="literal">true</span>).build();</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory)</span><br></pre></td></tr></table></figure>

<p><strong>2.自己实现 ThreadFactor。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程工厂，它设置线程名称，有利于我们定位问题。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NamingThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">threadNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory delegate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个带名字的线程池生产工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NamingThreadFactory</span><span class="params">(ThreadFactory delegate, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.delegate = delegate;</span><br><span class="line">        <span class="built_in">this</span>.name = name; <span class="comment">// TODO consider uniquifying this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> delegate.newThread(r);</span><br><span class="line">        t.setName(name + <span class="string">&quot; [#&quot;</span> + threadNum.incrementAndGet() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="正确配置线程池参数"><a href="#正确配置线程池参数" class="headerlink" title="正确配置线程池参数"></a>正确配置线程池参数</h3><p>说到如何给线程池配置参数，美团的骚操作至今让我难忘（后面会提到）！</p>
<p>我们先来看一下各种书籍和博客上一般推荐的配置线程池参数的方式，可以作为参考！</p>
<h4 id="常规操作"><a href="#常规操作" class="headerlink" title="常规操作"></a>常规操作</h4><p>很多人甚至可能都会觉得把线程池配置过大一点比较好！我觉得这明显是有问题的。就拿我们生活中非常常见的一例子来说：<strong>并不是人多就能把事情做好，增加了沟通交流成本。你本来一件事情只需要 3 个人做，你硬是拉来了 6 个人，会提升做事效率嘛？我想并不会。</strong> 线程数量过多的影响也是和我们分配多少人做事情一样，对于多线程这个场景来说主要是增加了<strong>上下文切换</strong>成本。不清楚什么是上下文切换的话，可以看我下面的介绍。</p>
<blockquote>
<p>上下文切换：</p>
<p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>
<p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>
<p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p>
</blockquote>
<p>类比于实现世界中的人类通过合作做某件事情，我们可以肯定的一点是线程池大小设置过大或者过小都会有问题，合适的才是最好。</p>
<ul>
<li>如果我们设置的线程池数量太小的话，如果同一时间有大量任务&#x2F;请求需要处理，可能会导致大量的请求&#x2F;任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务&#x2F;请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的，CPU 根本没有得到充分利用。</li>
<li>如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</li>
</ul>
<p>有一个简单并且适用面比较广的公式：</p>
<ul>
<li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li>
<li><strong>I&#x2F;O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I&#x2F;O 交互，而线程在处理 I&#x2F;O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I&#x2F;O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li>
</ul>
<p><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong></p>
<p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p>
<blockquote>
<p>🌈 拓展一下（参见：<a href="https://github.com/Snailclimb/JavaGuide/issues/1737">issue#1737open in new window</a>）：</p>
<p>线程数更严谨的计算的方法应该是：<code>最佳线程数 = N（CPU 核心数）∗（1+WT（线程等待时间）/ST（线程计算时间））</code>，其中 <code>WT（线程等待时间）=线程运行总时间 - ST（线程计算时间）</code>。</p>
<p>线程等待时间所占比例越高，需要越多线程。线程计算时间所占比例越高，需要越少线程。</p>
<p>我们可以通过 JDK 自带的工具 VisualVM 来查看 <code>WT/ST</code> 比例。</p>
<p>CPU 密集型任务的 <code>WT/ST</code> 接近或者等于 0，因此， 线程数可以设置为 N（CPU 核心数）∗（1+0）&#x3D; N，和我们上面说的 N（CPU 核心数）+1 差不多。</p>
<p>IO 密集型任务下，几乎全是线程等待时间，从理论上来说，你就可以将线程数设置为 2N（按道理来说，WT&#x2F;ST 的结果应该比较大，这里选择 2N 的原因应该是为了避免创建过多线程吧）。</p>
</blockquote>
<p><strong>公示也只是参考，具体还是要根据项目实际线上运行情况来动态调整。我在后面介绍的美团的线程池参数动态配置这种方案就非常不错，很实用！</strong></p>
<h4 id="美团的骚操作"><a href="#美团的骚操作" class="headerlink" title="美团的骚操作"></a>美团的骚操作</h4><p>美团技术团队在<a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">《Java 线程池实现原理及其在美团业务中的实践》open in new window</a>这篇文章中介绍到对线程池参数实现可自定义配置的思路和方法。</p>
<p>美团技术团队的思路是主要对线程池的核心参数实现自定义可配置。这三个核心参数是：</p>
<ul>
<li><strong>corePoolSize :</strong> 核心线程数线程数定义了最小可以同时运行的线程数量。</li>
<li><strong>maximumPoolSize :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li><strong>workQueue:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
</ul>
<p><strong>为什么是这三个参数？</strong></p>
<p>我在这篇<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485808&idx=1&sn=1013253533d73450cef673aee13267ab&chksm=cea246bbf9d5cfad1c21316340a0ef1609a7457fea4113a1f8d69e8c91e7d9cd6285f5ee1490&token=510053261&lang=zh_CN&scene=21#wechat_redirect">《新手也能看懂的线程池学习总结》open in new window</a> 中就说过这三个参数是 <code>ThreadPoolExecutor</code> 最重要的参数，它们基本决定了线程池对于任务的处理策略。</p>
<p><strong>如何支持参数动态配置？</strong> 且看 <code>ThreadPoolExecutor</code> 提供的下面这些方法。</p>
<p><img src="https://files.catbox.moe/uzthn4.png"></p>
<p>格外需要注意的是<code>corePoolSize</code>， 程序运行期间的时候，我们调用 <code>setCorePoolSize（）</code>这个方法的话，线程池会首先判断当前工作线程数是否大于<code>corePoolSize</code>，如果大于的话就会回收工作线程。</p>
<p>另外，你也看到了上面并没有动态指定队列长度的方法，美团的方式是自定义了一个叫做 <code>ResizableCapacityLinkedBlockIngQueue</code> 的队列（主要就是把<code>LinkedBlockingQueue</code>的 capacity 字段的 final 关键字修饰给去掉了，让它变为可变的）。</p>
<p>最终实现的可动态修改线程池参数效果如下。</p>
<p><img src="https://files.catbox.moe/f0g498.png"></p>
<p>还没看够？推荐 why 神的<a href="https://mp.weixin.qq.com/s/9HLuPcoWmTqAeFKa1kj-_A">《如何设置线程池参数？美团给出了一个让面试官虎躯一震的回答。》open in new window</a>这篇文章，深度剖析，很不错哦！</p>
<h1 id="Java-常见并发容器总结"><a href="#Java-常见并发容器总结" class="headerlink" title="Java 常见并发容器总结"></a>Java 常见并发容器总结</h1><p>JDK 提供的这些容器大部分在 <code>java.util.concurrent</code> 包中。</p>
<ul>
<li><strong>ConcurrentHashMap</strong> : 线程安全的 <code>HashMap</code></li>
<li><strong>CopyOnWriteArrayList</strong> : 线程安全的 <code>List</code>，在读多写少的场合性能非常好，远远好于 <code>Vector</code>。</li>
<li><strong>ConcurrentLinkedQueue</strong> : 高效的并发队列，使用链表实现。可以看做一个线程安全的 <code>LinkedList</code>，这是一个非阻塞队列。</li>
<li><strong>BlockingQueue</strong> : 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。</li>
<li><strong>ConcurrentSkipListMap</strong> : 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。</li>
</ul>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>我们知道 <code>HashMap</code> 不是线程安全的，在并发场景下如果要保证一种可行的方式是使用 <code>Collections.synchronizedMap()</code> 方法来包装我们的 <code>HashMap</code>。但这是通过使用一个全局的锁来同步不同线程间的并发访问，因此会带来不可忽视的性能问题。</p>
<p>所以就有了 <code>HashMap</code> 的线程安全版本—— <code>ConcurrentHashMap</code> 的诞生。</p>
<p>在 <code>ConcurrentHashMap</code> 中，无论是读操作还是写操作都能保证很高的性能：在进行读操作时(几乎)不需要加锁，而在写操作时通过锁分段技术只对所操作的段加锁而不影响客户端对其它段的访问。</p>
<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><h3 id="CopyOnWriteArrayList-简介"><a href="#CopyOnWriteArrayList-简介" class="headerlink" title="CopyOnWriteArrayList 简介"></a>CopyOnWriteArrayList 简介</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;E&gt;</span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">Object</span></span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, Serializable</span><br></pre></td></tr></table></figure>

<p>在很多应用场景中，读操作可能会远远大于写操作。由于读操作根本不会修改原有的数据，因此对于每次读取都进行加锁其实是一种资源浪费。我们应该允许多个线程同时访问 <code>List</code> 的内部数据，毕竟读取操作是安全的。</p>
<p>这和我们之前在多线程章节讲过 <code>ReentrantReadWriteLock</code> 读写锁的思想非常类似，也就是读读共享、写写互斥、读写互斥、写读互斥。JDK 中提供了 <code>CopyOnWriteArrayList</code> 类比相比于在读写锁的思想又更进一步。为了将读取的性能发挥到极致，<code>CopyOnWriteArrayList</code> 读取是完全不用加锁的，并且更厉害的是：写入也不会阻塞读取操作。只有写入和写入之间需要进行同步等待。这样一来，读操作的性能就会大幅度提升。<strong>那它是怎么做的呢？</strong></p>
<h3 id="CopyOnWriteArrayList-是如何做到的？"><a href="#CopyOnWriteArrayList-是如何做到的？" class="headerlink" title="CopyOnWriteArrayList 是如何做到的？"></a>CopyOnWriteArrayList 是如何做到的？</h3><p><code>CopyOnWriteArrayList</code> 类的所有可变操作（add，set 等等）都是通过创建底层数组的新副本来实现的。当 List 需要被修改的时候，我并不修改原有内容，而是对原有数据进行一次复制，将修改的内容写入副本。写完之后，再将修改完的副本替换原来的数据，这样就可以保证写操作不会影响读操作了。</p>
<p>从 <code>CopyOnWriteArrayList</code> 的名字就能看出 <code>CopyOnWriteArrayList</code> 是满足 <code>CopyOnWrite</code> 的。所谓 <code>CopyOnWrite</code> 也就是说：在计算机，如果你想要对一块内存进行修改时，我们不在原有内存块中进行写操作，而是将内存拷贝一份，在新的内存中进行写操作，写完之后呢，就将指向原来内存指针指向新的内存，原来的内存就可以被回收掉了。</p>
<h3 id="CopyOnWriteArrayList-读取和写入源码简单分析"><a href="#CopyOnWriteArrayList-读取和写入源码简单分析" class="headerlink" title="CopyOnWriteArrayList 读取和写入源码简单分析"></a>CopyOnWriteArrayList 读取和写入源码简单分析</h3><h4 id="CopyOnWriteArrayList-读取操作的实现"><a href="#CopyOnWriteArrayList-读取操作的实现" class="headerlink" title="CopyOnWriteArrayList 读取操作的实现"></a>CopyOnWriteArrayList 读取操作的实现</h4><p>读取操作没有任何同步控制和锁操作，理由就是内部数组 <code>array</code> 不会发生修改，只会被另外一个 <code>array</code> 替换，因此可以保证数据安全。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** The array, accessed only via getArray/setArray. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">get</span><span class="params">(Object[] a, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CopyOnWriteArrayList-写入操作的实现"><a href="#CopyOnWriteArrayList-写入操作的实现" class="headerlink" title="CopyOnWriteArrayList 写入操作的实现"></a>CopyOnWriteArrayList 写入操作的实现</h4><p><code>CopyOnWriteArrayList</code> 写入操作 <code>add()</code>方法在添加集合的时候加了锁，保证了同步，避免了多线程写的时候会 copy 出多个副本出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();<span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);<span class="comment">//拷贝新数组</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><p>Java 提供的线程安全的 <code>Queue</code> 可以分为<strong>阻塞队列</strong>和<strong>非阻塞队列</strong>，其中阻塞队列的典型例子是 <code>BlockingQueue</code>，非阻塞队列的典型例子是 <code>ConcurrentLinkedQueue</code>，在实际应用中要根据实际需要选用阻塞队列或者非阻塞队列。 <strong>阻塞队列可以通过加锁来实现，非阻塞队列可以通过 CAS 操作实现。</strong></p>
<p>从名字可以看出，<code>ConcurrentLinkedQueue</code>这个队列使用链表作为其数据结构．<code>ConcurrentLinkedQueue</code> 应该算是在高并发环境中性能最好的队列了。它之所有能有很好的性能，是因为其内部复杂的实现。</p>
<p><code>ConcurrentLinkedQueue</code> 内部代码我们就不分析了，大家知道 <code>ConcurrentLinkedQueue</code> 主要使用 CAS 非阻塞算法来实现线程安全就好了。</p>
<p><code>ConcurrentLinkedQueue</code> 适合在对性能要求相对较高，同时对队列的读写存在多个线程同时进行的场景，即如果对队列加锁的成本较高则适合使用无锁的 <code>ConcurrentLinkedQueue</code> 来替代。</p>
<h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><h3 id="BlockingQueue-简介"><a href="#BlockingQueue-简介" class="headerlink" title="BlockingQueue 简介"></a>BlockingQueue 简介</h3><p>上面我们己经提到了 <code>ConcurrentLinkedQueue</code> 作为高性能的非阻塞队列。下面我们要讲到的是阻塞队列——<code>BlockingQueue</code>。阻塞队列（<code>BlockingQueue</code>）被广泛使用在“生产者-消费者”问题中，其原因是 <code>BlockingQueue</code> 提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。</p>
<p><code>BlockingQueue</code> 是一个接口，继承自 <code>Queue</code>，所以其实现类也可以作为 <code>Queue</code> 的实现来使用，而 <code>Queue</code> 又继承自 <code>Collection</code> 接口。下面是 <code>BlockingQueue</code> 的相关实现类：</p>
<p><img src="https://files.catbox.moe/myvc89.png"></p>
<p>下面主要介绍一下 3 个常见的 <code>BlockingQueue</code> 的实现类：<code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code> 、<code>PriorityBlockingQueue</code> 。</p>
<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p><code>ArrayBlockingQueue</code> 是 <code>BlockingQueue</code> 接口的有界队列实现类，底层采用数组来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayBlockingQueue</span>&lt;E&gt;</span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt;</span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">BlockingQueue</span>&lt;E&gt;, Serializable&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><code>ArrayBlockingQueue</code> 一旦创建，容量不能改变。其并发控制采用可重入锁 <code>ReentrantLock</code> ，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞。</p>
<p><code>ArrayBlockingQueue</code> 默认情况下不能保证线程访问队列的公平性，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到 <code>ArrayBlockingQueue</code>。而非公平性则是指访问 <code>ArrayBlockingQueue</code> 的顺序不是遵守严格的时间顺序，有可能存在，当 <code>ArrayBlockingQueue</code> 可以被访问时，长时间阻塞的线程依然无法访问到 <code>ArrayBlockingQueue</code>。如果保证公平性，通常会降低吞吐量。如果需要获得公平性的 <code>ArrayBlockingQueue</code>，可采用如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayBlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Integer&gt;(<span class="number">10</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p><code>LinkedBlockingQueue</code> 底层基于<strong>单向链表</strong>实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用，同样满足 FIFO 的特性，与 <code>ArrayBlockingQueue</code> 相比起来具有更高的吞吐量，为了防止 <code>LinkedBlockingQueue</code> 容量迅速增，损耗大量内存。通常在创建 <code>LinkedBlockingQueue</code> 对象时，会指定其大小，如果未指定，容量等于 <code>Integer.MAX_VALUE</code> 。</p>
<p><strong>相关构造方法:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *某种意义上的无界队列</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> LinkedBlockingQueue&#125; with a capacity of</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Integer#MAX_VALUE&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *有界队列</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> LinkedBlockingQueue&#125; with the given (fixed) capacity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity the capacity of this queue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> capacity&#125; is not greater</span></span><br><span class="line"><span class="comment"> *         than zero</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    last = head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p><code>PriorityBlockingQueue</code> 是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现 <code>compareTo()</code> 方法来指定元素排序规则，或者初始化时通过构造器参数 <code>Comparator</code> 来指定排序规则。</p>
<p><code>PriorityBlockingQueue</code> 并发控制采用的是可重入锁 <code>ReentrantLock</code>，队列为无界队列（<code>ArrayBlockingQueue</code> 是有界队列，<code>LinkedBlockingQueue</code> 也可以通过在构造函数中传入 <code>capacity</code> 指定队列最大的容量，但是 <code>PriorityBlockingQueue</code> 只能指定初始的队列大小，后面插入元素的时候，<strong>如果空间不够的话会自动扩容</strong>）。</p>
<p>简单地说，它就是 <code>PriorityQueue</code> 的线程安全版本。不可以插入 null 值，同时，插入队列的对象必须是可比较大小的（comparable），否则报 <code>ClassCastException</code> 异常。它的插入操作 put 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。</p>
<p><strong>推荐文章：</strong> <a href="https://javadoop.com/post/java-concurrent-queue">《解读 Java 并发队列 BlockingQueue》open in new window</a></p>
<h2 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h2><p>下面这部分内容参考了极客时间专栏<a href="https://time.geekbang.org/column/intro/126?code=zl3GYeAsRI4rEJIBNu5B/km7LSZsPDlGWQEpAYw5Vu0=&utm_term=SPoster">《数据结构与算法之美》open in new window</a>以及《实战 Java 高并发程序设计》。</p>
<p>为了引出 <code>ConcurrentSkipListMap</code>，先带着大家简单理解一下跳表。</p>
<p>对于一个单链表，即使链表是有序的，如果我们想要在其中查找某个数据，也只能从头到尾遍历链表，这样效率自然就会很低，跳表就不一样了。跳表是一种可以用来快速查找的数据结构，有点类似于平衡树。它们都可以对元素进行快速的查找。但一个重要的区别是：对平衡树的插入和删除往往很可能导致平衡树进行一次全局的调整。而对跳表的插入和删除只需要对整个数据结构的局部进行操作即可。这样带来的好处是：在高并发的情况下，你会需要一个全局锁来保证整个平衡树的线程安全。而对于跳表，你只需要部分锁即可。这样，在高并发环境下，你就可以拥有更好的性能。而就查询的性能而言，跳表的时间复杂度也是 <strong>O(logn)</strong> 所以在并发数据结构中，JDK 使用跳表来实现一个 Map。</p>
<p>跳表的本质是同时维护了多个链表，并且链表是分层的，</p>
<p><img src="https://files.catbox.moe/g17viu.png"></p>
<p>最低层的链表维护了跳表内所有的元素，每上面一层链表都是下面一层的子集。</p>
<p>跳表内的所有链表的元素都是排序的。查找时，可以从顶级链表开始找。一旦发现被查找的元素大于当前链表中的取值，就会转入下一层链表继续找。这也就是说在查找过程中，搜索是跳跃式的。如上图所示，在跳表中查找元素 18。</p>
<p><img src="https://files.catbox.moe/8507hd.png"></p>
<p>查找 18 的时候原来需要遍历 18 次，现在只需要 7 次即可。针对链表长度比较大的时候，构建索引查找效率的提升就会非常明显。</p>
<p>从上面很容易看出，<strong>跳表是一种利用空间换时间的算法。</strong></p>
<p>使用跳表实现 <code>Map</code> 和使用哈希算法实现 <code>Map</code> 的另外一个不同之处是：哈希并不会保存元素的顺序，而跳表内所有的元素都是排序的。因此在对跳表进行遍历时，你会得到一个有序的结果。所以，如果你的应用需要有序性，那么跳表就是你不二的选择。JDK 中实现这一数据结构的类是 <code>ConcurrentSkipListMap</code>。</p>
<h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《实战 Java 高并发程序设计》</li>
<li><a href="https://javadoop.com/post/java-concurrent-queue">https://javadoop.com/post/java-concurrent-queue</a></li>
<li><a href="https://juejin.im/post/5aeebd02518825672f19c546">https://juejin.im/post/5aeebd02518825672f19c546</a></li>
</ul>
<h1 id="AQS-详解"><a href="#AQS-详解" class="headerlink" title="AQS 详解"></a>AQS 详解</h1><p>开始之前，先来看几道常见的面试题！建议你带着这些问题来看这篇文章：</p>
<ul>
<li>何为 AQS？AQS 原理了解吗？</li>
<li><code>CountDownLatch</code> 和 <code>CyclicBarrier</code> 了解吗？两者的区别是什么？</li>
<li>用过 <code>Semaphore</code> 吗？应用场景了解吗？</li>
<li>……</li>
</ul>
<p>相关阅读：<a href="https://javaguide.cn/java/concurrent/reentrantlock.html">从 ReentrantLock 的实现看AQS的原理及应用</a></p>
<h2 id="AQS-简单介绍"><a href="#AQS-简单介绍" class="headerlink" title="AQS 简单介绍"></a>AQS 简单介绍</h2><p>AQS 的全称为 <code>AbstractQueuedSynchronizer</code> ，翻译过来的意思就是抽象队列同步器。这个类在 <code>java.util.concurrent.locks</code> 包下面。</p>
<p><img src="https://files.catbox.moe/kdyqz7.png"></p>
<p>AQS 就是一个抽象类，主要用来构建锁和同步器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AQS 为构建锁和同步器提供了一些通用功能的是实现，因此，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 <code>ReentrantLock</code>，<code>Semaphore</code>，其他的诸如 <code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>，<code>FutureTask</code>(jdk1.7) 等等皆是基于 AQS 的。</p>
<h2 id="AQS-原理"><a href="#AQS-原理" class="headerlink" title="AQS 原理"></a>AQS 原理</h2><blockquote>
<p>在面试中被问到并发知识的时候，大多都会被问到“请你说一下自己对于 AQS 原理的理解”。下面给大家一个示例供大家参考，面试不是背题，大家一定要加入自己的思想，即使加入不了自己的思想也要保证自己能够通俗的讲出来而不是背出来。</p>
</blockquote>
<p>下面大部分内容其实在 AQS 类注释上已经给出了，不过是英语看着比较吃力一点，感兴趣的话可以看看源码。</p>
<h3 id="AQS-原理概览"><a href="#AQS-原理概览" class="headerlink" title="AQS 原理概览"></a>AQS 原理概览</h3><p>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 <strong>CLH 队列锁</strong>实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<blockquote>
<p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p>
</blockquote>
<p>看个 AQS(<code>AbstractQueuedSynchronizer</code>)原理图：</p>
<p><img src="https://files.catbox.moe/gnl8vi.png"></p>
<p>AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;<span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure>

<p>状态信息通过 <code>protected</code> 类型的<code>getState()</code>，<code>setState()</code>，<code>compareAndSetState()</code> 进行操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">        state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AQS-对资源的共享方式"><a href="#AQS-对资源的共享方式" class="headerlink" title="AQS 对资源的共享方式"></a>AQS 对资源的共享方式</h3><p>AQS 定义两种资源共享方式</p>
<p><strong>Exclusive</strong>（独占）</p>
<p>只有一个线程能执行，如 <code>ReentrantLock</code>。又可分为公平锁和非公平锁，<code>ReentrantLock</code> 同时支持两种锁，下面以 <code>ReentrantLock</code> 对这两种锁的定义做介绍：</p>
<ul>
<li><strong>公平锁</strong> ：按照线程在队列中的排队顺序，先到者先拿到锁</li>
<li><strong>非公平锁</strong> ：当线程要获取锁时，先通过两次 CAS 操作去抢锁，如果没抢到，当前线程再加入到队列中等待唤醒。</li>
</ul>
<blockquote>
<p>说明：下面这部分关于 <code>ReentrantLock</code> 源代码内容节选自：<a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer-2">https://www.javadoop.com/post/AbstractQueuedSynchronizer-2</a> ，这是一篇很不错文章，推荐阅读。</p>
</blockquote>
<p><strong>下面来看 ReentrantLock 中相关的源代码：</strong></p>
<p><code>ReentrantLock</code> 默认采用非公平锁，因为考虑获得更好的性能，通过 <code>boolean</code> 来决定是否用公平锁（传入 true 用公平锁）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Synchronizer providing all implementation mechanics */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 默认非公平锁</span></span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ReentrantLock</code> 中公平锁的 <code>lock</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AbstractQueuedSynchronizer.acquire(int arg)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 1. 和非公平锁相比，这里多了一个判断：是否有线程在等待</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非公平锁的 <code>lock</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 2. 和公平锁相比，这里会直接先进行一次CAS，成功就返回了</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AbstractQueuedSynchronizer.acquire(int arg)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment"> * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里没有对阻塞队列进行判断</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：公平锁和非公平锁只有两处不同：</p>
<ol>
<li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li>
<li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 <code>tryAcquire</code> 方法，在 <code>tryAcquire</code> 方法中，如果发现锁这个时候被释放了（state &#x3D;&#x3D; 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li>
</ol>
<p>公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。</p>
<p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p>
<p><strong>Share</strong>（共享）</p>
<p>多个线程可同时执行，如 <code>Semaphore/CountDownLatch</code>。<code>Semaphore</code>、<code>CountDownLatch</code>、 <code>CyclicBarrier</code>、<code>ReadWriteLock</code> 我们都会在后面讲到。</p>
<p><code>ReentrantReadWriteLock</code> 可以看成是组合式，因为 <code>ReentrantReadWriteLock</code> 也就是读写锁允许多个线程同时对某一资源进行读。</p>
<p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS 已经在上层已经帮我们实现好了。</p>
<h3 id="AQS-底层使用了模板方法模式"><a href="#AQS-底层使用了模板方法模式" class="headerlink" title="AQS 底层使用了模板方法模式"></a>AQS 底层使用了模板方法模式</h3><p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p>
<ol>
<li>使用者继承 <code>AbstractQueuedSynchronizer</code> 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）</li>
<li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li>
</ol>
<p>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。</p>
<p><strong>AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的钩子方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span>)</span><span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span>)</span><span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span>)</span><span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span>)</span><span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span><span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br></pre></td></tr></table></figure>

<p><strong>什么是钩子方法呢？</strong> 钩子方法是一种被声明在抽象类中的方法，一般使用 <code>protected</code> 关键字修饰，它可以是空方法（由子类实现），也可以是默认实现的方法。模板设计模式通过钩子方法控制固定步骤的实现。</p>
<p>篇幅问题，这里就不详细介绍模板方法模式了，不太了解的小伙伴可以看看这篇文章：<a href="https://mp.weixin.qq.com/s/zpScSCktFpnSWHWIQem2jg">用Java8 改造后的模板方法模式真的是 yyds!open in new window</a>。</p>
<p>除了上面提到的钩子方法之外，AQS 类中的其他方法都是 <code>final</code> ，所以无法被其他类重写。</p>
<p>以 <code>ReentrantLock</code> 为例，state 初始化为 0，表示未锁定状态。A 线程 <code>lock()</code> 时，会调用 <code>tryAcquire()</code> 独占该锁并将 <code>state+1</code> 。此后，其他线程再 <code>tryAcquire()</code> 时就会失败，直到 A 线程 <code>unlock()</code> 到 <code>state=</code>0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多少次，这样才能保证 state 是能回到零态的。</p>
<p>再以 <code>CountDownLatch</code> 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后<code> countDown()</code> 一次，state 会 CAS(Compare and Swap) 减 1。等到所有子线程都执行完后(即 <code>state=0</code> )，会 <code>unpark()</code> 主调用线程，然后主调用线程就会从 <code>await()</code> 函数返回，继续后余动作。</p>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p>
<p>推荐两篇 AQS 原理和相关源码分析的文章：</p>
<ul>
<li><a href="https://www.cnblogs.com/waterystone/p/4920797.html">Java并发之AQS详解open in new window</a></li>
<li><a href="https://www.cnblogs.com/chengxiao/p/7141160.html">Java并发包基石-AQS详解open in new window</a></li>
</ul>
<h2 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore(信号量)"></a>Semaphore(信号量)</h2><p><code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，<code>Semaphore</code>(信号量)可以指定多个线程同时访问某个资源。</p>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Snailclimb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年9月30日</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 需要一次性拿一个许可的情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreExample1</span> &#123;</span><br><span class="line">  <span class="comment">// 请求的数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">550</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">300</span>);</span><br><span class="line">    <span class="comment">// 一次只能允许执行的线程数量。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadnum</span> <span class="operator">=</span> i;</span><br><span class="line">      threadPool.execute(() -&gt; &#123;<span class="comment">// Lambda 表达式的运用</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          semaphore.acquire();<span class="comment">// 获取一个许可，所以可运行线程数量为20/1=20</span></span><br><span class="line">          test(threadnum);</span><br><span class="line">          semaphore.release();<span class="comment">// 释放一个许可</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">    System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> threadnum)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">    System.out.println(<span class="string">&quot;threadnum:&quot;</span> + threadnum);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行 <code>acquire()</code> 方法阻塞，直到有一个许可证可以获得然后拿走一个许可证；每个 <code>release</code> 方法增加一个许可证，这可能会释放一个阻塞的 <code>acquire()</code> 方法。然而，其实并没有实际的许可证这个对象，<code>Semaphore</code> 只是维持了一个可获得许可证的数量。 <code>Semaphore</code> 经常用于限制获取某种资源的线程数量。</p>
<p>当然一次也可以一次拿取和释放多个许可，不过一般没有必要这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">semaphore.acquire(<span class="number">5</span>);<span class="comment">// 获取5个许可，所以可运行线程数量为20/5=4</span></span><br><span class="line">test(threadnum);</span><br><span class="line">semaphore.release(<span class="number">5</span>);<span class="comment">// 释放5个许可</span></span><br></pre></td></tr></table></figure>

<p>除了 <code>acquire()</code> 方法之外，另一个比较常用的与之对应的方法是 <code>tryAcquire()</code> 方法，该方法如果获取不到许可就立即返回 false。</p>
<p><code>Semaphore</code> 有两种模式，公平模式和非公平模式。</p>
<ul>
<li><strong>公平模式：</strong> 调用 <code>acquire()</code> 方法的顺序就是获取许可证的顺序，遵循 FIFO；</li>
<li><strong>非公平模式：</strong> 抢占式的。</li>
</ul>
<p><code>Semaphore</code> 对应的两个构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> permits)</span> &#123;</span><br><span class="line">     sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(permits);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> permits, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">     sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>(permits) : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(permits);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>这两个构造方法，都必须提供许可的数量，第二个构造方法可以指定是公平模式还是非公平模式，默认非公平模式。</strong></p>
<p><a href="https://github.com/Snailclimb/JavaGuide/issues/645">issue645 补充内容open in new window</a> ：<code>Semaphore</code> 与 <code>CountDownLatch</code> 一样，也是共享锁的一种实现。它默认构造 AQS 的 state 为 <code>permits</code>。当执行任务的线程数量超出 <code>permits</code>，那么多余的线程将会被放入阻塞队列 Park,并自旋判断 state 是否大于 0。只有当 state 大于 0 的时候，阻塞的线程才能继续执行,此时先前执行任务的线程继续执行 <code>release()</code> 方法，<code>release()</code> 方法使得 state 的变量会加 1，那么自旋的线程便会判断成功。 如此，每次只有最多不超过 <code>permits</code> 数量的线程能自旋成功，便限制了执行任务线程的数量。</p>
<h2 id="CountDownLatch-（倒计时器）"><a href="#CountDownLatch-（倒计时器）" class="headerlink" title="CountDownLatch （倒计时器）"></a>CountDownLatch （倒计时器）</h2><p><code>CountDownLatch</code> 允许 <code>count</code> 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</p>
<p><code>CountDownLatch</code> 是共享锁的一种实现,它默认构造 AQS 的 <code>state</code> 值为 <code>count</code>。当线程使用 <code>countDown()</code> 方法时,其实使用了<code>tryReleaseShared</code>方法以 CAS 的操作来减少 <code>state</code>,直至 <code>state</code> 为 0 。当调用 <code>await()</code> 方法的时候，如果 <code>state</code> 不为 0，那就证明任务还没有执行完毕，<code>await()</code> 方法就会一直阻塞，也就是说 <code>await()</code> 方法之后的语句不会被执行。然后，<code>CountDownLatch</code> 会自旋 CAS 判断 <code>state == 0</code>，如果 <code>state == 0</code> 的话，就会释放所有等待的线程，<code>await()</code> 方法之后的语句得到执行。</p>
<h3 id="CountDownLatch-的两种典型用法"><a href="#CountDownLatch-的两种典型用法" class="headerlink" title="CountDownLatch 的两种典型用法"></a>CountDownLatch 的两种典型用法</h3><p><strong>1、某一线程在开始运行前等待 n 个线程执行完毕。</strong></p>
<p>将 <code>CountDownLatch</code> 的计数器初始化为 n （<code>new CountDownLatch(n)</code>），每当一个任务线程执行完毕，就将计数器减 1 （<code>countdownlatch.countDown()</code>），当计数器的值变为 0 时，在 <code>CountDownLatch 上 await()</code> 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。</p>
<p><strong>2、实现多个线程开始执行任务的最大并行性。</strong></p>
<p>注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 <code>CountDownLatch</code> 对象，将其计数器初始化为 1 （<code>new CountDownLatch(1)</code>），多个线程在开始执行任务前首先 <code>coundownlatch.await()</code>，当主线程调用 <code>countDown()</code> 时，计数器变为 0，多个线程同时被唤醒。</p>
<h3 id="CountDownLatch-的使用示例"><a href="#CountDownLatch-的使用示例" class="headerlink" title="CountDownLatch 的使用示例"></a>CountDownLatch 的使用示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> SnailClimb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年10月1日</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: CountDownLatch 使用方法示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchExample1</span> &#123;</span><br><span class="line">  <span class="comment">// 请求的数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">550</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">300</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadnum</span> <span class="operator">=</span> i;</span><br><span class="line">      threadPool.execute(() -&gt; &#123;<span class="comment">// Lambda 表达式的运用</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          test(threadnum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          countDownLatch.countDown();<span class="comment">// 表示一个请求已经被完成</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">    System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> threadnum)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">    System.out.println(<span class="string">&quot;threadnum:&quot;</span> + threadnum);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，我们定义了请求的数量为 550，当这 550 个请求被处理完成之后，才会执行<code>System.out.println(&quot;finish&quot;);</code>。</p>
<p>与 <code>CountDownLatch</code> 的第一次交互是主线程等待其他线程。主线程必须在启动其他线程后立即调用 <code>CountDownLatch.await()</code> 方法。这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。</p>
<p>其他 N 个线程必须引用闭锁对象，因为他们需要通知 <code>CountDownLatch</code> 对象，他们已经完成了各自的任务。这种通知机制是通过 <code>CountDownLatch.countDown()</code>方法来完成的；每调用一次这个方法，在构造函数中初始化的 count 值就减 1。所以当 N 个线程都调 用了这个方法，count 的值等于 0，然后主线程就能通过 <code>await()</code>方法，恢复执行自己的任务。</p>
<p>再插一嘴：<code>CountDownLatch</code> 的 <code>await()</code> 方法使用不当很容易产生死锁，比如我们上面代码中的 for 循环改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount-<span class="number">1</span>; i++) &#123;</span><br><span class="line">.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就导致 <code>count</code> 的值没办法等于 0，然后就会导致一直等待。</p>
<h3 id="CountDownLatch-的不足"><a href="#CountDownLatch-的不足" class="headerlink" title="CountDownLatch 的不足"></a>CountDownLatch 的不足</h3><p><code>CountDownLatch</code> 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 <code>CountDownLatch</code> 使用完毕后，它不能再次被使用。</p>
<h3 id="CountDownLatch-相常见面试题"><a href="#CountDownLatch-相常见面试题" class="headerlink" title="CountDownLatch 相常见面试题"></a>CountDownLatch 相常见面试题</h3><ul>
<li><code>CountDownLatch</code> 怎么用？应用场景是什么？</li>
<li><code>CountDownLatch</code> 和 <code>CyclicBarrier</code> 的不同之处？</li>
<li><code>CountDownLatch</code> 类中主要的方法？</li>
</ul>
<h2 id="CyclicBarrier-循环栅栏"><a href="#CyclicBarrier-循环栅栏" class="headerlink" title="CyclicBarrier(循环栅栏)"></a>CyclicBarrier(循环栅栏)</h2><p><code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 非常类似，它也可以实现线程间的技术等待，但是它的功能比 <code>CountDownLatch</code> 更加复杂和强大。主要应用场景和 <code>CountDownLatch</code> 类似。</p>
<blockquote>
<p><code>CountDownLatch</code> 的实现是基于 AQS 的，而 <code>CycliBarrier</code> 是基于 <code>ReentrantLock</code>(<code>ReentrantLock</code> 也属于 AQS 同步器)和 <code>Condition</code> 的。</p>
</blockquote>
<p><code>CyclicBarrier</code> 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是：让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</p>
<p><code>CyclicBarrier</code> 默认的构造方法是 <code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用 <code>await()</code> 方法告诉 <code>CyclicBarrier</code> 我已经到达了屏障，然后当前线程被阻塞。</p>
<p>再来看一下它的构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(parties, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.parties = parties;</span><br><span class="line">    <span class="built_in">this</span>.count = parties;</span><br><span class="line">    <span class="built_in">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，parties 就代表了有拦截的线程的数量，当拦截的线程数量达到这个值的时候就打开栅栏，让所有线程通过。</p>
<h3 id="CyclicBarrier-的应用场景"><a href="#CyclicBarrier-的应用场景" class="headerlink" title="CyclicBarrier 的应用场景"></a>CyclicBarrier 的应用场景</h3><p><code>CyclicBarrier</code> 可以用于多线程计算数据，最后合并计算结果的应用场景。比如我们用一个 Excel 保存了用户所有银行流水，每个 Sheet 保存一个帐户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个 sheet 里的银行流水，都执行完之后，得到每个 sheet 的日均银行流水，最后，再用 barrierAction 用这些线程的计算结果，计算出整个 Excel 的日均银行流水。</p>
<h3 id="CyclicBarrier-的使用示例"><a href="#CyclicBarrier-的使用示例" class="headerlink" title="CyclicBarrier 的使用示例"></a>CyclicBarrier 的使用示例</h3><p>示例 1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Snailclimb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年10月1日</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 测试 CyclicBarrier 类中带参数的 await() 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierExample2</span> &#123;</span><br><span class="line">  <span class="comment">// 请求的数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">550</span>;</span><br><span class="line">  <span class="comment">// 需要同步的线程数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 创建线程池</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadNum</span> <span class="operator">=</span> i;</span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      threadPool.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          test(threadNum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> threadnum)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;threadnum:&quot;</span> + threadnum + <span class="string">&quot;is ready&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">/**等待60秒，保证子线程完全执行结束*/</span></span><br><span class="line">      cyclicBarrier.await(<span class="number">60</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;-----CyclicBarrierException------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;threadnum:&quot;</span> + threadnum + <span class="string">&quot;is finish&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">threadnum:0is ready</span><br><span class="line">threadnum:1is ready</span><br><span class="line">threadnum:2is ready</span><br><span class="line">threadnum:3is ready</span><br><span class="line">threadnum:4is ready</span><br><span class="line">threadnum:4is finish</span><br><span class="line">threadnum:0is finish</span><br><span class="line">threadnum:1is finish</span><br><span class="line">threadnum:2is finish</span><br><span class="line">threadnum:3is finish</span><br><span class="line">threadnum:5is ready</span><br><span class="line">threadnum:6is ready</span><br><span class="line">threadnum:7is ready</span><br><span class="line">threadnum:8is ready</span><br><span class="line">threadnum:9is ready</span><br><span class="line">threadnum:9is finish</span><br><span class="line">threadnum:5is finish</span><br><span class="line">threadnum:8is finish</span><br><span class="line">threadnum:7is finish</span><br><span class="line">threadnum:6is finish</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>可以看到当线程数量也就是请求数量达到我们定义的 5 个的时候， <code>await()</code> 方法之后的方法才被执行。</p>
<p>另外，<code>CyclicBarrier</code> 还提供一个更高级的构造函数 <code>CyclicBarrier(int parties, Runnable barrierAction)</code>，用于在线程到达屏障时，优先执行 <code>barrierAction</code>，方便处理更复杂的业务场景。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> SnailClimb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年10月1日</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 新建 CyclicBarrier 的时候指定一个 Runnable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierExample3</span> &#123;</span><br><span class="line">  <span class="comment">// 请求的数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">550</span>;</span><br><span class="line">  <span class="comment">// 需要同步的线程数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">5</span>, () -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;------当线程数达到之后，优先执行------&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 创建线程池</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadNum</span> <span class="operator">=</span> i;</span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      threadPool.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          test(threadNum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> threadnum)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;threadnum:&quot;</span> + threadnum + <span class="string">&quot;is ready&quot;</span>);</span><br><span class="line">    cyclicBarrier.await();</span><br><span class="line">    System.out.println(<span class="string">&quot;threadnum:&quot;</span> + threadnum + <span class="string">&quot;is finish&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">threadnum:0is ready</span><br><span class="line">threadnum:1is ready</span><br><span class="line">threadnum:2is ready</span><br><span class="line">threadnum:3is ready</span><br><span class="line">threadnum:4is ready</span><br><span class="line">------当线程数达到之后，优先执行------</span><br><span class="line">threadnum:4is finish</span><br><span class="line">threadnum:0is finish</span><br><span class="line">threadnum:2is finish</span><br><span class="line">threadnum:1is finish</span><br><span class="line">threadnum:3is finish</span><br><span class="line">threadnum:5is ready</span><br><span class="line">threadnum:6is ready</span><br><span class="line">threadnum:7is ready</span><br><span class="line">threadnum:8is ready</span><br><span class="line">threadnum:9is ready</span><br><span class="line">------当线程数达到之后，优先执行------</span><br><span class="line">threadnum:9is finish</span><br><span class="line">threadnum:5is finish</span><br><span class="line">threadnum:6is finish</span><br><span class="line">threadnum:8is finish</span><br><span class="line">threadnum:7is finish</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h3 id="CyclicBarrier-源码分析"><a href="#CyclicBarrier-源码分析" class="headerlink" title="CyclicBarrier 源码分析"></a>CyclicBarrier 源码分析</h3><p>当调用 <code>CyclicBarrier</code> 对象调用 <code>await()</code> 方法时，实际上调用的是 <code>dowait(false, 0L)</code>方法。 <code>await()</code> 方法就像树立起一个栅栏的行为一样，将线程挡住了，当拦住的线程数量达到 <code>parties</code> 的值时，栅栏才会打开，线程才得以通过执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> dowait(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">   	 <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(toe); <span class="comment">// cannot happen</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dowait(false, 0L)</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当线程数量或者请求数量达到 count 时 await 之后的方法才会被执行。上面的示例中 count 的值就为 5。</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Main barrier code, covering the various policies.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dowait</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span><br><span class="line">           TimeoutException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 锁住</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Generation</span> <span class="variable">g</span> <span class="operator">=</span> generation;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果线程中断了，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout减1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> --count;</span><br><span class="line">        <span class="comment">// 当 count 数量减为 0 之后说明最后一个线程已经到达栅栏了，也就是达到了可以执行await 方法之后的条件</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">ranAction</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">command</span> <span class="operator">=</span> barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="literal">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 将 count 重置为 parties 属性的初始化值</span></span><br><span class="line">                <span class="comment">// 唤醒之前等待的线程</span></span><br><span class="line">                <span class="comment">// 下一波执行开始</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// We&#x27;re about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">// &quot;belong&quot; to subsequent execution.</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：<code>CyclicBarrier</code> 内部通过一个 count 变量作为计数器，count 的初始值为 parties 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减一。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务。</p>
<h3 id="CyclicBarrier-和-CountDownLatch-的区别"><a href="#CyclicBarrier-和-CountDownLatch-的区别" class="headerlink" title="CyclicBarrier 和 CountDownLatch 的区别"></a>CyclicBarrier 和 CountDownLatch 的区别</h3><p>下面这个是国外一个大佬的回答：</p>
<p><code>CountDownLatch</code> 是计数器，只能使用一次，而 <code>CyclicBarrier</code> 的计数器提供 <code>reset</code> 功能，可以多次使用。但是我不那么认为它们之间的区别仅仅就是这么简单的一点。我们来从 jdk 作者设计的目的来看，javadoc 是这么描述它们的：</p>
<blockquote>
<p>CountDownLatch: A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.(CountDownLatch: 一个或者多个线程，等待其他多个线程完成某件事情之后才能执行；) CyclicBarrier : A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point.(CyclicBarrier : 多个线程互相等待，直到到达同一个同步点，再继续一起执行。)</p>
</blockquote>
<p>对于 <code>CountDownLatch</code> 来说，重点是“一个线程（多个线程）等待”，而其他的 N 个线程在完成“某件事情”之后，可以终止，也可以等待。而对于 <code>CyclicBarrier</code>，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。</p>
<p><code>CountDownLatch</code> 是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而 <code>CyclicBarrier</code> 更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。</p>
<h3 id="ReentrantLock-和-ReentrantReadWriteLock"><a href="#ReentrantLock-和-ReentrantReadWriteLock" class="headerlink" title="ReentrantLock 和 ReentrantReadWriteLock"></a>ReentrantLock 和 ReentrantReadWriteLock</h3><p><code>ReentrantLock</code> 和 <code>synchronized</code> 的区别在上面已经讲过了这里就不多做讲解。另外，需要注意的是：读写锁 <code>ReentrantReadWriteLock</code> 可以保证多个线程可以同时读，所以在读操作远大于写操作的时候，读写锁就非常有用了。</p>
<h1 id="Atomic-原子类总结"><a href="#Atomic-原子类总结" class="headerlink" title="Atomic 原子类总结"></a>Atomic 原子类总结</h1><h2 id="Atomic-原子类介绍"><a href="#Atomic-原子类介绍" class="headerlink" title="Atomic 原子类介绍"></a>Atomic 原子类介绍</h2><p>Atomic 翻译成中文是原子的意思。在化学上，我们知道原子是构成一般物质的最小单位，在化学反应中是不可分割的。在我们这里 Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。</p>
<p>所以，所谓原子类说简单点就是具有原子&#x2F;原子操作特征的类。</p>
<p>并发包 <code>java.util.concurrent</code> 的原子类都存放在<code>java.util.concurrent.atomic</code>下,如下图所示。</p>
<p><img src="https://files.catbox.moe/be5dwd.png"></p>
<p>根据操作的数据类型，可以将 JUC 包中的原子类分为 4 类</p>
<p><strong>基本类型</strong></p>
<p>使用原子的方式更新基本类型</p>
<ul>
<li>AtomicInteger：整型原子类</li>
<li>AtomicLong：长整型原子类</li>
<li>AtomicBoolean ：布尔型原子类</li>
</ul>
<p><strong>数组类型</strong></p>
<p>使用原子的方式更新数组里的某个元素</p>
<ul>
<li>AtomicIntegerArray：整型数组原子类</li>
<li>AtomicLongArray：长整型数组原子类</li>
<li>AtomicReferenceArray ：引用类型数组原子类</li>
</ul>
<p><strong>引用类型</strong></p>
<ul>
<li>AtomicReference：引用类型原子类</li>
<li>AtomicMarkableReference：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来，也可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li>
<li>AtomicStampedReference ：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li>
</ul>
<p><strong>对象的属性修改类型</strong></p>
<ul>
<li>AtomicIntegerFieldUpdater:原子更新整型字段的更新器</li>
<li>AtomicLongFieldUpdater：原子更新长整型字段的更新器</li>
<li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段</li>
</ul>
<blockquote>
<p><strong>🐛 修正（参见：issue#626open in new window）</strong> : <code>AtomicMarkableReference</code> 不能解决 ABA 问题。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">AtomicMarkableReference是将一个boolean值作是否有更改的标记，本质就是它的版本号只有两个，true和false，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">修改的时候在这两个版本号之间来回切换，这样做并不能解决ABA的问题，只是会降低ABA问题发生的几率而已</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"><span class="doctag">@author</span> : mazh</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"><span class="doctag">@Date</span> : 2020/1/17 14:41</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SolveABAByAtomicMarkableReference</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicMarkableReference</span> <span class="variable">atomicMarkableReference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicMarkableReference</span>(<span class="number">100</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">refT1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                atomicMarkableReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, atomicMarkableReference.isMarked(), !atomicMarkableReference.isMarked());</span><br><span class="line">                atomicMarkableReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, atomicMarkableReference.isMarked(), !atomicMarkableReference.isMarked());</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">refT2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">marked</span> <span class="operator">=</span> atomicMarkableReference.isMarked();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">c3</span> <span class="operator">=</span> atomicMarkableReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, marked, !marked);</span><br><span class="line">                System.out.println(c3); <span class="comment">// 返回true,实际应该返回false</span></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            refT1.start();</span><br><span class="line">            refT2.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>CAS ABA 问题</strong></p>
<ul>
<li>描述: 第一个线程取到了变量 x 的值 A，然后巴拉巴拉干别的事，总之就是只拿到了变量 x 的值 A。这段时间内第二个线程也取到了变量 x 的值 A，然后把变量 x 的值改为 B，然后巴拉巴拉干别的事，最后又把变量 x 的值变为 A （相当于还原了）。在这之后第一个线程终于进行了变量 x 的操作，但是此时变量 x 的值还是 A，所以 compareAndSet 操作是成功。</li>
<li>例子描述(可能不太合适，但好理解): 年初，现金为零，然后通过正常劳动赚了三百万，之后正常消费了（比如买房子）三百万。年末，虽然现金零收入（可能变成其他形式了），但是赚了钱是事实，还是得交税的！</li>
<li>代码例子（以<code>AtomicInteger</code>为例）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerDefectDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        defectOfABA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">defectOfABA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">coreThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">currentValue</span> <span class="operator">=</span> atomicInteger.get();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ------ currentValue=&quot;</span> + currentValue);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 这段目的：模拟处理其他业务花费的时间</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">300</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">casResult</span> <span class="operator">=</span> atomicInteger.compareAndSet(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">&quot; ------ currentValue=&quot;</span> + currentValue</span><br><span class="line">                            + <span class="string">&quot;, finalValue=&quot;</span> + atomicInteger.get()</span><br><span class="line">                            + <span class="string">&quot;, compareAndSet Result=&quot;</span> + casResult);</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        coreThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这段目的：为了让 coreThread 线程先跑起来</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">amateurThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">currentValue</span> <span class="operator">=</span> atomicInteger.get();</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">casResult</span> <span class="operator">=</span> atomicInteger.compareAndSet(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">&quot; ------ currentValue=&quot;</span> + currentValue</span><br><span class="line">                            + <span class="string">&quot;, finalValue=&quot;</span> + atomicInteger.get()</span><br><span class="line">                            + <span class="string">&quot;, compareAndSet Result=&quot;</span> + casResult);</span><br><span class="line"></span><br><span class="line">                    currentValue = atomicInteger.get();</span><br><span class="line">                    casResult = atomicInteger.compareAndSet(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">&quot; ------ currentValue=&quot;</span> + currentValue</span><br><span class="line">                            + <span class="string">&quot;, finalValue=&quot;</span> + atomicInteger.get()</span><br><span class="line">                            + <span class="string">&quot;, compareAndSet Result=&quot;</span> + casResult);</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        amateurThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread-<span class="number">0</span> ------ currentValue=<span class="number">1</span></span><br><span class="line">Thread-<span class="number">1</span> ------ currentValue=<span class="number">1</span>, finalValue=<span class="number">2</span>, compareAndSet Result=<span class="literal">true</span></span><br><span class="line">Thread-<span class="number">1</span> ------ currentValue=<span class="number">2</span>, finalValue=<span class="number">1</span>, compareAndSet Result=<span class="literal">true</span></span><br><span class="line">Thread-<span class="number">0</span> ------ currentValue=<span class="number">1</span>, finalValue=<span class="number">2</span>, compareAndSet Result=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>下面我们来详细介绍一下这些原子类。</p>
<h2 id="基本类型原子类"><a href="#基本类型原子类" class="headerlink" title="基本类型原子类"></a>基本类型原子类</h2><h3 id="基本类型原子类介绍"><a href="#基本类型原子类介绍" class="headerlink" title="基本类型原子类介绍"></a>基本类型原子类介绍</h3><p>使用原子的方式更新基本类型</p>
<ul>
<li>AtomicInteger：整型原子类</li>
<li>AtomicLong：长整型原子类</li>
<li>AtomicBoolean ：布尔型原子类</li>
</ul>
<p>上面三个类提供的方法几乎相同，所以我们这里以 AtomicInteger 为例子来介绍。</p>
<p><strong>AtomicInteger 类常用方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lazySet</span><span class="params">(<span class="type">int</span> newValue)</span><span class="comment">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span><br></pre></td></tr></table></figure>

<h3 id="AtomicInteger-常见方法使用"><a href="#AtomicInteger-常见方法使用" class="headerlink" title="AtomicInteger 常见方法使用"></a>AtomicInteger 常见方法使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">temvalue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">AtomicInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">		temvalue = i.getAndSet(<span class="number">3</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;temvalue:&quot;</span> + temvalue + <span class="string">&quot;;  i:&quot;</span> + i);<span class="comment">//temvalue:0;  i:3</span></span><br><span class="line">		temvalue = i.getAndIncrement();</span><br><span class="line">		System.out.println(<span class="string">&quot;temvalue:&quot;</span> + temvalue + <span class="string">&quot;;  i:&quot;</span> + i);<span class="comment">//temvalue:3;  i:4</span></span><br><span class="line">		temvalue = i.getAndAdd(<span class="number">5</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;temvalue:&quot;</span> + temvalue + <span class="string">&quot;;  i:&quot;</span> + i);<span class="comment">//temvalue:4;  i:9</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基本数据类型原子类的优势"><a href="#基本数据类型原子类的优势" class="headerlink" title="基本数据类型原子类的优势"></a>基本数据类型原子类的优势</h3><p>通过一个简单例子带大家看一下基本数据类型原子类的优势</p>
<p><strong>① 多线程环境不使用原子类保证线程安全（基本数据类型）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//若要线程安全执行执行count++，需要加锁</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">                  count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>② 多线程环境使用原子类保证线程安全（基本数据类型）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">                  count.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//使用AtomicInteger之后，不需要加锁，也可以实现线程安全。</span></span><br><span class="line">       <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> count.get();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AtomicInteger-线程安全原理简单分析"><a href="#AtomicInteger-线程安全原理简单分析" class="headerlink" title="AtomicInteger 线程安全原理简单分析"></a>AtomicInteger 线程安全原理简单分析</h3><p>AtomicInteger 类的部分源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br></pre></td></tr></table></figure>

<p>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
<p>CAS 的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址。另外 value 是一个 volatile 变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p>
<h2 id="数组类型原子类"><a href="#数组类型原子类" class="headerlink" title="数组类型原子类"></a>数组类型原子类</h2><h3 id="数组类型原子类介绍"><a href="#数组类型原子类介绍" class="headerlink" title="数组类型原子类介绍"></a>数组类型原子类介绍</h3><p>使用原子的方式更新数组里的某个元素</p>
<ul>
<li>AtomicIntegerArray：整形数组原子类</li>
<li>AtomicLongArray：长整形数组原子类</li>
<li>AtomicReferenceArray ：引用类型数组原子类</li>
</ul>
<p>上面三个类提供的方法几乎相同，所以我们这里以 AtomicIntegerArray 为例子来介绍。</p>
<p><strong>AtomicIntegerArray 类常用方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">//获取 index=i 位置元素的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> newValue)</span><span class="comment">//返回 index=i 位置的当前的值，并将其设置为新值：newValue</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">(<span class="type">int</span> i)</span><span class="comment">//获取 index=i 位置元素的值，并让该位置的元素自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">//获取 index=i 位置元素的值，并让该位置的元素自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> delta)</span> <span class="comment">//获取 index=i 位置元素的值，并加上预期的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> expect, <span class="type">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将 index=i 位置的元素值设置为输入值（update）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lazySet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> newValue)</span><span class="comment">//最终 将index=i 位置的元素设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span><br></pre></td></tr></table></figure>

<h3 id="AtomicIntegerArray-常见方法使用"><a href="#AtomicIntegerArray-常见方法使用" class="headerlink" title="AtomicIntegerArray 常见方法使用"></a>AtomicIntegerArray 常见方法使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerArrayTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">temvalue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span>[] nums = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">		<span class="type">AtomicIntegerArray</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(nums);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">			System.out.println(i.get(j));</span><br><span class="line">		&#125;</span><br><span class="line">		temvalue = i.getAndSet(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;temvalue:&quot;</span> + temvalue + <span class="string">&quot;;  i:&quot;</span> + i);</span><br><span class="line">		temvalue = i.getAndIncrement(<span class="number">0</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;temvalue:&quot;</span> + temvalue + <span class="string">&quot;;  i:&quot;</span> + i);</span><br><span class="line">		temvalue = i.getAndAdd(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;temvalue:&quot;</span> + temvalue + <span class="string">&quot;;  i:&quot;</span> + i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="引用类型原子类"><a href="#引用类型原子类" class="headerlink" title="引用类型原子类"></a>引用类型原子类</h2><h3 id="引用类型原子类介绍"><a href="#引用类型原子类介绍" class="headerlink" title="引用类型原子类介绍"></a>引用类型原子类介绍</h3><p>基本类型原子类只能更新一个变量，如果需要原子更新多个变量，需要使用 引用类型原子类。</p>
<ul>
<li>AtomicReference：引用类型原子类</li>
<li>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li>
<li>AtomicMarkableReference ：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来，也可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li>
</ul>
<p>上面三个类提供的方法几乎相同，所以我们这里以 AtomicReference 为例子来介绍。</p>
<h3 id="AtomicReference-类使用示例"><a href="#AtomicReference-类使用示例" class="headerlink" title="AtomicReference 类使用示例"></a>AtomicReference 类使用示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicReferenceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		AtomicReference&lt;Person&gt; ar = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;Person&gt;();</span><br><span class="line">		<span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;SnailClimb&quot;</span>, <span class="number">22</span>);</span><br><span class="line">		ar.set(person);</span><br><span class="line">		<span class="type">Person</span> <span class="variable">updatePerson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Daisy&quot;</span>, <span class="number">20</span>);</span><br><span class="line">		ar.compareAndSet(person, updatePerson);</span><br><span class="line"></span><br><span class="line">		System.out.println(ar.get().getName());</span><br><span class="line">		System.out.println(ar.get().getAge());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码首先创建了一个 Person 对象，然后把 Person 对象设置进 AtomicReference 对象中，然后调用 compareAndSet 方法，该方法就是通过 CAS 操作设置 ar。如果 ar 的值为 person 的话，则将其设置为 updatePerson。实现原理与 AtomicInteger 类中的 compareAndSet 方法相同。运行上面的代码后的输出结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Daisy</span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure>

<h3 id="AtomicStampedReference-类使用示例"><a href="#AtomicStampedReference-类使用示例" class="headerlink" title="AtomicStampedReference 类使用示例"></a>AtomicStampedReference 类使用示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicStampedReferenceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 实例化、取当前值和 stamp 值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">initialRef</span> <span class="operator">=</span> <span class="number">0</span>, initialStamp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> AtomicStampedReference&lt;Integer&gt; asr = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(initialRef, initialStamp);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + asr.getReference() + <span class="string">&quot;, currentStamp=&quot;</span> + asr.getStamp());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compare and set</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">newReference</span> <span class="operator">=</span> <span class="number">666</span>, newStamp = <span class="number">999</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">casResult</span> <span class="operator">=</span> asr.compareAndSet(initialRef, newReference, initialStamp, newStamp);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + asr.getReference()</span><br><span class="line">                + <span class="string">&quot;, currentStamp=&quot;</span> + asr.getStamp()</span><br><span class="line">                + <span class="string">&quot;, casResult=&quot;</span> + casResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前的值和当前的 stamp 值</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">currentValue</span> <span class="operator">=</span> asr.get(arr);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">currentStamp</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + currentValue + <span class="string">&quot;, currentStamp=&quot;</span> + currentStamp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单独设置 stamp 值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">attemptStampResult</span> <span class="operator">=</span> asr.attemptStamp(newReference, <span class="number">88</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + asr.getReference()</span><br><span class="line">                + <span class="string">&quot;, currentStamp=&quot;</span> + asr.getStamp()</span><br><span class="line">                + <span class="string">&quot;, attemptStampResult=&quot;</span> + attemptStampResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新设置当前值和 stamp 值</span></span><br><span class="line">        asr.set(initialRef, initialStamp);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + asr.getReference() + <span class="string">&quot;, currentStamp=&quot;</span> + asr.getStamp());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [不推荐使用，除非搞清楚注释的意思了] weak compare and set</span></span><br><span class="line">        <span class="comment">// 困惑！weakCompareAndSet 这个方法最终还是调用 compareAndSet 方法。[版本: jdk-8u191]</span></span><br><span class="line">        <span class="comment">// 但是注释上写着 &quot;May fail spuriously and does not provide ordering guarantees,</span></span><br><span class="line">        <span class="comment">// so is only rarely an appropriate alternative to compareAndSet.&quot;</span></span><br><span class="line">        <span class="comment">// todo 感觉有可能是 jvm 通过方法名在 native 方法里面做了转发</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">wCasResult</span> <span class="operator">=</span> asr.weakCompareAndSet(initialRef, newReference, initialStamp, newStamp);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + asr.getReference()</span><br><span class="line">                + <span class="string">&quot;, currentStamp=&quot;</span> + asr.getStamp()</span><br><span class="line">                + <span class="string">&quot;, wCasResult=&quot;</span> + wCasResult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">currentValue=<span class="number">0</span>, currentStamp=<span class="number">0</span></span><br><span class="line">currentValue=<span class="number">666</span>, currentStamp=<span class="number">999</span>, casResult=<span class="literal">true</span></span><br><span class="line">currentValue=<span class="number">666</span>, currentStamp=<span class="number">999</span></span><br><span class="line">currentValue=<span class="number">666</span>, currentStamp=<span class="number">88</span>, attemptStampResult=<span class="literal">true</span></span><br><span class="line">currentValue=<span class="number">0</span>, currentStamp=<span class="number">0</span></span><br><span class="line">currentValue=<span class="number">666</span>, currentStamp=<span class="number">999</span>, wCasResult=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="AtomicMarkableReference-类使用示例"><a href="#AtomicMarkableReference-类使用示例" class="headerlink" title="AtomicMarkableReference 类使用示例"></a>AtomicMarkableReference 类使用示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicMarkableReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicMarkableReferenceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 实例化、取当前值和 mark 值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Boolean</span> <span class="variable">initialRef</span> <span class="operator">=</span> <span class="literal">null</span>, initialMark = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">final</span> AtomicMarkableReference&lt;Boolean&gt; amr = <span class="keyword">new</span> <span class="title class_">AtomicMarkableReference</span>&lt;&gt;(initialRef, initialMark);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + amr.getReference() + <span class="string">&quot;, currentMark=&quot;</span> + amr.isMarked());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compare and set</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Boolean</span> <span class="variable">newReference1</span> <span class="operator">=</span> <span class="literal">true</span>, newMark1 = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">casResult</span> <span class="operator">=</span> amr.compareAndSet(initialRef, newReference1, initialMark, newMark1);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + amr.getReference()</span><br><span class="line">                + <span class="string">&quot;, currentMark=&quot;</span> + amr.isMarked()</span><br><span class="line">                + <span class="string">&quot;, casResult=&quot;</span> + casResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前的值和当前的 mark 值</span></span><br><span class="line">        <span class="type">boolean</span>[] arr = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Boolean</span> <span class="variable">currentValue</span> <span class="operator">=</span> amr.get(arr);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">currentMark</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + currentValue + <span class="string">&quot;, currentMark=&quot;</span> + currentMark);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单独设置 mark 值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">attemptMarkResult</span> <span class="operator">=</span> amr.attemptMark(newReference1, <span class="literal">false</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + amr.getReference()</span><br><span class="line">                + <span class="string">&quot;, currentMark=&quot;</span> + amr.isMarked()</span><br><span class="line">                + <span class="string">&quot;, attemptMarkResult=&quot;</span> + attemptMarkResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新设置当前值和 mark 值</span></span><br><span class="line">        amr.set(initialRef, initialMark);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + amr.getReference() + <span class="string">&quot;, currentMark=&quot;</span> + amr.isMarked());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [不推荐使用，除非搞清楚注释的意思了] weak compare and set</span></span><br><span class="line">        <span class="comment">// 困惑！weakCompareAndSet 这个方法最终还是调用 compareAndSet 方法。[版本: jdk-8u191]</span></span><br><span class="line">        <span class="comment">// 但是注释上写着 &quot;May fail spuriously and does not provide ordering guarantees,</span></span><br><span class="line">        <span class="comment">// so is only rarely an appropriate alternative to compareAndSet.&quot;</span></span><br><span class="line">        <span class="comment">// todo 感觉有可能是 jvm 通过方法名在 native 方法里面做了转发</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">wCasResult</span> <span class="operator">=</span> amr.weakCompareAndSet(initialRef, newReference1, initialMark, newMark1);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + amr.getReference()</span><br><span class="line">                + <span class="string">&quot;, currentMark=&quot;</span> + amr.isMarked()</span><br><span class="line">                + <span class="string">&quot;, wCasResult=&quot;</span> + wCasResult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">currentValue=<span class="literal">null</span>, currentMark=<span class="literal">false</span></span><br><span class="line">currentValue=<span class="literal">true</span>, currentMark=<span class="literal">true</span>, casResult=<span class="literal">true</span></span><br><span class="line">currentValue=<span class="literal">true</span>, currentMark=<span class="literal">true</span></span><br><span class="line">currentValue=<span class="literal">true</span>, currentMark=<span class="literal">false</span>, attemptMarkResult=<span class="literal">true</span></span><br><span class="line">currentValue=<span class="literal">null</span>, currentMark=<span class="literal">false</span></span><br><span class="line">currentValue=<span class="literal">true</span>, currentMark=<span class="literal">true</span>, wCasResult=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="对象的属性修改类型原子类"><a href="#对象的属性修改类型原子类" class="headerlink" title="对象的属性修改类型原子类"></a>对象的属性修改类型原子类</h2><h3 id="对象的属性修改类型原子类介绍"><a href="#对象的属性修改类型原子类介绍" class="headerlink" title="对象的属性修改类型原子类介绍"></a>对象的属性修改类型原子类介绍</h3><p>如果需要原子更新某个类里的某个字段时，需要用到对象的属性修改类型原子类。</p>
<ul>
<li>AtomicIntegerFieldUpdater:原子更新整形字段的更新器</li>
<li>AtomicLongFieldUpdater：原子更新长整形字段的更新器</li>
<li>AtomicReferenceFieldUpdater ：原子更新引用类型里的字段的更新器</li>
</ul>
<p>要想原子地更新对象的属性需要两步。第一步，因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法 newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。第二步，更新的对象属性必须使用 public volatile 修饰符。</p>
<p>上面三个类提供的方法几乎相同，所以我们这里以 <code>AtomicIntegerFieldUpdater</code>为例子来介绍。</p>
<h3 id="AtomicIntegerFieldUpdater-类使用示例"><a href="#AtomicIntegerFieldUpdater-类使用示例" class="headerlink" title="AtomicIntegerFieldUpdater 类使用示例"></a>AtomicIntegerFieldUpdater 类使用示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerFieldUpdater;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerFieldUpdaterTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		AtomicIntegerFieldUpdater&lt;User&gt; a = AtomicIntegerFieldUpdater.newUpdater(User.class, <span class="string">&quot;age&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Java&quot;</span>, <span class="number">22</span>);</span><br><span class="line">		System.out.println(a.getAndIncrement(user));<span class="comment">// 22</span></span><br><span class="line">		System.out.println(a.get(user));<span class="comment">// 23</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">23</span></span><br></pre></td></tr></table></figure>

<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>《Java 并发编程的艺术》</li>
</ul>
<h1 id="ThreadLocal-详解"><a href="#ThreadLocal-详解" class="headerlink" title="ThreadLocal 详解"></a>ThreadLocal 详解</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><img src="https://files.catbox.moe/fej7la.png"></p>
<p><strong>全文共 10000+字，31 张图，这篇文章同样耗费了不少的时间和精力才创作完成，原创不易，请大家点点关注+在看，感谢。</strong></p>
<p>对于<code>ThreadLocal</code>，大家的第一反应可能是很简单呀，线程的变量副本，每个线程隔离。那这里有几个问题大家可以思考一下：</p>
<ul>
<li><code>ThreadLocal</code>的 key 是<strong>弱引用</strong>，那么在 <code>ThreadLocal.get()</code>的时候，发生<strong>GC</strong>之后，key 是否为<strong>null</strong>？</li>
<li><code>ThreadLocal</code>中<code>ThreadLocalMap</code>的<strong>数据结构</strong>？</li>
<li><code>ThreadLocalMap</code>的<strong>Hash 算法</strong>？</li>
<li><code>ThreadLocalMap</code>中<strong>Hash 冲突</strong>如何解决？</li>
<li><code>ThreadLocalMap</code>的<strong>扩容机制</strong>？</li>
<li><code>ThreadLocalMap</code>中<strong>过期 key 的清理机制</strong>？<strong>探测式清理</strong>和<strong>启发式清理</strong>流程？</li>
<li><code>ThreadLocalMap.set()</code>方法实现原理？</li>
<li><code>ThreadLocalMap.get()</code>方法实现原理？</li>
<li>项目中<code>ThreadLocal</code>使用情况？遇到的坑？</li>
<li>……</li>
</ul>
<p>上述的一些问题你是否都已经掌握的很清楚了呢？本文将围绕这些问题使用图文方式来剖析<code>ThreadLocal</code>的<strong>点点滴滴</strong>。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p><strong>注明：</strong> 本文源码基于<code>JDK 1.8</code></p>
<h3 id="ThreadLocal代码演示"><a href="#ThreadLocal代码演示" class="headerlink" title="ThreadLocal代码演示"></a><code>ThreadLocal</code>代码演示</h3><p>我们先看下<code>ThreadLocal</code>使用示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; messages = Lists.newArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ThreadLocalTest&gt; holder = ThreadLocal.withInitial(ThreadLocalTest::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        holder.get().messages.add(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt; messages = holder.get().messages;</span><br><span class="line">        holder.remove();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;size: &quot;</span> + holder.get().messages.size());</span><br><span class="line">        <span class="keyword">return</span> messages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ThreadLocalTest.add(<span class="string">&quot;一枝花算不算浪漫&quot;</span>);</span><br><span class="line">        System.out.println(holder.get().messages);</span><br><span class="line">        ThreadLocalTest.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[一枝花算不算浪漫]</span><br><span class="line">size: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><code>ThreadLocal</code>对象可以提供线程局部变量，每个线程<code>Thread</code>拥有一份自己的<strong>副本变量</strong>，多个线程互不干扰。</p>
<h3 id="ThreadLocal的数据结构"><a href="#ThreadLocal的数据结构" class="headerlink" title="ThreadLocal的数据结构"></a><code>ThreadLocal</code>的数据结构</h3><p><img src="https://files.catbox.moe/5j1b1k.png"></p>
<p><code>Thread</code>类有一个类型为<code>ThreadLocal.ThreadLocalMap</code>的实例变量<code>threadLocals</code>，也就是说每个线程有一个自己的<code>ThreadLocalMap</code>。</p>
<p><code>ThreadLocalMap</code>有自己的独立实现，可以简单地将它的<code>key</code>视作<code>ThreadLocal</code>，<code>value</code>为代码中放入的值（实际上<code>key</code>并不是<code>ThreadLocal</code>本身，而是它的一个<strong>弱引用</strong>）。</p>
<p>每个线程在往<code>ThreadLocal</code>里放值的时候，都会往自己的<code>ThreadLocalMap</code>里存，读也是以<code>ThreadLocal</code>作为引用，在自己的<code>map</code>里找对应的<code>key</code>，从而实现了<strong>线程隔离</strong>。</p>
<p><code>ThreadLocalMap</code>有点类似<code>HashMap</code>的结构，只是<code>HashMap</code>是由<strong>数组+链表</strong>实现的，而<code>ThreadLocalMap</code>中并没有<strong>链表</strong>结构。</p>
<p>我们还要注意<code>Entry</code>， 它的<code>key</code>是<code>ThreadLocal&lt;?&gt; k</code> ，继承自<code>WeakReference</code>， 也就是我们常说的弱引用类型。</p>
<h3 id="GC-之后-key-是否为-null？"><a href="#GC-之后-key-是否为-null？" class="headerlink" title="GC 之后 key 是否为 null？"></a>GC 之后 key 是否为 null？</h3><p>回应开头的那个问题， <code>ThreadLocal</code> 的<code>key</code>是弱引用，那么在<code>ThreadLocal.get()</code>的时候，发生<code>GC</code>之后，<code>key</code>是否是<code>null</code>？</p>
<p>为了搞清楚这个问题，我们需要搞清楚<code>Java</code>的<strong>四种引用类型</strong>：</p>
<ul>
<li><strong>强引用</strong>：我们常常 new 出来的对象就是强引用类型，只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足的时候</li>
<li><strong>软引用</strong>：使用 SoftReference 修饰的对象被称为软引用，软引用指向的对象在内存要溢出的时候被回收</li>
<li><strong>弱引用</strong>：使用 WeakReference 修饰的对象被称为弱引用，只要发生垃圾回收，若这个对象只被弱引用指向，那么就会被回收</li>
<li><strong>虚引用</strong>：虚引用是最弱的引用，在 Java 中使用 PhantomReference 进行定义。虚引用中唯一的作用就是用队列接收对象即将死亡的通知</li>
</ul>
<p>接着再来看下代码，我们使用反射的方式来看看<code>GC</code>后<code>ThreadLocal</code>中的数据情况：(下面代码来源自：<a href="https://blog.csdn.net/thewindkee/article/details/103726942">https://blog.csdn.net/thewindkee/article/details/103726942</a> 本地运行演示 GC 回收场景)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException, InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;test(<span class="string">&quot;abc&quot;</span>,<span class="literal">false</span>));</span><br><span class="line">        t.start();</span><br><span class="line">        t.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;--gc后--&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; test(<span class="string">&quot;def&quot;</span>, <span class="literal">true</span>));</span><br><span class="line">        t2.start();</span><br><span class="line">        t2.join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String s,<span class="type">boolean</span> isGC)</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;().set(s);</span><br><span class="line">            <span class="keyword">if</span> (isGC) &#123;</span><br><span class="line">                System.gc();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            Class&lt;? <span class="keyword">extends</span> <span class="title class_">Thread</span>&gt; clz = t.getClass();</span><br><span class="line">            <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clz.getDeclaredField(<span class="string">&quot;threadLocals&quot;</span>);</span><br><span class="line">            field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">ThreadLocalMap</span> <span class="operator">=</span> field.get(t);</span><br><span class="line">            Class&lt;?&gt; tlmClass = ThreadLocalMap.getClass();</span><br><span class="line">            <span class="type">Field</span> <span class="variable">tableField</span> <span class="operator">=</span> tlmClass.getDeclaredField(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">            tableField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            Object[] arr = (Object[]) tableField.get(ThreadLocalMap);</span><br><span class="line">            <span class="keyword">for</span> (Object o : arr) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o != <span class="literal">null</span>) &#123;</span><br><span class="line">                    Class&lt;?&gt; entryClass = o.getClass();</span><br><span class="line">                    <span class="type">Field</span> <span class="variable">valueField</span> <span class="operator">=</span> entryClass.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">                    <span class="type">Field</span> <span class="variable">referenceField</span> <span class="operator">=</span> entryClass.getSuperclass().getSuperclass().getDeclaredField(<span class="string">&quot;referent&quot;</span>);</span><br><span class="line">                    valueField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    referenceField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    System.out.println(String.format(<span class="string">&quot;弱引用key:%s,值:%s&quot;</span>, referenceField.get(o), valueField.get(o)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">弱引用key:java.lang.ThreadLocal@433619b6,值:abc</span><br><span class="line">弱引用key:java.lang.ThreadLocal@418a15e3,值:java.lang.ref.SoftReference<span class="meta">@bf97a12</span></span><br><span class="line">--gc后--</span><br><span class="line">弱引用key:<span class="literal">null</span>,值:def</span><br></pre></td></tr></table></figure>

<p><img src="https://files.catbox.moe/yjuqhk.png"></p>
<p>如图所示，因为这里创建的<code>ThreadLocal</code>并没有指向任何值，也就是没有任何引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;().set(s);</span><br></pre></td></tr></table></figure>

<p>所以这里在<code>GC</code>之后，<code>key</code>就会被回收，我们看到上面<code>debug</code>中的<code>referent=null</code>, 如果<strong>改动一下代码：</strong></p>
<p><img src="https://files.catbox.moe/pc6p2o.png"></p>
<p>这个问题刚开始看，如果没有过多思考，<strong>弱引用</strong>，还有<strong>垃圾回收</strong>，那么肯定会觉得是<code>null</code>。</p>
<p>其实是不对的，因为题目说的是在做 <code>ThreadLocal.get()</code> 操作，证明其实还是有<strong>强引用</strong>存在的，所以 <code>key</code> 并不为 <code>null</code>，如下图所示，<code>ThreadLocal</code>的<strong>强引用</strong>仍然是存在的。</p>
<p><img src="https://files.catbox.moe/xpzgcf.png"></p>
<p>如果我们的<strong>强引用</strong>不存在的话，那么 <code>key</code> 就会被回收，也就是会出现我们 <code>value</code> 没被回收，<code>key</code> 被回收，导致 <code>value</code> 永远存在，出现内存泄漏。</p>
<h3 id="ThreadLocal-set-方法源码详解"><a href="#ThreadLocal-set-方法源码详解" class="headerlink" title="ThreadLocal.set()方法源码详解"></a><code>ThreadLocal.set()</code>方法源码详解</h3><p><img src="https://files.catbox.moe/diql32.png"></p>
<p><code>ThreadLocal</code>中的<code>set</code>方法原理如上图所示，很简单，主要是判断<code>ThreadLocalMap</code>是否存在，然后使用<code>ThreadLocal</code>中的<code>set</code>方法进行数据处理。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要的核心逻辑还是在<code>ThreadLocalMap</code>中的，一步步往下看，后面还有更详细的剖析。</p>
<h3 id="ThreadLocalMap-Hash-算法"><a href="#ThreadLocalMap-Hash-算法" class="headerlink" title="ThreadLocalMap Hash 算法"></a><code>ThreadLocalMap</code> Hash 算法</h3><p>既然是<code>Map</code>结构，那么<code>ThreadLocalMap</code>当然也要实现自己的<code>hash</code>算法来解决散列表数组冲突问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><code>ThreadLocalMap</code>中<code>hash</code>算法很简单，这里<code>i</code>就是当前 key 在散列表中对应的数组下标位置。</p>
<p>这里最关键的就是<code>threadLocalHashCode</code>值的计算，<code>ThreadLocal</code>中有一个属性为<code>HASH_INCREMENT = 0x61c88647</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadLocalHashCode</span> <span class="operator">=</span> nextHashCode();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">nextHashCode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_INCREMENT</span> <span class="operator">=</span> <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextHashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line">        ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">            table = <span class="keyword">new</span> <span class="title class_">Entry</span>[INITIAL_CAPACITY];</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(firstKey, firstValue);</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            setThreshold(INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每当创建一个<code>ThreadLocal</code>对象，这个<code>ThreadLocal.nextHashCode</code> 这个值就会增长 <code>0x61c88647</code> 。</p>
<p>这个值很特殊，它是<strong>斐波那契数</strong> 也叫 <strong>黄金分割数</strong>。<code>hash</code>增量为 这个数字，带来的好处就是 <code>hash</code> <strong>分布非常均匀</strong>。</p>
<p>我们自己可以尝试下：</p>
<p><img src="https://files.catbox.moe/6ets2c.png"></p>
<p>可以看到产生的哈希码分布很均匀，这里不去细纠<strong>斐波那契</strong>具体算法，感兴趣的可以自行查阅相关资料。</p>
<h3 id="ThreadLocalMap-Hash-冲突"><a href="#ThreadLocalMap-Hash-冲突" class="headerlink" title="ThreadLocalMap Hash 冲突"></a><code>ThreadLocalMap</code> Hash 冲突</h3><blockquote>
<p><strong>注明：</strong> 下面所有示例图中，<strong>绿色块</strong><code>Entry</code>代表<strong>正常数据</strong>，<strong>灰色块</strong>代表<code>Entry</code>的<code>key</code>值为<code>null</code>，<strong>已被垃圾回收</strong>。<strong>白色块</strong>表示<code>Entry</code>为<code>null</code>。</p>
</blockquote>
<p>虽然<code>ThreadLocalMap</code>中使用了<strong>黄金分割数</strong>来作为<code>hash</code>计算因子，大大减少了<code>Hash</code>冲突的概率，但是仍然会存在冲突。</p>
<p><code>HashMap</code>中解决冲突的方法是在数组上构造一个<strong>链表</strong>结构，冲突的数据挂载到链表上，如果链表长度超过一定数量则会转化成<strong>红黑树</strong>。</p>
<p>而 <code>ThreadLocalMap</code> 中并没有链表结构，所以这里不能使用 <code>HashMap</code> 解决冲突的方式了。</p>
<p><img src="https://files.catbox.moe/urjhfi.png"></p>
<p>如上图所示，如果我们插入一个<code>value=27</code>的数据，通过 <code>hash</code> 计算后应该落入槽位 4 中，而槽位 4 已经有了 <code>Entry</code> 数据。</p>
<p>此时就会线性向后查找，一直找到 <code>Entry</code> 为 <code>null</code> 的槽位才会停止查找，将当前元素放入此槽位中。当然迭代过程中还有其他的情况，比如遇到了 <code>Entry</code> 不为 <code>null</code> 且 <code>key</code> 值相等的情况，还有 <code>Entry</code> 中的 <code>key</code> 值为 <code>null</code> 的情况等等都会有不同的处理，后面会一一详细讲解。</p>
<p>这里还画了一个<code>Entry</code>中的<code>key</code>为<code>null</code>的数据（<strong>Entry&#x3D;2 的灰色块数据</strong>），因为<code>key</code>值是<strong>弱引用</strong>类型，所以会有这种数据存在。在<code>set</code>过程中，如果遇到了<code>key</code>过期的<code>Entry</code>数据，实际上是会进行一轮<strong>探测式清理</strong>操作的，具体操作方式后面会讲到。</p>
<h3 id="ThreadLocalMap-set-详解"><a href="#ThreadLocalMap-set-详解" class="headerlink" title="ThreadLocalMap.set()详解"></a><code>ThreadLocalMap.set()</code>详解</h3><h4 id="ThreadLocalMap-set-原理图解"><a href="#ThreadLocalMap-set-原理图解" class="headerlink" title="ThreadLocalMap.set()原理图解"></a><code>ThreadLocalMap.set()</code>原理图解</h4><p>看完了<code>ThreadLocal</code> <strong>hash 算法</strong>后，我们再来看<code>set</code>是如何实现的。</p>
<p>往<code>ThreadLocalMap</code>中<code>set</code>数据（<strong>新增</strong>或者<strong>更新</strong>数据）分为好几种情况，针对不同的情况我们画图来说明。</p>
<p><strong>第一种情况：</strong> 通过<code>hash</code>计算后的槽位对应的<code>Entry</code>数据为空：</p>
<p><img src="https://files.catbox.moe/hhvbbx.png"></p>
<p>这里直接将数据放到该槽位即可。</p>
<p><strong>第二种情况：</strong> 槽位数据不为空，<code>key</code>值与当前<code>ThreadLocal</code>通过<code>hash</code>计算获取的<code>key</code>值一致：</p>
<p><img src="https://files.catbox.moe/0lvnr8.png"></p>
<p>这里直接更新该槽位的数据。</p>
<p><strong>第三种情况：</strong> 槽位数据不为空，往后遍历过程中，在找到<code>Entry</code>为<code>null</code>的槽位之前，没有遇到<code>key</code>过期的<code>Entry</code>：</p>
<p><img src="https://files.catbox.moe/ngntoz.png">遍历散列数组，线性往后查找，如果找到<code>Entry</code>为<code>null</code>的槽位，则将数据放入该槽位中，或者往后遍历过程中，遇到了<strong>key 值相等</strong>的数据，直接更新即可。</p>
<p><strong>第四种情况：</strong> 槽位数据不为空，往后遍历过程中，在找到<code>Entry</code>为<code>null</code>的槽位之前，遇到<code>key</code>过期的<code>Entry</code>，如下图，往后遍历过程中，遇到了<code>index=7</code>的槽位数据<code>Entry</code>的<code>key=null</code>：</p>
<p><img src="https://files.catbox.moe/z8fkp0.png"></p>
<p>散列数组下标为 7 位置对应的<code>Entry</code>数据<code>key</code>为<code>null</code>，表明此数据<code>key</code>值已经被垃圾回收掉了，此时就会执行<code>replaceStaleEntry()</code>方法，该方法含义是<strong>替换过期数据的逻辑</strong>，以<strong>index&#x3D;7</strong>位起点开始遍历，进行探测式数据清理工作。</p>
<p>初始化探测式清理过期数据扫描的开始位置：<code>slotToExpunge = staleSlot = 7</code></p>
<p>以当前<code>staleSlot</code>开始 向前迭代查找，找其他过期的数据，然后更新过期数据起始扫描下标<code>slotToExpunge</code>。<code>for</code>循环迭代，直到碰到<code>Entry</code>为<code>null</code>结束。</p>
<p>如果找到了过期的数据，继续向前迭代，直到遇到<code>Entry=null</code>的槽位才停止迭代，如下图所示，<strong>slotToExpunge 被更新为 0</strong>：</p>
<p><img src="https://files.catbox.moe/2hpq1e.png"></p>
<p>以当前节点(<code>index=7</code>)向前迭代，检测是否有过期的<code>Entry</code>数据，如果有则更新<code>slotToExpunge</code>值。碰到<code>null</code>则结束探测。以上图为例<code>slotToExpunge</code>被更新为 0。</p>
<p>上面向前迭代的操作是为了更新探测清理过期数据的起始下标<code>slotToExpunge</code>的值，这个值在后面会讲解，它是用来判断当前过期槽位<code>staleSlot</code>之前是否还有过期元素。</p>
<p>接着开始以<code>staleSlot</code>位置(<code>index=7</code>)向后迭代，<strong>如果找到了相同 key 值的 Entry 数据：</strong></p>
<p><img src="https://files.catbox.moe/d4sr3l.png"></p>
<p>从当前节点<code>staleSlot</code>向后查找<code>key</code>值相等的<code>Entry</code>元素，找到后更新<code>Entry</code>的值并交换<code>staleSlot</code>元素的位置(<code>staleSlot</code>位置为过期元素)，更新<code>Entry</code>数据，然后开始进行过期<code>Entry</code>的清理工作，如下图所示：</p>
<p><img src="https://files.catbox.moe/k9j5i4.png"></p>
<p>向后遍历过程中，如果没有找到相同 key 值的 Entry 数据：</p>
<p><img src="https://files.catbox.moe/jjocdu.png"></p>
<p>从当前节点<code>staleSlot</code>向后查找<code>key</code>值相等的<code>Entry</code>元素，直到<code>Entry</code>为<code>null</code>则停止寻找。通过上图可知，此时<code>table</code>中没有<code>key</code>值相同的<code>Entry</code>。</p>
<p>创建新的<code>Entry</code>，替换<code>table[stableSlot]</code>位置：</p>
<p><img src="https://files.catbox.moe/r55wgn.png"></p>
<p>替换完成后也是进行过期元素清理工作，清理工作主要是有两个方法：<code>expungeStaleEntry()</code>和<code>cleanSomeSlots()</code>，具体细节后面会讲到，请继续往后看。</p>
<h4 id="ThreadLocalMap-set-源码详解"><a href="#ThreadLocalMap-set-源码详解" class="headerlink" title="ThreadLocalMap.set()源码详解"></a><code>ThreadLocalMap.set()</code>源码详解</h4><p>上面已经用图的方式解析了<code>set()</code>实现的原理，其实已经很清晰了，我们接着再看下源码：</p>
<p><code>java.lang.ThreadLocal</code>.<code>ThreadLocalMap.set()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">         e != <span class="literal">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会通过<code>key</code>来计算在散列表中的对应位置，然后以当前<code>key</code>对应的桶的位置向后查找，找到可以使用的桶。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Entry[] tab = table;</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>什么情况下桶才是可以使用的呢？</p>
<ol>
<li><code>k = key</code> 说明是替换操作，可以使用</li>
<li>碰到一个过期的桶，执行替换逻辑，占用过期桶</li>
<li>查找过程中，碰到桶中<code>Entry=null</code>的情况，直接使用</li>
</ol>
<p>接着就是执行<code>for</code>循环遍历，向后查找，我们先看下<code>nextIndex()</code>、<code>prevIndex()</code>方法实现：</p>
<p><img src="https://files.catbox.moe/ja0rh3.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">prevIndex</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着看剩下<code>for</code>循环中的逻辑：</p>
<ol>
<li>遍历当前<code>key</code>值对应的桶中<code>Entry</code>数据为空，这说明散列数组这里没有数据冲突，跳出<code>for</code>循环，直接<code>set</code>数据到对应的桶中</li>
<li>如果<code>key</code>值对应的桶中<code>Entry</code>数据不为空<br>2.1 如果<code>k = key</code>，说明当前<code>set</code>操作是一个替换操作，做替换逻辑，直接返回<br>2.2 如果<code>key = null</code>，说明当前桶位置的<code>Entry</code>是过期数据，执行<code>replaceStaleEntry()</code>方法(核心方法)，然后返回</li>
<li><code>for</code>循环执行完毕，继续往下执行说明向后迭代的过程中遇到了<code>entry</code>为<code>null</code>的情况<br>3.1 在<code>Entry</code>为<code>null</code>的桶中创建一个新的<code>Entry</code>对象<br>3.2 执行<code>++size</code>操作</li>
<li>调用<code>cleanSomeSlots()</code>做一次启发式清理工作，清理散列数组中<code>Entry</code>的<code>key</code>过期的数据<br>4.1 如果清理工作完成后，未清理到任何数据，且<code>size</code>超过了阈值(数组长度的 2&#x2F;3)，进行<code>rehash()</code>操作<br>4.2 <code>rehash()</code>中会先进行一轮探测式清理，清理过期<code>key</code>，清理完成后如果<strong>size &gt;&#x3D; threshold - threshold &#x2F; 4</strong>，就会执行真正的扩容逻辑(扩容逻辑往后看)</li>
</ol>
<p>接着重点看下<code>replaceStaleEntry()</code>方法，<code>replaceStaleEntry()</code>方法提供替换过期数据的功能，我们可以对应上面<strong>第四种情况</strong>的原理图来再回顾下，具体代码如下：</p>
<p><code>java.lang.ThreadLocal.ThreadLocalMap.replaceStaleEntry()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span><br><span class="line"><span class="params">                                       <span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">slotToExpunge</span> <span class="operator">=</span> staleSlot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="literal">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line"></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>slotToExpunge</code>表示开始探测式清理过期数据的开始下标，默认从当前的<code>staleSlot</code>开始。以当前的<code>staleSlot</code>开始，向前迭代查找，找到没有过期的数据，<code>for</code>循环一直碰到<code>Entry</code>为<code>null</code>才会结束。如果向前找到了过期数据，更新探测清理过期数据的开始下标为 i，即<code>slotToExpunge=i</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> prevIndex(staleSlot, len);</span><br><span class="line">     (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">     i = prevIndex(i, len))&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e.get() == <span class="literal">null</span>)&#123;</span><br><span class="line">        slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着开始从<code>staleSlot</code>向后查找，也是碰到<code>Entry</code>为<code>null</code>的桶结束。 如果迭代过程中，<strong>碰到 k &#x3D;&#x3D; key</strong>，这说明这里是替换逻辑，替换新数据并且交换当前<code>staleSlot</code>位置。如果<code>slotToExpunge == staleSlot</code>，这说明<code>replaceStaleEntry()</code>一开始向前查找过期数据时并未找到过期的<code>Entry</code>数据，接着向后查找过程中也未发现过期数据，修改开始探测式清理过期数据的下标为当前循环的 index，即<code>slotToExpunge = i</code>。最后调用<code>cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</code>进行启发式过期数据清理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">    e.value = value;</span><br><span class="line"></span><br><span class="line">    tab[i] = tab[staleSlot];</span><br><span class="line">    tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">        slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>cleanSomeSlots()</code>和<code>expungeStaleEntry()</code>方法后面都会细讲，这两个是和清理相关的方法，一个是过期<code>key</code>相关<code>Entry</code>的启发式清理(<code>Heuristically scan</code>)，另一个是过期<code>key</code>相关<code>Entry</code>的探测式清理。</p>
<p><strong>如果 k !&#x3D; key</strong>则会接着往下走，<code>k == null</code>说明当前遍历的<code>Entry</code>是一个过期数据，<code>slotToExpunge == staleSlot</code>说明，一开始的向前查找数据并未找到过期的<code>Entry</code>。如果条件成立，则更新<code>slotToExpunge</code> 为当前位置，这个前提是前驱节点扫描时未发现过期数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (k == <span class="literal">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">    slotToExpunge = i;</span><br></pre></td></tr></table></figure>

<p>往后迭代的过程中如果没有找到<code>k == key</code>的数据，且碰到<code>Entry</code>为<code>null</code>的数据，则结束当前的迭代操作。此时说明这里是一个添加的逻辑，将新的数据添加到<code>table[staleSlot]</code> 对应的<code>slot</code>中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">tab[staleSlot] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br></pre></td></tr></table></figure>

<p>最后判断除了<code>staleSlot</code>以外，还发现了其他过期的<code>slot</code>数据，就要开启清理数据的逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">    cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br></pre></td></tr></table></figure>

<h3 id="ThreadLocalMap过期-key-的探测式清理流程"><a href="#ThreadLocalMap过期-key-的探测式清理流程" class="headerlink" title="ThreadLocalMap过期 key 的探测式清理流程"></a><code>ThreadLocalMap</code>过期 key 的探测式清理流程</h3><p>上面我们有提及<code>ThreadLocalMap</code>的两种过期<code>key</code>数据清理方式：<strong>探测式清理</strong>和<strong>启发式清理</strong>。</p>
<p>我们先讲下探测式清理，也就是<code>expungeStaleEntry</code>方法，遍历散列数组，从开始位置向后探测清理过期数据，将过期数据的<code>Entry</code>设置为<code>null</code>，沿途中碰到未过期的数据则将此数据<code>rehash</code>后重新在<code>table</code>数组中定位，如果定位的位置已经有了数据，则会将未过期的数据放到最靠近此位置的<code>Entry=null</code>的桶中，使<code>rehash</code>后的<code>Entry</code>数据距离正确的桶的位置更近一些。操作逻辑如下：</p>
<p><img src="https://files.catbox.moe/amxazy.png"></p>
<p>如上图，<code>set(27)</code> 经过 hash 计算后应该落到<code>index=4</code>的桶中，由于<code>index=4</code>桶已经有了数据，所以往后迭代最终数据放入到<code>index=7</code>的桶中，放入后一段时间后<code>index=5</code>中的<code>Entry</code>数据<code>key</code>变为了<code>null</code></p>
<p><img src="https://files.catbox.moe/oarf9p.png"></p>
<p>如果再有其他数据<code>set</code>到<code>map</code>中，就会触发<strong>探测式清理</strong>操作。</p>
<p>如上图，执行<strong>探测式清理</strong>后，<code>index=5</code>的数据被清理掉，继续往后迭代，到<code>index=7</code>的元素时，经过<code>rehash</code>后发现该元素正确的<code>index=4</code>，而此位置已经有了数据，往后查找离<code>index=4</code>最近的<code>Entry=null</code>的节点(刚被探测式清理掉的数据：<code>index=5</code>)，找到后移动<code>index= 7</code>的数据到<code>index=5</code>中，此时桶的位置离正确的位置<code>index=4</code>更近了。</p>
<p>经过一轮探测式清理后，<code>key</code>过期的数据会被清理掉，没过期的数据经过<code>rehash</code>重定位后所处的桶位置理论上更接近<code>i= key.hashCode &amp; (tab.len - 1)</code>的位置。这种优化会提高整个散列表查询性能。</p>
<p>接着看下<code>expungeStaleEntry()</code>具体流程，我们还是以先原理图后源码讲解的方式来一步步梳理：</p>
<p><img src="https://files.catbox.moe/vdihmb.png"></p>
<p>我们假设<code>expungeStaleEntry(3)</code> 来调用此方法，如上图所示，我们可以看到<code>ThreadLocalMap</code>中<code>table</code>的数据情况，接着执行清理操作：</p>
<p><img src="https://files.catbox.moe/v4pskq.png"></p>
<p>第一步是清空当前<code>staleSlot</code>位置的数据，<code>index=3</code>位置的<code>Entry</code>变成了<code>null</code>。然后接着往后探测：</p>
<p><img src="https://files.catbox.moe/e7lxm5.png"></p>
<p>执行完第二步后，index&#x3D;4 的元素挪到 index&#x3D;3 的槽位中。</p>
<p>继续往后迭代检查，碰到正常数据，计算该数据位置是否偏移，如果被偏移，则重新计算<code>slot</code>位置，目的是让正常数据尽可能存放在正确位置或离正确位置更近的位置</p>
<p><img src="https://files.catbox.moe/rkp8a6.png"></p>
<p>在往后迭代的过程中碰到空的槽位，终止探测，这样一轮探测式清理工作就完成了，接着我们继续看看具体<strong>实现源代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">expungeStaleEntry</span><span class="params">(<span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            e.value = <span class="literal">null</span>;</span><br><span class="line">            tab[i] = <span class="literal">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="literal">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们还是以<code>staleSlot=3</code> 来做示例说明，首先是将<code>tab[staleSlot]</code>槽位的数据清空，然后设置<code>size--</code> 接着以<code>staleSlot</code>位置往后迭代，如果遇到<code>k==null</code>的过期数据，也是清空该槽位数据，然后<code>size--</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">    e.value = <span class="literal">null</span>;</span><br><span class="line">    tab[i] = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>key</code>没有过期，重新计算当前<code>key</code>的下标位置是不是当前槽位下标位置，如果不是，那么说明产生了<code>hash</code>冲突，此时以新计算出来正确的槽位位置往后迭代，找到最近一个可以存放<code>entry</code>的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">    tab[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (tab[h] != <span class="literal">null</span>)</span><br><span class="line">        h = nextIndex(h, len);</span><br><span class="line"></span><br><span class="line">    tab[h] = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>里是处理正常的产生<code>Hash</code>冲突的数据，经过迭代后，有过<code>Hash</code>冲突数据的<code>Entry</code>位置会更靠近正确位置，这样的话，查询的时候 效率才会更高。</p>
<h3 id="ThreadLocalMap扩容机制"><a href="#ThreadLocalMap扩容机制" class="headerlink" title="ThreadLocalMap扩容机制"></a><code>ThreadLocalMap</code>扩容机制</h3><p>在<code>ThreadLocalMap.set()</code>方法的最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中<code>Entry</code>的数量已经达到了列表的扩容阈值<code>(len*2/3)</code>，就开始执行<code>rehash()</code>逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">    rehash();</span><br></pre></td></tr></table></figure>

<p>接着看下<code>rehash()</code>具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">()</span> &#123;</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">expungeStaleEntries</span><span class="params">()</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == <span class="literal">null</span>)</span><br><span class="line">            expungeStaleEntry(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先是会进行探测式清理工作，从<code>table</code>的起始位置往后清理，上面有分析清理的详细流程。清理完成之后，<code>table</code>中可能有一些<code>key</code>为<code>null</code>的<code>Entry</code>数据被清理掉，所以此时通过判断<code>size &gt;= threshold - threshold / 4</code> 也就是<code>size &gt;= threshold * 3/4</code> 来决定是否扩容。</p>
<p>我们还记得上面进行<code>rehash()</code>的阈值是<code>size &gt;= threshold</code>，所以当面试官套路我们<code>ThreadLocalMap</code>扩容机制的时候 我们一定要说清楚这两个步骤：</p>
<p><img src="https://files.catbox.moe/p2jsq1.png"></p>
<p>接着看看具体的<code>resize()</code>方法，为了方便演示，我们以<code>oldTab.len=8</code>来举例：</p>
<p><img src="https://files.catbox.moe/fx8jmm.png"></p>
<p>扩容后的<code>tab</code>的大小为<code>oldLen * 2</code>，然后遍历老的散列表，重新计算<code>hash</code>位置，然后放到新的<code>tab</code>数组中，如果出现<code>hash</code>冲突则往后寻找最近的<code>entry</code>为<code>null</code>的槽位，遍历完成之后，<code>oldTab</code>中所有的<code>entry</code>数据都已经放入到新的<code>tab</code>中了。重新计算<code>tab</code>下次扩容的<strong>阈值</strong>，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span> &#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldLen</span> <span class="operator">=</span> oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newLen</span> <span class="operator">=</span> oldLen * <span class="number">2</span>;</span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> <span class="title class_">Entry</span>[newLen];</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> oldTab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">                e.value = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="literal">null</span>)</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ThreadLocalMap-get-详解"><a href="#ThreadLocalMap-get-详解" class="headerlink" title="ThreadLocalMap.get()详解"></a><code>ThreadLocalMap.get()</code>详解</h3><p>上面已经看完了<code>set()</code>方法的源码，其中包括<code>set</code>数据、清理数据、优化数据桶的位置等操作，接着看看<code>get()</code>操作的原理。</p>
<h4 id="ThreadLocalMap-get-图解"><a href="#ThreadLocalMap-get-图解" class="headerlink" title="ThreadLocalMap.get()图解"></a><code>ThreadLocalMap.get()</code>图解</h4><p><strong>第一种情况：</strong> 通过查找<code>key</code>值计算出散列表中<code>slot</code>位置，然后该<code>slot</code>位置中的<code>Entry.key</code>和查找的<code>key</code>一致，则直接返回：</p>
<p><img src="https://files.catbox.moe/a6y07b.png"></p>
<p><strong>第二种情况：</strong> <code>slot</code>位置中的<code>Entry.key</code>和要查找的<code>key</code>不一致：</p>
<p><img src="https://files.catbox.moe/bdduj2.png"></p>
<p>我们以<code>get(ThreadLocal1)</code>为例，通过<code>hash</code>计算后，正确的<code>slot</code>位置应该是 4，而<code>index=4</code>的槽位已经有了数据，且<code>key</code>值不等于<code>ThreadLocal1</code>，所以需要继续往后迭代查找。</p>
<p>迭代到<code>index=5</code>的数据时，此时<code>Entry.key=null</code>，触发一次探测式数据回收操作，执行<code>expungeStaleEntry()</code>方法，执行完后，<code>index 5,8</code>的数据都会被回收，而<code>index 6,7</code>的数据都会前移。<code>index 6,7</code>前移之后，继续从 <code>index=5</code> 往后迭代，于是就在 <code>index=5</code> 找到了<code>key</code>值相等的<code>Entry</code>数据，如下图所示：</p>
<p><img src="https://files.catbox.moe/etz3dj.png"></p>
<h4 id="ThreadLocalMap-get-源码详解"><a href="#ThreadLocalMap-get-源码详解" class="headerlink" title="ThreadLocalMap.get()源码详解"></a><code>ThreadLocalMap.get()</code>源码详解</h4><p><code>java.lang.ThreadLocal.ThreadLocalMap.getEntry()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="type">int</span> i, Entry e)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ThreadLocalMap过期-key-的启发式清理流程"><a href="#ThreadLocalMap过期-key-的启发式清理流程" class="headerlink" title="ThreadLocalMap过期 key 的启发式清理流程"></a><code>ThreadLocalMap</code>过期 key 的启发式清理流程</h3><p>上面多次提及到<code>ThreadLocalMap</code>过期key的两种清理方式：<strong>探测式清理(expungeStaleEntry())<strong>、</strong>启发式清理(cleanSomeSlots())</strong></p>
<p>探测式清理是以当前<code>Entry</code> 往后清理，遇到值为<code>null</code>则结束清理，属于<strong>线性探测清理</strong>。</p>
<p>而启发式清理被作者定义为：<strong>Heuristically scan some cells looking for stale entries</strong>.</p>
<p><img src="https://files.catbox.moe/76c3uk.png"></p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">cleanSomeSlots</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">removed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == <span class="literal">null</span>) &#123;</span><br><span class="line">            n = len;</span><br><span class="line">            removed = <span class="literal">true</span>;</span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a><code>InheritableThreadLocal</code></h3><p>我们使用<code>ThreadLocal</code>的时候，在异步场景下是无法给子线程共享父线程中创建的线程副本数据的。</p>
<p>为了解决这个问题，JDK 中还有一个<code>InheritableThreadLocal</code>类，我们来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritableThreadLocalDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ThreadLocal&lt;String&gt; ThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">        ThreadLocal&lt;String&gt; inheritableThreadLocal = <span class="keyword">new</span> <span class="title class_">InheritableThreadLocal</span>&lt;&gt;();</span><br><span class="line">        ThreadLocal.set(<span class="string">&quot;父类数据:threadLocal&quot;</span>);</span><br><span class="line">        inheritableThreadLocal.set(<span class="string">&quot;父类数据:inheritableThreadLocal&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程获取父类ThreadLocal数据：&quot;</span> + ThreadLocal.get());</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程获取父类inheritableThreadLocal数据：&quot;</span> + inheritableThreadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">子线程获取父类ThreadLocal数据：<span class="literal">null</span></span><br><span class="line">子线程获取父类inheritableThreadLocal数据：父类数据:inheritableThreadLocal</span><br></pre></td></tr></table></figure>

<p>实现原理是子线程是通过在父线程中通过调用<code>new Thread()</code>方法来创建子线程，<code>Thread#init</code>方法在<code>Thread</code>的构造方法中被调用。在<code>init</code>方法中拷贝父线程数据到子线程中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span><br><span class="line"><span class="params">                      <span class="type">long</span> stackSize, AccessControlContext acc,</span></span><br><span class="line"><span class="params">                      <span class="type">boolean</span> inheritThreadLocals)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="literal">null</span>)</span><br><span class="line">        <span class="built_in">this</span>.inheritableThreadLocals =</span><br><span class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    <span class="built_in">this</span>.stackSize = stackSize;</span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但<code>InheritableThreadLocal</code>仍然有缺陷，一般我们做异步化处理都是使用的线程池，而<code>InheritableThreadLocal</code>是在<code>new Thread</code>中的<code>init()</code>方法给赋值的，而线程池是线程复用的逻辑，所以这里会存在问题。</p>
<p>当然，有问题出现就会有解决问题的方案，阿里巴巴开源了一个<code>TransmittableThreadLocal</code>组件就可以解决这个问题，这里就不再延伸，感兴趣的可自行查阅资料。</p>
<h3 id="ThreadLocal项目中使用实战"><a href="#ThreadLocal项目中使用实战" class="headerlink" title="ThreadLocal项目中使用实战"></a><code>ThreadLocal</code>项目中使用实战</h3><h4 id="ThreadLocal使用场景"><a href="#ThreadLocal使用场景" class="headerlink" title="ThreadLocal使用场景"></a><code>ThreadLocal</code>使用场景</h4><p>我们现在项目中日志记录用的是<code>ELK+Logstash</code>，最后在<code>Kibana</code>中进行展示和检索。</p>
<p>现在都是分布式系统统一对外提供服务，项目间调用的关系可以通过 <code>traceId</code> 来关联，但是不同项目之间如何传递 <code>traceId</code> 呢？</p>
<p>这里我们使用 <code>org.slf4j.MDC</code> 来实现此功能，内部就是通过 <code>ThreadLocal</code> 来实现的，具体实现如下：</p>
<p>当前端发送请求到<strong>服务 A</strong>时，<strong>服务 A</strong>会生成一个类似<code>UUID</code>的<code>traceId</code>字符串，将此字符串放入当前线程的<code>ThreadLocal</code>中，在调用<strong>服务 B</strong>的时候，将<code>traceId</code>写入到请求的<code>Header</code>中，<strong>服务 B</strong>在接收请求时会先判断请求的<code>Header</code>中是否有<code>traceId</code>，如果存在则写入自己线程的<code>ThreadLocal</code>中。</p>
<p><img src="https://files.catbox.moe/fwqi7p.png"></p>
<p>图中的<code>requestId</code>即为我们各个系统链路关联的<code>traceId</code>，系统间互相调用，通过这个<code>requestId</code>即可找到对应链路，这里还有会有一些其他场景：</p>
<p><img src="https://files.catbox.moe/rl6qa2.png"></p>
<p>针对于这些场景，我们都可以有相应的解决方案，如下所示</p>
<h4 id="Feign-远程调用解决方案"><a href="#Feign-远程调用解决方案" class="headerlink" title="Feign 远程调用解决方案"></a>Feign 远程调用解决方案</h4><p><strong>服务发送请求：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignInvokeInterceptor</span> <span class="keyword">implements</span> <span class="title class_">RequestInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate template)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">requestId</span> <span class="operator">=</span> MDC.get(<span class="string">&quot;requestId&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(requestId)) &#123;</span><br><span class="line">            template.header(<span class="string">&quot;requestId&quot;</span>, requestId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>服务接收请求：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogInterceptor</span> <span class="keyword">extends</span> <span class="title class_">HandlerInterceptorAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3)</span> &#123;</span><br><span class="line">        MDC.remove(<span class="string">&quot;requestId&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">requestId</span> <span class="operator">=</span> request.getHeader(BaseConstant.REQUEST_ID_KEY);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(requestId)) &#123;</span><br><span class="line">            requestId = UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        MDC.put(<span class="string">&quot;requestId&quot;</span>, requestId);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程池异步调用，requestId-传递"><a href="#线程池异步调用，requestId-传递" class="headerlink" title="线程池异步调用，requestId 传递"></a>线程池异步调用，requestId 传递</h4><p>因为<code>MDC</code>是基于<code>ThreadLocal</code>去实现的，异步过程中，子线程并没有办法获取到父线程<code>ThreadLocal</code>存储的数据，所以这里可以自定义线程池执行器，修改其中的<code>run()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadPoolTaskExecutor</span> <span class="keyword">extends</span> <span class="title class_">ThreadPoolTaskExecutor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable runnable)</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; context = MDC.getCopyOfContextMap();</span><br><span class="line">        <span class="built_in">super</span>.execute(() -&gt; run(runnable, context));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Runnable runnable, Map&lt;String, String&gt; context)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">            MDC.setContextMap(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            runnable.run();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            MDC.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用-MQ-发送消息给第三方系统"><a href="#使用-MQ-发送消息给第三方系统" class="headerlink" title="使用 MQ 发送消息给第三方系统"></a>使用 MQ 发送消息给第三方系统</h4><p>在 MQ 发送的消息体中自定义属性<code>requestId</code>，接收方消费消息后，自己解析<code>requestId</code>使用即可。</p>
<h1 id="CompletableFuture入门"><a href="#CompletableFuture入门" class="headerlink" title="CompletableFuture入门"></a>CompletableFuture入门</h1><p>自己在项目中使用 <code>CompletableFuture</code> 比较多，看到很多开源框架中也大量使用到了 <code>CompletableFuture</code> 。</p>
<p>因此，专门写一篇文章来介绍这个 Java 8 才被引入的一个非常有用的用于异步编程的类。</p>
<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p><code>CompletableFuture</code> 同时实现了 <code>Future</code> 和 <code>CompletionStage</code> 接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFuture</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Future</span>&lt;T&gt;, CompletionStage&lt;T&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CompletableFuture</code> 除了提供了更为好用和强大的 <code>Future</code> 特性之外，还提供了函数式编程的能力。</p>
<p><img src="https://files.catbox.moe/jl772n.png"></p>
<p><code>Future</code> 接口有 5 个方法：</p>
<ul>
<li><code>boolean cancel(boolean mayInterruptIfRunning)</code> ：尝试取消执行任务。</li>
<li><code>boolean isCancelled()</code> ：判断任务是否被取消。</li>
<li><code>boolean isDone()</code> ： 判断任务是否已经被执行完成。</li>
<li><code>get()</code> ：等待任务执行完成并获取运算结果。</li>
<li><code>get(long timeout, TimeUnit unit)</code> ：多了一个超时时间。</li>
</ul>
<p>&#96;<img src="https://files.catbox.moe/ykh9c2.png"></p>
<p>CompletionStage<T><code> 接口中的方法比较多，</code>CompletableFuture&#96; 的函数式能力就是这个接口赋予的。从这个接口的方法参数你就可以发现其大量使用了 Java8 引入的函数式编程。</p>
<p>由于方法众多，所以这里不能一一讲解，下文中我会介绍大部分常见方法的使用。</p>
<h2 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h2><h3 id="创建-CompletableFuture"><a href="#创建-CompletableFuture" class="headerlink" title="创建 CompletableFuture"></a>创建 CompletableFuture</h3><p>常见的创建 <code>CompletableFuture</code> 对象的方法如下：</p>
<ol>
<li>通过 new 关键字。</li>
<li>基于 <code>CompletableFuture</code> 自带的静态工厂方法：<code>runAsync()</code> 、<code>supplyAsync()</code> 。</li>
</ol>
<h4 id="new-关键字"><a href="#new-关键字" class="headerlink" title="new 关键字"></a>new 关键字</h4><p>通过 new 关键字创建 <code>CompletableFuture</code> 对象这种使用方式可以看作是将 <code>CompletableFuture</code> 当做 <code>Future</code> 来使用。</p>
<p>我在我的开源项目 <a href="https://github.com/Snailclimb/guide-rpc-framework">guide-rpc-frameworkopen in new window</a> 中就是这种方式创建的 <code>CompletableFuture</code> 对象。</p>
<p>下面咱们来看一个简单的案例。</p>
<p>我们通过创建了一个结果值类型为 <code>RpcResponse&lt;Object&gt;</code> 的 <code>CompletableFuture</code>，你可以把 <code>resultFuture</code> 看作是异步运算结果的载体。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt; resultFuture = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>假设在未来的某个时刻，我们得到了最终的结果。这时，我们可以调用 <code>complete()</code> 方法为其传入结果，这表示 <code>resultFuture</code> 已经被完成了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// complete() 方法只能调用一次，后续调用将被忽略。</span></span><br><span class="line">resultFuture.complete(rpcResponse);</span><br></pre></td></tr></table></figure>

<p>你可以通过 <code>isDone()</code> 方法来检查是否已经完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> result != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取异步计算的结果也非常简单，直接调用 <code>get()</code> 方法即可。调用 <code>get()</code> 方法的线程会阻塞直到 <code>CompletableFuture</code> 完成运算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rpcResponse = completableFuture.get();</span><br></pre></td></tr></table></figure>

<p>如果你已经知道计算的结果的话，可以使用静态方法 <code>completedFuture()</code> 来创建 <code>CompletableFuture</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.completedFuture(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">assertEquals(<span class="string">&quot;hello!&quot;</span>, future.get());</span><br></pre></td></tr></table></figure>

<p><code>completedFuture()</code> 方法底层调用的是带参数的 new 方法，只不过，这个方法不对外暴露。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">completedFuture</span><span class="params">(U value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;U&gt;((value == <span class="literal">null</span>) ? NIL : value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="静态工厂方法"><a href="#静态工厂方法" class="headerlink" title="静态工厂方法"></a>静态工厂方法</h4><p>这两个方法可以帮助我们封装计算逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span>;</span><br><span class="line"><span class="comment">// 使用自定义线程池(推荐)</span></span><br><span class="line"><span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span>;</span><br><span class="line"><span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable)</span>;</span><br><span class="line"><span class="comment">// 使用自定义线程池(推荐)</span></span><br><span class="line"><span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable, Executor executor)</span>;</span><br></pre></td></tr></table></figure>

<p><code>runAsync()</code> 方法接受的参数是 <code>Runnable</code> ，这是一个函数式接口，不允许返回值。当你需要异步操作且不关心返回结果的时候可以使用 <code>runAsync()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>supplyAsync()</code> 方法接受的参数是 <code>Supplier&lt;U&gt;</code> ，这也是一个函数式接口，<code>U</code> 是返回结果值的类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Supplier</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets a result.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    T <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你需要异步操作且关心返回结果的时候,可以使用 <code>supplyAsync()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; System.out.println(<span class="string">&quot;hello!&quot;</span>));</span><br><span class="line">future.get();<span class="comment">// 输出 &quot;hello!&quot;</span></span><br><span class="line">CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">assertEquals(<span class="string">&quot;hello!&quot;</span>, future2.get());</span><br></pre></td></tr></table></figure>

<h3 id="处理异步结算的结果"><a href="#处理异步结算的结果" class="headerlink" title="处理异步结算的结果"></a>处理异步结算的结果</h3><p>当我们获取到异步计算的结果之后，还可以对其进行进一步的处理，比较常用的方法有下面几个：</p>
<ul>
<li><code>thenApply()</code></li>
<li><code>thenAccept()</code></li>
<li><code>thenRun()</code></li>
<li><code>whenComplete()</code></li>
</ul>
<p><code>thenApply()</code> 方法接受一个 <code>Function</code> 实例，用它来处理结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 沿用上一个任务的线程池</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApply</span><span class="params">(</span></span><br><span class="line"><span class="params">    Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniApplyStage(<span class="literal">null</span>, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用默认的 ForkJoinPool 线程池（不推荐）</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApplyAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniApplyStage(defaultExecutor(), fn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用自定义线程池(推荐)</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApplyAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn, Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniApplyStage(screenExecutor(executor), fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>thenApply()</code> 方法使用示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.completedFuture(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line">        .thenApply(s -&gt; s + <span class="string">&quot;world!&quot;</span>);</span><br><span class="line">assertEquals(<span class="string">&quot;hello!world!&quot;</span>, future.get());</span><br><span class="line"><span class="comment">// 这次调用将被忽略。</span></span><br><span class="line">future.thenApply(s -&gt; s + <span class="string">&quot;nice!&quot;</span>);</span><br><span class="line">assertEquals(<span class="string">&quot;hello!world!&quot;</span>, future.get());</span><br></pre></td></tr></table></figure>

<p>你还可以进行 <strong>流式调用</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.completedFuture(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line">        .thenApply(s -&gt; s + <span class="string">&quot;world!&quot;</span>).thenApply(s -&gt; s + <span class="string">&quot;nice!&quot;</span>);</span><br><span class="line">assertEquals(<span class="string">&quot;hello!world!nice!&quot;</span>, future.get());</span><br></pre></td></tr></table></figure>

<p><strong>如果你不需要从回调函数中获取返回结果，可以使用 thenAccept() 或者 thenRun()。这两个方法的区别在于 thenRun() 不能访问异步计算的结果。</strong></p>
<p><code>thenAccept()</code> 方法的参数是 <code>Consumer&lt;? super T&gt;</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenAccept</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniAcceptStage(<span class="literal">null</span>, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniAcceptStage(defaultExecutor(), action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action,</span></span><br><span class="line"><span class="params">                                               Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniAcceptStage(screenExecutor(executor), action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顾名思义，<code>Consumer</code> 属于消费型接口，它可以接收 1 个输入对象然后进行“消费”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Consumer</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> Consumer&lt;T&gt; <span class="title function_">andThen</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; after)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>thenRun()</code> 的方法是的参数是 <code>Runnable</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenRun</span><span class="params">(Runnable action)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniRunStage(<span class="literal">null</span>, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenRunAsync</span><span class="params">(Runnable action)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniRunStage(defaultExecutor(), action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenRunAsync</span><span class="params">(Runnable action,</span></span><br><span class="line"><span class="params">                                            Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniRunStage(screenExecutor(executor), action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>thenAccept()</code> 和 <code>thenRun()</code> 使用示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture.completedFuture(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line">        .thenApply(s -&gt; s + <span class="string">&quot;world!&quot;</span>).thenApply(s -&gt; s + <span class="string">&quot;nice!&quot;</span>).thenAccept(System.out::println);<span class="comment">//hello!world!nice!</span></span><br><span class="line"></span><br><span class="line">CompletableFuture.completedFuture(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line">        .thenApply(s -&gt; s + <span class="string">&quot;world!&quot;</span>).thenApply(s -&gt; s + <span class="string">&quot;nice!&quot;</span>).thenRun(() -&gt; System.out.println(<span class="string">&quot;hello!&quot;</span>));<span class="comment">//hello!</span></span><br></pre></td></tr></table></figure>

<p><code>whenComplete()</code> 的方法的参数是 <code>BiConsumer&lt;? super T, ? super Throwable&gt;</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">whenComplete</span><span class="params">(</span></span><br><span class="line"><span class="params">    BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> Throwable&gt; action)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniWhenCompleteStage(<span class="literal">null</span>, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">whenCompleteAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> Throwable&gt; action)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniWhenCompleteStage(defaultExecutor(), action);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用自定义线程池(推荐)</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">whenCompleteAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> Throwable&gt; action, Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniWhenCompleteStage(screenExecutor(executor), action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相对于 <code>Consumer</code> ， <code>BiConsumer</code> 可以接收 2 个输入对象然后进行“消费”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BiConsumer</span>&lt;T, U&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t, U u)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> BiConsumer&lt;T, U&gt; <span class="title function_">andThen</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> U&gt; after)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (l, r) -&gt; &#123;</span><br><span class="line">            accept(l, r);</span><br><span class="line">            after.accept(l, r);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>whenComplete()</code> 使用示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;hello!&quot;</span>)</span><br><span class="line">        .whenComplete((res, ex) -&gt; &#123;</span><br><span class="line">            <span class="comment">// res 代表返回的结果</span></span><br><span class="line">            <span class="comment">// ex 的类型为 Throwable ，代表抛出的异常</span></span><br><span class="line">            System.out.println(res);</span><br><span class="line">            <span class="comment">// 这里没有抛出异常所有为 null</span></span><br><span class="line">            assertNull(ex);</span><br><span class="line">        &#125;);</span><br><span class="line">assertEquals(<span class="string">&quot;hello!&quot;</span>, future.get());</span><br></pre></td></tr></table></figure>

<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>你可以通过 <code>handle()</code> 方法来处理任务执行过程中可能出现的抛出异常的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">handle</span><span class="params">(</span></span><br><span class="line"><span class="params">    BiFunction&lt;? <span class="built_in">super</span> T, Throwable, ? extends U&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniHandleStage(<span class="literal">null</span>, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">handleAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    BiFunction&lt;? <span class="built_in">super</span> T, Throwable, ? extends U&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniHandleStage(defaultExecutor(), fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">handleAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    BiFunction&lt;? <span class="built_in">super</span> T, Throwable, ? extends U&gt; fn, Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniHandleStage(screenExecutor(executor), fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future</span><br><span class="line">        = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Computation error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello!&quot;</span>;</span><br><span class="line">&#125;).handle((res, ex) -&gt; &#123;</span><br><span class="line">    <span class="comment">// res 代表返回的结果</span></span><br><span class="line">    <span class="comment">// ex 的类型为 Throwable ，代表抛出的异常</span></span><br><span class="line">    <span class="keyword">return</span> res != <span class="literal">null</span> ? res : <span class="string">&quot;world!&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">assertEquals(<span class="string">&quot;world!&quot;</span>, future.get());</span><br></pre></td></tr></table></figure>

<p>你还可以通过 <code>exceptionally()</code> 方法来处理异常情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future</span><br><span class="line">        = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Computation error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello!&quot;</span>;</span><br><span class="line">&#125;).exceptionally(ex -&gt; &#123;</span><br><span class="line">    System.out.println(ex.toString());<span class="comment">// CompletionException</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;world!&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">assertEquals(<span class="string">&quot;world!&quot;</span>, future.get());</span><br></pre></td></tr></table></figure>

<p>如果你想让 <code>CompletableFuture</code> 的结果就是异常的话，可以使用 <code>completeExceptionally()</code> 方法为其赋值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; completableFuture = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">completableFuture.completeExceptionally(</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Calculation failed!&quot;</span>));</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">completableFuture.get(); <span class="comment">// ExecutionException</span></span><br></pre></td></tr></table></figure>

<h3 id="组合-CompletableFuture"><a href="#组合-CompletableFuture" class="headerlink" title="组合 CompletableFuture"></a>组合 CompletableFuture</h3><p>你可以使用 <code>thenCompose()</code> 按顺序链接两个 <code>CompletableFuture</code> 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; thenCompose(</span><br><span class="line">    Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn) &#123;</span><br><span class="line">    return uniComposeStage(null, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; thenComposeAsync(</span><br><span class="line">    Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn) &#123;</span><br><span class="line">    return uniComposeStage(defaultExecutor(), fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; thenComposeAsync(</span><br><span class="line">    Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn,</span><br><span class="line">    Executor executor) &#123;</span><br><span class="line">    return uniComposeStage(screenExecutor(executor), fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>thenCompose()</code> 方法会使用示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future</span><br><span class="line">        = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;hello!&quot;</span>)</span><br><span class="line">        .thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; s + <span class="string">&quot;world!&quot;</span>));</span><br><span class="line">assertEquals(<span class="string">&quot;hello!world!&quot;</span>, future.get());</span><br></pre></td></tr></table></figure>

<p>在实际开发中，这个方法还是非常有用的。比如说，我们先要获取用户信息然后再用用户信息去做其他事情。</p>
<p>和 <code>thenCompose()</code> 方法类似的还有 <code>thenCombine()</code> 方法， <code>thenCombine()</code> 同样可以组合两个 <code>CompletableFuture</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; completableFuture</span><br><span class="line">        = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;hello!&quot;</span>)</span><br><span class="line">        .thenCombine(CompletableFuture.supplyAsync(</span><br><span class="line">                () -&gt; <span class="string">&quot;world!&quot;</span>), (s1, s2) -&gt; s1 + s2)</span><br><span class="line">        .thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; s + <span class="string">&quot;nice!&quot;</span>));</span><br><span class="line">assertEquals(<span class="string">&quot;hello!world!nice!&quot;</span>, completableFuture.get());</span><br></pre></td></tr></table></figure>

<p><strong>那 thenCompose() 和 thenCombine() 有什么区别呢？</strong></p>
<ul>
<li><code>thenCompose()</code> 可以两个 <code>CompletableFuture</code> 对象，并将前一个任务的返回结果作为下一个任务的参数，它们之间存在着先后顺序。</li>
<li><code>thenCombine()</code> 会在两个任务都执行完成后，把两个任务的结果合并。两个任务是并行执行的，它们之间并没有先后依赖顺序。</li>
</ul>
<h3 id="并行运行多个-CompletableFuture"><a href="#并行运行多个-CompletableFuture" class="headerlink" title="并行运行多个 CompletableFuture"></a>并行运行多个 CompletableFuture</h3><p>你可以通过 <code>CompletableFuture</code> 的 <code>allOf()</code>这个静态方法来并行运行多个 <code>CompletableFuture</code> 。</p>
<p>实际项目中，我们经常需要并行运行多个互不相关的任务，这些任务之间没有依赖关系，可以互相独立地运行。</p>
<p>比说我们要读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。像这种情况我们就可以使用并行运行多个 <code>CompletableFuture</code> 来处理。</p>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; task1 =</span><br><span class="line">  CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">    <span class="comment">//自定义业务操作</span></span><br><span class="line">  &#125;);</span><br><span class="line">......</span><br><span class="line">CompletableFuture&lt;Void&gt; task6 =</span><br><span class="line">  CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">    <span class="comment">//自定义业务操作</span></span><br><span class="line">  &#125;);</span><br><span class="line">......</span><br><span class="line"> CompletableFuture&lt;Void&gt; headerFuture=CompletableFuture.allOf(task1,.....,task6);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    headerFuture.join();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">System.out.println(<span class="string">&quot;all done. &quot;</span>);</span><br></pre></td></tr></table></figure>

<p>经常和 <code>allOf()</code> 方法拿来对比的是 <code>anyOf()</code> 方法。</p>
<p><strong>allOf() 方法会等到所有的 CompletableFuture 都运行完成之后再返回</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span> + rand.nextInt(<span class="number">1000</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;future1 done...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span> + rand.nextInt(<span class="number">1000</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;future2 done...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;efg&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>调用 <code>join()</code> 可以让程序等<code>future1</code> 和 <code>future2</code> 都运行完了之后再继续执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.allOf(future1, future2);</span><br><span class="line">completableFuture.join();</span><br><span class="line">assertTrue(completableFuture.isDone());</span><br><span class="line">System.out.println(<span class="string">&quot;all futures done...&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">future1 done...</span><br><span class="line">future2 done...</span><br><span class="line">all futures done...</span><br></pre></td></tr></table></figure>

<p><strong>anyOf() 方法不会等待所有的 CompletableFuture 都运行完成之后再返回，只要有一个执行完成即可！</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Object&gt; f = CompletableFuture.anyOf(future1, future2);</span><br><span class="line">System.out.println(f.get());</span><br></pre></td></tr></table></figure>

<p>输出结果可能是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">future2 done...</span><br><span class="line">efg</span><br></pre></td></tr></table></figure>

<p>也可能是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">future1 done...</span><br><span class="line">abc</span><br></pre></td></tr></table></figure>

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这篇文章只是简单介绍了 <code>CompletableFuture</code> 比较常用的一些 API 。</p>
<p>如果想要深入学习的话，可以多找一些书籍和博客看。</p>
<p>另外，建议G友们可以看看京东的 <a href="https://gitee.com/jd-platform-opensource/asyncTool">asyncToolopen in new window</a> 这个并发框架，里面大量使用到了 <code>CompletableFuture</code> 。</p>
]]></content>
  </entry>
  <entry>
    <title>MySQL卸载与安装</title>
    <url>/2022/09/06/MySQL%E5%8D%B8%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h1 id="MySQL卸载与安装"><a href="#MySQL卸载与安装" class="headerlink" title="MySQL卸载与安装"></a>MySQL卸载与安装</h1><h2 id="MySQL如何卸载干净"><a href="#MySQL如何卸载干净" class="headerlink" title="MySQL如何卸载干净"></a>MySQL如何卸载干净</h2><p>卸载干净MySQL的步骤：首先关闭MySQL服务；然后卸载MySQL软件；接着删除MySQL在电脑中的残存文件；最后删除MySQL注册表信息即可。</p>
<p><strong>步骤1：关闭MySQL服务</strong></p>
<p>右击【计算机】，选择【管理】，打开“计算机管理”界面</p>
<p>选择【服务和应用程序】中的【服务】，在右侧找到【mysql】，右键，选择【停止】</p>
<p><strong>步骤2：卸载mysql软件</strong></p>
<p>可以在控制面板中卸载，或者找到它的安装目录删除文件夹</p>
<p><strong>步骤3：删除MySQL在电脑硬盘上物理位置上的所有文件</strong></p>
<p>1、卸载过后删除C:\Program Files (x86)\MySQL该目录下剩余了所有文件，把mysql文件夹也删了</p>
<p>2、删除HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\Eventlog\Application\MySQL文件夹，如果没有可以不用删除了。</p>
<p>3、删除C盘下的C:\ProgramData\MySQL 所有文件，如果删除不了则用360粉碎掉即可，该programData文件是隐藏的默认，设置显示后即可见</p>
<p>4、删除C:\Documents and Settings\All Users\Application Data\MySQL下的文件夹，一定要删（可选）</p>
<p>可以通过window系统自带的关键字查找功能来查找相关联的文件</p>
<p><strong>步骤4：MySQL的注册表信息</strong></p>
<p>注：这步是最繁琐的也是最为关键的，很多人就是因为在这步骤中没有清理干净注册表信息，从而不能重新安装成功。</p>
<p>1、windows+R运行“regedit”文件，打开注册表</p>
<p>2、删除注册表：HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\Application\MySQL文件夹</p>
<p><strong>mysql:【完美解决】The service already exists! The current server installed:……</strong></p>
<p>这个情况毫无疑问是之前下载的MySQL没有卸载干净，接下来将它卸载干净<br>首先以<code>管理员身份</code>运行命令提示符，输入：<strong>sc query mysql</strong><br>查看是否存在，若存在<br>继续输入：<strong>sc delete mysql</strong></p>
<h2 id="MySQL如何安装"><a href="#MySQL如何安装" class="headerlink" title="MySQL如何安装"></a>MySQL如何安装</h2><h2 id="一-进入MySQL官网下载安装"><a href="#一-进入MySQL官网下载安装" class="headerlink" title="一.进入MySQL官网下载安装"></a>一.进入<a href="https://cloud.tencent.com/product/cdb?from=10680">MySQL</a>官网下载安装</h2><ol>
<li>进入Mysql官网<a href="https://www.mysql.com/">MySQL</a>，下载后并解压到目标文件夹（一定要记住路径） </li>
<li>使用管理员身份运行cmd，打开后首先输入D:(记住加冒号) 从C盘到其他盘必须先转到其他盘以后才能使用cd命令</li>
</ol>
<p>再输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd D:\mysql-8.0.26-winx64\mysql-8.0.26-winx64\bin（bin文件的路径）</span><br></pre></td></tr></table></figure>

<p> 在MySQL目录下的bin目录下输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqld --initialize --console</span><br></pre></td></tr></table></figure>

<p> 运行结束后记住root@localhost:之后的密码后面会用(将密码右键复制下来，之后还要右键复制回来！！！)</p>
<p>随后开启MySQL服务并修改密码</p>
<p>接着输入 mysqld –install</p>
<p> 出现红线字样即安装成功(Service successfully installcd.)</p>
<p>再输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net start mysql</span><br></pre></td></tr></table></figure>

<p> 启动MySQL</p>
<p>再输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>

<p> 此时输入刚才保存的密码粘贴到命令台上</p>
<p>输入正确密码后我们输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;你想改新的密码&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>配置环境变量</strong></p>
<p>打开控制面板找到高级系统设置并打开环境变量,在path变量下，输入mysql的安装路径，到bin目录。</p>
<p><strong>检验是否安装成功</strong></p>
<p>如上面的步骤打开cmd输入cd+空格+自己的bin文件路径，再输入mysql -h localhost -u root -p登录<a href="https://cloud.tencent.com/solution/database?from=10680">数据库</a>，再输入数据库密码，查看信息。</p>
<p>输入 status 命令可以查看 MySQL的 版本信息，说明安装成功!</p>
<p><img src="https://files.catbox.moe/z1fkd6.png"></p>
<h2 id="mysql8-0版本连接navicat，出现连接错误，报1251-error"><a href="#mysql8-0版本连接navicat，出现连接错误，报1251-error" class="headerlink" title="mysql8.0版本连接navicat，出现连接错误，报1251 error"></a>mysql8.0版本连接navicat，出现连接错误，报1251 error</h2><p><img src="C:\Users\QARHPF\AppData\Local\Temp\1662446328706.png" alt="66244632870"></p>
<p>这是因为mysql8.0版本和5.0版本加密方式不一样，所以会报错</p>
<p><strong>解决方法：</strong></p>
<p>1.打开Win+R，输入cmd启动控制台</p>
<p>2.找到你安装mysql8.0的bin目录，在控制台上输入cd D:\mysql\mysql8.0\bin(具体为你安装路径)</p>
<p>3.在自己安装的磁盘下输入bin目录后，接着输入 mysql -h localhost -P3307 -uroot -p(这里的3307是自己设置的端口号，自己设置是什么就填什么)</p>
<p>4.输入密码</p>
<p>5.输入 ALTER USER ‘root’@‘localhost’ IDENTIFIED WITH mysql_native_password BY ‘X’;（这里的X写的是你的密码）</p>
<p>6.输入 FLUSH PRIVILEGES;</p>
<p>7.关闭，重新去navicat连接可以了</p>
]]></content>
  </entry>
  <entry>
    <title>MySQL基础操作</title>
    <url>/2022/09/07/MySQL%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h1 id="数据库基础与MySQL安装"><a href="#数据库基础与MySQL安装" class="headerlink" title="数据库基础与MySQL安装"></a>数据库基础与MySQL安装</h1><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>数据库是“按照数据结构来组织、存储和管理数据的仓库”。是一个长期存储在计算机内的、有组织的、可共享的、统一管理的大量数据的集合。这些数据被存放在结构化的数据表里。数据表之间相互关联，反映了客观事物间的本质联系。<br>数据库种类大概有3种：层次式数据库、网络式数据库和关系式数据库。不同种类的数据库按不同的数据结构来联系和组织。</p>
<h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><p>在关系数据库中，数据库表是一系列二维数组的集合，用来存储数据和操作数据的逻辑结构。它由纵向的列和横向的行组成。行被称为记录，是组织数据的单位；列被称为字段，每一列表示记录的一个属性，有相应的描述信息，如数据类型、数据宽度等。<br>一个有关学生信息的名为students的表中，每列包含所有学生某个特定类型的信息，比如“姓名”，而每行则包含了某个特定学生的所有信息</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>性别</th>
<th>年龄</th>
<th>专业</th>
</tr>
</thead>
<tbody><tr>
<td>20100803050130</td>
<td>张三</td>
<td>男</td>
<td>18</td>
<td>计算机科学与技术</td>
</tr>
<tr>
<td>20100803050131</td>
<td>李四</td>
<td>女</td>
<td>18</td>
<td>软件工程</td>
</tr>
</tbody></table>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>数据类型决定了数据在计算机中的存储格式，代表不同的信息类型。常用的数据类型有整数数据类型、浮点数数据类型、精确小数类型、二进制数据类型、日期&#x2F;时间数据类型、字符串数据类型。</p>
<h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><p>主键（Primary Key）又称主码，用于唯一地标识表中的每一条记录。可以定义表中的一列或多列为主键，主键列上既不能有两行相同的值，也不能为空值。例如students表中的学号，每个学生都有属于自己的学号，并且学号唯一，此时学号就可以作为主键。姓名不能做主键的原因是有可能多个人具有相同的姓名，这违反了主键的唯一性，因此不能作为主键</p>
<h2 id="SQL语言"><a href="#SQL语言" class="headerlink" title="SQL语言"></a>SQL语言</h2><p>对数据库进行查询和修改操作的语言叫作SQL。SQL的含义是结构化查询语言（Structured Query Language）。SQL有许多不同的类型，有3个主要的标准：ANSI（美国国家标准机构）SQL；对ANSI SQL修改后在1992年采纳的标准，称为SQL-92或SQL2；最近的SQL-99标准，从SQL2扩充而来，并增加了对象关系特征和许多其他新功能。各大数据库厂商提供不同版本的SQL，这些版本的SQL不但能包括原始的ANSI标准，而且在很大程度上支持SQL-92标准。</p>
<p>SQL语言包含以下4部分。</p>
<ol>
<li>数据定义语言（DDL）：DROP、CREATE、ALTER等语句。</li>
<li>数据操作语言（DML）：INSERT（插入）、UPDATE（修改）、DELETE（删除）语句。</li>
<li>数据查询语言（DQL）：SELECT语句。</li>
<li>数据控制语言（DCL）：GRANT、REVOKE、COMMIT、ROLLBACK等语句。</li>
</ol>
<h2 id="数据库访问接口"><a href="#数据库访问接口" class="headerlink" title="数据库访问接口"></a>数据库访问接口</h2><p>不同的编程语言会为不同的数据库提供访问接口，程序通过这些接口执行SQL语句，进行数据库管理，主要的数据库访问接口有ODBC，JDBC，ADO.NET和PDO。</p>
<h3 id="ODBC"><a href="#ODBC" class="headerlink" title="ODBC"></a>ODBC</h3><p>ODBC（Open Database Connectivity，开放数据库连接）技术为访问不同的SQL数据库提供了一个共同的接口。ODBC使用SQL作为访问数据的标准。</p>
<h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><p>JDBC（Java Data Base Connectivity，Java数据库连接）用于Java应用程序连接数据库的标准方法，是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，由一组用Java语言编写的类和接口组成。</p>
<h3 id="ADO-NET"><a href="#ADO-NET" class="headerlink" title="ADO.NET"></a>ADO.NET</h3><p>ADO.NET是微软在.NET框架下开发设计的一组用于和数据源进行交互的面向对象类&#x3D;库。</p>
<h3 id="PDO"><a href="#PDO" class="headerlink" title="PDO"></a>PDO</h3><p>PDO（PHP Data Object）为PHP访问数据库定义了一个轻量级的、一致性的接口，提供了一个数据访问抽象层。这样，无论使用什么数据库，都可以通过一致的函数执行查询和获取数据。</p>
<h2 id="MySQL简介"><a href="#MySQL简介" class="headerlink" title="MySQL简介"></a>MySQL简介</h2><p>MySQL是一个小型关系数据库管理系统。与其他大型数据库管理系统（例如Oracle、DB2、SQL Server等）相比，MySQL规模小、功能有限，但是它体积小、速度快、成本低，并且提供的功能对稍微复杂的应用来说已经够用，这些特性使得MySQL成为世界上最受欢迎的开放源代码数据库。</p>
<h3 id="MySQL特点"><a href="#MySQL特点" class="headerlink" title="MySQL特点"></a>MySQL特点</h3><ol>
<li>速度：运行速度快。</li>
<li>价格：MySQL对多数个人来说是免费的。</li>
<li>容易使用：与其他大型数据库的设置和管理相比，其复杂程度较低，易于学习。</li>
<li>可移植性：能够工作在众多不同的系统平台上，例如Windows、Linux、UNIX、Mac OS等。</li>
<li>丰富的接口：提供了用于C、C++、Eiffel、Java、Perl、PHP、Python、Ruby和Tcl等语言的API。</li>
<li>支持查询语言：MySQL可以利用标准SQL语法和支持ODBC的应用程序。</li>
<li>安全性和连接性：十分灵活和安全的权限和密码系统，允许基于主机的验证。连接到服务器时，所有的密码传输均采用加密形式，从而保证了密码安全。由于MySQL是网络化的，因此可以在因特网上的任何地方访问，提高数据共享的效率。</li>
</ol>
<h3 id="MySQL命令简介"><a href="#MySQL命令简介" class="headerlink" title="MySQL命令简介"></a>MySQL命令简介</h3><p>MySQL服务端提供了一些命令工具，这些工具都放在MySQL安装目录下的bin目录中：</p>
<ol>
<li><p>mysqld：SQL后台程序（MySQL服务器进程）。必须在该程序运行之后，客户端才能通过连接服务器来访问数据库。</p>
</li>
<li><p>mysqld_safe：服务器启动脚本。在UNIX和NetWare中推荐使用mysqld_safe来启动mysqld服务器。mysqld_safe增加了一些安全特性，例如当出现错误时重启服务器并向错误日志文件写入运行时间信息。</p>
</li>
<li><p>mysql.server：服务器启动脚本。该脚本用于使用包含为特定级别的、运行启动服务的脚本的、运行目录的系统。它调用mysqld_safe来启动MySQL服务器。</p>
</li>
<li><p>mysql_multi：服务器启动脚本，可以启动或停止系统上安装的多个服务器。</p>
</li>
<li><p>myisamchk：用来描述、检查、优化和维护MyISAM表的实用工具。</p>
</li>
<li><p>mysqlbug：MySQL缺陷报告脚本。它可以用来向MySQL邮件系统发送缺陷报告。</p>
</li>
<li><p>mysql_install_db：该脚本用默认权限创建MySQL授权表。通常只是在系统上首次安装MySQL时执行一次。同样，MySQL也提供了客户度的一些命令工具，这些工具也放在MySQL安装目录下的bin目录中：</p>
</li>
<li><p>myisampack：压缩MyISAM表，以产生更小的只读表的一个工具。</p>
</li>
<li><p>mysql：交互式输入SQL语句或从文件以批处理模式执行它们的命令行工具。</p>
</li>
<li><p>mysqlaccess：检查访问主机名、用户名和数据库组合的权限的脚本。</p>
</li>
<li><p>mysqladmin：执行管理操作的客户程序，例如创建或删除数据库、重载授权表、将表刷新到硬盘上以及重新打开日志文件。mysqladmin还可以用来检索版本、进程，以及服务器的状态信息。</p>
</li>
<li><p>mysqlbinlog：从二进制日志读取语句的工具。在二进制日志文件中包含执行过的语句，可用来帮助系统从崩溃中恢复。</p>
</li>
<li><p>mysqlcheck：检查、修复、分析以及优化表的表维护客户程序。</p>
</li>
<li><p>mysqldump：将MySQL数据库转储到一个文件（例如SQL语句或tab分隔符文本文件）的客户程序。</p>
</li>
<li><p>mysqlhotcopy：当服务器在运行时，快速备份MyISAM或ISAM表的工具。</p>
</li>
<li><p>mysqlimport：使用LOAD DATA INFILE将文本文件导入相关表的客户程序。</p>
</li>
<li><p>mysqlshow：显示数据库、表、列以及索引相关信息的客户程序。</p>
</li>
<li><p>perror：显示系统或MySQL错误代码含义的工具。</p>
</li>
</ol>
<h1 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h1><p>MySQL安装完成后，会自动创建几个必须的数据库，可以使用show databases;查看当前已经存在或者创建的数据库。</p>
<h2 id="创建和删除数据库"><a href="#创建和删除数据库" class="headerlink" title="创建和删除数据库"></a>创建和删除数据库</h2><p>数据库可以想象为一个仓库，仓库内存放着所需的数据。</p>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>创建数据库就是在硬盘上划分一块区域用于数据的存储和管理，创建数据库的语法格式如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE DATABASE_NAME;</span><br></pre></td></tr></table></figure>

<p>例如：创建名称为students_manage的数据库，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE STUDENTS_MANAGE;</span><br></pre></td></tr></table></figure>

<p>当数据库创建成功后会显示Query OK, 1 row affected (0.05 sec)，表明语句执行成功，影响了1行，并输出执行该语句的消耗时长。</p>
<h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><p>删除数据库使用DROP命令，如果要删除某个数据库命令格式如下：<br>DROP DATABASE DATABASE_NAME;</p>
<p>接下来，删除刚才创建的数据库STUDENTS_MANAGE。命令如下<br>DROP DATABASES STUDENTS_MANAGE;</p>
<h2 id="数据表的创建和删除"><a href="#数据表的创建和删除" class="headerlink" title="数据表的创建和删除"></a>数据表的创建和删除</h2><p>在创建完数据库之后，接下来的工作就是创建数据表。所谓创建数据表，指的是在已经创建好的数据库中建立新表。创建数据表的过程是规定数据列的属性的过程，同时也是实施数据完整性（包括实体完整性、引用完整性和域完整性等）约束的过程</p>
<h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><p>数据库相当于仓库，而表则相当于数据库中不同的存储货物的区域，也就是说数据表数属于仓库的，因此在创建表之前，应该先明确这张表数据哪个数据库。确定数据库可以使用USE语句，例如使用名称为test的数据库，则语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USE TEST;</span><br></pre></td></tr></table></figure>

<p>如果没有选择数据库则会出现“No database selected”的错误。</p>
<p>在选择好要使用的数据库后就可以创建表了，创建表的语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE TABLE_NAME(</span><br><span class="line">    字段名1 数据类型 [约束] [默认值],</span><br><span class="line">    字段名2 数据类型 [约束] [默认值],</span><br><span class="line">    ....</span><br><span class="line">  	[表级别约束]</span><br><span class="line"> );</span><br></pre></td></tr></table></figure>

<p>在创建表时需要注意以下信息：</p>
<ol>
<li>要创建的表的名称，不区分大小写，不能使用SQL语言中的关键字，如DROP、ALTER、INSERT等。</li>
<li>数据表中每一列（字段）的名称和数据类型，如果创建多列，就要用逗号隔开。</li>
<li>创建表语句结束后末尾要加“;”，表明该命令已经结束。</li>
</ol>
<p>例如，创建学生信息表：（关于MySQL数据类型会在第3章详解介绍）</p>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>数据类型</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>INT(11)</td>
<td>学生编号</td>
</tr>
<tr>
<td>student_name</td>
<td>VARCHAR(30)</td>
<td>学生姓名</td>
</tr>
<tr>
<td>student_age</td>
<td>INT(3)</td>
<td>学生年龄</td>
</tr>
<tr>
<td>student_gender</td>
<td>CHAR(2)</td>
<td>学生性别</td>
</tr>
</tbody></table>
<p>下面，通过示例来创建数据库和表</p>
<ol>
<li>创建测试数据库</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE TEST_DB;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用数据库</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USE TEST_DB;</span><br></pre></td></tr></table></figure>

<ol>
<li>创建数据表</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE STUDENT_INFO(</span><br><span class="line">  ID INT(11),</span><br><span class="line">  STUDENT_NAME VARCHAR(25),</span><br><span class="line">  STUDENT_AGE VARCHAR(11),</span><br><span class="line">  STUDENT_GENDER CHAR(2)</span><br><span class="line"> );</span><br></pre></td></tr></table></figure>

<p>依次执行上述SQL语句即可创建好数据表。使用<code>SHOW TABLES;</code>即可查看创建好的表。</p>
<h3 id="数据表基本操作"><a href="#数据表基本操作" class="headerlink" title="数据表基本操作"></a>数据表基本操作</h3><h4 id="新增数据"><a href="#新增数据" class="headerlink" title="新增数据"></a>新增数据</h4><p>在表中新增数据可以使用INSERT语句。语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO TABLE_NAME (FIELD1,FIELD2,...FIELDN) VALUES (VALUE1,VALUES2,...VALUEN);</span><br></pre></td></tr></table></figure>

<p>上述语句中table_name指表名，FILED则是指要插入值的字段名称，VALUE指要插入数据库的值。例如在上述表中插入数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO STUDENT_INFO (ID,STUDENT_NAME,STUDENT_AGE,STUDENT_GENDER) VALUES (1,&#x27;张三&#x27;,18,&#x27;男&#x27;);</span><br></pre></td></tr></table></figure>

<p>运行上面的语句后对数据库进行查询</p>
<p>在上面的语句中，对表中的所有字段都插入了值，需要注意的是使用该语句是字段列的值和数据值的数量必须相同。如果确定是向表中的所有字段新增值，还有另外一种写法，此种写法可以省略所有的字段名称，但是值的顺序必须和创建表时书写的字段顺序保持一致，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO STUDENT_INFO VALUES (1,&#x27;张三&#x27;,18,&#x27;男&#x27;);</span><br></pre></td></tr></table></figure>

<p>需要注意的是，此种写法只能是所有字段都插入值的时候才能使用。</p>
<p>通常情况下，新增数据会向表中的所有字段插入值，但是也有一些特殊情况，只向数据表中的某几个字段添加值，此时，只需要写明要新增值的字段名称和对应的值即可(不能省略字段名称)，例如，新增一条数据，学生姓名为李四，性别为女。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO STUDENT_INFO (STUDENT_NAME,STUDENT_GENDER) VALUES (&#x27;李四&#x27;,&#x27;女&#x27;);</span><br></pre></td></tr></table></figure>

<p>执行该语句后对数据库进行查询，结果如图所示，可以看出没有新增值的字段使用NULL值填充。</p>
<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p>从数据表中删除数据使用DELETE语句，DELETE语句允许WHERE子句指定删除条件，DELETE语句基本格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM TABLE_NAME WHERE...</span><br></pre></td></tr></table></figure>

<p>table_name指定要执行删除操作的表；“[WHERE &lt;condition&gt;]”为可选参数，指定删除条件，如果没有WHERE子句，DELETE语句将删除表中的所有记录。</p>
<p>例如，删除数据表中姓名为李四的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM STUDENT_INFO WHERE STUDENT_NAME = &quot;李四&quot;;</span><br></pre></td></tr></table></figure>

<p>执行SQL语句后查询数据库，结果如图所示：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2745416/1630911441041-22fb31d7-f808-4988-9c86-a683fe3a5b0c.png" alt="img"></p>
<p>注意：如果想删除表中的所有记录，还可以使用 TRUNCATE  TABLE语句。TRUNCATE将直接删除原来的表，并重新创建一个表，其语法结构为TRUNCATE TABLE table_name。TRUNCATE直接删除表而不是删除记录，因此执行速度比DELETE快。执行DELETE操作时，一定要限定条件，如果不限定条件则会导致整张表中的记录被删除。</p>
<h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><p>表中有数据后，还可以对数据进行修改，MySQL中使用UPDATA语句更新表中的记录，可以更新特定的行或者同时更新所有的行。基本语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE TABLE_NAME SET COLUMN_NAME1 = VALUE1,CONLUMN_NAME2=VALUE2,...COLUMNN_NAMEN = VALUEN</span><br><span class="line">WHERE ...</span><br></pre></td></tr></table></figure>

<p>column_name1,column_name2,……,column_namen为指定更新的字段的名称；value1, value2,……,valuen为相对应的指定字段的更新值；condition指定更新的记录需要满足的条件。更新多列时，每个“列-值”对之间用逗号隔开，最后一列之后不需要逗号。</p>
<p>例如将表中的张三年龄修改为19：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE STUDENT_INFO SET STUDENT_AGE = 19 WHERE STUDENT_NAME = &#x27;张三&#x27;;</span><br></pre></td></tr></table></figure>

<p>修改完毕后查询数据表：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2745416/1630911121887-093a20b6-63d1-48b6-b8c8-6cbe78920d60.png" alt="img"></p>
<p><strong>保证UPDATE以WHERE子句结束，通过WHERE子句指定被更新的记录所需要满足的条件，如果忽略WHERE子句，MySQL将更新表中所有的行。</strong></p>
<h3 id="删除数据表"><a href="#删除数据表" class="headerlink" title="删除数据表"></a>删除数据表</h3><p>如果要删除数据表也可以使用DROP命令。命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE TABLE_NAME;</span><br></pre></td></tr></table></figure>

<p>接下来删除刚才创建的数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE STUDENT_INFO;</span><br></pre></td></tr></table></figure>

<p>删除完数据库后，再次运行<code>SHOW TABLES;</code>命令显示如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2745416/1630899092991-627b725d-92b1-4c44-9e02-8dc0fe99050d.png" alt="img"></p>
<h2 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h2><p>修改表指的是修改数据库中已经存在的数据表的结构。MySQL使用ALTER TABLE语句修改表。常用的修改表的操作有修改表名、修改字段数据类型或字段名、增加和删除字段等。</p>
<h3 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h3><p>MySQL是通过ALTER TABLE语句来实现表名的修改的，具体的语法规则如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TBALE OLD_TABLE_NAME RENAME TO NEW_TABLE_NAME;</span><br></pre></td></tr></table></figure>

<p>例如，将上述内容中STUDENT_INFO表名修改为STUDENT。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE STUDENT_INFO RENAME TO STUDENT;</span><br></pre></td></tr></table></figure>

<p>修改结束后，执行<code>SHOW TABLES;</code>查看修改结果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2745416/1630912401371-d30c41a6-0182-4adc-b058-e6fa3b87d4f6.png" alt="img"></p>
<h3 id="修改字段的数据类型"><a href="#修改字段的数据类型" class="headerlink" title="修改字段的数据类型"></a>修改字段的数据类型</h3><p>修改字段的数据类型就是把字段的数据类型修改为另一种类型，例如，通常情况下会用字符“男”，“女”表示性别，但是也可以使用整型，用0和1表示，修改字段数据类型的语法规则如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE TABLE_NAME MODIFY FIELD_NAME DATATYPE;</span><br></pre></td></tr></table></figure>

<p>其中TABLE_NAME是指修改字段所属的表名，FIELD_NAME是被修改的字段名称，DATATYPE则是指修改后的数据类型。</p>
<p>例如将上述STUDENT表中的SUTDENT_GENDER字段数据类型由char类型修改为int类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE STUDENT MODIFY STUDENT_GENDER INT(2);</span><br></pre></td></tr></table></figure>

<p>需要注意的，修改字段数据类型时如果已有数据的数据类型和修改后的数据类型不兼容，则会报错。如图所示</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2745416/1630912802444-218dbabb-b9fe-4ca6-a998-fdea81f37f7d.png" alt="img"></p>
<p>针对这种情况，可以先删除表中的数据，再进行修改。</p>
<p>删除表中数据后再次进行修改，结果如图</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2745416/1630912864471-638506dd-1c1f-4307-8e3a-b75fb9ad37d6.png" alt="img"></p>
<p>修改结束后可以运行<code>DESC TABLE;</code>命令查看表结构，运行<code>DESC STUDENT;</code>结果如图：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2745416/1630912979523-6470250e-99c7-4c5c-a5a0-ceaf1b1fe310.png" alt="img"></p>
<p>从图中可以看出成功修改了字段STUDENT_GENDER的数据类型。</p>
<h3 id="修改字段名"><a href="#修改字段名" class="headerlink" title="修改字段名"></a>修改字段名</h3><p>MySQL修改字段名的语法规则如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &lt;TABLE_NAME&gt; CHANGE &lt;OLD_FIELD_NAME&gt; &lt;NEW_FIELD_NAME&gt; &lt;NEW_DATA_TYPE&gt;</span><br></pre></td></tr></table></figure>

<p>将上表中的STUDENT_GENDER字段名称修改为GENDER。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE STUDENT CHANGE STUDENT_GENDER GENDER CHAR(2);</span><br></pre></td></tr></table></figure>

<p>修改完毕后，执行DESC查看表结构</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2745416/1630913397078-677a43c7-6da5-4f09-a82e-3efc922426ef.png" alt="img"></p>
<p>从图中可以看出，上述语句不但可以修改字段名称，还可以修改字段数据类型。</p>
<p>CHANGE也可以只修改数据类型，实现和MODIFY同样的效果，方法是将SQL语句中的“新字段名”和“旧字段名”设置为相同的名称，只改变“数据类型”。由于不同类型的数据在机器中存储的方式及长度并不相同，修改数据类型可能会影响到数据表中已有的数据记录，因此当数据库表中已经有数据时，不要轻易修改数据类型。</p>
<h3 id="添加字段"><a href="#添加字段" class="headerlink" title="添加字段"></a>添加字段</h3><p>有时在创建完数据库后或者随着业务的变化，需要在已经存在表中添加新的字段，一个完整字段包括字段名、数据类型、完整性约束。添加字段的语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &lt;TABLE_NAME&gt; ADD &lt;FIELD_NAME&gt; &lt;DATA_TYPE&gt; [约束] [FIRST|AFTER 已存在字段]</span><br></pre></td></tr></table></figure>

<p>新字段名为需要添加的字段的名称；“FIRST”为可选参数，其作用是将新添加的字段设置为表的第一个字段；“AFTER”为可选参数，其作用是将新添加的字段添加到指定的“已存在字段名”的后面。</p>
<p>“FIRST”或“AFTER已存在字段名”用于指定新增字段在表中的位置，如果SQL语句中没有这两个参数，则默认将新添加的字段设置为数据表的最后列。</p>
<p>接下来，为STUDENT表新增字段STUDENT_HEIGHT。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE STUDENT ADD STUDENT_HEIGHT FLOAT AFTER GENDER;</span><br></pre></td></tr></table></figure>

<p>执行完上述语句后，查看表结构，如图所示：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2745416/1630915355208-ec7f705f-7704-4ac7-b8d2-ae6800479f76.png" alt="img"></p>
<p>可以看出在GENDER字段后添加了数据类型为FLOAT的STUDENT_HEIGHT字段。</p>
<h3 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h3><p>删除字段即将数据表中的某个字段从表中移除。语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE TABLE_NAME DROP FIELD_NAME;</span><br></pre></td></tr></table></figure>

<p>例如，删除表中的STUDENT_HEIGTHT字段。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE STUDENT DROP STUDENT_HEIGTHT;</span><br></pre></td></tr></table></figure>

<p>执行上述语句后查看表结构，如图所示，可以看出已经删除了STUDENT_HEIGHT字段</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2745416/1630915313506-b93c849d-1f5f-4e91-876c-6fcbc3fe89e4.png" alt="img"></p>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>数据库完整性（Database Integrity）是指数据库中数据在逻辑上的一致性、正确性、有效性和相容性。数据库完整性由各种各样的完整性约束来保证，因此可以说数据库完整性设计就是数据库完整性约束的设计。在数据库中包含了以下4个完整性：</p>
<ol>
<li>实体完整性：实体完整性指表中行的完整性。主要用于保证操作的数据（记录）非空、唯一且不重复。即实体完整性要求每个关系（表）有且仅有一个主键，每一个主键值必须唯一，而且不允许为“空”（NULL）或重复。</li>
<li>域完整性：是指数据库表中的列必须满足某种特定的数据类型或约束。其中约束又包括取值范围、精度等规定。表中的CHECK、FOREIGN KEY 约束和DEFAULT、 NOT NULL定义都属于域完整性的范畴。</li>
<li>参照完整性：属于表间规则。对于永久关系的相关表，在更新、插入或删除记录时，如果只改其一，就会影响数据的完整性。如删除父表的某记录后，子表的相应记录未删除，致使这些记录称为孤立记录。对于更新、插入或删除表间数据的完整性，统称为参照完整性。</li>
<li>自定义完整性：对数据表中字段属性的约束，<strong>用户定义完整性规则</strong>（User-defined integrity）也称<strong>域完整性规则</strong>。包括字段的值域、字段的类型和字段的有效规则（如小数位数）等约束，是由确定关系结构时所定义的字段的属性决定的。如，百分制成绩的取值范围在0~100之间等。</li>
</ol>
<h3 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h3><p>主键，又称主码，是表中一列或多列的组合。主键约束（Primary KeyConstraint）要求主键列的数据唯一，并且不允许为空。主键能够唯一地标识表中的一条记录，可以结合外键来定义不同数据表之间的关系，并且可以加快数据库查询的速度。主键和记录之间的关系如同身份证和人之间的关系，它们之间是一一对应的。主键分为两种类型：单字段主键和多字段联合主键。</p>
<h4 id="单字段主键"><a href="#单字段主键" class="headerlink" title="单字段主键"></a>单字段主键</h4><p>主键由一个字段组成，SQL语句格式分为以下3种情况。</p>
<ol>
<li>在定义列的同时指定主键，语法规则如下：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字段名 数据类型 PRIMARY KEY;</span><br></pre></td></tr></table></figure>

<p>新建表并添加主键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE TEMP11(</span><br><span class="line">	ID INT PRIMARY KEY,</span><br><span class="line">  NAME VARCHAR(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ol>
<li>定义完所有列后指定主键</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE TEMP11(</span><br><span class="line">	ID INT,</span><br><span class="line">  NAME VARCHAR(20),</span><br><span class="line">  PRIMARY KEY(ID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ol>
<li>在创建完表后添加主键，语法格式如下</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 约束名 PRIMARY KEY(列名);</span><br></pre></td></tr></table></figure>

<h4 id="联合主键"><a href="#联合主键" class="headerlink" title="联合主键"></a>联合主键</h4><p>主键由多个字段联合组成，语法规则如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PRIMARY KEY [FIELD1,FIELD2,...FIELDN]</span><br></pre></td></tr></table></figure>

<p>例如，将上表中ID和NAME作为联合主键：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE TEMP11(</span><br><span class="line">  ID INT,</span><br><span class="line">  NAME VARCHAR(20),</span><br><span class="line">  PRIMARY KEY(ID,NAME)</span><br><span class="line"> )</span><br></pre></td></tr></table></figure>

<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>外键用来在两个表的数据之间建立连接，可以是一列或者多列。一个表可以有一个或多个外键。外键对应的是参照完整性，一个表的外键可以为空值，若不为空值，则每一个外键值必须等于另一个表中主键的某个值。</p>
<p>外键：首先它是表中的一个字段，虽可以不是本表的主键，但要对应另外一个表的主键。外键的主要作用是保证数据引用的完整性，定义外键后，不允许删除在另一个表中具有关联关系的行。外键的作用是保持数据的一致性、完整性。</p>
<p>主表：具有关联关系的多张表中，被引用主键所在的表叫主表，又叫做父表。</p>
<p>从表：具有关联关系的多张表中，引用某张表主键表叫从表（外键所在的表），又叫做子表。</p>
<p>创建外键的语法规则如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[CONSTRAINT &lt;外键名&gt;] FOREIGN KEY 字段名1,[字段名2...] REFERENCES &lt;主表名&gt; 主键列1,[主键列2...]</span><br></pre></td></tr></table></figure>

<p>“外键名”为定义的外键约束的名称，一个表中不能有相同名称的外键；“字段名”表示子表需要添加外键约束的字段列；“主表名”即被子表外键所依赖的表的名称；“主键列”表示主表中定义的主键列，或者列组合。</p>
<p>添加外键约束有两种方式：</p>
<ol>
<li>在创建表时添加</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE TB_STUDENT(</span><br><span class="line">  ID INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  USERANEM VARCHAR(20),</span><br><span class="line">  USERPASS VARCHAR(50)</span><br><span class="line">  )</span><br><span class="line">CREATE TABLE TB_STUDENT_INFO(</span><br><span class="line">	ID INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	NAME VARCHAR(20) NOT NULL,</span><br><span class="line">	TELPHONE VARCHAR(14) NOT NULL,</span><br><span class="line">	ADDRESS VARCHAR(30),</span><br><span class="line">	STUDENT_ID INT,</span><br><span class="line">	CONSTRAINT FK_STUDENT_ID FOREIGN KEY(STUDENT_ID) REFERENCES TB_STUDENT(ID)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ol>
<li>表创建结束后添加外键约束</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (列名) REFERENCES 被引用表(列名);</span><br></pre></td></tr></table></figure>

<p><strong>注意：当主表的记录被从表记录参照时，主表记录不允许被删除，必须先把从表里参照该记录的所有记录全部删除后，才可以删除主表的该记录。还有一种方式，删除主表记录时级联删除从表中所有参照该记录的从表记录，通过触发器可以实现第二种方式。</strong></p>
<h3 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h3><p>非空约束（Not Null Constraint）指字段的值不能为空。对于使用了非空约束的字段，如果用户在添加数据时没有指定值，数据库系统会报错。</p>
<p>非空约束语法规则如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字段名 数据类型 not null</span><br></pre></td></tr></table></figure>

<p>添加非空约束的方式有两种：</p>
<ol>
<li>在创建表时添加</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE TEMP11(</span><br><span class="line">	ID INT,</span><br><span class="line">	NAME VARCHAR(20) NOT NULL</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ol>
<li>创建表结束后添加</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE TABLENAME MODIFY COLUMN_NAME DATATYPE NOT NULL ;</span><br></pre></td></tr></table></figure>

<p>从上述代码可以看出，第2种方式其实本质上就是在修改列。</p>
<h3 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h3><p>唯一性约束（Unique Constraint）要求该列唯一，允许为空，但只能出现一个空值。唯一约束可以确保一列或者几列不出现重复值。</p>
<p>唯一约束的语法规则如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字段名 数据类型 UNIQUE</span><br></pre></td></tr></table></figure>

<p>添加唯一约束的方式有两种：</p>
<ol>
<li>在创建表时添加：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TEMP11(</span><br><span class="line">	ID <span class="type">INT</span>,</span><br><span class="line">	NAME <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>当某个字段添加唯一约束后该字段的值唯一即不能重复。<br>2.表创建完成以后添加</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> TBALE TABLENAME <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 约束名 <span class="keyword">UNIQUE</span>(列名)</span><br></pre></td></tr></table></figure>

<h3 id="默认约束"><a href="#默认约束" class="headerlink" title="默认约束"></a>默认约束</h3><p>默认约束（Default Constraint）指定某列的默认值。如男性同学较多，性别就可以默认为‘男’。如果插入一条新的记录时没有为这个字段赋值，那么系统会自动为这个字段赋值为‘男’。</p>
<p>默认约束的语法规则如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">字段名 数据类型 <span class="keyword">DEFAULT</span> 默认值</span><br></pre></td></tr></table></figure>

<p>添加默认约束的方式有2种：</p>
<ol>
<li>创建表时添加</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TEMP11(</span><br><span class="line">	ID <span class="type">INT</span> ,</span><br><span class="line">	NAME <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">  #该字段默认值是当前时间</span><br><span class="line">	<span class="keyword">DAY</span> DATETIME <span class="keyword">DEFAULT</span> NOW() </span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ol>
<li>创建表结束时添加</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 CHANGE 旧列名 新列名 DATATYPE DEFAULTE 默认值</span><br></pre></td></tr></table></figure>

<p>从代码中可以看出，第2种添加默认约束的方式和修改列名的语法一致。</p>
<h3 id="删除约束"><a href="#删除约束" class="headerlink" title="删除约束"></a>删除约束</h3><p>当不再需要约束时，可以删除约束，删除约束的语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span>  <span class="keyword">primary</span> key; <span class="operator">/</span><span class="operator">/</span>删除主键</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">drop</span> index 字段名;  <span class="operator">/</span><span class="operator">/</span>删除唯一约束</span><br></pre></td></tr></table></figure>

<h2 id="设置字段自增加"><a href="#设置字段自增加" class="headerlink" title="设置字段自增加"></a>设置字段自增加</h2><p>在数据库应用中，经常希望在每次插入新记录时，系统自动生成字段的主键值。可以通过为表主键添加AUTO_INCREMENT关键字来实现。默认的，在MySQL中AUTO_INCREMENT的初始值是1，每新增一条记录，字段值自动加1。一个表只能有一个字段使用AUTO_INCREMENT约束，且该字段必须为主键的一部分。AUTO_INCREMENT约束的字段可以是任何整数类型（TINYINT、SMALLIN、INT、BIGINT等）。</p>
<p>设置表的属性值自动增加的语法规则如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">字段名 数据类型 AUTO_INCERMENT;</span><br></pre></td></tr></table></figure>

<p>定义数据表temp1,指定字段ID为自增长：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TEMP1(</span><br><span class="line">  ID <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">  NAME <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line"> );</span><br></pre></td></tr></table></figure>

<p>在数据库中创建好表，并新增两条数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TEMP1 (NAME) <span class="keyword">VALUES</span> (&quot;张三&quot;);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TEMP1 (NAME) <span class="keyword">VALUES</span> (&quot;李四&quot;);</span><br></pre></td></tr></table></figure>

<p>执行结束后查询数据库：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2745416/1630920540845-1f5aa850-b796-49f9-8ac3-5fc1be6b7d00.png" alt="img"></p>
<p>在插入数据时，并没有为ID设置值，ID值为数据库自动生成并插入。每条数据的ID都比前一条数据的值大1.</p>
<h2 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h2><p>DESCRIBE&#x2F;DESC语句可以查看表的字段信息，其中包括字段名、字段数据类型、是否为主键、是否有默认值等。语法规则如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DESC</span> 表名;</span><br></pre></td></tr></table></figure>

<p>例如，查看temp1的表结构</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2745416/1630920707146-fd63f7be-7a87-4385-bd72-ec8131c9f928.png" alt="img"></p>
<p>其中，各个字段的含义分别解释如下：</p>
<ul>
<li>NULL：表示该列是否可以存储NULL值。</li>
<li>Key：表示该列是否已编制索引。PRI表示该列是表主键的一部分；UNI表示该列是UNIQUE索引的一部分；MUL表示在列中某个给定值允许出现多次。</li>
<li>Default：表示该列是否有默认值，有的话指定值是多少。</li>
<li>Extra：表示可以获取的与给定列有关的附加信息，例如AUTO_INCREMENT等。</li>
</ul>
<h2 id="数据库备份与恢复"><a href="#数据库备份与恢复" class="headerlink" title="数据库备份与恢复"></a>数据库备份与恢复</h2><p>数据备份是数据库管理员非常重要的工作之一。系统意外崩溃或者硬件的损坏都可能导致数据库的丢失，因此MySQL管理员应该定期地备份数据库，使得在意外情况发生时，尽可能减少损失。</p>
<h3 id="使用MySQLdump命令备份"><a href="#使用MySQLdump命令备份" class="headerlink" title="使用MySQLdump命令备份"></a>使用MySQLdump命令备份</h3><p>MySQLdump是MySQL提供的一个非常有用的数据库备份工具。MySQLdump命令执行时，可以将数据库备份成一个文本文件，该文件中实际包含了多个CREATE和INSERT语句，使用这些语句可以重新创建表和插入数据。MySQLdump备份数据库语句的基本语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>u <span class="keyword">user</span> <span class="operator">-</span>p dbname tbname1 tbname2 ... tbnamen <span class="operator">&gt;</span>filename.sql; </span><br></pre></td></tr></table></figure>

<p>user表示用户名称；password为登录密码；dbname为需要备份的数据库名称；tbname为dbname数据库中需要备份的数据表，可以指定多个需要备份的表，多个表之间用空格分隔；右箭头符号“&gt;”告诉MySQLdump将备份数据表的定义和数据写入备份文件；filename.sql为备份文件的名称。如果要备份整个数据库则省略表名即可。</p>
<p>注意：要保证保存文件的路径存在，否则会提示错误。</p>
<h3 id="恢复数据"><a href="#恢复数据" class="headerlink" title="恢复数据"></a>恢复数据</h3><p>对于已经备份的包含CREATE、INSERT语句的文本文件，可以使用MySQL命令导入到数据库中。本小节将介绍MySQL命令导入sql文件的方法。备份的sql文件中包含CREATE、INSERT语句（有时也会有DROP语句）。MySQL命令可以直接执行文件中的这些语句。其语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">-</span>u <span class="keyword">user</span> <span class="operator">-</span>p dbname <span class="operator">&lt;</span> filename.sql</span><br></pre></td></tr></table></figure>

<p>user是执行backup.sql中语句的用户名；-p表示输入用户密码；dbname是数据库名。</p>
<p>如果已经登录MySQL服务器，还可以使用source命令导入sql文件。source语句语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">source filename;</span><br></pre></td></tr></table></figure>

<h2 id="数据库设计范式"><a href="#数据库设计范式" class="headerlink" title="数据库设计范式"></a>数据库设计范式</h2><p>设计出性能良好、结构合理且符合业务的需求的数据库及数据表是需要具备一定经验及技巧的，并且还需要遵循一定的规则，在关系型数据库中这种规则就叫做范式，数据库设计总共有6大范式，一般设计数据库满足三大范式即可。</p>
<h3 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h3><p>第一范式是最基本的范式，指在关系模型中，所有的列都应该是原子列，即数据库表的每一列都是不可分割的原子数据项。</p>
<p>例如下面的数据表就是一个反例。</p>
<table>
<thead>
<tr>
<th>student_id</th>
<th>student_name</th>
<th>student_age</th>
<th>address</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>张三</td>
<td>18</td>
<td>陕西省西安市未央区明光路11号</td>
</tr>
<tr>
<td>2</td>
<td>李四</td>
<td>20</td>
<td>陕西省西安市未央区明光路21号</td>
</tr>
</tbody></table>
<h3 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h3><p>第二范式是指在满足第一范式的基础上，实体的属性完全依赖于主键列，而不能只能与主键的某一部分相关（这种情况一般出现在表中有联合主键的情况）。即在一个数据库表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。例如下表就违反了第二范式：</p>
<table>
<thead>
<tr>
<th>student_num</th>
<th>student_name</th>
<th>course_num</th>
<th>course_name</th>
</tr>
</thead>
<tbody><tr>
<td>20181101</td>
<td>张三</td>
<td>09001</td>
<td>Java</td>
</tr>
<tr>
<td>20181101</td>
<td>张三</td>
<td>09002</td>
<td>MySQL</td>
</tr>
<tr>
<td>20181102</td>
<td>李四</td>
<td>09001</td>
<td>Java</td>
</tr>
<tr>
<td>20181104</td>
<td>赵六</td>
<td>09002</td>
<td>MySQL</td>
</tr>
</tbody></table>
<p>在上表中需要学生编号和课程编号作为联合主键，课程名称值依赖于课程编号，而和学号没有关系，随着数据的增加，会产生大量的冗余数据。</p>
<p>可以对上表进行分割：</p>
<p>表1：学生表</p>
<table>
<thead>
<tr>
<th>student_num</th>
<th>student_name</th>
</tr>
</thead>
<tbody><tr>
<td>20181101</td>
<td>张三</td>
</tr>
<tr>
<td>20181102</td>
<td>李四</td>
</tr>
<tr>
<td>20181103</td>
<td>王五</td>
</tr>
<tr>
<td>20181104</td>
<td>赵六</td>
</tr>
</tbody></table>
<p>表2：课程表</p>
<table>
<thead>
<tr>
<th>course_num</th>
<th>course_name</th>
</tr>
</thead>
<tbody><tr>
<td>09001</td>
<td>Java</td>
</tr>
<tr>
<td>09002</td>
<td>MySQL</td>
</tr>
</tbody></table>
<p>表3：选课表</p>
<table>
<thead>
<tr>
<th>student_num</th>
<th>course_num</th>
</tr>
</thead>
<tbody><tr>
<td>20181101</td>
<td>09001</td>
</tr>
<tr>
<td>20181101</td>
<td>09002</td>
</tr>
<tr>
<td>20181102</td>
<td>09001</td>
</tr>
<tr>
<td>20181103</td>
<td>09002</td>
</tr>
</tbody></table>
<p>2.8.3 第三范式<br>第三范式是在满足第二范式的基础上，任何非主键列都与主键列直接相关，不能间接相关，例如下表：</p>
<table>
<thead>
<tr>
<th>order_num</th>
<th>good_id</th>
<th>good_price</th>
<th>good_count</th>
<th>good_total_price</th>
</tr>
</thead>
<tbody><tr>
<td>20201001002</td>
<td>1001</td>
<td>18.0</td>
<td>2</td>
<td>36</td>
</tr>
<tr>
<td>20201001003</td>
<td>1002</td>
<td>18.0</td>
<td>3</td>
<td>54</td>
</tr>
</tbody></table>
<p>上表是一个订单表，每行数据是一个订单，表中的good_total_price和订单主键订单号没有直接关键，因为该字段是依赖good_price和good_count计算而来的，所以违反了第三范式。对上表进行修改。</p>
]]></content>
  </entry>
  <entry>
    <title>面试并发篇</title>
    <url>/2022/09/07/%E9%9D%A2%E8%AF%95%E5%B9%B6%E5%8F%91%E7%AF%87/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<p>#Java 线程</p>
<p><img src="https://files.catbox.moe/uk4zgq.png"></p>
<p><img src="https://files.catbox.moe/5tabbh.png"></p>
<p><img src="https://files.catbox.moe/rgn04f.png"></p>
<p><img src="https://files.catbox.moe/9am7vb.png"></p>
<h2 id="简述线程、进程、程序的基本概念？"><a href="#简述线程、进程、程序的基本概念？" class="headerlink" title="简述线程、进程、程序的基本概念？"></a>简述线程、进程、程序的基本概念？</h2><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>程序，是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程，是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程，与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<p>另外，Java 线程是重量级的，每个线程默认使用 1024KB 的内存，所以一个 Java 进程是无法开启大量线程的。可以看 <a href="http://landcareweb.com/questions/33900/javazhong-de-qing-liang-ji-xian-cheng">《Java 中的轻量级线程？》</a> 的讨论，没准未来 Java 也有内置的协程（Coroutine）。</p>
<h3 id="三者之间的关系"><a href="#三者之间的关系" class="headerlink" title="三者之间的关系"></a>三者之间的关系</h3><ul>
<li>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。</li>
<li>从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</li>
</ul>
<h3 id="线程有什么优缺点？"><a href="#线程有什么优缺点？" class="headerlink" title="线程有什么优缺点？"></a>线程有什么优缺点？</h3><p>1）好处</p>
<ul>
<li>使用多线程可以把程序中占据时间长的任务放到后台去处理，如图片、视屏的下载。</li>
<li>发挥多核处理器的优势，并发执行让系统运行的更快、更流畅，用户体验更好。</li>
</ul>
<p>2）坏处</p>
<ul>
<li>大量的线程降低代码的可读性。</li>
<li>更多的线程需要更多的内存空间。</li>
<li>当多个线程对同一个资源出现争夺时候要注意线程安全的问题。</li>
</ul>
<h3 id="你了解守护线程吗？它和非守护线程有什么区别？"><a href="#你了解守护线程吗？它和非守护线程有什么区别？" class="headerlink" title="你了解守护线程吗？它和非守护线程有什么区别？"></a>你了解守护线程吗？它和非守护线程有什么区别？</h3><p>Java 中的线程分为两种：守护线程（Daemon）和用户线程（User）。</p>
<ul>
<li>任何线程都可以设置为守护线程和用户线程，通过方法Thread#setDaemon(boolean on) 设置。true 则把该线程设置为守护线程，反之则为用户线程。</li>
<li>Thread#setDaemon(boolean on) 方法，必须在Thread#start() 方法之前调用，否则运行时会抛出异常。</li>
</ul>
<p>唯一的区别是：</p>
<p>程序运行完毕，JVM 会等待非守护线程完成后关闭，但是 JVM 不会等待守护线程。</p>
<ul>
<li>判断虚拟机(JVM)何时离开，Daemon 是为其他线程提供服务，如果全部的 User Thread 已经撤离，Daemon 没有可服务的线程，JVM 撤离。</li>
<li>也可以理解为守护线程是 JVM 自动创建的线程（但不一定），用户线程是程序创建的线程。比如，JVM 的垃圾回收线程是一个守护线程，当所有线程已经撤离，不再产生垃圾，守护线程自然就没事可干了，当垃圾回收线程是 Java 虚拟机上仅剩的线程时，Java 虚拟机会自动离开。</li>
</ul>
<p>扩展：Thread Dump 打印出来的线程信息，含有 daemon 字样的线程即为守护进程。可能会有：服务守护进程、编译守护进程、Windows 下的监听 Ctrl + break 的守护进程、Finalizer 守护进程、引用处理守护进程、GC 守护进程。</p>
<p>关于守护线程的各种操作，可以看看 <a href="https://blog.csdn.net/u013256816/article/details/50392298">《Java 守护线程概述》</a> 。</p>
<h3 id="什么是线程组，为什么在-Java-中不推荐使用？"><a href="#什么是线程组，为什么在-Java-中不推荐使用？" class="headerlink" title="什么是线程组，为什么在 Java 中不推荐使用？"></a>什么是线程组，为什么在 Java 中不推荐使用？</h3><p>ThreadGroup 类，可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构有点类似于树的形式。</p>
<p>简单的说，ThreadGroup 为了方便线程的管理。</p>
<p>为什么不推荐使用？ThreadGroup API 比较薄弱，它并没有比 Thread 提供了更多的功能。它有两个主要的功能：一是获取线程组中处于活跃状态线程的列表；二是设置为线程设置未捕获异常处理器(uncaught exception handler)。但在 Java5 中 Thread 类也添加了 #setUncaughtExceptionHandler(UncaughtExceptionHandler eh) 方法，所以 ThreadGroup 是已经过时的，不建议继续使用。</p>
<h2 id="什么是多线程上下文切换？"><a href="#什么是多线程上下文切换？" class="headerlink" title="什么是多线程上下文切换？"></a>什么是多线程上下文切换？</h2><p>多线程会共同使用一组计算机上的 CPU ，而线程数大于给程序分配的 CPU 数量时，为了让各个线程都有执行的机会，就需要轮转使用 CPU 。</p>
<p>不同的线程切换使用 CPU 发生的切换数据等，就是上下文切换。</p>
<ul>
<li>在上下文切换过程中，CPU 会停止处理当前运行的程序，并保存当前程序运行的具体位置以便之后继续运行。从这个角度来看，上下文切换有点像我们同时阅读几本书，在来回切换书本的同时我们需要记住每本书当前读到的页码。在程序中，上下文切换过程中的“页码”信息是保存在进程控制块（PCB）中的。PCB还经常被称作“切换桢”（switchframe）。“页码”信息会一直保存到CPU的内存中，直到他们被再次使用。</li>
<li>上下文切换是存储和恢复 CPU 状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。</li>
</ul>
<h3 id="Java-中用到的线程调度算法是什么？"><a href="#Java-中用到的线程调度算法是什么？" class="headerlink" title="Java 中用到的线程调度算法是什么？"></a>Java 中用到的线程调度算法是什么？</h3><p>假设计算机只有一个 CPU ，则在任意时刻只能执行一条机器指令，每个线程只有获得 CPU 的使用权才能执行指令。</p>
<ul>
<li>所谓多线程的并发运行，其实是指从宏观上看，各个线程轮流获得 CPU 的使用权，分别执行各自的任务。</li>
<li>在运行池中，会有多个处于就绪状态的线程在等待 CPU ，Java 虚拟机的一项任务就是负责线程的调度，线程调度是指按照特定机制为多个线程分配 CPU 的使用权。</li>
</ul>
<p>有两种调度模型：分时调度模型和抢占式调度模型。</p>
<ul>
<li>分时调度模型是指让所有的线程轮流获得 CPU 的使用权,并且平均分配每个线程占用的 CPU 的时间片这个也比较好理解。</li>
<li>Java 虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用 CPU ，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用 CPU 。处于运行状态的线程会一直运行，直至它不得不放弃 CPU 。</li>
</ul>
<p>如非特别需要，尽量不要用，防止线程饥饿。</p>
<h3 id="什么是线程饥饿？"><a href="#什么是线程饥饿？" class="headerlink" title="什么是线程饥饿？"></a>什么是线程饥饿？</h3><p>线程饥饿，一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。</p>
<p>Java 中导致饥饿的原因：</p>
<ul>
<li>高优先级线程吞噬所有的低优先级线程的 CPU 时间。</li>
<li>线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。</li>
<li>线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的 wait 方法)，因为其他线程总是被持续地获得唤醒。</li>
</ul>
<h3 id="你对线程优先级的理解是什么？"><a href="#你对线程优先级的理解是什么？" class="headerlink" title="你对线程优先级的理解是什么？"></a>你对线程优先级的理解是什么？</h3><p>每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。</p>
<ul>
<li>我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个 int 变量(从1-10)，1 代表最低优先级，10 代表最高优先级。</li>
<li>Java 的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级有关，如非特别需要，一般无需设置线程优先级。</li>
</ul>
<h2 id="线程的生命周期？"><a href="#线程的生命周期？" class="headerlink" title="线程的生命周期？"></a>线程的生命周期？</h2><p>线程一共有五个状态，分别如下：</p>
<ul>
<li>新建(new)：当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。例如：Thread t1 &#x3D; new Thread() 。</li>
<li>可运行(runnable)：线程对象创建后，其他线程(比如 main 线程）调用了该对象的 start 方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取 cpu 的使用权。例如：t1.start() 。</li>
</ul>
<p>有些文章，会称可运行(runnable)为就绪，意思是一样的。</p>
<ul>
<li><p>运行(running)：线程获得 CPU 资源正在执行任务（#run() 方法），此时除非此线程自动放弃 CPU 资源或者有优先级更高的线程进入，线程将一直运行到结束。</p>
</li>
<li><p>死亡(dead)：当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。</p>
</li>
<li><ul>
<li>自然终止：正常运行完 #run()方法，终止。</li>
<li>异常终止：调用 #stop() 方法，让一个线程终止运行。</li>
</ul>
</li>
<li><p>阻塞(blocked)：由于某种原因导致正在运行的线程让出 CPU 并暂停自己的执行，即进入堵塞状态。直到线程进入可运行(runnable)状态，才有机会再次获得 CPU 资源，转到运行(running)状态。阻塞的情况有三种：</p>
</li>
<li><ul>
<li>正在睡眠：调用 #sleep(long t) 方法，可使线程进入睡眠方式。</li>
</ul>
</li>
</ul>
<p>一个睡眠着的线程在指定的时间过去可进入可运行(runnable)状态。</p>
<ul>
<li><ul>
<li>正在等待：调用 #wait() 方法。</li>
</ul>
</li>
</ul>
<p>调用 notify() 方法，回到就绪状态。</p>
<ul>
<li><ul>
<li>被另一个线程所阻塞：调用 #suspend() 方法。</li>
</ul>
</li>
</ul>
<p>调用 #resume() 方法，就可以恢复。</p>
<p><img src="https://files.catbox.moe/dol38j.png"></p>
<p>整体如下图所示：Thread的线程状态：</p>
<ul>
<li><p>中间一行是线程的顺畅的执行过程的四个状态。其上下两侧，是存在对应的情况，达到阻塞状态和恢复执行的过程。</p>
</li>
<li><p>有一点要注意，新建(new)和死亡(dead)是单向的状态，不可重复。**</p>
</li>
<li><p>理解线程的状态，可以用早起坐地铁来比喻这个过程：</p>
</li>
<li><ul>
<li>还没起床：sleeping 。</li>
<li>起床收拾好了，随时可以坐地铁出发：Runnable 。</li>
<li>等地铁来：Waiting 。</li>
<li>地铁来了，但要排队上地铁：I&#x2F;O 阻塞 。</li>
<li>上了地铁，发现暂时没座位：synchronized 阻塞。</li>
<li>地铁上找到座位：Running 。</li>
<li>到达目的地：Dead 。</li>
</ul>
</li>
</ul>
<p><img src="https://files.catbox.moe/whj2b0.png"></p>
<p>如下是另外一个图，把阻塞的情况，放在了一起，也可以作为参考：Thread 的线程状态</p>
<p>无意中，又看到一张画的更牛逼的，如下图：</p>
<p><img src="https://files.catbox.moe/z2mxzf.png"></p>
<p>Thread 的线程状态</p>
<h3 id="如何结束一个一直运行的线程？"><a href="#如何结束一个一直运行的线程？" class="headerlink" title="如何结束一个一直运行的线程？"></a>如何结束一个一直运行的线程？</h3><p>一般来说，有两种方式：</p>
<ul>
<li>方式一，使用退出标志，这个 flag 变量要多线程可见。</li>
</ul>
<p>在这种方式中，之所以引入共享变量，是因为该变量可以被多个执行相同任务的线程用来作为是否中断的信号，通知中断线程的执行。</p>
<ul>
<li>方式二，使用 interrupt 方法，结合 isInterrupted 方法一起使用。</li>
</ul>
<p>如果一个线程由于等待某些事件的发生而被阻塞，又该怎样停止该线程呢？这种情况经常会发生，比如当一个线程由于需要等候键盘输入而被阻塞，或者调用 Thread#join() 方法，或者 Thread#sleep(…) 方法，在网络中调用ServerSocket#accept() 方法，或者调用了DatagramSocket#receive() 方法时，都有可能导致线程阻塞，使线程处于处于不可运行状态时。即使主程序中将该线程的共享变量设置为 true ，但该线程此时根本无法检查循环标志，当然也就无法立即中断。</p>
<p>这里我们给出的建议是，不要使用 Thread#stop()· 方法，而是使用 Thread 提供的#interrupt()&#96; 方法，因为该方法虽然不会中断一个正在运行的线程，但是它可以使一个被阻塞的线程抛出一个中断异常，从而使线程提前结束阻塞状态，退出堵塞代码。</p>
<p>所以，方式一和方式二，并不是冲突的两种方式，而是可能根据实际场景下，进行结合。</p>
<h3 id="一个线程如果出现了运行时异常会怎么样"><a href="#一个线程如果出现了运行时异常会怎么样" class="headerlink" title="一个线程如果出现了运行时异常会怎么样?"></a>一个线程如果出现了运行时异常会怎么样?</h3><p>如果这个异常没有被捕获的话，这个线程就停止执行了。</p>
<p>另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放。</p>
<h2 id="创建线程的方式及实现？"><a href="#创建线程的方式及实现？" class="headerlink" title="创建线程的方式及实现？"></a>创建线程的方式及实现？</h2><p>Java 中创建线程主要有三种方式：</p>
<p>具体的每种方式的代码实现，可以看看 <a href="https://blog.csdn.net/u012973218/article/details/51280044">《Java创建线程的四种方式》</a> 。</p>
<p>关于文章中的方式四，实际是基于线程池的方式，使用下面的三种方式，也是生产实践中，最为推荐和常用的方式。</p>
<ul>
<li>方式一，继承 Thread 类创建线程类。</li>
<li>方式二，通过 Runnable 接口创建线程类。</li>
<li>方式三，通过 Callable 和 Future 创建线程。</li>
</ul>
<p>创建线程的三种方式的对比：</p>
<ul>
<li><p>使用方式一</p>
</li>
<li><ul>
<li>优点：编写简单，如果需要访问当前线程，则无需使用 Thread#currentThread() 方法，直接使用 this 即可获得当前线程。</li>
<li>缺点：线程类已经继承了 Thread 类，所以不能再继承其他父类。</li>
</ul>
</li>
<li><p>使用方式二、或方式三</p>
</li>
<li><ul>
<li>优点：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。</li>
<li>在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将 CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123; ... &#125;;</span><br><span class="line"><span class="comment">// 通过new Thread(target, name) 方法创建新线程</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(runna,<span class="string">&quot;新线程1&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(runna,<span class="string">&quot;新线程2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li><ul>
<li><ul>
<li>当然，实际比较少这么用。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>【最重要】可以使用线程池。</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>缺点：编程稍微复杂，如果要访问当前线程，则必须使用Thread#currentThread() 方法。</li>
</ul>
</li>
</ul>
<h3 id="start-和-run-方法有什么区别？"><a href="#start-和-run-方法有什么区别？" class="headerlink" title="start 和 run 方法有什么区别？"></a>start 和 run 方法有什么区别？</h3><ul>
<li>当你调用 start 方法时，你将创建新的线程，并且执行在 run 方法里的代码。</li>
<li>但是如果你直接调用 run 方法，它不会创建新的线程也不会执行调用线程的代码，只会把 run 方法当作普通方法去执行。</li>
</ul>
<p>一个线程运行时发生异常会怎样？</p>
<p>如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler 是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候 JVM 会使用 Thread#getUncaughtExceptionHandler() 方法来查询线程的 UncaughtExceptionHandler 并将线程和异常作为参数传递给 handler 的 #uncaughtException(exception) 方法进行处理。</p>
<p>具体的使用，可以看看 <a href="https://blog.csdn.net/u013256816/article/details/50417822">《JAVA 多线程之 UncaughtExceptionHandler —— 处理非正常的线程中止》</a> 。</p>
<h2 id="如何使用-wait-notify-实现通知机制？"><a href="#如何使用-wait-notify-实现通知机制？" class="headerlink" title="如何使用 wait + notify 实现通知机制？"></a>如何使用 wait + notify 实现通知机制？</h2><p>在 Java 发展史上，曾经使用 suspend、resume 方法对于线程进行阻塞唤醒，但随之出现很多问题，比较典型的还是死锁问题。</p>
<p>解决方案可以使用以对象为目标的阻塞，即利用 Object 类的 wait 和 notify方法实现线程阻塞。</p>
<ul>
<li>首先，wait、notify 方法是针对对象的，调用任意对象的 wait 方法都将导致线程阻塞，阻塞的同时也将释放该对象的锁，相应地，调用任意对象的 notify 方法则将随机解除该对象阻塞的线程，但它需要重新获取改对象的锁，直到获取成功才能往下执行。</li>
<li>其次，wait、notify 方法必须在 synchronized 块或方法中被调用，并且要保证同步块或方法的锁对象与调用 wait、notify 方法的对象是同一个，如此一来在调用 wait 之前当前线程就已经成功获取某对象的锁，执行 wait 阻塞后当前线程就将之前获取的对象锁释放。</li>
</ul>
<p>具体的实现，看看 <a href="https://juejin.im/entry/5a2bb783f265da43163cff74">《Wait &#x2F; Notify通知机制解析》</a> 文章。</p>
<h3 id="Thread类的-sleep-方法和对象的-wait-方法都可以让线程暂停执行，它们有什么区别？"><a href="#Thread类的-sleep-方法和对象的-wait-方法都可以让线程暂停执行，它们有什么区别？" class="headerlink" title="Thread类的 sleep 方法和对象的 wait 方法都可以让线程暂停执行，它们有什么区别？"></a>Thread类的 sleep 方法和对象的 wait 方法都可以让线程暂停执行，它们有什么区别？</h3><p>关于这个问题，可以结合 <a href="http://svip.iocoder.cn/Java/Concurrent/Interview/#">「线程的生命周期？」</a> 问题的图。</p>
<ul>
<li>sleep 方法，是线程类 Thread 的静态方法。调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态）</li>
<li>wait 方法，是 Object 类的方法。调用对象的 #wait() 方法，会导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的 #notify() 方法（或#notifyAll()方法）时，才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。</li>
</ul>
<h3 id="请说出与线程同步以及线程调度相关的方法？"><a href="#请说出与线程同步以及线程调度相关的方法？" class="headerlink" title="请说出与线程同步以及线程调度相关的方法？"></a>请说出与线程同步以及线程调度相关的方法？</h3><ul>
<li>wait 方法，使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁。</li>
<li>sleep 方法，使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理 InterruptedException 异常。</li>
<li>notify 方法，唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关。</li>
<li>notityAll 方法，唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态。</li>
</ul>
<h3 id="notify-和-notifyAll-有什么区别？"><a href="#notify-和-notifyAll-有什么区别？" class="headerlink" title="notify 和 notifyAll 有什么区别？"></a>notify 和 notifyAll 有什么区别？</h3><p>当一个线程进入 wait 之后，就必须等其他线程 notify&#x2F;notifyAll 。</p>
<ul>
<li>使用 notifyAll,可以唤醒所有处于 wait 状态的线程，使其重新进入锁的争夺队列中，而 notify 只能唤醒一个。</li>
<li>如果没把握，建议 notifyAll ，防止 notify 因为信号丢失而造成程序错误。</li>
</ul>
<p>关于 notify 的信息丢失，可以看看 <a href="https://www.jianshu.com/p/91d95bb5a4bd">《wait 和 notify 的坑》</a> 文章。</p>
<h3 id="为什么-wait-notify-和-notifyAll-这三方法不在-Thread-类里面？"><a href="#为什么-wait-notify-和-notifyAll-这三方法不在-Thread-类里面？" class="headerlink" title="为什么 wait, notify 和 notifyAll 这三方法不在 Thread 类里面？"></a>为什么 wait, notify 和 notifyAll 这三方法不在 Thread 类里面？</h3><p>一个很明显的原因是 Java 提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。由于 wait，notify 和 notifyAll 方法都是锁级别的操作，所以把它们定义在 Object 类中，因为锁属于对象。</p>
<h3 id="为什么-wait-和-notify-方法要在同步块中调用？"><a href="#为什么-wait-和-notify-方法要在同步块中调用？" class="headerlink" title="为什么 wait 和 notify 方法要在同步块中调用？"></a>为什么 wait 和 notify 方法要在同步块中调用？</h3><ul>
<li>Java API 强制要求这样做，如果你不这么做，你的代码会抛出 IllegalMonitorStateException 异常。</li>
<li>还有一个原因是为了避免 wait 和 notify 之间产生竞态条件。</li>
</ul>
<h3 id="为什么你应该在循环中检查等待条件？"><a href="#为什么你应该在循环中检查等待条件？" class="headerlink" title="为什么你应该在循环中检查等待条件？"></a>为什么你应该在循环中检查等待条件？</h3><p>处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。</p>
<p>所以，我们不能写 if (condition) 而应该是 while (condition) ，特别是 CAS 竞争的时候。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The standard idiom for using the wait method</span></span><br><span class="line"><span class="keyword">synchronized</span> (obj) &#123;    </span><br><span class="line">    <span class="keyword">while</span> (condition does not hold) &#123;       </span><br><span class="line">        <span class="comment">// (Releases lock, and reacquires on wakeup)  </span></span><br><span class="line">        obj.wait(); </span><br><span class="line">     &#125;    </span><br><span class="line">    ... <span class="comment">// Perform action appropriate to condition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>另外，也可以看看 <a href="https://blog.csdn.net/qq_35181209/article/details/77362297">《wait 必须放在 while 循环里面的原因探析》</a></li>
</ul>
<h2 id="sleep、join、yield-方法有什么区别？"><a href="#sleep、join、yield-方法有什么区别？" class="headerlink" title="sleep、join、yield 方法有什么区别？"></a>sleep、join、yield 方法有什么区别？</h2><p>1）sleep 方法</p>
<p>在指定的毫秒数内，让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。让其他线程有机会继续执行，但它并不释放对象锁。也就是如果有synchronized 同步块，其他线程仍然不能访问共享数据。注意该方法要捕获异常。</p>
<p>比如有两个线程同时执行(没有 synchronized)，一个线程优先级为MAX_PRIORITY ，另一个为 MIN_PRIORITY 。</p>
<ul>
<li>如果没有 sleep 方法，只有高优先级的线程执行完成后，低优先级的线程才能执行。但当高优先级的线程 #sleep(5000) 后，低优先级就有机会执行了。</li>
<li>总之，sleep 方法，可以使低优先级的线程得到执行的机会，当然也可以让同优先级、高优先级的线程有执行的机会。</li>
</ul>
<p>2）yield 方法</p>
<p>yield 方法和 sleep 方法类似，也不会释放“锁标志”，区别在于：</p>
<ul>
<li>它没有参数，即 yield 方法只是使当前线程重新回到可执行状态，所以执行yield 的线程有可能在进入到可执行状态后马上又被执行。</li>
<li>另外 yield 方法只能使同优先级或者高优先级的线程得到执行机会，这也和 sleep 方法不同。</li>
</ul>
<p>3）join 方法</p>
<p>Thread 的非静态方法 join ，让一个线程 B “加入”到另外一个线程 A 的尾部。在线程 A 执行完毕之前，线程 B 不能工作。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">t.start();</span><br><span class="line">t.join();</span><br></pre></td></tr></table></figure>

<ul>
<li>保证当前线程停止执行，直到该线程所加入的线程 t 完成为止。然而，如果它加入的线程 t 没有存活，则当前线程不需要停止。</li>
</ul>
<h3 id="线程的-sleep-方法和-yield-方法有什么区别？"><a href="#线程的-sleep-方法和-yield-方法有什么区别？" class="headerlink" title="线程的 sleep 方法和 yield 方法有什么区别？"></a>线程的 sleep 方法和 yield 方法有什么区别？</h3><ul>
<li>sleep 方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会。yield 方法只会给相同优先级或更高优先级的线程以运行的机会。</li>
<li>线程执行 sleep 方法后转入阻塞（blocked）状态，而执行 yield 方法后转入就绪（ready）状态。</li>
<li>sleep 方法声明抛出 InterruptedException 异常，而 yield 方法没有声明任何异常。</li>
<li>sleep 方法比 yield 方法（跟操作系统 CPU 调度相关）具有更好的可移植性。</li>
</ul>
<p>实际场景下，我们很少使用 yield 方法。</p>
<h3 id="为什么-Thread-类的-sleep-和-yield-方法是静态的？"><a href="#为什么-Thread-类的-sleep-和-yield-方法是静态的？" class="headerlink" title="为什么 Thread 类的 sleep 和 yield 方法是静态的？"></a>为什么 Thread 类的 sleep 和 yield 方法是静态的？</h3><p>Thread 类的 sleep 和 yield 方法，将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。</p>
<h3 id="sleep-0-有什么用途？"><a href="#sleep-0-有什么用途？" class="headerlink" title="sleep(0) 有什么用途？"></a>sleep(0) 有什么用途？</h3><p>Thread#sleep(0) 方法，并非是真的要线程挂起 0 毫秒，意义在于这次调用 Thread#sleep(0) 方法，把当前线程确实的被冻结了一下，让其他线程有机会优先执行。Thread#sleep(0) 方法，是你的线程暂时放弃 CPU ，也就是释放一些未用的时间片给其他线程或进程使用，就相当于一个让位动作。</p>
<p>可以看看 <a href="https://blog.csdn.net/qiaoquan3/article/details/56281092">《Sleep(0) 的妙用》</a> 的示例。</p>
<h3 id="你如何确保-main-方法所在的线程是-Java-程序最后结束的线程？"><a href="#你如何确保-main-方法所在的线程是-Java-程序最后结束的线程？" class="headerlink" title="你如何确保 main 方法所在的线程是 Java 程序最后结束的线程？"></a>你如何确保 main 方法所在的线程是 Java 程序最后结束的线程？</h3><p>考点，就是 join 方法。</p>
<p>我们可以使用 Thread 类的 #join() 方法，来确保所有程序创建的线程在 main 方法退出前结束。</p>
<h2 id="interrupted-和-isInterrupted-方法的区别？"><a href="#interrupted-和-isInterrupted-方法的区别？" class="headerlink" title="interrupted 和 isInterrupted 方法的区别？"></a>interrupted 和 isInterrupted 方法的区别？</h2><p>1）interrupt 方法</p>
<p>Thread#interrupt() 方法，用于中断线程。调用该方法的线程的状态为将被置为”中断”状态。</p>
<p>注意：线程中断仅仅是置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出 InterruptedException 的方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。</p>
<p>2）interrupted</p>
<p>Thread#interrupted() 静态方法，查询当前线程的中断状态，并且清除原状态。如果一个线程被中断了，第一次调用 #interrupted() 方法则返回 true ，第二次和后面的就返回 false 了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span> &#123;    </span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="literal">true</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">(<span class="type">boolean</span> ClearInterrupted)</span>;</span><br></pre></td></tr></table></figure>

<p>3）interrupted</p>
<p>Thread#isInterrupted() 方法，查询指定线程的中断状态，不会清除原状态。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span> &#123;    </span><br><span class="line">    <span class="keyword">return</span> isInterrupted(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">(<span class="type">boolean</span> ClearInterrupted)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="什么叫线程安全？"><a href="#什么叫线程安全？" class="headerlink" title="什么叫线程安全？"></a>什么叫线程安全？</h2><p>线程安全，是编程中的术语，指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。</p>
<h3 id="Servlet-是线程安全吗？"><a href="#Servlet-是线程安全吗？" class="headerlink" title="Servlet 是线程安全吗？"></a>Servlet 是线程安全吗？</h3><p>Servlet 不是线程安全的，Servlet 是单实例多线程的，当多个线程同时访问同一个方法，是不能保证共享变量的线程安全性的。</p>
<h3 id="SpringMVC-是线程安全吗？"><a href="#SpringMVC-是线程安全吗？" class="headerlink" title="SpringMVC 是线程安全吗？"></a>SpringMVC 是线程安全吗？</h3><p>不是的，和 Servlet 类似的处理流程。</p>
<h3 id="单例模式的线程安全性"><a href="#单例模式的线程安全性" class="headerlink" title="单例模式的线程安全性?"></a>单例模式的线程安全性?</h3><p>老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下：</p>
<ul>
<li>饿汉式单例模式的写法：线程安全</li>
<li>懒汉式单例模式的写法：非线程安全</li>
<li>双检锁单例模式的写法：线程安全</li>
</ul>
<h2 id="多线程同步和互斥有几种实现方法，都是什么？"><a href="#多线程同步和互斥有几种实现方法，都是什么？" class="headerlink" title="多线程同步和互斥有几种实现方法，都是什么？"></a>多线程同步和互斥有几种实现方法，都是什么？</h2><p>1）线程同步</p>
<p>线程同步，是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。</p>
<p>线程间的同步方法，大体可分为两类：用户模式和内核模式。顾名思义：</p>
<ul>
<li><p>内核模式，就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态。内核模式下的方法有：</p>
</li>
<li><ul>
<li>事件</li>
<li>信号量</li>
<li>互斥量</li>
</ul>
</li>
<li><p>用户模式，就是不需要切换到内核态，只在用户态完成操作。用户模式下的方法有：</p>
</li>
<li><ul>
<li>原子操作（例如一个单一的全局变量）</li>
<li>临界区</li>
</ul>
</li>
</ul>
<p>2）线程互斥</p>
<p>线程互斥，是指对于共享的进程系统资源，在各单个线程访问时的排它性。</p>
<ul>
<li>当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。</li>
<li>线程互斥可以看成是一种特殊的线程同步。</li>
</ul>
<h3 id="如何在两个线程间共享数据？"><a href="#如何在两个线程间共享数据？" class="headerlink" title="如何在两个线程间共享数据？"></a>如何在两个线程间共享数据？</h3><p>在两个线程间共享变量，即可实现共享。</p>
<p>一般来说，共享变量要求变量本身是线程安全的，然后在线程内使用的时候，如果有对共享变量的复合操作，那么也得保证复合操作的线程安全性。</p>
<h3 id="怎么检测一个线程是否拥有锁？"><a href="#怎么检测一个线程是否拥有锁？" class="headerlink" title="怎么检测一个线程是否拥有锁？"></a>怎么检测一个线程是否拥有锁？</h3><p>调用 Thread#holdsLock(Object obj) 静态方法，它返回 true 如果当且仅当当前线程拥有某个具体对象的锁。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">holdsLock</span><span class="params">(Object obj)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="10-个线程和-2-个线程的同步代码，哪个更容易写？"><a href="#10-个线程和-2-个线程的同步代码，哪个更容易写？" class="headerlink" title="10 个线程和 2 个线程的同步代码，哪个更容易写？"></a>10 个线程和 2 个线程的同步代码，哪个更容易写？</h3><p>从写代码的角度来说，两者的复杂度是相同的，因为同步代码与线程数量是相互独立的。</p>
<p>但是同步策略的选择依赖于线程的数量，因为越多的线程意味着更大的竞争，所以你需要利用同步技术，如锁分离，这要求更复杂的代码和专业知识。</p>
<h2 id="什么是-ThreadLocal-变量？"><a href="#什么是-ThreadLocal-变量？" class="headerlink" title="什么是 ThreadLocal 变量？"></a>什么是 ThreadLocal 变量？</h2><p>ThreadLocal ，是 Java 里一种特殊的变量。每个线程都有一个 ThreadLocal 就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。</p>
<p>它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用 ThreadLocal 让 SimpleDateFormat 变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。</p>
<ul>
<li>首先，通过复用减少了代价高昂的对象的创建个数。</li>
<li>其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。</li>
</ul>
<p>所以，ThreadLocal 很适合实现线程级的单例。</p>
<p>详细的，可以看看 <a href="https://www.cnblogs.com/dolphin0520/p/3920407.html">《Java并发编程：深入剖析ThreadLocal》</a> 文章。</p>
<p>关于源码，可以看看 <a href="http://www.iocoder.cn/JUC/sike/ThreadLocal/?vip">《【死磕 Java 并发】—– 深入分析 ThreadLocal》</a> 。</p>
<h3 id="什么是-InheritableThreadLocal-？"><a href="#什么是-InheritableThreadLocal-？" class="headerlink" title="什么是 InheritableThreadLocal ？"></a>什么是 InheritableThreadLocal ？</h3><p>InheritableThreadLocal 类，是 ThreadLocal 类的子类。ThreadLocal 中每个线程拥有它自己的值，与 ThreadLocal 不同的是，InheritableThreadLocal 允许一个线程以及该线程创建的所有子线程都可以访问它保存的值。</p>
<ul>
<li>具体的实现原理，可以看看 <a href="https://blog.csdn.net/ni357103403/article/details/51970748">《Java 多线程：InheritableThreadLocal 实现原理》</a> 文章。</li>
<li>具体的使用示例，可以看看 <a href="http://blog.didispace.com/Spring-Cloud%E4%B8%ADHystrix-%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB%E5%AF%BC%E8%87%B4ThreadLocal%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1/">《Spring Cloud中Hystrix 线程隔离导致ThreadLocal数据丢失》</a> 。</li>
</ul>
<h3 id="在多线程环境下，SimpleDateFormat-是线程安全的吗？"><a href="#在多线程环境下，SimpleDateFormat-是线程安全的吗？" class="headerlink" title="在多线程环境下，SimpleDateFormat 是线程安全的吗？"></a>在多线程环境下，SimpleDateFormat 是线程安全的吗？</h3><p>不是，非常不幸，DateFormat 的所有实现，包括 SimpleDateFormat 都不是线程安全的，因此你不应该在多线程序中使用，除非是在对外线程安全的环境中使用，如将 SimpleDateFormat 限制在 ThreadLocal 中。</p>
<p>如果你不这么做，在解析或者格式化日期的时候，可能会获取到一个不正确的结果。因此，从日期、时间处理的所有实践来说，我强力推荐 joda-time 库。</p>
<h2 id="如何在-Java-中获取线程堆栈？"><a href="#如何在-Java-中获取线程堆栈？" class="headerlink" title="如何在 Java 中获取线程堆栈？"></a>如何在 Java 中获取线程堆栈？</h2><ul>
<li>kill -3 [java pid]<br>不会在当前终端输出，它会输出到代码执行的或指定的地方去。比如， kill -3 tomcat pid , 输出堆栈到 log 目录下。</li>
<li>Jstack [java pid]<br>这个比较简单，在当前终端显示，也可以重定向到指定文件中。</li>
<li><a href="https://juejin.im/post/5a3b92def265da4319567218">JVisualVM：Thread Dump</a><br>打开 JVisualVM 后，都是界面操作，过程还是很简单的。</li>
</ul>
<h2 id="什么是Java-Timer-类？"><a href="#什么是Java-Timer-类？" class="headerlink" title="什么是Java Timer 类？"></a>什么是Java Timer 类？</h2><p>java.util.Timer ，是一个工具类，可以用于安排一个线程在未来的某个特定时间执行。Timer 类可以用安排一次性任务或者周期任务。</p>
<p>java.util.TimerTask ，是一个实现了 Runnable 接口的抽象类，我们需要去继承这个类来创建我们自己的定时任务并使用 Timer 去安排它的执行。</p>
<p>目前有开源的 Qurtz 可以用来创建定时任务。</p>
<h2 id="你有哪些多线程开发良好的实践？"><a href="#你有哪些多线程开发良好的实践？" class="headerlink" title="你有哪些多线程开发良好的实践？"></a>你有哪些多线程开发良好的实践？</h2><ul>
<li>1、给线程命名。</li>
</ul>
<p>这样可以方便找 bug 或追踪。OrderProcessor、QuoteProcessor、TradeProcessor 这种名字比 Thread-1、Thread-2、Thread-3 好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个最佳实践。</p>
<ul>
<li>2、最小化同步范围。</li>
</ul>
<p>锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。</p>
<ul>
<li>3、优先使用 volatile ，而不是 synchronized 。</li>
<li>4、尽可能使用更高层次的并发工具而非 wait 和 notify 方法来实现线程通信。</li>
</ul>
<p>首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用 wait 和 notify 很难实现对复杂控制流的控制。</p>
<p>其次，这些类是由最好的企业编写和维护在后续的 JDK 中它们还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。</p>
<ul>
<li>5、优先使用并发容器，而非同步容器。</li>
</ul>
<p>这是另外一个容易遵循且受益巨大的最佳实践，并发容器比同步容器的可扩展性更好，所以在并发编程时使用并发集合效果更好。如果下一次你需要用到 Map ，我们应该首先想到用 ConcurrentHashMap 类。</p>
<ul>
<li>6、考虑使用线程池。</li>
</ul>
<h2 id="并发编程和并行编程有什么区别？"><a href="#并发编程和并行编程有什么区别？" class="headerlink" title="并发编程和并行编程有什么区别？"></a>并发编程和并行编程有什么区别？</h2><p>并发（Concurrency）和并行（Parallellism）是：</p>
<ul>
<li>解释一：并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。</li>
<li>解释二：并行是在不同实体上的多个事件；并发是在同一实体上的多个事件。</li>
<li>解释三：在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如 Hadoop 分布式集群。</li>
</ul>
<p>所以并发编程的目标是，充分的利用处理器的每一个核，以达到最高的处理性能。</p>
<h2 id="同步和异步有何异同，在什么情况下分别使用他们？"><a href="#同步和异步有何异同，在什么情况下分别使用他们？" class="headerlink" title="同步和异步有何异同，在什么情况下分别使用他们？"></a>同步和异步有何异同，在什么情况下分别使用他们？</h2><p>如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。</p>
<p>当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。</p>
<p>当然，如果我们对效率没有特别大的要求，也不一定需要使用异步编程，因为它会带来编码的复杂性。总之，合适才是正确的。</p>
<h2 id="Java-锁"><a href="#Java-锁" class="headerlink" title="Java 锁"></a>Java 锁</h2><p><img src="https://files.catbox.moe/bg804u.png"></p>
<p><img src="https://files.catbox.moe/xj5dfd.png"></p>
<p><img src="https://files.catbox.moe/pwu2gu.png"></p>
<h2 id="synchronized-的原理是什么"><a href="#synchronized-的原理是什么" class="headerlink" title="synchronized 的原理是什么?"></a>synchronized 的原理是什么?</h2><p>synchronized是 Java 内置的关键字，它提供了一种独占的加锁方式。</p>
<ul>
<li><p>synchronized的获取和释放锁由JVM实现，用户不需要显示的释放锁，非常方便。</p>
</li>
<li><p>然而，synchronized也有一定的局限性。</p>
</li>
<li><ul>
<li>当线程尝试获取锁的时候，如果获取不到锁会一直阻塞。</li>
<li>如果获取锁的线程进入休眠或者阻塞，除非当前线程异常，否则其他线程尝试获取锁必须一直等待。</li>
</ul>
</li>
</ul>
<p>关于原理，直接阅读 <a href="http://www.iocoder.cn/JUC/sike/synchronized/?vip">《【死磕 Java 并发】—– 深入分析 synchronized 的实现原理》</a> 文章，有几个重点要注意看。</p>
<ul>
<li><p>实现原理</p>
</li>
<li><p>Java 对象头、Monitor</p>
</li>
<li><p>锁优化</p>
</li>
<li><ul>
<li>自旋锁</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>适应自旋锁</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>锁消除</li>
<li>锁粗化</li>
<li>锁的升级</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>重量级锁</li>
<li>轻量级锁</li>
<li>偏向锁</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="当一个线程进入某个对象的一个-synchronized-的实例方法后，其它线程是否可进入此对象的其它方法？"><a href="#当一个线程进入某个对象的一个-synchronized-的实例方法后，其它线程是否可进入此对象的其它方法？" class="headerlink" title="当一个线程进入某个对象的一个 synchronized 的实例方法后，其它线程是否可进入此对象的其它方法？"></a>当一个线程进入某个对象的一个 synchronized 的实例方法后，其它线程是否可进入此对象的其它方法？</h3><ul>
<li>如果其他方法没有 synchronized 的话，其他线程是可以进入的。</li>
<li>所以要开放一个线程安全的对象时，得保证每个方法都是线程安全的。</li>
</ul>
<h3 id="同步方法和同步块，哪个是更好的选择？"><a href="#同步方法和同步块，哪个是更好的选择？" class="headerlink" title="同步方法和同步块，哪个是更好的选择？"></a>同步方法和同步块，哪个是更好的选择？</h3><p>同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。</p>
<p>同步块更要符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，这样从侧面来说也可以避免死锁。</p>
<h3 id="在监视器-Monitor-内部，是如何做线程同步的？"><a href="#在监视器-Monitor-内部，是如何做线程同步的？" class="headerlink" title="在监视器(Monitor)内部，是如何做线程同步的？"></a>在监视器(Monitor)内部，是如何做线程同步的？</h3><p>监视器和锁在 Java 虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。</p>
<h3 id="Java-如何实现“自旋”（spin）"><a href="#Java-如何实现“自旋”（spin）" class="headerlink" title="Java 如何实现“自旋”（spin）"></a>Java 如何实现“自旋”（spin）</h3><p>参考 <a href="http://ifeve.com/java_lock_see1/">《Java 锁的种类以及辨析（一）：自旋锁》</a></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinLock</span> &#123;    </span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; sign =<span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">// &lt;1&gt;        </span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();       </span><br><span class="line">        <span class="keyword">while</span>(!sign .compareAndSet(<span class="literal">null</span>, current)) &#123;</span><br><span class="line">            <span class="comment">// &lt;1.1&gt;        </span></span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span> <span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">// &lt;2&gt;        </span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();        </span><br><span class="line">        sign .compareAndSet(current, <span class="literal">null</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>&lt;1&gt; 处，#lock() 方法，如果获得不到锁，就会“死循环”，直到或得到锁为止。考虑到“死循环”会持续占用 CPU ，可能导致其它线程无法获得到 CPU 执行，可以在 &lt;1.1&gt; 处增加 Thread.yiead() 代码段，出让下 CPU 。</li>
<li>&lt;2&gt; 处，#unlock() 方法，释放锁。</li>
</ul>
<h2 id="volatile-实现原理"><a href="#volatile-实现原理" class="headerlink" title="volatile 实现原理"></a>volatile 实现原理</h2><p>volatile 涉及的内容直接看：</p>
<ul>
<li><a href="http://www.iocoder.cn/JUC/sike/volatile/?vip">《【死磕 Java 并发】—– 深入分析 volatile 的实现原理》</a></li>
<li><a href="https://www.infoq.cn/article/ftf-java-volatile">聊聊并发（一）——深入分析Volatile的实现原理</a></li>
</ul>
<h3 id="volatile-有什么用？"><a href="#volatile-有什么用？" class="headerlink" title="volatile 有什么用？"></a>volatile 有什么用？</h3><p>volatile 保证内存可见性和禁止指令重排。</p>
<p>同时，volatile 可以提供部分原子性。</p>
<p>简单来说，volatile 用于多线程环境下的单次操作(单次读或者单次写)。</p>
<h3 id="volatile-变量和-atomic-变量有什么不同？"><a href="#volatile-变量和-atomic-变量有什么不同？" class="headerlink" title="volatile 变量和 atomic 变量有什么不同？"></a>volatile 变量和 atomic 变量有什么不同？</h3><ul>
<li>volatile 变量，可以确保先行关系，即写操作会发生在后续的读操作之前，但它并不能保证原子性。例如用 volatile 修饰 count 变量，那么 count++ 操作就不是原子性的。</li>
<li>AtomicInteger 类提供的 atomic 方法，可以让这种操作具有原子性。例如 #getAndIncrement() 方法，会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</li>
</ul>
<h3 id="可以创建-volatile-数组吗"><a href="#可以创建-volatile-数组吗" class="headerlink" title="可以创建 volatile 数组吗?"></a>可以创建 volatile 数组吗?</h3><p>Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。</p>
<p>同理，对于 Java POJO 类，使用 volatile 修饰，只能保证这个引用的可见性，不能保证其内部的属性。</p>
<h3 id="volatile-能使得一个非原子操作变成原子操作吗"><a href="#volatile-能使得一个非原子操作变成原子操作吗" class="headerlink" title="volatile 能使得一个非原子操作变成原子操作吗?"></a>volatile 能使得一个非原子操作变成原子操作吗?</h3><p>一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile 。为什么？因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 volatile 型的 long 或 double 变量的读写是原子。</p>
<p>如下的内容，可以作为上面的内容的补充。</p>
<p>一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。</p>
<h3 id="volatile-类型变量提供什么保证？"><a href="#volatile-类型变量提供什么保证？" class="headerlink" title="volatile 类型变量提供什么保证？"></a>volatile 类型变量提供什么保证？</h3><p>volatile 主要有两方面的作用：</p>
<ol>
<li>避免指令重排</li>
<li>可见性保证</li>
</ol>
<p>例如，JVM 或者 JIT 为了获得更好的性能会对语句重排序，但是 volatile 类型变量即使在没有同步块的情况下赋值也不会与其他语句重排序。</p>
<ul>
<li>volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。</li>
<li>某些情况下，volatile 还能提供原子性，如读 64 位数据类型，像 long 和 double 都不是原子的(低 32 位和高 32 位)，但 volatile 类型的 double 和 long 就是原子的。不过需要在 64 位的 JVM 虚拟机上。详细的分析，可以看看 <a href="https://my.oschina.net/u/1753415/blog/724242">《Java中 long 和 double 的原子性》</a> 。</li>
</ul>
<h3 id="volatile-和-synchronized-的区别？"><a href="#volatile-和-synchronized-的区别？" class="headerlink" title="volatile 和 synchronized 的区别？"></a>volatile 和 synchronized 的区别？</h3><ol>
<li>volatile 本质是在告诉 JVM 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取。synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li>
<li>volatile 仅能使用在变量级别。synchronized 则可以使用在变量、方法、和类级别的。</li>
<li>volatile 仅能实现变量的修改可见性，不能保证原子性。而synchronized 则可以保证变量的修改可见性和原子性。</li>
<li>volatile 不会造成线程的阻塞。synchronized 可能会造成线程的阻塞。</li>
<li>volatile 标记的变量不会被编译器优化。synchronized标记的变量可以被编译器优化。</li>
</ol>
<p>另外，会有面试官会问 volatile 能否取代 synchronized 呢？答案肯定是不能，虽然说 volatile 被称之为轻量级锁，但是和 synchronized 是有本质上的区别，原因就是上面的几点。</p>
<h3 id="什么场景下可以使用-volatile-替换-synchronized-？"><a href="#什么场景下可以使用-volatile-替换-synchronized-？" class="headerlink" title="什么场景下可以使用 volatile 替换 synchronized ？"></a>什么场景下可以使用 volatile 替换 synchronized ？</h3><ol>
<li>只需要保证共享资源的可见性的时候可以使用 volatile 替代，synchronized 保证可操作的原子性一致性和可见性。</li>
<li>volatile 适用于新值不依赖于旧值的情形。</li>
<li>1 写 N 读。</li>
<li>不与其他变量构成不变性条件时候使用 volatile 。</li>
</ol>
<h2 id="什么是死锁、活锁？"><a href="#什么是死锁、活锁？" class="headerlink" title="什么是死锁、活锁？"></a>什么是死锁、活锁？</h2><p>死锁，是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</p>
<p>产生死锁的必要条件：</p>
<ul>
<li>互斥条件：所谓互斥就是进程在某一时间内独占资源。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：进程已获得资源，在末使用完之前，不能强行剥夺。</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
<p>死锁的解决方法：</p>
<ul>
<li>撤消陷于死锁的全部进程。</li>
<li>逐个撤消陷于死锁的进程，直到死锁不存在。</li>
<li>从陷于死锁的进程中逐个强迫放弃所占用的资源，直至死锁消失。</li>
<li>从另外一些进程那里强行剥夺足够数量的资源分配给死锁进程，以解除死锁状态。</li>
</ul>
<h3 id="什么是活锁？"><a href="#什么是活锁？" class="headerlink" title="什么是活锁？"></a>什么是活锁？</h3><p>活锁，任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。</p>
<h3 id="死锁与活锁的区别？"><a href="#死锁与活锁的区别？" class="headerlink" title="死锁与活锁的区别？"></a>死锁与活锁的区别？</h3><p>活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”，而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。</p>
<p>实际上，是不是已经发现，死锁就是悲观锁可能产生的结果，而活锁是乐观锁可能产生的结果。</p>
<h2 id="什么是悲观锁、乐观锁？"><a href="#什么是悲观锁、乐观锁？" class="headerlink" title="什么是悲观锁、乐观锁？"></a>什么是悲观锁、乐观锁？</h2><p>1）悲观锁</p>
<p>悲观锁，总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。</p>
<ul>
<li>传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</li>
<li>再比如 Java 里面的同步原语 synchronized 关键字的实现也是悲观锁。</li>
</ul>
<p>2）乐观锁</p>
<p>乐观锁，顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。</p>
<ul>
<li>像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。</li>
</ul>
<p>例如，version 字段（比较跟上一次的版本号，如果一样则更新，如果失败则要重复读-比较-写的操作）</p>
<ul>
<li>在 Java 中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。</li>
</ul>
<p>乐观锁的实现方式：</p>
<ul>
<li>使用版本标识来确定读到的数据与提交时的数据是否一致。提交后修改版本标识，不一致时可以采取丢弃和再次尝试的策略。</li>
<li>Java 中的 Compare and Swap 即 CAS ，当多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</li>
</ul>
<h1 id="Java-Lock-接口"><a href="#Java-Lock-接口" class="headerlink" title="Java Lock 接口"></a>Java Lock 接口</h1><p>虽然 Lock 也翻译成锁，但是和上面的 <a href="http://svip.iocoder.cn/Java/Concurrent/Interview/#">「Java 锁」</a> 分开，它更多强调的是 synchronized 和 volatile 关键字带来的重量级和轻量级锁。而 Lock 是 Java 锁接口，提供了更多灵活的功能。</p>
<p><img src="https://files.catbox.moe/vy39xs.png"></p>
<h2 id="Java-AQS"><a href="#Java-AQS" class="headerlink" title="Java AQS"></a>Java AQS</h2><p>java.util.concurrent.locks.AbstractQueuedSynchronizer 抽象类，简称 AQS ，是一个用于构建锁和同步容器的同步器。事实上concurrent 包内许多类都是基于 AQS 构建。例如 ReentrantLock，Semaphore，CountDownLatch，ReentrantReadWriteLock，等。AQS 解决了在实现同步容器时设计的大量细节问题。</p>
<p>AQS 使用一个 FIFO 的队列表示排队等待锁的线程，队列头节点称作“哨兵节点”或者“哑节点”，它不与任何线程关联。其他的节点与等待线程关联，每个节点维护一个等待状态 waitStatus 。</p>
<p>可见如下的四篇文章。</p>
<ul>
<li><a href="http://www.iocoder.cn/JUC/sike/aqs-0-intro?vip">《【死磕 Java 并发】—– J.U.C 之 AQS：AQS 简介》</a></li>
<li><a href="http://www.iocoder.cn/JUC/sike/aqs-1-clh?vip">《【死磕 Java 并发】—– J.U.C 之 AQS：CLH 同步队列》</a></li>
<li><a href="http://www.iocoder.cn/JUC/sike/aqs-2?vip">《【死磕 Java 并发】—– J.U.C 之 AQS：同步状态的获取与释放》</a></li>
<li><a href="http://www.iocoder.cn/JUC/sike/aqs-3?vip">《【死磕 Java 并发】—– J.U.C 之 AQS：阻塞和唤醒线程》</a></li>
</ul>
<h2 id="什么是-Java-Lock-接口？"><a href="#什么是-Java-Lock-接口？" class="headerlink" title="什么是 Java Lock 接口？"></a>什么是 Java Lock 接口？</h2><p>java.util.concurrent.locks.Lock 接口，比 synchronized 提供更具拓展行的锁操作。它允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。它的优势有：</p>
<ul>
<li>可以使锁更公平。</li>
<li>可以使线程在等待锁的时候响应中断。</li>
<li>可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间。</li>
<li>可以在不同的范围，以不同的顺序获取和释放锁。</li>
</ul>
<h2 id="什么是可重入锁（ReentrantLock）？"><a href="#什么是可重入锁（ReentrantLock）？" class="headerlink" title="什么是可重入锁（ReentrantLock）？"></a>什么是可重入锁（ReentrantLock）？</h2><p>举例来说明锁的可重入性。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnReentrant</span>&#123;    </span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lock</span>();    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outer</span><span class="params">()</span> &#123;        </span><br><span class="line">        lock.lock();        </span><br><span class="line">        inner();        </span><br><span class="line">        lock.unlock();    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inner</span><span class="params">()</span> &#123;        </span><br><span class="line">        lock.lock();        </span><br><span class="line">        <span class="comment">//do something        </span></span><br><span class="line">        lock.unlock();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>#outer() 方法中调用了 #inner() 方法，#outer() 方法先锁住了 lock ，这样 #inner() 就不能再获取 lock 。</li>
<li>其实调用 #outer() 方法的线程已经获取了 lock 锁，但是不能在 #inner() 方法中重复利用已经获取的锁资源，这种锁即称之为不可重入。</li>
<li>可重入就意味着：线程可以进入任何一个它已经拥有的锁所同步着的代码块。</li>
</ul>
<p>synchronized、ReentrantLock 都是可重入的锁，可重入锁相对来说简化了并发编程的开发。</p>
<p>关于 ReentrantLock 类，详细的源码解析，可以看看 <a href="http://www.iocoder.cn/JUC/sike/ReentrantLock/?vip">《【死磕 Java 并发】—– J.U.C 之重入锁：ReentrantLock》</a> 。</p>
<p>简单来说，ReenTrantLock 的实现是一种自旋锁，通过循环调用 CAS 操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。想尽办法避免线程进入内核的阻塞状态是我们去分析和理解锁设计的关键钥匙。</p>
<h3 id="synchronized-和-ReentrantLock-异同？"><a href="#synchronized-和-ReentrantLock-异同？" class="headerlink" title="synchronized 和 ReentrantLock 异同？"></a>synchronized 和 ReentrantLock 异同？</h3><ul>
<li><p>相同点</p>
</li>
<li><ul>
<li>都实现了多线程同步和内存可见性语义。</li>
<li>都是可重入锁。</li>
</ul>
</li>
<li><p>不同点</p>
</li>
<li><ul>
<li>同步实现机制不同</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>synchronized 通过 Java 对象头锁标记和 Monitor 对象实现同步。</li>
<li>ReentrantLock 通过CAS、AQS（AbstractQueuedSynchronizer）和 LockSupport（用于阻塞和解除阻塞）实现同步。</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>可见性实现机制不同</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>synchronized 依赖 JVM 内存模型保证包含共享变量的多线程内存可见性。</li>
<li>ReentrantLock 通过 ASQ 的 volatile state 保证包含共享变量的多线程内存可见性。</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>使用方式不同</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>synchronized 可以修饰实例方法（锁住实例对象）、静态方法（锁住类对象）、代码块（显示指定锁对象）。</li>
<li>ReentrantLock 显示调用 tryLock 和 lock 方法，需要在 finally 块中释放锁。</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>功能丰富程度不同</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>synchronized 不可设置等待时间、不可被中断（interrupted）。</li>
<li>ReentrantLock 提供有限时间等候锁（设置过期时间）、可中断锁（lockInterruptibly）、condition（提供 await、condition（提供 await、signal 等方法）等丰富功能</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>锁类型不同</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>synchronized 只支持非公平锁。</li>
<li>ReentrantLock 提供公平锁和非公平锁实现。当然，在大部分情况下，非公平锁是高效的选择。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>在 synchronized 优化以前，它的性能是比 ReenTrantLock 差很多的，但是自从 synchronized 引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用 synchronized 。</p>
<p>并且，实际代码实战中，可能的优化场景是，通过读写分离，进一步性能的提升，所以使用 ReentrantReadWriteLock 。</p>
<h2 id="ReadWriteLock-是什么？"><a href="#ReadWriteLock-是什么？" class="headerlink" title="ReadWriteLock 是什么？"></a>ReadWriteLock 是什么？</h2><p>ReadWriteLock ，读写锁是，用来提升并发程序性能的锁分离技术的 Lock 实现类。可以用于 “多读少写” 的场景，读写锁支持多个读操作并发执行，写操作只能由一个线程来操作。</p>
<p>ReadWriteLock 对向数据结构相对不频繁地写入，但是有多个任务要经常读取这个数据结构的这类情况进行了优化。ReadWriteLock 使得你可以同时有多个读取者，只要它们都不试图写入即可。如果写锁已经被其他任务持有，那么任何读取者都不能访问，直至这个写锁被释放为止。</p>
<p>ReadWriteLock 对程序性能的提高主要受制于如下几个因素：</p>
<ol>
<li>数据被读取的频率与被修改的频率相比较的结果。</li>
<li>读取和写入的时间</li>
<li>有多少线程竞争</li>
<li>是否在多处理机器上运行</li>
</ol>
<p>ReadWriteLock 的源码解析，可以看看 <a href="http://www.iocoder.cn/JUC/sike/ReentrantReadWriteLock/">《【死磕 Java 并发】—– J.U.C 之读写锁：ReentrantReadWriteLock》</a> 。</p>
<h2 id="Condition-是什么？"><a href="#Condition-是什么？" class="headerlink" title="Condition 是什么？"></a>Condition 是什么？</h2><p>在没有 Lock 之前，我们使用 synchronized 来控制同步，配合 Object 的 #wait()、#notify() 等一系列方法可以实现等待 &#x2F; 通知模式。在 Java SE 5 后，Java 提供了 Lock 接口，相对于 synchronized 而言，Lock 提供了条件 Condition ，对线程的等待、唤醒操作更加详细和灵活。下图是 Condition 与 Object 的监视器方法的对比（摘自《Java并发编程的艺术》）：</p>
<p><img src="https://files.catbox.moe/etgg5d.png"></p>
<p>Condition 与 Object 的监视器方法的对比</p>
<ul>
<li>Condition 的使用，可以看看 <a href="http://www.importnew.com/9281.html">《怎么理解 Condition》</a></li>
<li>Condition 的源码，可以看看 <a href="http://www.iocoder.cn/JUC/sike/Condition/">《【死磕 Java 并发】—– J.U.C 之 Condition》</a> 。</li>
</ul>
<h3 id="用三个线程按顺序循环打印-abc-三个字母，比如-abcabcabc-？"><a href="#用三个线程按顺序循环打印-abc-三个字母，比如-abcabcabc-？" class="headerlink" title="用三个线程按顺序循环打印 abc 三个字母，比如 abcabcabc ？"></a>用三个线程按顺序循环打印 abc 三个字母，比如 abcabcabc ？</h3><ul>
<li>使用 Lock + Condition 来实现。具体代码，参看 <a href="https://blog.csdn.net/Big_Blogger/article/details/65629204">《用三个线程按顺序循环打印 abc 三个字母，比如 abcabcabc》</a> 。</li>
<li>使用 synchronized + await&#x2F;notifyAll 来实现，参看 <a href="https://blog.csdn.net/weixin_41704428/article/details/80482928">《Java用三个线程按顺序循环打印 abc 三个字母,比如 abcabcabc》</a></li>
</ul>
<h2 id="LockSupport-是什么？"><a href="#LockSupport-是什么？" class="headerlink" title="LockSupport 是什么？"></a>LockSupport 是什么？</h2><p>LockSupport 是 JDK 中比较底层的类，用来创建锁和其他同步工具类的基本线程阻塞。</p>
<ul>
<li>Java 锁和同步器框架的核心 AQS(AbstractQueuedSynchronizer)，就是通过调用 LockSupport#park()和 LockSupport#unpark() 方法，来实现线程的阻塞和唤醒的。</li>
<li>LockSupport 很类似于二元信号量(只有 1 个许可证可供使用)，如果这个许可还没有被占用，当前线程获取许可并继续执行；如果许可已经被占用，当前线程阻塞，等待获取许可。</li>
</ul>
<p>对于 LockSupport 了解即可，面试一般问的不多。感兴趣的，可以看看如下文章：</p>
<ul>
<li><a href="https://www.cnblogs.com/hvicen/p/6217303.html">《多线程同步工具 —— LockSupport》</a></li>
<li><a href="http://www.tianshouzhi.com/api/tutorials/mutithread/303">《Java 并发编程 —— LockSupport》</a> 带部分源码解析。</li>
</ul>
<h1 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h1><p>关于 Java 内存模型，涉及的内容会很多，所以建议看如下的 <a href="https://files-cdn.cnblogs.com/files/skywang12345/%E6%B7%B1%E5%85%A5Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.pdf">《深入Java内存模型.pdf》</a> 这本小书。</p>
<p>然后，看完之后你肯定会忘记，就可以靠 <a href="http://www.iocoder.cn/JUC/zhisheng/Java-Memory-Model?vip">《《深入理解 Java 内存模型》读书笔记》</a> 来补刀。</p>
<p>再另外，<a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/Concurrent/Interview/#">「第五部分 高效并发」</a> 也推荐阅读。</p>
<h2 id="什么是-Java-内存模型？"><a href="#什么是-Java-内存模型？" class="headerlink" title="什么是 Java 内存模型？"></a>什么是 Java 内存模型？</h2><p>Java 虚拟机规范中试图定义一种 Java 内存模型（Java Memory Model，JMM）来屏蔽掉各层硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</p>
<p>Java 内存模型规定了所有的变量都存储在主内存（Main Memory）中。每条线程还有自己的工作内存（Working Memory），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间的变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的关系如下图：</p>
<p><img src="https://files.catbox.moe/lz3kiu.png"></p>
<h2 id="三十、两个线程之间是如何通信的呢？"><a href="#三十、两个线程之间是如何通信的呢？" class="headerlink" title="三十、两个线程之间是如何通信的呢？"></a>三十、两个线程之间是如何通信的呢？</h2><p>线程之间的通信方式，目前有共享内存和消息传递两种。</p>
<p>1）共享内存</p>
<p>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。典型的共享内存通信方式，就是通过共享对象进行通信。</p>
<p><img src="https://files.catbox.moe/cf3ssf.png"></p>
<p>例如上图线程 A 与 线程 B 之间如果要通信的话，那么就必须经历下面两个步骤：</p>
<ol>
<li>首先，线程 A 把本地内存 A 更新过得共享变量刷新到主内存中去。</li>
<li>然后，线程 B 到主内存中去读取线程 A 之前更新过的共享变量。</li>
</ol>
<p>2）消息传递</p>
<p>在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。在 Java 中典型的消息传递方式，就是 #wait() 和 #notify() ，或者 BlockingQueue 。</p>
<p><img src="https://files.catbox.moe/02cgn0.png"></p>
<h2 id="为什么代码会重排序？"><a href="#为什么代码会重排序？" class="headerlink" title="为什么代码会重排序？"></a>为什么代码会重排序？</h2><p>在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：</p>
<ul>
<li>在单线程环境下不能改变程序运行的结果。</li>
<li>存在数据依赖关系的不允许重排序</li>
</ul>
<p>需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。</p>
<h2 id="什么是内存模型的-happens-before-呢？"><a href="#什么是内存模型的-happens-before-呢？" class="headerlink" title="什么是内存模型的 happens-before 呢？"></a>什么是内存模型的 happens-before 呢？</h2><p>详细看 <a href="http://www.iocoder.cn/JUC/sike/happens-before/?vip">《【死磕 Java 并发】—– Java 内存模型之 happens-before》</a> 文章。</p>
<h2 id="什么是内存屏障？"><a href="#什么是内存屏障？" class="headerlink" title="什么是内存屏障？"></a>什么是内存屏障？</h2><p>内存屏障，又称内存栅栏，是一组处理器指令，用于实现对内存操作的顺序限制。</p>
<h3 id="内存屏障为何重要？"><a href="#内存屏障为何重要？" class="headerlink" title="内存屏障为何重要？"></a>内存屏障为何重要？</h3><p>对主存的一次访问一般花费硬件的数百次时钟周期。处理器通过缓存（caching）能够从数量级上降低内存延迟的成本这些缓存为了性能重新排列待定内存操作的顺序。也就是说，程序的读写操作不一定会按照它要求处理器的顺序执行。当数据是不可变的，同时&#x2F;或者数据限制在线程范围内，这些优化是无害的。如果把这些优化与对称多处理（symmetric multi-processing）和共享可变状态（shared mutable state）结合，那么就是一场噩梦。</p>
<p>当基于共享可变状态的内存操作被重新排序时，程序可能行为不定。一个线程写入的数据可能被其他线程可见，原因是数据写入的顺序不一致。适当的放置内存屏障，通过强制处理器顺序执行待定的内存操作来避免这个问题。</p>
<h1 id="Java-并发容器"><a href="#Java-并发容器" class="headerlink" title="Java 并发容器"></a>Java 并发容器</h1><h2 id="什么是并发容器的实现？"><a href="#什么是并发容器的实现？" class="headerlink" title="什么是并发容器的实现？"></a>什么是并发容器的实现？</h2><p>何为同步容器？可以简单地理解为通过 synchronized来实现同步的容器，如果有多个线程调用同步容器的方法，它们将会串行执行。</p>
<ul>
<li>比如 Vector，Hashtable，以及 Collections#synchronizedSet()，Collections#synchronizedList() 等方法返回的容器。</li>
<li>可以通过查看 Vector，Hashtable 等这些同步容器的实现代码，可以看到这些容器实现线程安全的方式就是将它们的状态封装起来，并在需要同步的方法上加上关键字 synchronized 。</li>
</ul>
<p>并发容器，使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性。</p>
<ul>
<li>例如在 ConcurrentHashMap 中采用了一种粒度更细的加锁机制，可以称为分段锁。在这种锁机制下，允许任意数量的读线程并发地访问 map ，并且执行读操作的线程和写操作的线程也可以并发的访问 map ，同时允许一定数量的写操作线程并发地修改 map ，所以它可以在并发环境下实现更高的吞吐量。</li>
<li>再例如，CopyOnWriteArrayList 。</li>
</ul>
<h2 id="SynchronizedMap-和-ConcurrentHashMap-有什么区别？"><a href="#SynchronizedMap-和-ConcurrentHashMap-有什么区别？" class="headerlink" title="SynchronizedMap 和 ConcurrentHashMap 有什么区别？"></a>SynchronizedMap 和 ConcurrentHashMap 有什么区别？</h2><ul>
<li><p>SynchronizedMap</p>
</li>
<li><ul>
<li>一次锁住整张表来保证线程安全，所以每次只能有一个线程来访为 map 。</li>
</ul>
</li>
<li><p>ConcurrentHashMap</p>
</li>
<li><ul>
<li>使用分段锁来保证在多线程下的性能。ConcurrentHashMap 中则是一次锁住一个桶。ConcurrentHashMap 默认将 hash 表分为 16 个桶，诸如 get,put,remove 等常用操作只锁当前需要用到的桶。这样，原来只能一个线程进入，现在却能同时有 16 个写线程执行，并发性能的提升是显而易见的。【注意，这块是 JDK7 的实现。在 JDK8 中，具体的实现已经改变】</li>
<li>另外 ConcurrentHashMap 使用了一种不同的迭代方式。在这种迭代方式中，当 iterator 被创建后集合再发生改变就不再是抛出 ConcurrentModificationException 异常，取而代之的是在改变时 new 新的数据从而不影响原有的数据，iterator 完成后再将头指针替换为新的数据 ，这样 iterator 线程可以使用原来老的数据，而写线程也可以并发的完成改变。</li>
</ul>
</li>
</ul>
<p>关于 ConcurrentHashMap 的源码解析，推荐看看如下两篇文章：</p>
<ul>
<li><a href="http://www.iocoder.cn/JUC/sike/ConcurrentHashMap/?vip">《【死磕 Java 并发】—– J.U.C 之 Java并发容器：ConcurrentHashMap》</a></li>
<li><a href="http://www.iocoder.cn/JUC/sike/ConcurrentHashMap-red-black-tree/?vip">《【死磕 Java 并发】—– J.U.C 之 ConcurrentHashMap 红黑树转换分析》</a></li>
</ul>
<h3 id="Java-中-ConcurrentHashMap-的并发度是什么？"><a href="#Java-中-ConcurrentHashMap-的并发度是什么？" class="headerlink" title="Java 中 ConcurrentHashMap 的并发度是什么？"></a>Java 中 ConcurrentHashMap 的并发度是什么？</h3><p>在 JDK8 前，ConcurrentHashMap 把实际 map 划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是 ConcurrentHashMap 类构造函数的一个可选参数，默认值为 16 ，这样在多线程情况下就能避免争用。</p>
<p>在 JDK8 后，它摒弃了 Segment（锁段）的概念，而是启用了一种全新的方式实现，利用 CAS 算法。同时加入了更多的辅助变量来提高并发度。</p>
<h3 id="ConcurrentHashMap-为何读不用加锁？"><a href="#ConcurrentHashMap-为何读不用加锁？" class="headerlink" title="ConcurrentHashMap 为何读不用加锁？"></a>ConcurrentHashMap 为何读不用加锁？</h3><p>在 JDK7 以及以前</p>
<ul>
<li><p>HashEntry 中的key、hash、next均为final型，只能表头插入、删除结点。</p>
</li>
<li><ul>
<li>HashEntry 类的 value 域被声明为 volatile 型。</li>
<li>不允许用 null 作为键和值，当读线程读到某个 HashEntry 的 value 域的值为 null 时，便知道产生了冲突——发生了重排序现象（put 方法设置新 value 对象的字节码指令重排序），需要加锁后重新读入这个 value 值。</li>
</ul>
</li>
<li><p>volatile 变量 count 协调读写线程之间的内存可见性，写操作后修改 count ，读操作先读 count，根据 happen-before 传递性原则写操作的修改读操作能够看到。</p>
</li>
</ul>
<p>在 JDK8 开始</p>
<ul>
<li>Node 的 val 和 next 均为 volatile 型。</li>
<li>#tabAt(..,) 和 #casTabAt(…) 对应的 Unsafe 操作实现了 volatile 语义。</li>
</ul>
<h2 id="CopyOnWriteArrayList-可以用于什么应用场景？"><a href="#CopyOnWriteArrayList-可以用于什么应用场景？" class="headerlink" title="CopyOnWriteArrayList 可以用于什么应用场景？"></a>CopyOnWriteArrayList 可以用于什么应用场景？</h2><p>CopyOnWriteArrayList(免锁容器)的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出ConcurrentModificationException 异常。在 CopyOnWriteArrayList 中，写入将导致创建整个底层数组的副本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。</p>
<ul>
<li>由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 ygc 或者 fgc 。</li>
<li>不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个 set 操作后，读取到数据可能还是旧的,虽然 CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求。</li>
</ul>
<p>CopyOnWriteArrayList 透露的思想：</p>
<ul>
<li>读写分离，读和写分开</li>
<li>最终一致性</li>
<li>使用另外开辟空间的思路，来解决并发冲突</li>
</ul>
<p>CopyOnWriteArrayList 适用于读操作远远多于写操作的场景。例如，缓存。</p>
<p>关于 CopyOnWriteArrayList 的源码，可以看看 <a href="http://www.importnew.com/12773.html">《CopyOnWriteArrayList 实现原理及源码分析》</a> 文章。</p>
<h1 id="Java-阻塞队列"><a href="#Java-阻塞队列" class="headerlink" title="Java 阻塞队列"></a>Java 阻塞队列</h1><h2 id="什么是阻塞队列？有什么适用场景？"><a href="#什么是阻塞队列？有什么适用场景？" class="headerlink" title="什么是阻塞队列？有什么适用场景？"></a>什么是阻塞队列？有什么适用场景？</h2><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：</p>
<ul>
<li>在队列为空时，获取元素的线程会等待队列变为非空。</li>
<li>当队列满时，存储元素的线程会等待队列可用。</li>
</ul>
<p>阻塞队列常用于生产者和消费者的场景：</p>
<ul>
<li>生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程</li>
<li>阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</li>
</ul>
<p>如下的内容，和上面是相对重复的，或者是换一个说法，重新描述。</p>
<p>BlockingQueue 接口，是 Queue 的子接口，它的主要用途并不是作为容器，而是作为线程同步的的工具，因此他具有一个很明显的特性：</p>
<ul>
<li>当生产者线程试图向 BlockingQueue 放入元素时，如果队列已满，则线程被阻塞。</li>
<li>当消费者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞。</li>
<li>正是因为它所具有这个特性，所以在程序中多个线程交替向BlockingQueue中 放入元素，取出元素，它可以很好的控制线程之间的通信。</li>
</ul>
<p>阻塞队列使用最经典的场景，就是 Socket 客户端数据的读取和解析：</p>
<ul>
<li>读取数据的线程不断将数据放入队列。</li>
<li>然后，解析线程不断从队列取数据解析。</li>
</ul>
<h2 id="Java-提供了哪些阻塞队列的实现？"><a href="#Java-提供了哪些阻塞队列的实现？" class="headerlink" title="Java 提供了哪些阻塞队列的实现？"></a>Java 提供了哪些阻塞队列的实现？</h2><p>JDK7 提供了 7 个阻塞队列。分别是：</p>
<p>Java5 之前实现同步存取时，可以使用普通的一个集合，然后在使用线程的协作和线程同步可以实现生产者，消费者模式，主要的技术就是用好 wait、notify、notifyAll、sychronized 这些关键字。</p>
<p>而在 Java5 之后，可以使用阻塞队列来实现，此方式大大简少了代码量，使得多线程编程更加容易，安全方面也有保障。</p>
<ul>
<li>【最常用】ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</li>
</ul>
<p>此队列按照先进先出（FIFO）的原则对元素进行排序，但是默认情况下不保证线程公平的访问队列，即如果队列满了，那么被阻塞在外面的线程对队列访问的顺序是不能保证线程公平（即先阻塞，先插入）的。</p>
<ul>
<li>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。</li>
</ul>
<p>此队列按照先出先进的原则对元素进行排序</p>
<ul>
<li>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</li>
<li>DelayQueue：支持延时获取元素的无界阻塞队列，即可以指定多久才能从队列中获取当前元素。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。</li>
</ul>
<p>每一个 put 必须等待一个 take 操作，否则不能继续添加元素。并且他支持公平访问队列。</p>
<ul>
<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li>
</ul>
<p>相对于其他阻塞队列，多了 tryTransfer 和 transfer 方法。</p>
<ul>
<li><p>transfer 方法：如果当前有消费者正在等待接收元素（take 或者待时间限制的 poll 方法），transfer 可以把生产者传入的元素立刻传给消费者。如果没有消费者等待接收元素，则将元素放在队列的 tail 节点，并等到该元素被消费者消费了才返回。</p>
</li>
<li><p>tryTransfer 方法：用来试探生产者传入的元素能否直接传给消费者。如果没有消费者在等待，则返回 false 。和上述方法的区别是该方法无论消费者是否接收，方法立即返回。而 transfer 方法是必须等到消费者消费了才返回。</p>
</li>
<li><p>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</p>
</li>
</ul>
<p>优势在于多线程入队时，减少一半的竞争。</p>
<p>具体的源码解析，可以看看如下文章：</p>
<ul>
<li><a href="http://www.iocoder.cn/JUC/sike/ArrayBlockingQueue?vip">《【死磕 Java 并发】—– J.U.C 之阻塞队列：ArrayBlockingQueue》</a></li>
<li><a href="http://www.iocoder.cn/JUC/sike/PriorityBlockingQueue?vip">《【死磕 Java 并发】—– J.U.C 之阻塞队列：PriorityBlockingQueue》</a></li>
<li><a href="http://www.iocoder.cn/JUC/sike/DelayQueue?vip">《【死磕 Java 并发】—– J.U.C 之阻塞队列：DelayQueue》</a></li>
<li><a href="http://www.iocoder.cn/JUC/sike/SynchronousQueue?vip">《【死磕 Java 并发】—– J.U.C 之阻塞队列：SynchronousQueue》</a></li>
<li><a href="http://www.iocoder.cn/JUC/sike/LinkedTransferQueue?vip">《【死磕 Java 并发】—– J.U.C 之阻塞队列：LinkedTransferQueue》</a></li>
<li><a href="http://www.iocoder.cn/JUC/sike/LinkedBlockingDeque?vip">《【死磕 Java 并发】—– J.U.C 之阻塞队列：LinkedBlockingDeque》</a></li>
<li><a href="http://www.iocoder.cn/JUC/sike/BlockingQueue?vip">《【死磕 Java 并发】—– J.U.C 之阻塞队列：BlockingQueue 总结》</a></li>
</ul>
<h3 id="阻塞队列提供哪些重要方法？"><a href="#阻塞队列提供哪些重要方法？" class="headerlink" title="阻塞队列提供哪些重要方法？"></a>阻塞队列提供哪些重要方法？</h3><table>
<thead>
<tr>
<th>方法处理方式</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody><tr>
<td>插入方法</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e, time, unit)</td>
</tr>
<tr>
<td>移除方法</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time, unit)</td>
</tr>
<tr>
<td>检查方法</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody></table>
<h3 id="ArrayBlockingQueue-与-LinkedBlockingQueue-的区别？"><a href="#ArrayBlockingQueue-与-LinkedBlockingQueue-的区别？" class="headerlink" title="ArrayBlockingQueue 与 LinkedBlockingQueue 的区别？"></a>ArrayBlockingQueue 与 LinkedBlockingQueue 的区别？</h3><table>
<thead>
<tr>
<th>Queue</th>
<th>阻塞与否</th>
<th>是否有界</th>
<th>线程安全保障</th>
<th>适用场景</th>
<th>注意事项</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayBlockingQueue</td>
<td>阻塞</td>
<td>有界</td>
<td>一把全局锁</td>
<td>生产消费模型，平衡两边处理速度</td>
<td>用于存储队列元素的存储空间是预先分配的，使用过程中内存开销较小（无须动态申请存储空间）</td>
</tr>
<tr>
<td>LinkedBlockingQueue</td>
<td>阻塞</td>
<td>可配置</td>
<td>存取采用 2 把锁</td>
<td>生产消费模型，平衡两边处理速度</td>
<td>无界的时候注意内存溢出问题，用于存储队列元素的存储空间是在其使用过程中动态分配的，因此它可能会增加 JVM 垃圾回收的负担。</td>
</tr>
</tbody></table>
<p>感兴趣的可以看看如下两篇文章：</p>
<ul>
<li><a href="https://www.jianshu.com/p/5b85c1794351">《ArrayBlockingQueue 与 LinkedBlockingQueue》</a></li>
<li><a href="http://hellojava.info/?p=464">《从一个故障说说 Java 的三个 BlockingQueue》</a></li>
</ul>
<h2 id="什么是双端队列？"><a href="#什么是双端队列？" class="headerlink" title="什么是双端队列？"></a>什么是双端队列？</h2><p>在上面，我们看到的 LinkedBlockingQueue、ArrayBlockingQueue、PriorityBlockingQueue、SynchronousQueue 等，都是阻塞队列。</p>
<p>而 ArrayDeque、LinkedBlockingDeque 就是双端队列，类名以 Deque 结尾。</p>
<ul>
<li><p>正如阻塞队列适用于生产者消费者模式，双端队列同样适用与另一种模式，即工作密取。在生产者-消费者设计中，所有消费者共享一个工作队列，而在工作密取中，每个消费者都有各自的双端队列。</p>
</li>
<li><ul>
<li>如果一个消费者完成了自己双端队列中的全部工作，那么他就可以从其他消费者的双端队列末尾秘密的获取工作。具有更好的可伸缩性，这是因为工作者线程不会在单个共享的任务队列上发生竞争。</li>
<li>在大多数时候，他们都只是访问自己的双端队列，从而极大的减少了竞争。当工作者线程需要访问另一个队列时，它会从队列的尾部而不是头部获取工作，因此进一步降低了队列上的竞争。</li>
</ul>
</li>
<li><p>适用于：网页爬虫等任务中</p>
</li>
</ul>
<h2 id="延迟队列的实现方式，DelayQueue-和时间轮算法的异同？"><a href="#延迟队列的实现方式，DelayQueue-和时间轮算法的异同？" class="headerlink" title="延迟队列的实现方式，DelayQueue 和时间轮算法的异同？"></a>延迟队列的实现方式，DelayQueue 和时间轮算法的异同？</h2><p>JDK 的 Timer 和 DelayQueue 插入和删除操作的平均时间复杂度为 O(nlog(n)) ，而基于时间轮可以将插入和删除操作的时间复杂度都降为 O(1) 。</p>
<ul>
<li>关于 DelayQueue 的实现方式，在 <a href="http://www.iocoder.cn/JUC/sike/DelayQueue?vip">《【死磕 Java 并发】—– J.U.C 之阻塞队列：DelayQueue》》</a> 。</li>
<li>关于实践论的实现方法，在 <a href="https://blog.csdn.net/u013256816/article/details/80697456">《Kafka解惑之时间轮（TimingWheel）》</a> 。</li>
</ul>
<h2 id="简述-ConcurrentLinkedQueue-和-LinkedBlockingQueue-的用处和不同之处？"><a href="#简述-ConcurrentLinkedQueue-和-LinkedBlockingQueue-的用处和不同之处？" class="headerlink" title="简述 ConcurrentLinkedQueue 和 LinkedBlockingQueue 的用处和不同之处？"></a>简述 ConcurrentLinkedQueue 和 LinkedBlockingQueue 的用处和不同之处？</h2><p>参考 <a href="https://www.jianshu.com/p/1a49293294aa">《LinkedBlockingQueue 和 ConcurrentLinkedQueue的用法及区别》</a> 。</p>
<p>在 Java 多线程应用中，队列的使用率很高，多数生产消费模型的首选数据结构就是队列(先进先出)。</p>
<p>Java 提供的线程安全的 Queue 可以分为</p>
<ul>
<li>阻塞队列，典型例子是 LinkedBlockingQueue 。</li>
</ul>
<p>适用阻塞队列的好处：多线程操作共同的队列时不需要额外的同步，另外就是队列会自动平衡负载，即那边（生产与消费两边）处理快了就会被阻塞掉，从而减少两边的处理速度差距。</p>
<ul>
<li>非阻塞队列，典型例子是 ConcurrentLinkedQueue 。</li>
</ul>
<p>当许多线程共享访问一个公共集合时，ConcurrentLinkedQueue 是一个恰当的选择。</p>
<p>具体的选择，如下：</p>
<ul>
<li><p>LinkedBlockingQueue 多用于任务队列。</p>
</li>
<li><ul>
<li>单生产者，单消费者</li>
<li>多生产者，单消费者</li>
</ul>
</li>
<li><p>ConcurrentLinkedQueue 多用于消息队列。</p>
</li>
<li><ul>
<li>单生产者，多消费者</li>
<li>多生产者，多消费者</li>
</ul>
</li>
</ul>
<h1 id="Java-原子操作类"><a href="#Java-原子操作类" class="headerlink" title="Java 原子操作类"></a>Java 原子操作类</h1><h2 id="什么是原子操作？"><a href="#什么是原子操作？" class="headerlink" title="什么是原子操作？"></a>什么是原子操作？</h2><p>原子操作（Atomic Operation），意为”不可被中断的一个或一系列操作”。</p>
<ul>
<li>处理器使用基于对缓存加锁或总线加锁的方式，来实现多处理器之间的原子操作。</li>
<li>在 Java 中，可以通过锁和循环 CAS 的方式来实现原子操作。CAS操作 —— Compare &amp; Set ，或是 Compare &amp; Swap ，现在几乎所有的 CPU 指令都支持 CAS 的原子操作。</li>
</ul>
<p>原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。</p>
<ul>
<li>int++ 并不是一个原子操作，所以当一个线程读取它的值并加 1 时，另外一个线程有可能会读到之前的值，这就会引发错误。</li>
<li>为了解决这个问题，必须保证增加操作是原子的，在 JDK5 之前我们可以使用同步技术来做到这一点。到 JDK5 后，java.util.concurrent.atomic 包提供了 int 和 long 类型的原子包装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。</li>
</ul>
<p>java.util.concurrent 这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由 JVM 从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。</p>
<ul>
<li>原子类：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference 。</li>
<li>原子数组：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray 。</li>
<li>原子属性更新器：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater 。</li>
<li>解决 ABA 问题的原子类：AtomicMarkableReference（通过引入一个boolean 来反映中间有没有变过），AtomicStampedReference（通过引入一个 int 来累加来反映中间有没有变过）。</li>
</ul>
<p>关于 CAS 的内容，建议看看 <a href="http://www.iocoder.cn/JUC/sike/CAS/">《【死磕 Java 并发】—- 深入分析 CAS》</a> 。</p>
<h2 id="CAS-操作有什么缺点？"><a href="#CAS-操作有什么缺点？" class="headerlink" title="CAS 操作有什么缺点？"></a>CAS 操作有什么缺点？</h2><p>1）ABA 问题</p>
<p>比如说一个线程 one 从内存位置 V 中取出 A ，这时候另一个线程 two 也从内存中取出 A ，并且 two 进行了一些操作变成了 B ，然后 two 又将 V 位置的数据变成 A ，这时候线程 one 进行 CAS 操作发现内存中仍然是 A ，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。</p>
<p>从 Java5 开始 JDK 的 atomic包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。</p>
<p>2）循环时间长开销大</p>
<p>对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized 。</p>
<p>3）只能保证一个共享变量的原子操作</p>
<p>当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁。</p>
<h1 id="Java-并发工具类"><a href="#Java-并发工具类" class="headerlink" title="Java 并发工具类"></a>Java 并发工具类</h1><h2 id="Semaphore-是什么？"><a href="#Semaphore-是什么？" class="headerlink" title="Semaphore 是什么？"></a>Semaphore 是什么？</h2><p>Semaphore ，是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。</p>
<ul>
<li>如有必要，在许可可用前会阻塞每一个 #acquire() 方法，然后再获取该许可。</li>
<li>每个 #release() 方法，添加一个许可，从而可能释放一个正在阻塞的获取者。</li>
<li>但是，不使用实际的许可对象，Semaphore 只对可用许可的数量进行计数，并采取相应的行动。</li>
</ul>
<p>信号量常常用于多线程的代码中，比如数据库连接池。</p>
<ul>
<li>使用方式，可以看看 <a href="https://my.oschina.net/cloudcoder/blog/362974">《JAVA多线程 – 信号量(Semaphore)》</a> 。</li>
<li>源码解析，可以看看 <a href="http://www.iocoder.cn/JUC/sike/Semaphore/">《【死磕 Java 并发】—– J.U.C 之并发工具类：Semaphore》</a> 。</li>
</ul>
<h2 id="说说-CountDownLatch-原理"><a href="#说说-CountDownLatch-原理" class="headerlink" title="说说 CountDownLatch 原理"></a>说说 CountDownLatch 原理</h2><p>CountDownLatch ，字面意思是减小计数（CountDown）的门闩（Latch）。它要做的事情是，等待指定数量的计数被减少，意味着门闩被打开，然后进行执行。</p>
<p>CountDownLatch 默认的构造方法是 CountDownLatch(int count) ，其参数表示需要减少的计数，主线程调用 #await() 方法告诉 CountDownLatch 阻塞等待指定数量的计数被减少，然后其它线程调用 CountDownLatch 的 #countDown() 方法，减小计数(不会阻塞)。等待计数被减少到零，主线程结束阻塞等待，继续往下执行。</p>
<ul>
<li>CountDownLatch 的使用示例，请看 <a href="https://zk1878.iteye.com/blog/1002652">《Java 多线程 CountDownLatch 用法》</a> 。</li>
<li>CountDownLatch 的源码解析，请看 <a href="http://www.iocoder.cn/JUC/sike/CountDownLatch/?vip">《【死磕 Java 并发】—– J.U.C 之并发工具类：CountDownLatch》</a></li>
</ul>
<h2 id="说说-CyclicBarrier-原理"><a href="#说说-CyclicBarrier-原理" class="headerlink" title="说说 CyclicBarrier 原理"></a>说说 CyclicBarrier 原理</h2><p>CyclicBarrier ，字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</p>
<p>CyclicBarrier 默认的构造方法是 CyclicBarrier(int parties) ，其参数表示屏障拦截的线程数量，每个线程调用 #await() 方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞，直到 parties 个线程到达，结束阻塞。</p>
<ul>
<li>CyclicBarrier 的使用示例，请看 <a href="https://www.cnblogs.com/liuling/p/2013-8-21-01.html">《CyclicBarrier 的用法》</a></li>
<li>CyclicBarrier 的源码解析，请看 <a href="http://www.iocoder.cn/JUC/sike/CyclicBarrier/?vip">《【死磕 Java 并发】—- J.U.C 之并发工具类：CyclicBarrier》</a> 。</li>
</ul>
<h2 id="说说-Exchanger-原理"><a href="#说说-Exchanger-原理" class="headerlink" title="说说 Exchanger 原理"></a>说说 Exchanger 原理</h2><p>Exchanger 基本没在业务中使用过。</p>
<ul>
<li>Exchanger 的使用示例，请看 <a href="https://blog.csdn.net/eson_15/article/details/51581842">《【Java并发】线程同步工具Exchanger的使用》</a> 。</li>
<li>Exchanger 的源码解析，请看 <a href="http://www.iocoder.cn/JUC/sike/Exchanger/">《【死磕 Java 并发】—– J.U.C 之并发工具类：Exchanger》</a></li>
</ul>
<h2 id="CyclicBarrier-和-CountdownLatch-有什么区别？"><a href="#CyclicBarrier-和-CountdownLatch-有什么区别？" class="headerlink" title="CyclicBarrier 和 CountdownLatch 有什么区别？"></a>CyclicBarrier 和 CountdownLatch 有什么区别？</h2><p>CyclicBarrier 可以重复使用，而 CountdownLatch 不能重复使用。</p>
<ul>
<li><p>CountDownLatch 其实可以把它看作一个计数器，只不过这个计数器的操作是原子操作。</p>
</li>
<li><ul>
<li>你可以向 CountDownLatch 对象设置一个初始的数字作为计数值，任何调用这个对象上的 #await() 方法都会阻塞，直到这个计数器的计数值被其他的线程减为 0 为止。所以在当前计数到达零之前，await 方法会一直受阻塞。之后，会释放所有等待的线程，await 的所有后续调用都将立即返回。这种现象只出现一次——计数无法被重置。如果需要重置计数，请考虑使用 CyclicBarrier 。</li>
<li>CountDownLatch 的一个非常典型的应用场景是：有一个任务想要往下执行，但必须要等到其他的任务执行完毕后才可以继续往下执行。假如我们这个想要继续往下执行的任务调用一个 CountDownLatch 对象的 #await() 方法，其他的任务执行完自己的任务后调用同一个 CountDownLatch 对象上的 #countDown() 方法，这个调用 #await() 方法的任务将一直阻塞等待，直到这个 CountDownLatch 对象的计数值减到 0 为止。</li>
</ul>
</li>
<li><p>CyclicBarrier 一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier 在释放等待线程后可以重用，所以称它为循环的 barrier 。</p>
</li>
</ul>
<p>整理表格如下：</p>
<table>
<thead>
<tr>
<th>CountDownLatch</th>
<th>CyclicBarrier</th>
</tr>
</thead>
<tbody><tr>
<td>减计数方式</td>
<td>加计数方式</td>
</tr>
<tr>
<td>计算为 0 时释放所有等待的线程</td>
<td>计数达到指定值时释放所有等待线程</td>
</tr>
<tr>
<td>计数为 0 时，无法重置</td>
<td>计数达到指定值时，计数置为 0 重新开始</td>
</tr>
<tr>
<td>调用 <code>#countDown()</code> 方法计数减一，调用 <code>#await()</code> 方法只进行阻塞，对计数没任何影响</td>
<td>调用 <code>#await()</code> 方法计数加 1 ，若加 1 后的值不等于构造方法的值，则线程阻塞</td>
</tr>
<tr>
<td>不可重复利用</td>
<td>可重复利用</td>
</tr>
</tbody></table>
<h1 id="Java-线程池"><a href="#Java-线程池" class="headerlink" title="Java 线程池"></a>Java 线程池</h1><p><img src="https://files.catbox.moe/mde02y.png"></p>
<h2 id="什么是-Executor-框架？"><a href="#什么是-Executor-框架？" class="headerlink" title="什么是 Executor 框架？"></a>什么是 Executor 框架？</h2><p>Executor 框架，是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。</p>
<p>无限制的创建线程，会引起应用程序内存溢出。所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。利用 Executor 框架，可以非常方便的创建一个线程池。</p>
<h3 id="为什么使用-Executor-框架？"><a href="#为什么使用-Executor-框架？" class="headerlink" title="为什么使用 Executor 框架？"></a>为什么使用 Executor 框架？</h3><ol>
<li>每次执行任务创建线程 new Thread() 比较消耗性能，创建一个线程是比较耗时、耗资源的。</li>
<li>调用 new Thread() 创建的线程缺乏管理，被称为野线程，而且可以无限制的创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源。</li>
<li>接使用 new Thread() 启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。</li>
</ol>
<h3 id="在-Java-中-Executor-和-Executors-的区别？"><a href="#在-Java-中-Executor-和-Executors-的区别？" class="headerlink" title="在 Java 中 Executor 和 Executors 的区别？"></a>在 Java 中 Executor 和 Executors 的区别？</h3><ul>
<li><p>Executors 是 Executor 的工具类，不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。</p>
</li>
<li><p>Executor 接口对象，能执行我们的线程任务。</p>
</li>
<li><ul>
<li>ExecutorService 接口，继承了 Executor 接口，并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>使用 ThreadPoolExecutor ，可以创建自定义线程池。</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的完成，并可以使用 #get() 方法，获取计算的结果。</li>
</ul>
</li>
</ul>
<h2 id="讲讲线程池的实现原理"><a href="#讲讲线程池的实现原理" class="headerlink" title="讲讲线程池的实现原理"></a>讲讲线程池的实现原理</h2><ul>
<li><a href="http://www.cnblogs.com/dolphin0520/p/3932921.html">《Java并发编程：线程池的使用》</a></li>
<li><a href="http://www.iocoder.cn/JUC/sike/ThreadPool-core/?vip">《【死磕 Java 并发】—– J.U.C 之线程池：线程池的基础架构》</a></li>
<li><a href="http://www.iocoder.cn/JUC/sike/ThreadPoolExecutor/?vip">《【死磕 Java 并发】—– J.U.C 之线程池：ThreadPoolExecutor》</a></li>
<li><a href="http://www.iocoder.cn/JUC/sike/ScheduledThreadPoolExecutor/?vip">《【死磕 Java 并发】—– J.U.C 之线程池：ScheduledThreadPoolExecutor》</a></li>
</ul>
<h2 id="创建线程池的几种方式？"><a href="#创建线程池的几种方式？" class="headerlink" title="创建线程池的几种方式？"></a>创建线程池的几种方式？</h2><p>Java 类库提供一个灵活的线程池以及一些有用的默认配置，我们可以通过Executors 的静态方法来创建线程池。</p>
<p>Executors 创建的线程池，分成普通任务线程池，和定时任务线程池。</p>
<ul>
<li><p>普通任务线程池</p>
</li>
<li><ul>
<li>1、#newFixedThreadPool(int nThreads)方法，创建一个固定长度的线程池。</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化。</li>
<li>当线程发生未预期的错误而结束时，线程池会补充一个新的线程。</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>2、#newCachedThreadPool()方法，创建一个可缓存的线程池。</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>如果线程池的规模超过了处理需求，将自动回收空闲线程。</li>
<li>当需求增加时，则可以自动添加新线程。线程池的规模不存在任何限制。</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>3、#newSingleThreadExecutor()方法，创建一个单线程的线程池。</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它。</li>
<li>它的特点是，能确保依照任务在队列中的顺序来串行执行。</li>
</ul>
</li>
</ul>
</li>
<li><p>定时任务线程池</p>
</li>
<li><ul>
<li>4、#newScheduledThreadPool(int corePoolSize) 方法，创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似 Timer 。</li>
<li>5、#newSingleThreadExecutor() 方法，创建了一个固定长度为 1 的线程池，而且以延迟或定时的方式来执行任务，类似 Timer 。</li>
</ul>
</li>
</ul>
<h3 id="如何使用-ThreadPoolExecutor-创建线程池？"><a href="#如何使用-ThreadPoolExecutor-创建线程池？" class="headerlink" title="如何使用 ThreadPoolExecutor 创建线程池？"></a>如何使用 ThreadPoolExecutor 创建线程池？</h3><p>Executors 提供了创建线程池的常用模板，实际场景下，我们可能需要自动以更灵活的线程池，此时就需要使用 ThreadPoolExecutor 类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,                          </span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,                          </span></span><br><span class="line"><span class="params">                          TimeUnit unit,                          </span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,                          </span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,                          </span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123;    </span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||        </span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||        </span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||        </span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)        </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();    </span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)        </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();    </span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;    </span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;    </span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;    </span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);    </span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;    </span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>corePoolSize 参数，核心线程数大小，当线程数 &lt; corePoolSize ，会创建线程执行任务。</p>
</li>
<li><p>maximumPoolSize参数，最大线程数， 当线程数 &gt;&#x3D; corePoolSize 的时候，会把任务放入workQueue队列中。</p>
</li>
<li><ul>
<li>keepAliveTime 参数，保持存活时间，当线程数大于 corePoolSize 的空闲线程能保持的最大时间。</li>
<li>unit 参数，时间单位。</li>
</ul>
</li>
<li><p>workQueue参数，保存任务的阻塞队列。</p>
</li>
<li><ul>
<li>handler 参数，超过阻塞队列的大小时，使用的拒绝策略。</li>
</ul>
</li>
<li><p>threadFactory 参数，创建线程的工厂。</p>
</li>
</ul>
<h3 id="ThreadPoolExecutor-有哪些拒绝策略？"><a href="#ThreadPoolExecutor-有哪些拒绝策略？" class="headerlink" title="ThreadPoolExecutor 有哪些拒绝策略？"></a>ThreadPoolExecutor 有哪些拒绝策略？</h3><p>ThreadPoolExecutor 默认有四个拒绝策略：</p>
<ul>
<li>ThreadPoolExecutor.AbortPolicy() ，直接抛出异常 RejectedExecutionException 。</li>
<li>ThreadPoolExecutor.CallerRunsPolicy() ，直接调用 run 方法并且阻塞执行。</li>
<li>ThreadPoolExecutor.DiscardPolicy() ，直接丢弃后来的任务。</li>
<li>ThreadPoolExecutor.DiscardOldestPolicy() ，丢弃在队列中队首的任务。</li>
</ul>
<p>如果我们有需要，可以自己实现 RejectedExecutionHandler 接口，实现自定义的拒绝逻辑。当然，绝大多数是不需要的。</p>
<h2 id="线程池的关闭方式有几种？"><a href="#线程池的关闭方式有几种？" class="headerlink" title="线程池的关闭方式有几种？"></a>线程池的关闭方式有几种？</h2><p>ThreadPoolExecutor 提供了两个方法，用于线程池的关闭，分别是：</p>
<ul>
<li>#shutdown() 方法，不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务。</li>
<li>#shutdownNow() 方法，立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务。</li>
</ul>
<p>实际场景下，一般会结合这两个方法，一起实现线程池的优雅关闭。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">shutdownAndAwaitTermination</span><span class="params">(ExecutorService pool)</span> &#123;  </span><br><span class="line">    pool.shutdown(); </span><br><span class="line">    <span class="comment">// Disable new tasks from being submitted  </span></span><br><span class="line">    <span class="keyword">try</span> &#123;    </span><br><span class="line">        <span class="comment">// Wait a while for existing tasks to terminate    </span></span><br><span class="line">        <span class="keyword">if</span> (!pool.awaitTermination(<span class="number">60</span>, TimeUnit.SECONDS)) &#123;      </span><br><span class="line">            pool.shutdownNow(); </span><br><span class="line">            <span class="comment">// Cancel currently executing tasks      </span></span><br><span class="line">            <span class="comment">// Wait a while for tasks to respond to being cancelled      </span></span><br><span class="line">            <span class="keyword">if</span> (!pool.awaitTermination(<span class="number">60</span>, TimeUnit.SECONDS))          </span><br><span class="line">                System.err.println(<span class="string">&quot;Pool did not terminate&quot;</span>);      </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;<span class="keyword">catch</span> (InterruptedException ie) &#123;    </span><br><span class="line">    <span class="comment">// (Re-)Cancel if current thread also interrupted    </span></span><br><span class="line">    pool.shutdownNow();    </span><br><span class="line">    <span class="comment">// Preserve interrupt status    T</span></span><br><span class="line">    hread.currentThread().interrupt();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java-线程池大小为何会大多被设置成-CPU-核心数-1-？"><a href="#Java-线程池大小为何会大多被设置成-CPU-核心数-1-？" class="headerlink" title="Java 线程池大小为何会大多被设置成 CPU 核心数 +1 ？"></a>Java 线程池大小为何会大多被设置成 CPU 核心数 +1 ？</h2><p>详细的可以看看 <a href="http://ifeve.com/how-to-calculate-threadpool-size/">《如何合理地估算线程池大小？》</a> 。如下是简单的总结和整理：</p>
<p>一般说来，大家认为线程池的大小经验值应该这样设置：（其中 N 为CPU的个数）</p>
<ul>
<li>如果是 CPU 密集型应用，则线程池大小设置为 N+1</li>
</ul>
<p>因为 CPU 密集型任务使得 CPU 使用率很高，若开过多的线程数，只能增加上下文切换的次数，因此会带来额外的开销。</p>
<ul>
<li>如果是 IO 密集型应用，则线程池大小设置为 2N+1</li>
</ul>
<p>IO密 集型任务 CPU 使用率并不高，因此可以让 CPU 在等待 IO 的时候去处理别的任务，充分利用 CPU 时间。</p>
<ul>
<li>如果是混合型应用，那么分别创建线程池</li>
</ul>
<p>可以将任务分成 IO 密集型和 CPU 密集型任务，然后分别用不同的线程池去处理。 只要分完之后两个任务的执行时间相差不大，那么就会比串行执行来的高效。</p>
<p>因为如果划分之后两个任务执行时间相差甚远，那么先执行完的任务就要等后执行完的任务，最终的时间仍然取决于后执行完的任务，而且还要加上任务拆分与合并的开销，得不偿失。</p>
<p>如果一台服务器上只部署这一个应用并且只有这一个线程池，那么这种估算或许合理，具体还需自行测试验证。</p>
<p>但是，IO 优化中，这样的估算公式可能更适合：最佳线程数目 &#x3D; （（线程等待时间 + 线程 CPU 时间）&#x2F; 线程 CPU 时间 ）* CPU 数目</p>
<p>因为很显然，线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。</p>
<p>下面举个例子：比如平均每个线程 CPU 运行时间为 0.5s ，而线程等待时间（非 CPU 运行时间，比如 IO）为 1.5s ，CPU 核心数为 8 。</p>
<p>那么根据上面这个公式估算得到：((0.5 + 1.5) &#x2F; 0.5) * 8 &#x3D; 32。这个公式进一步转化为：最佳线程数目 &#x3D; （线程等待时间与线程 CPU 时间之比 + 1）* CPU数目。</p>
<h3 id="线程池容量的动态调整？"><a href="#线程池容量的动态调整？" class="headerlink" title="线程池容量的动态调整？"></a>线程池容量的动态调整？</h3><p>ThreadPoolExecutor 提供了动态调整线程池容量大小的方法：</p>
<ul>
<li>setCorePoolSize：设置核心池大小。</li>
<li>setMaximumPoolSize：设置线程池最大能创建的线程数目大小。</li>
</ul>
<p>当上述参数从小变大时，ThreadPoolExecutor 进行线程赋值，还可能立即创建新的线程来执行任务。</p>
<h2 id="什么是-Callable、Future、FutureTask-？"><a href="#什么是-Callable、Future、FutureTask-？" class="headerlink" title="什么是 Callable、Future、FutureTask ？"></a>什么是 Callable、Future、FutureTask ？</h2><p>1）Callable</p>
<p>Callable 接口，类似于 Runnable ，从名字就可以看出来了，但是Runnable 不会返回结果，并且无法抛出返回结果的异常，而 Callable 功能更强大一些，被线程执行后，可以返回值，这个返回值可以被 Future 拿到，也就是说，Future 可以拿到异步执行任务的返回值。</p>
<p>简单来说，可以认为是带有回调的 Runnable 。</p>
<p>2）Future</p>
<p>Future 接口，表示异步任务，是还没有完成的任务给出的未来结果。所以说 Callable 用于产生结果，Future 用于获取结果。</p>
<p>3）FutureTask</p>
<p>在 Java 并发程序中，FutureTask 表示一个可以取消的异步运算。</p>
<ul>
<li>它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。</li>
<li>一个 FutureTask 对象，可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是继承了 Runnable 接口，所以它可以提交给 Executor 来执行。</li>
</ul>
<h2 id="线程池执行任务的过程？"><a href="#线程池执行任务的过程？" class="headerlink" title="线程池执行任务的过程？"></a>线程池执行任务的过程？</h2><p>刚创建时，里面没有线程调用 execute() 方法，添加任务时：</p>
<ol>
<li>如果正在运行的线程数量小于核心参数corePoolSize，继续创建线程运行这个任务</li>
</ol>
<ul>
<li><ul>
<li>否则，如果正在运行的线程数量大于或等于 corePoolSize ，将任务加入到阻塞队列中。</li>
<li>否则，如果队列已满，同时正在运行的线程数量小于核心参数 maximumPoolSize ，继续创建线程运行这个任务。</li>
<li>否则，如果队列已满，同时正在运行的线程数量大于或等于 maximumPoolSize ，根据设置的拒绝策略处理。</li>
</ul>
</li>
</ul>
<ol>
<li>完成一个任务，继续取下一个任务处理。</li>
</ol>
<ul>
<li><ul>
<li>没有任务继续处理，线程被中断或者线程池被关闭时，线程退出执行，如果线程池被关闭，线程结束。</li>
<li>否则，判断线程池正在运行的线程数量是否大于核心线程数，如果是，线程结束，否则线程阻塞。因此线程池任务全部执行完成后，继续留存的线程池大小为 corePoolSize 。</li>
</ul>
</li>
</ul>
<h3 id="线程池中-submit-和-execute-方法有什么区别？"><a href="#线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="线程池中 submit 和 execute 方法有什么区别？"></a>线程池中 submit 和 execute 方法有什么区别？</h3><p>两个方法都可以向线程池提交任务。</p>
<ul>
<li>#execute(…) 方法，返回类型是 void ，它定义在 Executor 接口中。</li>
<li>#submit(…) 方法，可以返回持有计算结果的 Future 对象，它定义在 ExecutorService 接口中，它扩展了 Executor 接口，其它线程池类像 ThreadPoolExecutor 和 ScheduledThreadPoolExecutor 都有这些方法。</li>
</ul>
<h3 id="如果你提交任务时，线程池队列已满，这时会发生什么？"><a href="#如果你提交任务时，线程池队列已满，这时会发生什么？" class="headerlink" title="如果你提交任务时，线程池队列已满，这时会发生什么？"></a>如果你提交任务时，线程池队列已满，这时会发生什么？</h3><p>重点在于线程池的队列是有界还是无界的。</p>
<ul>
<li>如果你使用的 LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为 LinkedBlockingQueue 可以近乎认为是一个无穷大的队列，可以无限存放任务。</li>
<li>如果你使用的是有界队列比方说 ArrayBlockingQueue 的话，任务首先会被添加到 ArrayBlockingQueue 中，ArrayBlockingQueue满了，则会使用拒绝策略 RejectedExecutionHandler 处理满了的任务，默认是 AbortPolicy 。</li>
</ul>
<h2 id="Fork-x2F-Join-框架是什么？"><a href="#Fork-x2F-Join-框架是什么？" class="headerlink" title="Fork&#x2F;Join 框架是什么？"></a>Fork&#x2F;Join 框架是什么？</h2><p>大体知道就好。</p>
<p>Oracle 的官方给出的定义是：Fork&#x2F;Join 框架是一个实现了 ExecutorService接口 的多线程处理器。它可以把一个大的任务划分为若干个小的任务并发执行，充分利用可用的资源，进而提高应用的执行效率。</p>
<p>我们再通过 Fork 和 Join 这两个单词来理解下 Fork&#x2F;Join 框架。</p>
<ul>
<li>Fork 就是把一个大任务切分为若干子任务并行的执行，Join 就是合并这些子任务的执行结果，最后得到这个大任务的结果。</li>
<li>比如计算 1+2+…＋10000 ，可以分割成 10 个子任务，每个子任务分别对 1000 个数进行求和，最终汇总这 10 个子任务的结果。</li>
</ul>
<p>感兴趣可以看看如下文章：</p>
<ul>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-forkjoin/index.html">《JDK 7 中的 Fork&#x2F;Join 模式》</a></li>
<li><a href="https://www.infoq.cn/article/fork-join-introduction">《聊聊并发（八） —— Fork&#x2F;Join 框架介绍》</a></li>
</ul>
<h2 id="如何让一段程序并发的执行，并最终汇总结果？"><a href="#如何让一段程序并发的执行，并最终汇总结果？" class="headerlink" title="如何让一段程序并发的执行，并最终汇总结果？"></a>如何让一段程序并发的执行，并最终汇总结果？</h2><ul>
<li>1、CountDownLatch：允许一个或者多个线程等待前面的一个或多个线程完成，构造一个 CountDownLatch 时指定需要 countDown 的点的数量，每完成一点就 countDown 一下。当所有点都完成，CountDownLatch 的 #await() 就解除阻塞。</li>
<li>2、CyclicBarrier：可循环使用的 Barrier ，它的作用是让一组线程到达一个 Barrier 后阻塞，直到所有线程都到达 Barrier 后才能继续执行。</li>
</ul>
<p>CountDownLatch 的计数值只能使用一次，CyclicBarrier 可以通过使用 reset 重置，还可以指定到达栅栏后优先执行的任务。</p>
<ul>
<li>3、Fork&#x2F;Join 框架，fork 把大任务分解成多个小任务，然后汇总多个小任务的结果得到最终结果。使用一个双端队列，当线程空闲时从双端队列的另一端领取任务。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>面试虚拟机篇</title>
    <url>/2022/09/07/%E9%9D%A2%E8%AF%95%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AF%87/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h1 id="虚拟机篇"><a href="#虚拟机篇" class="headerlink" title="虚拟机篇"></a>虚拟机篇</h1><h1 id="什么是虚拟机？"><a href="#什么是虚拟机？" class="headerlink" title="什么是虚拟机？"></a>什么是虚拟机？</h1><p>Java 虚拟机，是一个可以执行 Java 字节码的虚拟机进程。Java 源文件被编译成能被 Java 虚拟机执行的字节码文件( .class )。<br>Java 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。<br>但是，跨平台的是 Java 程序(包括字节码文件)，，而不是 JVM。JVM 是用 C&#x2F;C++ 开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的 JVM 。</p>
<p><img src="https://files.catbox.moe/6g6q25.png"></p>
<h2 id="JVM-由哪些部分组成？"><a href="#JVM-由哪些部分组成？" class="headerlink" title="JVM 由哪些部分组成？"></a>JVM 由哪些部分组成？</h2><p>考察对 JVM 体系结构的掌握</p>
<p><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「2.2 运行时数据区域」</a> 。</p>
<p>JVM 的结构基本上由 4 部分组成：</p>
<p>注意打钩的 4 个地方。</p>
<p><img src="https://files.catbox.moe/bevj77.png"></p>
<ul>
<li>类加载器，在 JVM 启动时或者类运行时将需要的 class 加载到 JVM 中。</li>
<li>内存区，将内存划分成若干个区以模拟实际机器上的存储、记录和调度功能模块，如实际机器上的各种功能的寄存器或者 PC 指针的记录器等。</li>
</ul>
<p>关于这一块，我们在 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「Java 内存区域与内存溢出异常」</a> 也会细看。</p>
<ul>
<li>执行引擎，执行引擎的任务是负责执行 class 文件中包含的字节码指令，相当于实际机器上的 CPU 。</li>
<li>本地方法调用，调用 C 或 C++ 实现的本地方法的代码返回结果。</li>
</ul>
<h2 id="怎样通过-Java-程序来判断-JVM-是-32-位-还是-64-位？"><a href="#怎样通过-Java-程序来判断-JVM-是-32-位-还是-64-位？" class="headerlink" title="怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位？"></a>怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位？</h2><p>Sun 有一个 Java System 属性来确定JVM的位数：32 或 64。</p>
<ul>
<li>sun.arch.data.model&#x3D;32 &#x2F;&#x2F; 32 bit JVM</li>
<li>sun.arch.data.model&#x3D;64 &#x2F;&#x2F; 64 bit JVM</li>
</ul>
<p>我可以使用以下语句来确定 JVM 是 32 位还是 64 位：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.getProperty(<span class="string">&quot;sun.arch.data.model&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="32-位-JVM-和-64-位-JVM-的最大堆内存分别是多数？"><a href="#32-位-JVM-和-64-位-JVM-的最大堆内存分别是多数？" class="headerlink" title="32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？"></a>32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？</h3><p>理论上说上 32 位的 JVM 堆内存可以到达 2^32，即 4GB ，但实际上会比这个小很多。不同操作系统之间不同，如 Windows 系统大约 1.5 GB，Solaris 大约 3GB。</p>
<p>64 位 JVM 允许指定最大的堆内存，理论上可以达到 2^64 ，这是一个非常大的数字，实际上你可以指定堆内存大小到 100GB 。甚至有的 JVM，如 Azul ，堆内存到 1000G 都是可能的。</p>
<h3 id="64-位-JVM-中，int-的长度是多数？"><a href="#64-位-JVM-中，int-的长度是多数？" class="headerlink" title="64 位 JVM 中，int 的长度是多数？"></a>64 位 JVM 中，int 的长度是多数？</h3><p>Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位或者 4 个字节。意思就是说，在 32 位 和 64 位 的Java 虚拟机中，int 类型的长度是相同的。</p>
<h1 id="Java-内存区域与内存溢出异常"><a href="#Java-内存区域与内存溢出异常" class="headerlink" title="Java 内存区域与内存溢出异常"></a>Java 内存区域与内存溢出异常</h1><h2 id="JVM-运行内存的分类？"><a href="#JVM-运行内存的分类？" class="headerlink" title="JVM 运行内存的分类？"></a>JVM 运行内存的分类？</h2><p><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「2.3.1 对象的创建」</a> 。</p>
<p>JVM 运行内存的分类如下图所示：</p>
<p>注意，这个图是基于 JDK6 版本的运行内存的分类。</p>
<p><img src="https://files.catbox.moe/ofk74t.png"></p>
<ul>
<li><p>程序计数器： Java 线程私有，类似于操作系统里的 PC 计数器，它可以看做是当前线程所执行的字节码的行号指示器。</p>
</li>
<li><ul>
<li>如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。</li>
<li>此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</li>
</ul>
</li>
<li><p>虚拟机栈（栈内存）：Java线程私有，虚拟机栈描述的是 Java 方法执行的内存模型：</p>
</li>
<li><ul>
<li>每个方法在执行的时候，都会创建一个栈帧用于存储局部变量、操作数、动态链接、方法出口等信息。</li>
<li>每个方法调用都意味着一个栈帧在虚拟机栈中入栈到出栈的过程。</li>
</ul>
</li>
<li><p>本地方法栈 ：和 Java 虚拟机栈的作用类似，区别是该区域为 JVM 提供使用 Native 方法的服务。</p>
</li>
<li><p>堆内存（线程共享）：所有线程共享的一块区域，垃圾收集器管理的主要区域。</p>
</li>
<li><ul>
<li>目前主要的垃圾回收算法都是分代收集算法，所以 Java 堆中还可以细分为：新生代和老年代；再细致一点的有 Eden 空间、From Survivor 空间、To Survivor 空间等，默认情况下新生代按照 8:1:1 的比例来分配。</li>
<li>根据 Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘一样。</li>
</ul>
</li>
<li><p>方法区（线程共享）：各个线程共享的一个区域，用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
</li>
<li><ul>
<li>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</li>
<li>运行时常量池：是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。</li>
</ul>
</li>
</ul>
<h3 id="直接内存是不是虚拟机运行时数据区的一部分？"><a href="#直接内存是不是虚拟机运行时数据区的一部分？" class="headerlink" title="直接内存是不是虚拟机运行时数据区的一部分？"></a>直接内存是不是虚拟机运行时数据区的一部分？</h3><p>参见 <a href="https://blog.csdn.net/leaf_0303/article/details/78961936">《JVM 直接内存》</a> 文章。</p>
<p>直接内存(Direct Memory)，并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中农定义的内存区域。在 JDK1.4 中新加入了 NIO(New Input&#x2F;Output) 类，引入了一种基于通道(Channel)与缓冲区（Buffer）的 I&#x2F;O 方式，它可以使用 native 函数库直接分配堆外内存，然后通脱一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</p>
<ul>
<li>本机直接内存的分配不会受到 Java 堆大小的限制，受到本机总内存大小限制。</li>
<li>配置虚拟机参数时，不要忽略直接内存，防止出现 OutOfMemoryError 异常。</li>
</ul>
<h3 id="直接内存（堆外内存）与堆内存比较？"><a href="#直接内存（堆外内存）与堆内存比较？" class="headerlink" title="直接内存（堆外内存）与堆内存比较？"></a>直接内存（堆外内存）与堆内存比较？</h3><ol>
<li>直接内存申请空间耗费更高的性能，当频繁申请到一定量时尤为明显。</li>
<li>直接内存 IO 读写的性能要优于普通的堆内存，在多次读写操作的情况下差异明显。</li>
</ol>
<h3 id="实际上，后续的版本，主要对【方法区】做了一定的调整"><a href="#实际上，后续的版本，主要对【方法区】做了一定的调整" class="headerlink" title="实际上，后续的版本，主要对【方法区】做了一定的调整"></a>实际上，后续的版本，主要对【方法区】做了一定的调整</h3><ul>
<li><p>JDK7 的改变</p>
</li>
<li><ul>
<li>存储在永久代的部分数据就已经转移到了 Java Heap 或者是 Native Heap。但永久代仍存在于 JDK7 中，但是并没完全移除。</li>
<li>常量池和静态变量放到 Java 堆里。</li>
</ul>
</li>
<li><p>JDK8 的改变</p>
</li>
<li><ul>
<li>废弃 PermGen（永久代），新增 Metaspace（元数据区）。</li>
<li>那么方法区还在么？FROM 狼哥 的解答：方法区在 Metaspace 中了，方法区都是一个概念的东西。</li>
</ul>
</li>
</ul>
<p>因为，《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。</p>
<p>同时，大多数用的 JVM 都是 Sun 公司的 HotSpot 。在 HotSpot 上把 GC 分代收集扩展至方法区，或者说使用永久带来实现方法区。</p>
<ul>
<li><p>参考文章</p>
</li>
<li><ul>
<li><a href="https://www.cnblogs.com/SaraMoring/p/5713732.html">《JVM 内存堆布局图解分析》</a></li>
<li><a href="https://www.jianshu.com/p/855b38c57925">《笔记之 JVM 方法区：永久带 VS 元空间》</a></li>
<li><a href="https://blog.csdn.net/wenniuwuren/article/details/51170275">《JVM —— 移除永久代》</a></li>
<li><a href="https://www.bbsmax.com/A/RnJW679gzq/">《JDK 源码剖析五：JDK8 —— 废弃永久代（PermGen）迎来元空间（Metaspace）》</a></li>
<li><a href="https://www.cnblogs.com/paddix/p/5309550.html">《Java8 内存模型 —— 永久代(PermGen)和元空间(Metaspace)》</a></li>
</ul>
</li>
</ul>
<h3 id="JDK8-之后-Perm-Space-有哪些变动-MetaSpace-⼤⼩默认是⽆限的么-还是你们会通过什么⽅式来指定⼤⼩"><a href="#JDK8-之后-Perm-Space-有哪些变动-MetaSpace-⼤⼩默认是⽆限的么-还是你们会通过什么⽅式来指定⼤⼩" class="headerlink" title="JDK8 之后 Perm Space 有哪些变动? MetaSpace ⼤⼩默认是⽆限的么? 还是你们会通过什么⽅式来指定⼤⼩?"></a>JDK8 之后 Perm Space 有哪些变动? MetaSpace ⼤⼩默认是⽆限的么? 还是你们会通过什么⽅式来指定⼤⼩?</h3><ul>
<li><p>JDK8 后用元空间替代了 Perm Space ；字符串常量存放到堆内存中。</p>
</li>
<li><p>MetaSpace 大小默认没有限制，一般根据系统内存的大小。JVM 会动态改变此值。</p>
</li>
<li><p>可以通过 JVM 参数配置</p>
</li>
<li><ul>
<li>-XX:MetaspaceSize ： 分配给类元数据空间（以字节计）的初始大小（Oracle 逻辑存储上的初始高水位，the initial high-water-mark）。此值为估计值，MetaspaceSize 的值设置的过大会延长垃圾回收时间。垃圾回收过后，引起下一次垃圾回收的类元数据空间的大小可能会变大。</li>
<li>-XX:MaxMetaspaceSize ：分配给类元数据空间的最大值，超过此值就会触发Full GC 。此值默认没有限制，但应取决于系统内存的大小，JVM 会动态地改变此值。</li>
</ul>
</li>
</ul>
<h3 id="为什么要废弃永久代？"><a href="#为什么要废弃永久代？" class="headerlink" title="为什么要废弃永久代？"></a>为什么要废弃永久代？</h3><p>1）现实使用中易出问题。</p>
<p>由于永久代内存经常不够用或发生内存泄露，爆出异常 java.lang.OutOfMemoryError: PermGen 。</p>
<ul>
<li>字符串存在永久代中，容易出现性能问题和内存溢出。</li>
<li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</li>
</ul>
<p>2）永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</p>
<p>3）Oracle 可能会将HotSpot 与 JRockit 合二为一。</p>
<p>参照 JEP122 ：<a href="http://openjdk.java.net/jeps/122">http://openjdk.java.net/jeps/122</a> ，原文截取：</p>
<p>Motivation</p>
<p>This is part of the JRockit and Hotspot convergence effort. JRockit customers do not need to configure the permanent generation (since JRockit does not have a permanent generation) and are accustomed to not configuring the permanent generation.</p>
<p>即：移除永久代是为融合 HotSpot JVM 与 JRockit VM 而做出的努力，因为 JRockit 没有永久代，不需要配置永久代。</p>
<h2 id="Java-内存堆和栈区别？"><a href="#Java-内存堆和栈区别？" class="headerlink" title="Java 内存堆和栈区别？"></a>Java 内存堆和栈区别？</h2><ul>
<li>栈内存用来存储基本类型的变量和对象的引用变量；堆内存用来存储Java中的对象，无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。</li>
<li>栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存；堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。</li>
<li>如果栈内存没有可用的空间存储方法调用和局部变量，JVM 会抛出 java.lang.StackOverFlowError 错误；如果是堆内存没有可用的空间存储生成的对象，JVM 会抛出 java.lang.OutOfMemoryError 错误。</li>
<li>栈的内存要远远小于堆内存，如果你使用递归的话，那么你的栈很快就会充满。-Xss 选项设置栈内存的大小，-Xms 选项可以设置堆的开始时的大小。</li>
</ul>
<p>当然，如果你记不住这个些，只要记住如下即可：</p>
<p>JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。</p>
<p><img src="https://files.catbox.moe/ify8gy.png"></p>
<h2 id="JAVA-对象创建的过程？"><a href="#JAVA-对象创建的过程？" class="headerlink" title="JAVA 对象创建的过程？"></a>JAVA 对象创建的过程？</h2><p><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「2.3.1 对象的创建」</a> 。</p>
<p>注意，加粗的文字部分。</p>
<p><img src="https://files.catbox.moe/a0rick.png"></p>
<ul>
<li>Java 中对象的创建就是在堆上分配内存空间的过程，此处说的对象创建仅限于 new 关键字创建的普通 Java 对象，不包括数组对象的创建。</li>
</ul>
<p>1）检测类是否被加载</p>
<p>当虚拟机遇到 new 指令时，首先先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，就执行类加载过程。</p>
<p>2）为对象分配内存</p>
<p>类加载完成以后，虚拟机就开始为对象分配内存，此时所需内存的大小就已经确定了。只需要在堆上分配所需要的内存即可。</p>
<p>具体的分配内存有两种情况：第一种情况是内存空间绝对规整，第二种情况是内存空间是不连续的。</p>
<ul>
<li>对于内存绝对规整的情况相对简单一些，虚拟机只需要在被占用的内存和可用空间之间移动指针即可，这种方式被称为“指针碰撞”。</li>
<li>对于内存不规整的情况稍微复杂一点，这时候虚拟机需要维护一个列表，来记录哪些内存是可用的。分配内存的时候需要找到一个可用的内存空间，然后在列表上记录下已被分配，这种方式成为“空闲列表”。</li>
</ul>
<p>多线程并发时会出现正在给对象 A 分配内存，还没来得及修改指针，对象 B 又用这个指针分配内存，这样就出现问题了。解决这种问题有两种方案：</p>
<ul>
<li>第一种，是采用同步的办法，使用 CAS 来保证操作的原子性。</li>
<li>另一种，是每个线程分配内存都在自己的空间内进行，即是每个线程都在堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB），分配内存的时候再TLAB上分配，互不干扰。可以通过 -XX:+&#x2F;-UseTLAB 参数决定。</li>
</ul>
<p>3）为分配的内存空间初始化零值</p>
<p>对象的内存分配完成后，还需要将对象的内存空间都初始化为零值，这样能保证对象即使没有赋初值，也可以直接使用。</p>
<p>4）对对象进行其他设置</p>
<p>分配完内存空间，初始化零值之后，虚拟机还需要对对象进行其他必要的设置，设置的地方都在对象头中，包括这个对象所属的类，类的元数据信息，对象的 hashcode ，GC 分代年龄等信息。</p>
<p>5）执行 init 方法</p>
<p>执行完上面的步骤之后，在虚拟机里这个对象就算创建成功了，但是对于 Java 程序来说还需要执行 init 方法才算真正的创建完成，因为这个时候对象只是被初始化零值了，还没有真正的去根据程序中的代码分配初始值，调用了 init 方法之后，这个对象才真正能使用。</p>
<p>到此为止一个对象就产生了，这就是 new 关键字创建对象的过程。过程如下：</p>
<p><img src="C:\Users\QARHPF\AppData\Local\Temp\1662556580063.png" alt="66255658006"></p>
<p>另外，这个问题，面试官可能引申成 “A a &#x3D; new A() 经历过什么过程”的问题。</p>
<h2 id="对象的内存布局是怎样的？"><a href="#对象的内存布局是怎样的？" class="headerlink" title="对象的内存布局是怎样的？"></a>对象的内存布局是怎样的？</h2><p><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「2.3.2 对象的内存布局」</a> 。</p>
<p>对象的内存布局包括三个部分：</p>
<ul>
<li><p>对象头：对象头包括两部分信息。</p>
</li>
<li><ul>
<li>第一部分，是存储对象自身的运行时数据，如哈希码，GC 分代年龄，锁状态标志，线程持有的锁等等。</li>
<li>第二部分，是类型指针，即对象指向类元数据的指针。</li>
</ul>
</li>
<li><p>实例数据：就是数据。</p>
</li>
<li><p>对齐填充：不是必然的存在，就是为了对齐。</p>
</li>
</ul>
<h2 id="对象是如何定位访问的？"><a href="#对象是如何定位访问的？" class="headerlink" title="对象是如何定位访问的？"></a>对象是如何定位访问的？</h2><p><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「2.3.3 对象的访问定位」</a> 。</p>
<p>对象的访问定位有两种：</p>
<ul>
<li>句柄定位：Java 堆会画出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</li>
</ul>
<p><img src="https://files.catbox.moe/p2r2r9.png"></p>
<p>直接指针访问：Java 堆对象的不居中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址。</p>
<p><img src="https://files.catbox.moe/02dpls.png"></p>
<h3 id="对比两种方式？"><a href="#对比两种方式？" class="headerlink" title="对比两种方式？"></a>对比两种方式？</h3><p>这两种对象访问方式各有优势。</p>
<ul>
<li>使用句柄来访问的最大好处，就是 reference 中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。</li>
<li>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。</li>
</ul>
<p>我们目前主要虚拟机 Sun HotSpot 而言，它是使用第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。</p>
<h2 id="有哪些-OutOfMemoryError-异常？"><a href="#有哪些-OutOfMemoryError-异常？" class="headerlink" title="有哪些 OutOfMemoryError 异常？"></a>有哪些 OutOfMemoryError 异常？</h2><p><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「2.4 实战：OutOfMemoryError 异常」</a> 。</p>
<p>在 Java 虚拟机中规范的描述中，除了程序计数器外，虚拟机内存的其它几个运行时区域都有发生的 OutOfMemoryError(简称为“OOM”) 异常的可能。</p>
<ul>
<li>Java 堆溢出</li>
<li>虚拟机栈和本地方法栈溢出</li>
<li>方法区和运行时常量池溢出</li>
</ul>
<p>从 JDK8 开始，就变成元数据区的内存溢出。</p>
<ul>
<li>本机直接内存溢出</li>
</ul>
<p>1）Java 堆溢出</p>
<p>重现方式，参见 <a href="https://blog.csdn.net/sells2012/article/details/18654915">《Java 堆溢出》</a> 文章。</p>
<p>另外，Java 堆溢出的原因，有可能是内存泄露，可以使用 MAT 进行分析。</p>
<p>2）虚拟机栈和本地方法栈溢出</p>
<p>由于在 HotSpot 虚拟机中并不区分虚拟机栈和本地方法栈，因此，对于 HotSpot 来说，虽然 -Xoss 参数（设置本地方法栈大小）存在，但实际上是无效的，栈容量只由 -Xss参数设定。</p>
<p>关于虚拟机栈和本地方法栈，在 Java 虚拟机规范中描述了两种异常：</p>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 StackOverflowError 异常。</li>
</ul>
<p>StackOverflowError 不属于 OOM 异常哈。</p>
<ul>
<li>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出 OutOfMemoryError 异常。</li>
</ul>
<p>重现方式，参见 <a href="https://blog.csdn.net/en_joker/article/details/79727675">《OutOfMemoryError 异常 —— 虚拟机栈和本地方法栈溢出》</a> 文章。</p>
<p>3）运行时常量池溢出</p>
<p>因为 JDK7 将常量池和静态变量放到 Java 堆里，所以无法触发运行时常量池溢出。如果想要触发，可以使用 JDK6 的版本。</p>
<p>重现方式，参见 <a href="https://www.niuhp.com/java/jvm-oom-pg.html">《JVM 内存溢出 - 方法区及运行时常量池溢出》</a> 文章。</p>
<p>4）方法区的内存溢出</p>
<p>因为 JDK8 将方法区溢出，所以无法触发方法区的内存溢出溢出。如果想要触发，可以使用 JDK7 的版本。</p>
<p>重现方式，参见 <a href="https://blog.csdn.net/tanga842428/article/details/52636836">《Java 方法区溢出》</a> 文章。</p>
<p>5）元数据区的内存溢出</p>
<p>实际上，方法区的内存溢出在 JDK8 中，变成了元数据区的内存溢出。所以，重现方式，还是参见 <a href="https://blog.csdn.net/tanga842428/article/details/52636836">《Java 方法区溢出》</a> 文章，只是说，需要增加 -XX:MaxMetaspaceSize&#x3D;10m VM 配置项。</p>
<p>6）本机直接内存溢出</p>
<p>重现方式，参见 <a href="https://www.niuhp.com/java/jvm-oom-direct.html">《JVM 内存溢出 —— 直接内存溢出》</a> 文章。</p>
<p>另外，非常推荐一篇文章，提供了更多有趣的案例，<a href="https://www.jianshu.com/p/2fdee831ed03">《Java 内存溢出(OOM)异常完全指南》</a> 。</p>
<h3 id="当出现了内存溢出，你怎么排错？"><a href="#当出现了内存溢出，你怎么排错？" class="headerlink" title="当出现了内存溢出，你怎么排错？"></a>当出现了内存溢出，你怎么排错？</h3><ul>
<li><p>1、首先，控制台查看错误日志。</p>
</li>
<li><p>2、然后，使用 JDK 自带的 jvisualvm 工具查看系统的堆栈日志。</p>
</li>
<li><p>3、定位出内存溢出的空间：堆，栈还是永久代（JDK8 以后不会出现永久代的内存溢出）。</p>
</li>
<li><ul>
<li>如果是堆内存溢出，看是否创建了超大的对象。</li>
<li>如果是栈内存溢出，看是否创建了超大的对象，或者产生了死循环。</li>
</ul>
</li>
</ul>
<h2 id="Java-中会存在内存泄漏吗？"><a href="#Java-中会存在内存泄漏吗？" class="headerlink" title="Java 中会存在内存泄漏吗？"></a>Java 中会存在内存泄漏吗？</h2><p>理论上 Java 因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是 Java 被广泛使用于服务器端编程的一个重要原因）。然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被 GC 回收也会发生内存泄露。例如说：</p>
<ul>
<li>Hibernate 的 Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象。</li>
<li>使用 Netty 的堆外的 ByteBuf 对象，在使用完后，并未归还，导致使用的一点一点在泄露。</li>
</ul>
<h1 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h1><h2 id="什么是垃圾回收机制？"><a href="#什么是垃圾回收机制？" class="headerlink" title="什么是垃圾回收机制？"></a>什么是垃圾回收机制？</h2><p><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「3.1 概述」</a> 。</p>
<ul>
<li>Java 中对象是采用 new 或者反射的方法创建的，这些对象的创建都是在堆(Heap)中分配的，所有对象的回收都是由 Java 虚拟机通过垃圾回收机制完成的。GC 为了能够正确释放对象，会监控每个对象的运行状况，对他们的申请、引用、被引用、赋值等状况进行监控。</li>
<li>Java 程序员不用担心内存管理，因为垃圾收集器会自动进行管理。</li>
<li>可以调用下面的方法之一：System#gc() 或 Runtime#getRuntime()#gc() ，但 JVM 也可以屏蔽掉显示的垃圾回收调用。</li>
</ul>
<h3 id="为什么不建议在程序中显式的声明-System-gc-？"><a href="#为什么不建议在程序中显式的声明-System-gc-？" class="headerlink" title="为什么不建议在程序中显式的声明 System.gc() ？"></a>为什么不建议在程序中显式的声明 System.gc() ？</h3><p>因为显式声明是做堆内存全扫描，也就是 Full GC ，是需要停止所有的活动的(Stop The World Collection)，对应用很大可能存在影响。</p>
<p>另外，调用 System.gc() 方法后，不会立即执行 Full GC ，而是虚拟机自己决定的。</p>
<h3 id="如果一个对象的引用被设置为-null-GC-会立即释放该对象的内存么"><a href="#如果一个对象的引用被设置为-null-GC-会立即释放该对象的内存么" class="headerlink" title="如果一个对象的引用被设置为 null , GC 会立即释放该对象的内存么?"></a>如果一个对象的引用被设置为 null , GC 会立即释放该对象的内存么?</h3><p>不会, 这个对象将会在下一次 GC 循环中被回收。</p>
<h3 id="finalize-方法什么时候被调用？它的目的是什么？"><a href="#finalize-方法什么时候被调用？它的目的是什么？" class="headerlink" title="#finalize() 方法什么时候被调用？它的目的是什么？"></a>#finalize() 方法什么时候被调用？它的目的是什么？</h3><p><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「3.2.4 生存还是死亡」</a> 。</p>
<p>#finallize() 方法，是在释放该对象内存前由 GC (垃圾回收器)调用。</p>
<ul>
<li>通常建议在这个方法中释放该对象持有的资源，例如持有的堆外内存、和远程服务的长连接。</li>
<li>一般情况下，不建议重写该方法。</li>
<li>对于一个对象，该方法有且仅会被调用一次。</li>
</ul>
<h2 id="如何判断一个对象是否已经死去？"><a href="#如何判断一个对象是否已经死去？" class="headerlink" title="如何判断一个对象是否已经死去？"></a>如何判断一个对象是否已经死去？</h2><p><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「3.2 对象已死吗」</a> 。</p>
<p>有两种方式：</p>
<ol>
<li>引用计数</li>
<li>可达性分析</li>
</ol>
<p>1）引用计数</p>
<p>每个对象有一个引用计数属性，新增一个引用时计数加 1 ，引用释放时计数减 1 ，计数为 0 时可以回收。此方法简单，无法解决对象相互循环引用的问题。目前在用的有 Python、ActionScript3 等语言。</p>
<p>2）可达性分析（Reachability Analysis）</p>
<p>从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。不可达对象。目前在用的有 Java、C# 等语言。</p>
<h3 id="如果-A-和-B-对象循环引用，是否可以被-GC？"><a href="#如果-A-和-B-对象循环引用，是否可以被-GC？" class="headerlink" title="如果 A 和 B 对象循环引用，是否可以被 GC？"></a>如果 A 和 B 对象循环引用，是否可以被 GC？</h3><p>可以，因为 Java 采用可达性分析的判断方式。</p>
<h3 id="在-Java-语言里，可作为-GC-Roots-的对象包括以下几种？"><a href="#在-Java-语言里，可作为-GC-Roots-的对象包括以下几种？" class="headerlink" title="在 Java 语言里，可作为 GC Roots 的对象包括以下几种？"></a>在 Java 语言里，可作为 GC Roots 的对象包括以下几种？</h3><ol>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中的类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中 JNI(即一般说的 Native 方法)中引用的对象。</li>
</ol>
<h3 id="方法区是否能被回收？"><a href="#方法区是否能被回收？" class="headerlink" title="方法区是否能被回收？"></a>方法区是否能被回收？</h3><p>方法区可以被回收，但是价值很低，主要回收废弃的常量和无用的类。</p>
<p>如何判断无用的类，需要完全满足如下三个条件：</p>
<ol>
<li>该类所有实例都被回收（Java 堆中没有该类的对象）。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方利用反射访问该类。</li>
</ol>
<h2 id="Java-对象有哪些引用类型？"><a href="#Java-对象有哪些引用类型？" class="headerlink" title="Java 对象有哪些引用类型？"></a>Java 对象有哪些引用类型？</h2><p><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「3.2.3 再谈引用类型」</a> 。</p>
<p>Java 一共有四种引用类型：</p>
<ul>
<li>强引用</li>
<li>软引用（SoftReference）</li>
<li>弱引用（WeakReference）</li>
<li>虚引用（PhantomReference）</li>
</ul>
<p>1）强引用</p>
<p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>
<p>2）软引用（SoftReference）</p>
<p>如果一个对象只具有软引用，那就类似于可有可物的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p>
<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<p>3）弱引用（WeakReference）</p>
<p>如果一个对象只具有弱引用，那就类似于可有可物的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<p>4）虚引用（PhantomReference）</p>
<p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p>
<p>虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃 圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>
<h3 id="WeakReference-与-SoftReference的区别？"><a href="#WeakReference-与-SoftReference的区别？" class="headerlink" title="WeakReference 与 SoftReference的区别？"></a>WeakReference 与 SoftReference的区别？</h3><p>虽然 WeakReference 与 SoftReference 都有利于提高 GC 和 内存的效率。</p>
<ul>
<li>但是 WeakReference 一旦失去最后一个强引用，就会被 GC 回收</li>
<li>而 SoftReference 虽然不能阻止被回收，但是可以延迟到 JVM 内存不足的时候。</li>
</ul>
<h3 id="为什么要有不同的引用类型？"><a href="#为什么要有不同的引用类型？" class="headerlink" title="为什么要有不同的引用类型？"></a>为什么要有不同的引用类型？</h3><p>不像 C 语言，我们可以控制内存的申请和释放，在 Java 中有时候我们需要适当的控制对象被回收的时机，因此就诞生了不同的引用类型，可以说不同的引用类型实则是对 GC 回收时机不可控的妥协。有以下几个使用场景可以充分的说明：</p>
<ul>
<li>利用软引用和弱引用解决 OOM 问题。用一个 HashMap 来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM 会自动回收这些缓存图片对象所占用的空间，从而有效地避免了 OOM 的问题.</li>
<li>通过软引用实现 Java 对象的高速缓存。比如我们创建了一 Person 的类，如果每次需要查询一个人的信息，哪怕是几秒中之前刚刚查询过的，都要重新构建一个实例，这将引起大量 Person 对象的消耗，并且由于这些对象的生命周期相对较短，会引起多次 GC 影响性能。此时，通过软引用和 HashMap 的结合可以构建高速缓存，提供性能。</li>
</ul>
<h2 id="JVM-垃圾回收算法？"><a href="#JVM-垃圾回收算法？" class="headerlink" title="JVM 垃圾回收算法？"></a>JVM 垃圾回收算法？</h2><p>有四种算法：</p>
<ol>
<li>标记-清除算法</li>
<li>标记-整理算法</li>
<li>复制算法</li>
<li>分代收集算法</li>
</ol>
<p>1）标记-清除算法</p>
<p>标记-清除（Mark-Sweep）算法，是现代垃圾回收算法的思想基础。</p>
<p>标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。</p>
<p>一种可行的实现是，在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象（好多资料说标记出要回收的对象，其实明白大概意思就可以了）。然后，在清除阶段，清除所有未被标记的对象。</p>
<p><img src="https://files.catbox.moe/lrag6q.png"></p>
<ul>
<li><p>缺点：</p>
</li>
<li><ul>
<li>1、效率问题，标记和清除两个过程的效率都不高。</li>
<li>2、空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li>
</ul>
</li>
</ul>
<p>2）标记-整理算法</p>
<p>标记整理算法，类似与标记清除算法，不过它标记完对象后，不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。</p>
<p><img src="https://files.catbox.moe/bt6gvd.png"></p>
<ul>
<li><p>优点：</p>
</li>
<li><ul>
<li>1、相对标记清除算法，解决了内存碎片问题。</li>
<li>2、没有内存碎片后，对象创建内存分配也更快速了（可以使用TLAB进行分配）。</li>
</ul>
</li>
<li><p>缺点：</p>
</li>
<li><ul>
<li>1、效率问题，（同标记清除算法）标记和整理两个过程的效率都不高。</li>
</ul>
</li>
</ul>
<p>3）复制算法</p>
<p>复制算法，可以解决效率问题，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块内存用完了，就将还存活着的对象复制到另一块上面，然后再把已经使用过的内存空间一次清理掉，这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可（还可使用TLAB进行高效分配内存）。</p>
<p><img src="https://files.catbox.moe/p9ob1j.png"></p>
<ul>
<li><p>图的上半部分是未回收前的内存区域，图的下半部分是回收后的内存区域。通过图，我们发现不管回收前还是回收后都有一半的空间未被利用。</p>
</li>
<li><p>优点：</p>
</li>
<li><ul>
<li>1、效率高，没有内存碎片。</li>
</ul>
</li>
<li><p>缺点：</p>
</li>
<li><ul>
<li>1、浪费一半的内存空间。</li>
<li>2、复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。</li>
</ul>
</li>
</ul>
<p>4）分代收集算法</p>
<p>当前商业虚拟机都是采用分代收集算法，它根据对象存活周期的不同将内存划分为几块，一般是把 Java 堆分为新生代和老年代，然后根据各个年代的特点采用最适当的收集算法。</p>
<ul>
<li>在新生代中，每次垃圾收集都发现有大批对象死去，只有少量存活，就选用复制算法。</li>
<li>而老年代中，因为对象存活率高，没有额外空间对它进行分配担保，就必须使用“标记清理”或者“标记整理”算法来进行回收。</li>
</ul>
<p><img src="https://files.catbox.moe/0cq0c0.png"></p>
<ul>
<li><p>图的左半部分是未回收前的内存区域，右半部分是回收后的内存区域。</p>
</li>
<li><p>对象分配策略：</p>
</li>
<li><ul>
<li>对象优先在 Eden 区域分配，如果对象过大直接分配到 Old 区域。</li>
<li>长时间存活的对象进入到 Old 区域。</li>
</ul>
</li>
<li><p>改进自复制算法</p>
</li>
<li><ul>
<li>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM 公司的专门研究表明，新生代中的对象 98% 是“朝生夕死”的，所以并不需要按照 1:1 的比例来划分内存空间，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor 。当回收时，将 Eden 和 Survivor 中还存活着的对象一次性地复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。</li>
<li>HotSpot 虚拟机默认 Eden 和 2 块 Survivor 的大小比例是 8:1:1，也就是每次新生代中可用内存空间为整个新生代容量的 90%（80%+10%），只有 10% 的内存会被“浪费”。当然，98% 的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于 10% 的对象存活，当 Survivor 空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。</li>
</ul>
</li>
</ul>
<h2 id="什么是安全点？"><a href="#什么是安全点？" class="headerlink" title="什么是安全点？"></a>什么是安全点？</h2><p><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「3.4.2 安全点」</a> 。</p>
<p>SafePoint 安全点，顾名思义是指一些特定的位置，当线程运行到这些位置时，线程的一些状态可以被确定(the thread’s representation of it’s Java machine state is well described)，比如记录OopMap 的状态，从而确定 GC Root 的信息，使 JVM 可以安全的进行一些操作，比如开始 GC 。</p>
<p>SafePoint 指的特定位置主要有：</p>
<ol>
<li>循环的末尾 (防止大循环的时候一直不进入 Safepoint ，而其他线程在等待它进入 Safepoint )。</li>
<li>方法返回前。</li>
<li>调用方法的 Call 之后。</li>
<li>抛出异常的位置。</li>
</ol>
<p>详细的内容，可以看看 <a href="https://my.oschina.net/wenbo123/blog/1822414">《深入学习 JVM-JVM 安全点和安全区域》</a> 。</p>
<ul>
<li><p>如何使线程中断</p>
</li>
<li><ul>
<li>主动式</li>
</ul>
</li>
</ul>
<p>主动式 JVM 设置一个全局变量，线程去按照某种策略检查这个变量一旦发现是 SafePoint 就主动挂起。</p>
<p>HostSpot 虚拟机采用的是主动式使线程中断。</p>
<ul>
<li><ul>
<li>被动式</li>
</ul>
</li>
</ul>
<p>被动式就是发个信号，例如关机、Control+C ，带来的问题就是不可控，发信号的时候不知道线程处于什么状态。</p>
<ul>
<li>安全区域</li>
</ul>
<p>如果程序长时间不执行，比如线程调用的 sleep 方法，这时候程序无法响应 JVM 中断请求这时候线程无法到达安全点，显然 JVM 也不可能等待程序唤醒，这时候就需要安全区域了。</p>
<p>安全区域是指一段代码片中，引用关系不会发生变化，在这个区域任何地方 GC 都是安全的，安全区域可以看做是安全点的一个扩展。</p>
<ul>
<li>线程执行到安全区域的代码时，首先标识自己进入了安全区域，这样 GC 时就不用管进入安全区域的线程了.</li>
<li>线程要离开安全区域时就检查 JVM 是否完成了 GC Roots 枚举（或者整个 GC 过程），如果完成就继续执行，如果没有完成就等待直到收到可以安全离开的信号。</li>
</ul>
<h2 id="JVM-垃圾收集器有哪些？"><a href="#JVM-垃圾收集器有哪些？" class="headerlink" title="JVM 垃圾收集器有哪些？"></a>JVM 垃圾收集器有哪些？</h2><p><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「3.5 垃圾收集器」</a> 。</p>
<p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</p>
<ul>
<li><p>新生代收集器</p>
</li>
<li><ul>
<li>Serial 收集器</li>
<li>ParNew 收集器</li>
</ul>
</li>
</ul>
<p>ParNew 收集器，是 Serial 收集器的多线程版。</p>
<ul>
<li><ul>
<li>Parallel Scavenge 收集器</li>
</ul>
</li>
<li><p>老年代收集器</p>
</li>
<li><ul>
<li>Serial Old 收集器</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>Serial Old 收集器，是 Serial 收集器的老年代版本。</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>Parallel Old 收集器</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>Parallel Old 收集器，是 Parallel Scavenge 收集器的老年代版本。</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>CMS 收集器</li>
</ul>
</li>
<li><p>新生代 + 老年代收集器</p>
</li>
<li><ul>
<li>G1 收集器</li>
<li>ZGC 收集器</li>
</ul>
</li>
</ul>
<p>小结表格如下：</p>
<table>
<thead>
<tr>
<th>收集器</th>
<th>串行、并行or并发</th>
<th>新生代&#x2F;老年代</th>
<th>算法</th>
<th>目标</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Serial</strong></td>
<td>串行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>单CPU环境下的Client模式</td>
</tr>
<tr>
<td><strong>Serial Old</strong></td>
<td>串行</td>
<td>老年代</td>
<td>标记-整理</td>
<td>响应速度优先</td>
<td>单CPU环境下的Client模式、CMS的后备预案</td>
</tr>
<tr>
<td><strong>ParNew</strong></td>
<td>并行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>多CPU环境时在Server模式下与CMS配合</td>
</tr>
<tr>
<td><strong>Parallel Scavenge</strong></td>
<td>并行</td>
<td>新生代</td>
<td>复制算法</td>
<td>吞吐量优先</td>
<td>在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td><strong>Parallel Old</strong></td>
<td>并行</td>
<td>老年代</td>
<td>标记-整理</td>
<td>吞吐量优先</td>
<td>在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td><strong>CMS</strong></td>
<td>并发</td>
<td>老年代</td>
<td>标记-清除</td>
<td>响应速度优先</td>
<td>集中在互联网站或B&#x2F;S系统服务端上的Java应用</td>
</tr>
<tr>
<td><strong>G1</strong></td>
<td>并发</td>
<td>both</td>
<td>标记-整理+复制算法</td>
<td>响应速度优先</td>
<td>面向服务端应用，将来替换CMS</td>
</tr>
</tbody></table>
<p>关于每种垃圾收集器的说明，请看 如下文章：</p>
<ul>
<li><a href="https://crowhawk.github.io/2017/08/15/jvm_3/">《深入理解 JVM(3) —— 7 种垃圾收集器》</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/43608166">《一文读懂 Java 11 的 ZGC 为何如此高效》</a></li>
</ul>
<h3 id="G1-和-CMS-的区别？"><a href="#G1-和-CMS-的区别？" class="headerlink" title="G1 和 CMS 的区别？"></a>G1 和 CMS 的区别？</h3><ul>
<li>CMS ：并发标记清除。他的主要步骤有：初始收集，并发标记，重新标记，并发清除（删除）、重置。</li>
<li>G1：主要步骤：初始标记，并发标记，重新标记，复制清除（整理）</li>
<li>CMS 的缺点是对 CPU 的要求比较高。G1是将内存化成了多块，所有对内段的大小有很大的要求。</li>
<li>CMS是清除，所以会存在很多的内存碎片。G1是整理，所以碎片空间较小。</li>
<li>G1 和 CMS 都是响应优先把，他们的目的都是尽量控制 STW 时间。</li>
</ul>
<p>G1 和 CMS 的 Full GC 都是单线程 mark sweep compact 算法，直到 JDK10 才优化为并行的。</p>
<p>感兴趣的，可以看看 <a href="http://engineering.xueqiu.com/blog/2015/06/25/jvm-gc-tuning/">《GC 优化的一些总结》</a> 的分析。</p>
<h3 id="CMS-算法的过程，CMS-回收过程中-JVM-是否需要暂停？"><a href="#CMS-算法的过程，CMS-回收过程中-JVM-是否需要暂停？" class="headerlink" title="CMS 算法的过程，CMS 回收过程中 JVM 是否需要暂停？"></a>CMS 算法的过程，CMS 回收过程中 JVM 是否需要暂停？</h3><p>会有短暂的停顿。详细的，可以看看 [《<a href="https://blog.csdn.net/wfh6732/article/details/57490195">jvm][面试] 并发收集器 CMS(Concurrent Mark-Sweep)》</a> 。</p>
<h3 id="如何使用指定的垃圾收集器"><a href="#如何使用指定的垃圾收集器" class="headerlink" title="如何使用指定的垃圾收集器"></a>如何使用指定的垃圾收集器</h3><table>
<thead>
<tr>
<th>配置</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-XX:+UserSerialGC</td>
<td>串行垃圾收集器</td>
</tr>
<tr>
<td>-XX:+UserParrallelGC</td>
<td>并行垃圾收集器</td>
</tr>
<tr>
<td>-XX:+UseConcMarkSweepGC</td>
<td>并发标记扫描垃圾回收器</td>
</tr>
<tr>
<td>-XX:ParallelCMSThreads</td>
<td>并发标记扫描垃圾回收器 &#x3D;为使用的线程数量</td>
</tr>
<tr>
<td>-XX:+UseG1GC</td>
<td>G1垃圾回收器</td>
</tr>
</tbody></table>
<h2 id="对象分配规则是什么？"><a href="#对象分配规则是什么？" class="headerlink" title="对象分配规则是什么？"></a>对象分配规则是什么？</h2><p><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「3.6 对象分配与回收策略」</a> 。</p>
<ul>
<li>对象优先分配在 Eden 区。</li>
</ul>
<p>如果 Eden 区无法分配，那么尝试把活着的对象放到 Survivor0 中去（Minor GC）</p>
<ul>
<li><p>如果 Survivor0 可以放入，那么放入之后清除 Eden 区。</p>
</li>
<li><p>如果 Survivor0 不可以放入，那么尝试把 Eden 和 Survivor0 的存活对象放到 Survivor1 中。</p>
</li>
<li><ul>
<li>如果 Survivor1 可以放入，那么放入 Survivor1 之后清除 Eden 和 Survivor0 ，之后再把 Survivor1 中的对象复制到 Survivor0 中，保持 Survivor1 一直为空。</li>
<li>如果 Survivor1 不可以放入，那么直接把它们放入到老年代中，并清除 Eden 和 Survivor0 ，这个过程也称为分配担保。</li>
</ul>
</li>
</ul>
<p>ps：清除 Eden、Survivor 区，就是 Minor GC 。</p>
<p>总结来说，分配的顺序是：新生代（Eden &#x3D;&gt; Survivor0 &#x3D;&gt; Survivor1）&#x3D;&gt; 老年代</p>
<ul>
<li>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。</li>
</ul>
<p>这样做的目的是，避免在 Eden 区和两个 Survivor 区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。</p>
<ul>
<li>长期存活的对象进入老年代。</li>
</ul>
<p>虚拟机为每个对象定义了一个年龄计数器，如果对象经过了 1 次 Minor GC 那么对象会进入 Survivor 区，之后每经过一次 Minor GC 那么对象的年龄加 1 ，知道达到阀值对象进入老年区。</p>
<ul>
<li>动态判断对象的年龄。</li>
</ul>
<p>为了更好的适用不同程序的内存情况，虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代。</p>
<p>如果 Survivor 区中相同年龄的所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。</p>
<ul>
<li>空间分配担保。</li>
</ul>
<p>每次进行 Minor GC 时，JVM 会计算 Survivor 区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次 Full GC ，如果小于检查 HandlePromotionFailure 设置，如果 true 则只进行 Monitor GC ，如果 false 则进行 Full GC 。</p>
<p>如下是一张对象创建时，分配内存的图：</p>
<p><img src="https://files.catbox.moe/k89tqo.png"></p>
<h3 id="为什么新生代内存需要有两个-Survivor-区？"><a href="#为什么新生代内存需要有两个-Survivor-区？" class="headerlink" title="为什么新生代内存需要有两个 Survivor 区？"></a>为什么新生代内存需要有两个 Survivor 区？</h3><p>详细的原因，可以看 <a href="https://blog.csdn.net/qq_27093465/article/details/79802884">《为什么新生代内存需要有两个 Survivor 区》</a> 文章。</p>
<h2 id="什么是新生代-GC-和老年代-GC？"><a href="#什么是新生代-GC-和老年代-GC？" class="headerlink" title="什么是新生代 GC 和老年代 GC？"></a>什么是新生代 GC 和老年代 GC？</h2><p>GC 经常发生的区域是堆区，堆区还可以细分为</p>
<p><img src="https://files.catbox.moe/d71h7z.png"></p>
<ul>
<li><p>新生代</p>
</li>
<li><ul>
<li>一个 Eden 区</li>
<li>两个 Survivor 区</li>
</ul>
</li>
<li><p>老年代</p>
</li>
</ul>
<p>默认新生代(Young)与老年代(Old)的比例的值为 1:2 (该值可以通过参数 –XX:NewRatio 来指定)。</p>
<p>默认的 Eden:from:to&#x3D;8:1:1 (可以通过参数 –XX:SurvivorRatio 来设定)。</p>
<p>新生代GC（MinorGC&#x2F;YoungGC）：指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 MinorGC 非常频繁，一般回收速度也比较快。</p>
<p>老年代GC（MajorGC&#x2F;FullGC）：指发生在老年代的 GC，出现了 MajorGC，经常会伴随至少一次的 MinorGC（但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 MajorGC 的策略选择过程）。MajorGC 的速度一般会比 MinorGC 慢 10 倍以上。</p>
<h3 id="什么情况下会出现-Young-GC？"><a href="#什么情况下会出现-Young-GC？" class="headerlink" title="什么情况下会出现 Young GC？"></a>什么情况下会出现 Young GC？</h3><p>对象优先在新生代 Eden 区中分配，如果 Eden 区没有足够的空间时，就会触发一次 Young GC 。</p>
<h3 id="什么情况下回出现-Full-GC？"><a href="#什么情况下回出现-Full-GC？" class="headerlink" title="什么情况下回出现 Full GC？"></a>什么情况下回出现 Full GC？</h3><p>Full GC 的触发条件有多个，FULL GC 的时候会 STOP THE WORD 。</p>
<ul>
<li>1、在执行 Young GC 之前，JVM 会进行空间分配担保——如果老年代的连续空间小于新生代对象的总大小（或历次晋升的平均大小），则触发一次 Full GC 。</li>
<li>2、大对象直接进入老年代，从年轻代晋升上来的老对象，尝试在老年代分配内存时，但是老年代内存空间不够。</li>
<li>3、显式调用 System#gc() 方法时。</li>
</ul>
<h1 id="虚拟机性能监控与故障处理工具"><a href="#虚拟机性能监控与故障处理工具" class="headerlink" title="虚拟机性能监控与故障处理工具"></a>虚拟机性能监控与故障处理工具</h1><h2 id="JDK-的命令行工具有哪些可以监控虚拟机？"><a href="#JDK-的命令行工具有哪些可以监控虚拟机？" class="headerlink" title="JDK 的命令行工具有哪些可以监控虚拟机？"></a>JDK 的命令行工具有哪些可以监控虚拟机？</h2><p><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「4.2 JDK 的命令行工具」</a> 。</p>
<ul>
<li>jps ：虚拟机进程状况工具</li>
</ul>
<p>JVM Process Status Tool ，显示指定系统内所有的HotSpot虚拟机进程。</p>
<ul>
<li>jstat ：虚拟机统计信息监控工具</li>
</ul>
<p>JVM statistics Monitoring ，是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</p>
<ul>
<li>jinfo ：Java 配置信息工具</li>
</ul>
<p>JVM Configuration info ，这个命令作用是实时查看和调整虚拟机运行参数。</p>
<ul>
<li>jmap ：Java 内存映射工具</li>
</ul>
<p>JVM Memory Map ，命令用于生成 heap dump 文件。</p>
<ul>
<li>jhat ：虚拟机堆转储快照分析工具</li>
</ul>
<p>JVM Heap Analysis Tool ，命令是与 jmap 搭配使用，用来分析 jmap 生成的 dump 文件。jhat 内置了一个微型 的HTTP&#x2F;HTML 服务器，生成 dump 的分析结果后，可以在浏览器中查看。</p>
<ul>
<li>jstack ：Java 堆栈跟踪工具</li>
</ul>
<p>Java Stack Trace ，用于生成 Java 虚拟机当前时刻的线程快照。</p>
<ul>
<li>HSDIS ：JIT 生成代码反编译</li>
</ul>
<h2 id="JDK-的可视化工具有哪些可以监控虚拟机？"><a href="#JDK-的可视化工具有哪些可以监控虚拟机？" class="headerlink" title="JDK 的可视化工具有哪些可以监控虚拟机？"></a>JDK 的可视化工具有哪些可以监控虚拟机？</h2><ul>
<li><p>Java 自带</p>
</li>
<li><ul>
<li>JConsole ：Java 监视与管理控制台</li>
</ul>
</li>
</ul>
<p>Java Monitoring and Management Console 是从 Java5 开始，在 JDK 中自带的 Java 监控和管理控制台，用于对 JVM 中内存，线程和类等的监控。</p>
<ul>
<li><ul>
<li><a href="https://blog.csdn.net/a19881029/article/details/8432368/">VisualVM</a> ：多合一故障处理工具</li>
</ul>
</li>
</ul>
<p>JDK 自带全能工具，可以分析内存快照、线程快照、监控内存变化、GC变化等。</p>
<p>特别是 BTrace 插件，动态跟踪分析工具。</p>
<ul>
<li><p>第三方</p>
</li>
<li><ul>
<li>MAT ：内存分析工具</li>
</ul>
</li>
</ul>
<p>Memory Analyzer Tool ，一个基于 Eclipse 的内存分析工具，是一个快速、功能丰富的 Java heap 分析工具，它可以帮助我们查找内存泄漏和减少内存消耗。</p>
<ul>
<li><ul>
<li><a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/GC%20%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%20%E2%80%94%E2%80%94%20GChisto">GChisto</a> ：一款专业分析 GC 日志的工具。</li>
</ul>
</li>
</ul>
<p>另外，一些开源项目，例如 <a href="https://github.com/apache/incubator-skywalking">SkyWalking</a>、<a href="https://github.com/dianping/cat">Cat</a> ，也提供了 JVM 监控的功能，更加适合生产环境，对 JVM 的监控。</p>
<h2 id="怎么获取-Java-程序使用的内存？"><a href="#怎么获取-Java-程序使用的内存？" class="headerlink" title="怎么获取 Java 程序使用的内存？"></a>怎么获取 Java 程序使用的内存？</h2><p>可以通过 java.lang.Runtime 类中与内存相关方法来获取剩余的内存，总内存及最大堆内存。通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余空间。</p>
<ul>
<li>Runtime#freeMemory() 方法，返回剩余空间的字节数。</li>
<li>Runtime#totalMemory() 方法，总内存的字节数。</li>
<li>Runtime#maxMemory() 方法，返回最大内存的字节数。</li>
</ul>
<h1 id="调优案例分析与实战"><a href="#调优案例分析与实战" class="headerlink" title="调优案例分析与实战"></a>调优案例分析与实战</h1><p>在 <a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「第5章 调优案例分析与实战」</a> 中，已经提供了一些案例，建议看看。</p>
<h2 id="常见-GC-的优化配置？"><a href="#常见-GC-的优化配置？" class="headerlink" title="常见 GC 的优化配置？"></a>常见 GC 的优化配置？</h2><table>
<thead>
<tr>
<th>配置</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-Xms</td>
<td>初始化堆内存大小</td>
</tr>
<tr>
<td>-Xmx</td>
<td>堆内存最大值</td>
</tr>
<tr>
<td>-Xmn</td>
<td>新生代大小</td>
</tr>
<tr>
<td>-XX:PermSize</td>
<td>初始化永久代大小</td>
</tr>
<tr>
<td>-XX:MaxPermSize</td>
<td>永久代最大容量</td>
</tr>
<tr>
<td>-XX:SurvivorRatio</td>
<td>设置年轻代中 Eden 区与 Survivor 区的比值</td>
</tr>
<tr>
<td>-XX:Xmn</td>
<td>设置年轻代大小</td>
</tr>
</tbody></table>
<p>另外，也可以看看 <a href="https://blog.csdn.net/zhaojw_420/article/details/70527138">《JVM 调优》</a> 文章。</p>
<h2 id="如何排查线程-Full-GC-频繁的问题？"><a href="#如何排查线程-Full-GC-频繁的问题？" class="headerlink" title="如何排查线程 Full GC 频繁的问题？"></a>如何排查线程 Full GC 频繁的问题？</h2><ul>
<li><a href="https://blog.csdn.net/wilsonpeng3/article/details/70064336/">《线上 Full GC 频繁的排查》</a></li>
<li><a href="https://blog.csdn.net/chenleixing/article/details/46706039/">《触发 JVM 进行 Full GC 的情况及应对策略》</a></li>
</ul>
<h3 id="JVM-的永久代中会发生垃圾回收么？"><a href="#JVM-的永久代中会发生垃圾回收么？" class="headerlink" title="JVM 的永久代中会发生垃圾回收么？"></a>JVM 的永久代中会发生垃圾回收么？</h3><ul>
<li>Young GC 不会发生在永久代。</li>
<li>如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果我们仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免 Full GC 是非常重要的原因。</li>
</ul>
<p>Java8 ：从永久代到元数据区 (注：Java8 中已经移除了永久代，新加了一个叫做元数据区的 native 内存区)。</p>
<h2 id="有看过-GC-日志么？"><a href="#有看过-GC-日志么？" class="headerlink" title="有看过 GC 日志么？"></a>有看过 GC 日志么？</h2><p>这个问题，一般面试不会问，加进来，主要是为了知道，有这么个知识点。</p>
<p>参见文章如下：</p>
<ul>
<li>[《<a href="https://www.jianshu.com/p/fd1d4f21733a">JVM]理解GC日志》</a></li>
<li><a href="https://blog.csdn.net/TimHeath/article/details/53053106">《GC 日志查看分析》</a></li>
</ul>
<h2 id="类加载器是有了解吗？"><a href="#类加载器是有了解吗？" class="headerlink" title="类加载器是有了解吗？"></a>类加载器是有了解吗？</h2><p><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「7.4 类加载器」</a> 。</p>
<p>类加载器(ClassLoader)，用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序(.java 文件)在经过 Java 编译器编译之后就被转换成 Java 字节代码(.class 文件)。</p>
<p>类加载器，负责读取 Java 字节代码，并转换成 java.lang.Class 类的一个实例。</p>
<ul>
<li>每个这样的实例用来表示一个 Java 类。通过此实例的 Class#newInstance(…) 方法，就可以创建出该类的一个对象。</li>
<li>实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。</li>
</ul>
<h2 id="类加载发生的时机是什么时候？"><a href="#类加载发生的时机是什么时候？" class="headerlink" title="类加载发生的时机是什么时候？"></a>类加载发生的时机是什么时候？</h2><p><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「7.2 类加载的时机」</a> 。</p>
<p>虚拟机严格规定，有且仅有 5 种情况必须对类进行加载：</p>
<p>注意，有些文章会称为对类进行“初始化”。</p>
<ul>
<li>1、遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类还没进行初始化，则需要先触发其初始化。</li>
<li>2、使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类还没进行初始化，则需要先触发其初始化。</li>
<li>3、当初始化了一个类的时候，如果发现其父类还没进行初始化，则需要先触发其父类的初始化。</li>
<li>4、当虚拟机启动时，用户需要指定一个执行的主类，即调用其 #main(String[] args) 方法，虚拟机则会先初始化该主类。</li>
<li>5、当使用 JDK7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li>
</ul>
<h2 id="类加载器是如何加载-Class-文件的？"><a href="#类加载器是如何加载-Class-文件的？" class="headerlink" title="类加载器是如何加载 Class 文件的？"></a>类加载器是如何加载 Class 文件的？</h2><p>下图所示是 ClassLoader 加载一个 .class 文件到 JVM 时需要经过的步骤：</p>
<p><img src="https://files.catbox.moe/lf5iww.png"></p>
<ul>
<li>第一个阶段，加载(Loading)，是找到 .class 文件并把这个文件包含的字节码加载到内存中。</li>
<li>第二阶段，连接(Linking)，又可以分为三个步骤，分别是字节码验证、Class 类数据结构分析及相应的内存分配、最后的符号表的解析。</li>
<li>第三阶段，Initialization(类中静态属性和初始化赋值)，以及Using(静态块的执行)等。</li>
</ul>
<p>注意，不包括卸载(Unloading)部分。</p>
<p><strong>1.加载</strong></p>
<p>加载是“类加载”过程的第一阶段，不要混淆这两个名字。</p>
<p>在加载阶段，虚拟机需要完成以下三件事情：</p>
<ul>
<li>通过一个类的全限定名来获取其定义的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在Java堆中生成一个代表这个类的 java.lang.Class 对象，作为对方法区中这些数据的访问入口。</li>
</ul>
<p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p>
<p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个 java.lang.Class 类的对象，这样便可以通过该对象访问方法区中的这些数据。</p>
<p><strong>2.验证</strong></p>
<p>2.1 验证：确保被加载的类的正确性</p>
<p>验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p>验证阶段大致会完成4个阶段的检验动作：</p>
<ul>
<li>文件格式验证：验证字节流是否符合 Class 文件格式的规范。例如：是否以 0xCAFEBABE 开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li>
<li>元数据验证：对字节码描述的信息进行语义分析（注意：对比 javac 编译阶段的语义分析），以保证其描述的信息符合 Java 语言规范的要求。例如：这个类是否有父类，除了 java.lang.Object 之外。</li>
<li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li>
<li>符号引用验证：确保解析动作能正确执行。</li>
</ul>
<p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 -Xverifynone 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<p>2.2 准备：为类的静态变量分配内存，并将其初始化为默认值</p>
<p>准备阶段，是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p>
<ul>
<li>1、这时候进行内存分配的仅包括类变量(static)，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li>
</ul>
<p>思考下，对于类本身，静态变量就是其属性。</p>
<ul>
<li>2、这里所设置的初始值通常情况下是数据类型默认的零值(如 0、0L、null、false 等），而不是被在 Java 代码中被显式地赋予的值。<br>假设一个类变量的定义为： public static int value &#x3D; 3。那么静态变量 value 在准备阶段过后的初始值为 0，而不是 3。因为这时候尚未开始执行任何 Java 方法，而把 value 赋值为 3 的 public static 指令是在程序编译后，存放于类构造器 <clinit>() 方法之中的，所以把 value 赋值为 3 的动作将在初始化阶段才会执行。</li>
</ul>
<p>这里还需要注意如下几点：</p>
<ul>
<li><p>对基本数据类型来说，对于类变量(static)和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</p>
</li>
<li><p>对于同时被 static 和 final 修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被 final 修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</p>
</li>
<li><p>对于引用数据类型 reference 来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的空值，即 null 。</p>
</li>
<li><p>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的“空”值。</p>
</li>
<li><p>3、如果类字段的字段属性表中存在 ConstantValue 属性，即同时被 final 和 static 修饰，那么在准备阶段变量 value 就会被初始化为 ConstValue 属性所指定的值。<br>假设上面的类变量 value 被定义为： public static final int value &#x3D; 3 。编译时， javac 将会为 value 生成 ConstantValue 属性。在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 3。我们可以理解为 static final 常量在编译期就将其结果放入了调用它的类的常量池中。</p>
</li>
</ul>
<p>2.3 解析：把类中的符号引用转换为直接引用</p>
<p><a href="https://www.zhihu.com/question/50258991">《JVM 符号引用转换直接引用的过程?》</a> 和 <a href="https://www.zhihu.com/question/30300585">《JVM 里的符号引用如何存储？》</a> 做过解答</p>
<p>解析阶段，是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作，主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行。</p>
<ul>
<li>符号引用，就是一组符号来描述目标，可以是任何字面量。</li>
<li>直接引用，就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li>
</ul>
<p><strong>3.初始化</strong></p>
<p>初始化，为类的静态变量赋予正确的初始值，JVM 负责对类进行初始化，主要对类变量进行初始化。在 Java 中对类变量进行初始值设定有两种方式：</p>
<ul>
<li>1、声明类变量是指定初始值。</li>
<li>2、使用静态代码块为类变量指定初始值。</li>
</ul>
<p>JVM 初始化步骤：</p>
<ul>
<li>1、假如这个类还没有被加载和连接，则程序先加载并连接该类。</li>
<li>2、假如该类的直接父类还没有被初始化，则先初始化其直接父类。</li>
<li>3、假如类中有初始化语句，则系统依次执行这些初始化语句。</li>
</ul>
<h2 id="什么是双亲委派模型（Parent-Delegation-Model）？"><a href="#什么是双亲委派模型（Parent-Delegation-Model）？" class="headerlink" title="什么是双亲委派模型（Parent Delegation Model）？"></a>什么是双亲委派模型（Parent Delegation Model）？</h2><p>类加载器 ClassLoader 是具有层次结构的，也就是父子关系，如下图所示：</p>
<p><img src="https://files.catbox.moe/arbzju.png"></p>
<ul>
<li>Bootstrap ClassLoader ：根类加载器，负责加载 Java 的核心类，它不是 java.lang.ClassLoader 的子类，而是由 JVM 自身实现。</li>
</ul>
<p>此处，说的是 Hotspot 的情况下。</p>
<ul>
<li><p>Extension ClassLoader ：扩展类加载器，扩展类加载器的加载路径是 JDK 目录下 jre&#x2F;lib&#x2F;ext 。扩展加载器的 #getParent() 方法返回 null ，实际上扩展类加载器的父类加载器是根加载器，只是根加载器并不是 Java 实现的。</p>
</li>
<li><p>System ClassLoader ：系统(应用)类加载器，它负责在 JVM 启动时加载来自 Java 命令的 -classpath 选项、java.class.path 系统属性或 CLASSPATH 环境变量所指定的 jar 包和类路径。程序可以通过 #getSystemClassLoader() 来获取系统类加载器。系统加载器的加载路径是程序运行的当前路径。</p>
</li>
<li><p>该模型要求除了顶层的 Bootstrap 启动类加载器外，其余的类加载器都应当有自己的父类加载器。子类加载器和父类加载器不是以继承（Inheritance）的关系来实现，而是通过组合（Composition）关系来复用父加载器的代码。</p>
</li>
<li><p>每个类加载器都有自己的命名空间（由该加载器及所有父类加载器所加载的类组成。</p>
</li>
<li><ul>
<li>在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类。</li>
<li>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类）。</li>
<li>类加载器负责加载所有的类，同一个类(一个类用其全限定类名(包名加类名)标志)只会被加载一次。</li>
</ul>
</li>
</ul>
<h3 id="Java-虚拟机是如何判定两个-Java-类是相同的？"><a href="#Java-虚拟机是如何判定两个-Java-类是相同的？" class="headerlink" title="Java 虚拟机是如何判定两个 Java 类是相同的？"></a>Java 虚拟机是如何判定两个 Java 类是相同的？</h3><p>Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。</p>
<p>比如一个 Java 类 com.example.Sample ，编译之后生成了字节代码文件 Sample.class 。两个不同的类加载器 ClassLoaderA 和 ClassLoaderB 分别读取了这个 Sample.class 文件，并定义出两个 java.lang.Class 类的实例来表示这个类。这两个实例是不相同的。对于 Java 虚拟机来说，它们是不同的类。试图对这两个类的对象进行相互赋值，会抛出运行时异常 ClassCastException 。</p>
<h3 id="双亲委派模型的工作过程？"><a href="#双亲委派模型的工作过程？" class="headerlink" title="双亲委派模型的工作过程？"></a>双亲委派模型的工作过程？</h3><ul>
<li>1、当前 ClassLoader 首先从自己已经加载的类中，查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。</li>
</ul>
<p>每个类加载器都有自己的加载缓存，当一个类被加载了以后就会放入缓存，等下次加载的时候就可以直接返回了。</p>
<ul>
<li><p>2、当前 ClassLoader 的缓存中没有找到被加载的类的时候</p>
</li>
<li><ul>
<li>委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到 bootstrap ClassLoader。</li>
<li>当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回。</li>
</ul>
</li>
</ul>
<p>让我们来简单撸下源码。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;    </span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;        </span><br><span class="line">        <span class="comment">// 首先，从缓存中获得 name 对应的类        </span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);        </span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 获得不到            </span></span><br><span class="line">            <span class="keyword">try</span> &#123;                </span><br><span class="line">                <span class="comment">// 其次，如果父类非空，使用它去加载类                </span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;                    </span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);               </span><br><span class="line">                    <span class="comment">// 其次，如果父类为空，使用 Bootstrap 去加载类                </span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);                </span><br><span class="line">                &#125;            </span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123; </span><br><span class="line">            &#125;            </span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123; </span><br><span class="line">                <span class="comment">// 还是加载不到                </span></span><br><span class="line">                <span class="comment">// 最差，使用自己去加载类                </span></span><br><span class="line">                c = findClass(name);           </span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="comment">// 如果要解析类，则进行解析        </span></span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;            </span><br><span class="line">            resolveClass(c);        </span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> c;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为什么优先使用父-ClassLoader-加载类？"><a href="#为什么优先使用父-ClassLoader-加载类？" class="headerlink" title="为什么优先使用父 ClassLoader 加载类？"></a>为什么优先使用父 ClassLoader 加载类？</h3><ul>
<li>1、共享功能：可以避免重复加载，当父亲已经加载了该类的时候，子类不需要再次加载，一些 Framework 层级的类一旦被顶层的 ClassLoader 加载过就缓存在内存里面，以后任何地方用到都不需要重新加载。</li>
<li>2、隔离功能：主要是为了安全性，避免用户自己编写的类动态替换 Java 的一些核心类，比如 String ，同时也避免了重复加载，因为 JVM 中区分不同类，不仅仅是根据类名，相同的 class 文件被不同的 ClassLoader 加载就是不同的两个类，如果相互转型的话会抛 java.lang.ClassCaseException 。</li>
</ul>
<p>这也就是说，即使我们自己定义了一个 java.util.String 类，也不会被重复加载。</p>
<h2 id="什么是破坏双亲委托模型？"><a href="#什么是破坏双亲委托模型？" class="headerlink" title="什么是破坏双亲委托模型？"></a>什么是破坏双亲委托模型？</h2><p>正如我们上面看到的源码，破坏双亲委托模型，需要做的是，#loadClass(String name, boolean resolve) 方法中，不调用父 parent ClassLoader 方法去加载类，那么就成功了。那么我们要做的仅仅是，错误的覆盖 ##loadClass(String name, boolean resolve) 方法，不去使用父 parent ClassLoader 方法去加载类即可。</p>
<p>想要深入的可以看看如下文章：</p>
<ul>
<li><a href="https://blog.csdn.net/dangwanma6489/article/details/80244981">《Tomcat 类加载器之为何违背双亲委派模型》</a></li>
<li><a href="https://blog.csdn.net/yangcheng33/article/details/52631940">《真正理解线程上下文类加载器（多案例分析）》</a> 提供了多种打破双亲委托模型的案例。</li>
<li><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「第 9 章 类加载及执行子系统的案例与实战」</a></li>
</ul>
<h3 id="如何自定义-ClassLoader-类？"><a href="#如何自定义-ClassLoader-类？" class="headerlink" title="如何自定义 ClassLoader 类？"></a>如何自定义 ClassLoader 类？</h3><p>直接参考 <a href="https://www.jianshu.com/p/3036b46f1188">《Java 自定义 ClassLoader 实现 JVM 类加载》</a> 文章即可。</p>
<h3 id="OSGI-如何实现模块化热部署？"><a href="#OSGI-如何实现模块化热部署？" class="headerlink" title="OSGI 如何实现模块化热部署？"></a>OSGI 如何实现模块化热部署？</h3><p>OSGI 实现模块化热部署的关键，是它自定义的类加载器机制的实现。每一个程序模块都有一个自己的类加载器，当需要等换一个模块时，就把模块连同类加载器一起换掉以实现代码的热替换。</p>
<h2 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h2><p>有时我们会听到 JIT 这个概念，并说它是 JVM 的一部分，这让我们很困惑。JIT 是 JVM 的一部分，它可以在同一时间编译类似的字节码来优化将字节码转换为机器特定语言的过程相似的字节码，从而将优化字节码转换为机器特定语言的过程，这样减少转换过程所需要花费的时间。</p>
]]></content>
  </entry>
  <entry>
    <title>MySQL数据类型</title>
    <url>/2022/09/08/MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>数据库表由多列字段构成，每一个字段指定了不同的数据类型。指定字段的数据类型之后，也就决定了向字段插入的数据内容，例如，当要插入数值的时候，可以将它们存储为整数类型，也可以将它们存储为字符串类型。不同的数据类型也决定了MySQL在存储它们的时候使用的方式，以及在使用它们的时候选择什么运算符号进行运算。</p>
<h2 id="MySQL数据类型介绍"><a href="#MySQL数据类型介绍" class="headerlink" title="MySQL数据类型介绍"></a>MySQL数据类型介绍</h2><ol>
<li>数值类型：包括整数类型TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT、浮点小数数据类型FLOAT和DOUBLE，定点小数类型DECIMAL。</li>
<li>日期&#x2F;时间类型：包括YEAR、TIME、DATE、DATETIME和TIMESTAMP。</li>
<li>字符串类型：包括CHAR、VARCHAR、BINARY、BLOB、TEXT、ENUM和SET等。字符串类型又分为文本字符串和二进制字符串。</li>
</ol>
<h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p>数值型数据类型主要用来存储数字，MySQL提供了多种数值数据类型，不同的数据类型提供不同的取值范围，可以存储的值范围越大，其所需要的存储空间也会越大。MySQL主要提供的整数类型有TINYINT、SMALLINT、MEDIUMINT、INT（INTEGER）、BIGINT。整数类型的属性字段可以添加AUTO_INCREMENT自增约束条件。下面列出了MySQL中的数值类型。</p>
<table>
<thead>
<tr>
<th>类型名称</th>
<th>说明</th>
<th>存储需求</th>
</tr>
</thead>
<tbody><tr>
<td>TINYINT</td>
<td>很小的整数</td>
<td>1字节</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>小的整数</td>
<td>2字节</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>中等大小的整数</td>
<td>3字节</td>
</tr>
<tr>
<td>INT</td>
<td>普通大小的整数</td>
<td>4字节</td>
</tr>
<tr>
<td>BIGINT</td>
<td>大整数</td>
<td>8字节</td>
</tr>
</tbody></table>
<p>从表中可以看到，不同类型整数存储所需的字节数是不同的，占用字节数最小的是TINYINT类型，占用字节最大的是BIGINT类型，相应的占用字节越多的类型所能表示的数值范围越大。根据占用字节数可以求出每一种数据类型的取值范围。例如，TINYINT需要1字节（8 bits）来存储，那么TINYINT无符号数的最大值为-2^7，最大值为2^7-1，其他类型的整数的取值范围计算方法相同。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>有符号</th>
<th>无符号</th>
</tr>
</thead>
<tbody><tr>
<td>TINYINT</td>
<td>-128-127</td>
<td>0-255</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>-32768-32767</td>
<td>0-65535</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>-8388608-8388607</td>
<td>0-16777215</td>
</tr>
<tr>
<td>INT</td>
<td>-2147483648-2147483647</td>
<td>0-4294967295</td>
</tr>
<tr>
<td>BIGINT</td>
<td>-923372036854775808-923372036854775808</td>
<td>0-18446744073709551615</td>
</tr>
</tbody></table>
<p>例如，有如下建表语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test(</span><br><span class="line">	id <span class="type">int</span>(<span class="number">4</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>id字段的数据类型为INT(4)，注意后面的数字4，它表示的是该数据类型指定的显示宽度，即能够显示的数值中数字的个数。<br>在这里要注意：显示宽度和数据类型的取值范围是无关的。显示宽度只是指明MySQL最大可能显示的数字个数，数值的位数小于指定的宽度时会由空格填充；如果插入了大于显示宽度的值，只要该值不超过该类型整数的取值范围，数值依然可以插入，而且能够显示出来。例如，向id字段插入一个数值19999，当使用SELECT查询该列值的时候，MySQL显示的将是完整的带有5位数字的19999，而不是4位数字的值。<br>其他整型数据类型也可以在定义表结构时指定所需要的显示宽度，如果不指定，则系统为每一种类型指定默认的宽度值。<br>例如，创建表tmp1，其中字段x、y、z、m、n数据类型依次为TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，SQL语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TEMP1(</span><br><span class="line">	x TINYINT, y <span class="type">SMALLINT</span>, Z MEDIUMINT, M <span class="type">INT</span> , N <span class="type">BIGINT</span> </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>执行成功之后，使用DESC查看表结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DESC TEMP1;</span><br></pre></td></tr></table></figure>

<p>+——-+————–+——+—–+———+——-+</p>
<p>| Field | Type         | Null | Key | Default | Extra |</p>
<p>+——-+————–+——+—–+———+——-+</p>
<p>| X     | tinyint(4)    | YES  |     | NULL    |       |</p>
<p>| Y     | smallint(6)  | YES  |     | NULL    |       |</p>
<p>| Z     | mediumint(9) | YES  |     | NULL    |       |</p>
<p>| M    | int(11)      | YES  |     | NULL    |       |</p>
<p>| N    | bigint(20)   | YES  |     | NULL    |       |</p>
<p>+——-+————–+——+—–+———+——-+</p>
<p>可以看到，系统将添加不同的默认显示宽度。这些显示宽度能够保证显示每一种数据类型可以取到取值范围内的所有值。例如，TINYINT有符号数和无符号数的取值范围分别为-128127和0255，由于负号占了一个数字位，因此TINYINT默认的显示宽度为4。同理，其他整数类型的默认显示宽度与其有符号数的最小值的宽度相同。不同的整数类型有不同的取值范围，并且需要不同的存储空间，因此应该根据实际需要选择最合适的类型，这样有利于提高查询的效率和节省存储空间。整数类型是不带小数部分的数值，现实生活中很多地方需要用到带小数的数值，下面将介绍MySQL中支持的小数类型。</p>
<h2 id="浮点数类型和定点数类型"><a href="#浮点数类型和定点数类型" class="headerlink" title="浮点数类型和定点数类型"></a>浮点数类型和定点数类型</h2><p>MySQL中使用浮点数和定点数来表示小数。浮点数类型有两种：单精度浮点类型（FLOAT）和双精度浮点类型（DOUBLE）。定点数类型只有一种：DECIMAL。浮点数类型和定点数类型都可以用（M，N）来表示。其中，M称为精度，表示总共的位数；N称为标度，表示小数的位数。列出了MySQL中的小数类型和存储需求。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>存储需求</th>
</tr>
</thead>
<tbody><tr>
<td>FLOAT</td>
<td>单精度浮点数</td>
<td>4字节</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>双精度浮点数</td>
<td>8字节</td>
</tr>
<tr>
<td>DECIMAL(M,N)</td>
<td>定点数</td>
<td>M+2字节</td>
</tr>
</tbody></table>
<p>DECIMAL类型不同于FLOAT和DOUBLE，DECIMAL实际是以串存放的，可能的最大取值范围与DOUBLE一样，但是其有效的取值范围由M和D的值决定。如果改变M而固定D，则其取值范围将随M的变大而变大。从可以看到，DECIMAL的存储空间并不是固定的，而由其精度值M决定的，占用M+2字节。<br>FLOAT类型的取值范围如下：<br>●有符号的取值范围：-3.402823466E+38 ~ -1.175494351E-38。<br>●无符号的取值范围：0和1.175494351E-38 ~ 3.402823466E+38。<br>DOUBLE类型的取值范围如下：<br>●有符号的取值范围：-1.7976931348623157E+308 ~-2.2250738585072014E-308。<br>●无符号的取值范围：0和2.2250738585072014E-308 ~1.7976931348623157E+308。<br>不论是定点数还是浮点数类型，如果用户指定的精度超出精度范围，则会四舍五入。<br>创建表tmp2，其中字段x、y、z的数据类型依次为FLOAT(5,1)、DOUBLE(5,1)和DECIMAL(5,1)，向表中插入数据5.12、5.15和5.123，SQL语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TEMP2(</span><br><span class="line">	x <span class="type">FLOAT</span>(<span class="number">5</span>,<span class="number">1</span>),</span><br><span class="line">	y <span class="keyword">DOUBLE</span>(<span class="number">5</span>,<span class="number">1</span>),</span><br><span class="line">	z <span class="type">DECIMAL</span>(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>向表中插入数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TEMP2 <span class="keyword">VALUES</span> (<span class="number">5.12</span>,<span class="number">5.16</span>,<span class="number">5.123</span>);</span><br></pre></td></tr></table></figure>

<p>可以看到在插入数据时，MySQL给出了一个警告信息，使用SHOW WARNINGS;语句查看警告信息：</p>
<p>可以看到，FLOAT和DOUBLE在进行四舍五入时没有给出警告，只给出z字段数值被截断的警告。查看结果：</p>
<p>FLOAT和DOUBLE在不指定精度时，默认会按照实际的精度（由计算机硬件和操作系统决定），DECIMAL若不指定精度则默认为(10,0)。浮点数相对于定点数的优点是在长度一定的情况下，浮点数能够表示更大的数据范围；它的缺点是会引起精度问题。</p>
<p>在MySQL中，定点数以字符串形式存储，在对精度要求比较高的时候（如货币、科学数据等）使用DECIMAL的类型比较好，另外两个浮点数进行减法和比较运算时容易出问题，所以在使用浮点数时需要注意，并尽量避免做浮点数比较。</p>
<h2 id="日期与时间类型"><a href="#日期与时间类型" class="headerlink" title="日期与时间类型"></a>日期与时间类型</h2><p>MySQL中有多种表示日期的数据类型，主要有DATETIME、DATE、TIMESTAMP、TIME和YEAR。例如，当只记录年信息的时候，可以只使用YEAR类型，而没有必要使用DATE。每一个类型都有合法的取值范围，当指定确实不合法的值时系统将“零”值插入到数据库中。本节将介绍MySQL日期和时间类型的使用方法。</p>
<table>
<thead>
<tr>
<th>类型名称</th>
<th>日期格式</th>
<th>日期范围</th>
<th>存储需求</th>
</tr>
</thead>
<tbody><tr>
<td>YEAR</td>
<td>YYYY</td>
<td>1901-2155</td>
<td>1字节</td>
</tr>
<tr>
<td>TIME</td>
<td>HH:MM:SS</td>
<td>-838:59:59-838:59:59</td>
<td>3字节</td>
</tr>
<tr>
<td>DATE</td>
<td>YYYY-MM-DD</td>
<td>1000-01-01~9999-12-3</td>
<td>3字节</td>
</tr>
<tr>
<td>DATETIME</td>
<td>YYYY-MM-DD  HH:MM:SS</td>
<td>1000-01-01 00:00:00~9999-12-3 00:00:00</td>
<td>8字节</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>YYYY-MM-DD  HH:MM:SS</td>
<td></td>
<td>4字节</td>
</tr>
</tbody></table>
<h3 id="YEAR"><a href="#YEAR" class="headerlink" title="YEAR"></a>YEAR</h3><p>YEAR类型是一个单字节类型，用于表示年，在存储时只需要1字节。可以使用各种格式指定YEAR值，如下所示：</p>
<ol>
<li>以4位字符串或者4位数字格式表示的YEAR，范围为‘1901’～‘2155’。输入格式为‘YYYY’或者YYYY。例如，输入‘2010’或2010，插入到数据库的值均为2010。</li>
<li>以2位字符串格式表示的YEAR，范围为‘00’到‘99’。‘00’～‘69’和‘70’～‘99’范围的值分别被转换为2000～2069和1970～1999范围的YEAR值。‘0’与‘00’的作用相同。插入超过取值范围的值将被转换为2000。</li>
<li>以2位数字表示的YEAR，范围为1～99。1～69和70～99范围的值分别被转换为2001～2069和1970～1999范围的YEAR值。注意：在这里0值将被转换为0000，而不是2000。</li>
</ol>
<p>两位整数范围与两位字符串范围稍有不同。例如：插入2000年，可能会使用数字格式的0表示YEAR，实际上，插入数据库的值为0000，而不是所希望的2000。只有使用字符串格式的’0’或’00’，才可以被正确地解释为2000。非法YEAR值将被转换为0000。</p>
<h3 id="TIME"><a href="#TIME" class="headerlink" title="TIME"></a>TIME</h3><p>TIME类型用在只需要时间信息的值，在存储时需要3字节，格式为‘HH:MM:SS’。其中，HH表示小时，MM表示分钟，SS表示秒。TIME类型的取值范围为-838:59:59 ～838:59:59，小时部分会如此大的原因是TIME类型不仅可以用于表示一天的时间（必须小于24小时），还可能是某个事件过去的时间或两个事件之间的时间间隔（可以大于24小时，或者甚至为负）。可以使用各种格式指定TIME值。</p>
<ol>
<li>‘D HH:MM:SS’格式的字符串。可以使用下面任何一种“非严格”的语法：‘HH:MM:SS’、‘HH:MM’、‘D HH:MM’、‘D HH’或‘SS’。这里的D表示日，可以取0~34之间的值。在插入数据库时，D被转换为小时保存，格式为“D*24+HH”。</li>
<li>‘HHMMSS’格式的、没有间隔符的字符串或者HHMMSS格式的数值，假定是有意义的时间。例如：‘101112’被理解为‘10:11:12’，但‘109712’是不合法的（它有一个没有意义的分钟部分），存储时将变为00:00:00。</li>
</ol>
<p>为TIME列分配简写值时应注意：如果没有冒号，MySQL解释值时，假定最右边的两位表示秒。（MySQL解释TIME值为过去的时间而不是当天的时间。）例如，读者可能认为‘1112’和1112表示11:12:00（11点12分），但MySQL将它们解释为00:11:12（11分12秒）。同样‘12’和12被解释为00:00:12。相反，TIME值中如果使用冒号则肯定被看作当天的时间。也就是说，‘11:12’表示11:12:00，而不是00:11:12。</p>
<h3 id="DATE"><a href="#DATE" class="headerlink" title="DATE"></a>DATE</h3><p>DATE类型用在仅需要日期值时，没有时间部分，在存储时需要3字节。日期格式为‘YYYY-MM-DD’。其中，YYYY表示年，MM表示月，DD表示日。在给DATE类型的字段赋值时，可以使用字符串类型或者数字类型的数据插入，只要符合DATE的日期格式即可。</p>
<ol>
<li>以‘YYYY-MM-DD’或者‘YYYYMMDD’字符串格式表示的日期，取值范围为‘1000-01-01’～‘9999-12-3’。例如，输入‘2012-12-31’或者‘20121231’，插入数据库的日期都为2012-12-31。</li>
<li>以‘YY-MM-DD’或者‘YYMMDD’字符串格式表示的日期，在这里YY表示两位的年值。包含两位年值的日期会令人模糊，因为不知道世纪。MySQL使用以下规则解释两位年值：‘00～69’范围的年值转换为‘2000～2069’；‘70～99’范围的年值转换为‘1970～1999’。例如，输入‘12-12-31’，插入数据库的日期为2012-12-31；输入‘981231’，插入数据的日期为1998-12-31。</li>
<li>以YY-MM-DD或者YYMMDD数字格式表示的日期，与前面相似，00~69范围的年值转换为2000～2069，70～99范围的年值转换为1970～1999。例如，输入12-12-31插入数据库的日期为2012-12-31；输入981231，插入数据的日期为1998-12-31。</li>
<li>使用CURRENT_DATE或者NOW()，插入当前系统日期。</li>
</ol>
<h3 id="DATETIME"><a href="#DATETIME" class="headerlink" title="DATETIME"></a>DATETIME</h3><p>DATETIME类型用于需要同时包含日期和时间信息的值，在存储时需要8字节。日期格式为‘YYYY-MM-DD HH:MM:SS’。其中，YYYY表示年，MM表示月，DD表示日，HH表示小时，MM表示分钟，SS表示秒。在给DATETIME类型的字段赋值时，可以使用字符串类型或者数字类型的数据插入，只要符合DATETIME的日期格式即可。</p>
<ol>
<li>以‘YYYY-MM-DD HH:MM:SS’或者‘YYYYMMDDHHMMSS’字符串格式表示的值，取值范围为‘1000-01-01 00:00:00’～‘9999-12-3 23:59:59’。例如，输入‘2012-12-31 05: 05: 05’或者‘20121231050505’，插入数据库的DATETIME值都为2012-12-31 05: 05: 05。</li>
<li>以‘YY-MM-DD HH:MM:SS’或者‘YYMMDDHHMMSS’字符串格式表示的日期，在这里YY表示两位的年值。与前面相同，‘00～69’范围的年值转换为‘2000～2069’，‘70～99’范围的年值转换为‘1970～1999’。例如，输入‘12-12-31 05: 05: 05’，插入数据库的DATETIME为2012-12-31 05: 05:05；输入‘980505050505’，插入数据库的DATETIME为1998-05-05 05: 05:05。</li>
<li>以YYYYMMDDHHMMSS或者YYMMDDHHMMSS数字格式表示的日期和时间。例如，输入20121231050505，插入数据库的DATETIME为2012-12-3105:05:05；输入981231050505，插入数据的DATETIME为1998-12-31 05: 05:05。</li>
</ol>
<p>MySQL允许“不严格”语法：任何标点符号都可以用作日期部分或时间部分之间的间隔符。例如，‘98-12-31 11:30:45’、‘98.12.3111+30+45’、‘98&#x2F;12&#x2F;31 11<em>30</em>45’和‘98@12@31 113045’是等价的，这些值都可以正确地插入数据库。</p>
<h3 id="TIMESTAMP"><a href="#TIMESTAMP" class="headerlink" title="TIMESTAMP"></a>TIMESTAMP</h3><p>TIMESTAMP的显示格式与DATETIME相同，显示宽度固定在19个字符，日期格式为YYYY-MM-DD HH:MM:SS，在存储时需要4字节。TIMESTAMP列的取值范围小于DATETIME的取值范围，为‘1970-01-01 00:00:01’UTC～‘2038-01-1903:14:07’UTC。其中，UTC（Coordinated Universal Time）为世界标准时间，因此在插入数据时，要保证在合法的取值范围内。</p>
<p>TIMESTAMP与DATETIME除了存储字节和支持的范围不同外，还有一个最大的区别就是：DATETIME在存储日期数据时，按实际输入的格式存储，即输入什么就存储什么，与时区无关；而TIMESTAMP值的存储是以UTC（世界标准时间）格式保存的，存储时对当前时区进行转换，检索时再转换回当前时区。查询时，不同时区显示的时间值是不同的。</p>
<h2 id="文本类型"><a href="#文本类型" class="headerlink" title="文本类型"></a>文本类型</h2><p>字符串类型用来存储字符串数据，除了可以存储字符串数据之外，还可以存储其他数据，比如图片和声音的二进制数据。MySQL支持两类字符型数据：文本字符串和二进制字符串。本小节主要讲解文本字符串类型。文本字符串可以进行区分或者不区分大小写的串比较，还可以进行模式匹配查找。在MySQL中，文本字符串类型是指CHAR、VARCHAR、TEXT、ENUM和SET。列出了MySQL中的文本字符串数据类型。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>存储需求</th>
</tr>
</thead>
<tbody><tr>
<td>CHAR(M)</td>
<td>固定长度非二进制字符串</td>
<td>M字节，1≤M≤255</td>
</tr>
<tr>
<td>VARCHAR(M)</td>
<td>变长非二进制字符串</td>
<td>L+1字节，在此L≤M和1≤M≤255</td>
</tr>
<tr>
<td>TINYTEXT</td>
<td>非常小的非二进制字符串</td>
<td>L+1字节，在此L&lt;2^8</td>
</tr>
<tr>
<td>TEXT</td>
<td>小的非二进制字符串</td>
<td>L+2字节，在此L&lt;2^16</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>中等大小的非二进制字符串</td>
<td>L+3字节，在此L&lt;2^24</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>大的非二进制字符串</td>
<td>L+4字节，在此L&lt;2^32</td>
</tr>
<tr>
<td>ENUM</td>
<td>枚举类型，只能有一个枚举字符串值</td>
<td>1或2字节，取决于枚举值的数目（最大值为65535）</td>
</tr>
<tr>
<td>SET</td>
<td>一个设置，字符串对象可以有0个或者多个SET成员</td>
<td>1、2、3、4或8字节，取决于集合成员的数量（最多为64个成员）</td>
</tr>
</tbody></table>
<h3 id="CHAR和VARCHAR类型"><a href="#CHAR和VARCHAR类型" class="headerlink" title="CHAR和VARCHAR类型"></a>CHAR和VARCHAR类型</h3><p>CHAR(M)为固定长度字符串，在定义时指定字符串列长。当保存时在右侧填充空格，以达到指定的长度。M表示列长度，M的范围是0-255个字符。例如，CHAR(4)定义了一个固定长度的字符串列，其包含的字符个数最大为4。当检索到CHAR值时，尾部的空格将被删除。VARCHAR(M)是长度可变的字符串，M表示最大列长度。M的范围是0-65535。VARCHAR的最大实际长度由最长的行的大小和使用的字符集确定，而其实际占用的空间为字符串的实际长度加1。例如，VARCHAR(50)定义了一个最大长度为50的字符串，如果插入的字符串只有10个字符，则实际存储的字符串为10个字符和一个字符串结束字符。VARCHAR在值检索时尾部的空格仍保留。</p>
<h3 id="TEXT类型"><a href="#TEXT类型" class="headerlink" title="TEXT类型"></a>TEXT类型</h3><p>TEXT列保存非二进制字符串，如文章内容、评论等。当保存或查询TEXT列的值时，不删除尾部空格。Text类型分为4种：TINYTEXT、TEXT、MEDIUMTEXT和LONGTEXT。不同的TEXT类型的存储空间和数据长度不同。</p>
<ol>
<li>TINYTEXT最大长度为255（2^8–1）字符的TEXT列。</li>
<li>TEXT最大长度为65535（2^16–1）字符的TEXT列。</li>
<li>MEDIUMTEXT最大长度为16777215（2^24–1）字符的TEXT列。</li>
<li>LONGTEXT最大长度为4294967295（2^32–1）或4GB字符的TEXT列。</li>
</ol>
<h3 id="ENUM类型"><a href="#ENUM类型" class="headerlink" title="ENUM类型"></a>ENUM类型</h3><p>ENUM是一个字符串对象，其值为表创建时在列规定中枚举的一列值。语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">字段名 ENUM (<span class="string">&#x27;值1&#x27;</span>,<span class="string">&#x27;值2&#x27;</span>....<span class="string">&#x27;值3&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>其中，“字段名”指将要定义的字段，“值n”指枚举列表中的第n个值。ENUM类型的字段在取值时，只能在指定的枚举列表中取，而且一次只能取一个。创建的成员中有空格时，其尾部的空格将自动被删除。ENUM值在内部用整数表示，并且每个枚举值均有一个索引值：列表值所允许的成员值从1开始编号，MySQL存储的就是这个索引编号。枚举最多可以有65535个元素。<br>例如，定义ENUM类型的列(‘first’，’second’，’third’)。<br>3.4.4 SET类型<br>SET是一个字符串对象，可以有零或多个值。SET列最多可以有64个成员，其值为表创建时规定的一列值。指定包括多个SET成员的SET列值时，各成员之间用逗号(,)间隔开。语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">字段名 <span class="keyword">SET</span> (<span class="string">&#x27;值1&#x27;</span>,<span class="string">&#x27;值2&#x27;</span>....<span class="string">&#x27;值3&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="二进制字符串类型"><a href="#二进制字符串类型" class="headerlink" title="二进制字符串类型"></a>二进制字符串类型</h2><p>前面讲解了存储文本的字符串类型，这一小节将讲解MySQL中存储二进制数据的字符串类型。MySQL中的二进制数据类型有BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB。本节将讲解各类二进制字符串类型的特点和使用方法。</p>
<h3 id="BIT类型"><a href="#BIT类型" class="headerlink" title="BIT类型"></a>BIT类型</h3><p>BIT类型是位字段类型。M表示每个值的位数，范围为1~64。如果M被省略，默认为1。如果为BIT(M)列分配的值的长度小于M位，就在值的左边用0填充。例如，为BIT(6)列分配一个值b’101’，其效果与分配b’000101’相同。BIT数据类型用来保存位字段值。例如，以二进制的形式保存数据13（13的二进制形式为1101），在这里需要位数至少为4位的BIT类型，即可以定义列类型为BIT(4)，大于二进制1111的数据是不能插入BIT(4)类型的字段中的。</p>
<p>默认情况下，MySQL不可以插入超出该列允许范围的值，因而插入的数据要确保插入的值在指定的范围内。</p>
<h3 id="BINARY和VARBINARY类型"><a href="#BINARY和VARBINARY类型" class="headerlink" title="BINARY和VARBINARY类型"></a>BINARY和VARBINARY类型</h3><p>BINARY和VARBINARY类型类似于CHAR和VARCHAR，不同的是它们包含二进制字节字符串。其使用的语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">列名称 <span class="type">BINARY</span>(M) 或者<span class="type">VARBINARY</span>(M)</span><br></pre></td></tr></table></figure>

<p>BINARY类型的长度是固定的，指定长度之后，不足最大长度的，将在它们右边填充‘\0’补齐以达到指定长度。例如：指定列数据类型为BINARY(3)，当插入‘a’时，存储的内容实际为“a\0\0”，当插入“ab”时，实际存储的内容为“ab\0”，不管存储的内容是否达到指定的长度，其存储空间均为指定的值M。VARBINARY类型的长度是可变的，指定好长度之后，其长度可以在0到最大值之间。例如：指定列数据类型为VARBINARY(20)，如果插入的值的长度只有10，则实际存储空间为10加1，即实际占用的空间为字符串的实际长度加1。<br>3.5.3 BLOB类型<br>BLOB是一个二进制大对象，用来存储可变数量的数据。BLOB类型分为4种：TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB，它们可容纳值的最大长度不同<br>BLOB列存储的是二进制字符串（字节字符串），TEXT列存储的是非二进制字符串（字符字符串）。BLOB列没有字符集，并且排序和比较基于列值字节的数值；TEXT列有一个字符集，并且根据字符集对值进行排序和比较。<br>3.6 运算符<br>运算符连接表达式中的各个操作数，其作用是用来指明对操作数所进行的运算。运用运算符可以更加灵活地使用表中的数据，常见的运算符类型有算术运算符、比较运算符、逻辑运算符和位运算符。本节将介绍各种运算符的特点和使用方法。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> A(</span><br><span class="line">   AGE <span class="type">INT</span>(<span class="number">3</span>)</span><br><span class="line">   );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> A <span class="keyword">VALUES</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>算术运算符用于各类数值运算，包括加（+）、减（-）、乘（*）、除（&#x2F;）、求余（或称模运算，%）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> AGE<span class="operator">+</span><span class="number">100</span> <span class="keyword">FROM</span> A;</span><br></pre></td></tr></table></figure>

<p><img src="https://files.catbox.moe/96yopo.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> AGE<span class="number">-10</span> <span class="keyword">FROM</span> A;</span><br></pre></td></tr></table></figure>

<p><img src="https://files.catbox.moe/uire1v.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> AGE<span class="operator">*</span><span class="number">10</span> <span class="keyword">FROM</span> A;</span><br></pre></td></tr></table></figure>

<p><img src="https://files.catbox.moe/yqz7yz.png"></p>
<p><img src="https://files.catbox.moe/dryijd.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> AGE<span class="operator">/</span><span class="number">5</span> <span class="keyword">FROM</span> A;</span><br></pre></td></tr></table></figure>

<p><img src="https://files.catbox.moe/vaf0mh.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> AGE<span class="operator">%</span><span class="number">3</span> <span class="keyword">FROM</span> A;</span><br></pre></td></tr></table></figure>

<p><img src="https://files.catbox.moe/oj4ipa.png"></p>
<p>3.6.2 比较运算符</p>
<p>比较运算符用于比较运算，包括大于（&gt;）、小于（&lt;）、等于（&#x3D;）、大于等于（&gt;&#x3D;）、小于等于（&lt;&#x3D;）、不等于（!&#x3D;），以及IN、BETWEEN AND、ISNULL、GREATEST、LEAST等。<br>LEAST:语法格式为：LEAST(值1，值2，…，值n)。在有两个或多个参数的情况下，返回最小值。假如任意一个自变量为NULL，则LEAST()的返回值为NULL。<br>GREATEST:语法格式为：LEAST(值1，值2，…，值n)。当有两个或多个参数时，返回值为最大值。假如任意一个自变量为NULL，则GREATEST()的返回值为NULL。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> AGE<span class="operator">&gt;</span><span class="number">30</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://files.catbox.moe/n05ffh.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SELECT * FROM A WHERE AGE&lt;<span class="number">23</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://files.catbox.moe/yj1myx.png"></p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符的求值所得结果均为1（TRUE）、0（FALSE），这类运算符有逻辑非（NOT或者!）、逻辑与（AND或者&amp;&amp;）、逻辑或（OR或者||）、逻辑异或（XOR）。</p>
<p>逻辑非运算符NOT或者！表示当操作数为0时，所得值为1；当操作数为非零值时，所得值为0；当操作数为NULL时，所得的返回值为NULL。</p>
<p>逻辑与运算符AND或者&amp;&amp;表示当所有操作数均为非零值并且不为NULL时，计算所得结果为1；当一个或多个操作数为0时，所得结果为0；其余情况返回值为NULL。</p>
<p>逻辑或运算符OR或者||表示当两个操作数均为非NULL值且任意一个操作数为非零值时，结果为1，否则结果为0；当有一个操作数为NULL，且另一个操作数为非零值时，则结果为1，否则结果为NULL；当两个操作数均为NULL时，则所得结果为NULL。</p>
<p>逻辑异或运算符XOR表示当任意一个操作数为NULL时，返回值为NULL；对于非NULL的操作数，如果两个操作数都是非0值或者都是0值，则返回结果为0；如果一个为0值、另一个为非0值，返回结果为1。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> AGE<span class="operator">&gt;</span><span class="number">20</span><span class="operator">&amp;&amp;</span>AGE<span class="operator">&lt;</span><span class="number">30</span> <span class="keyword">FROM</span> A;</span><br></pre></td></tr></table></figure>

<p><img src="https://files.catbox.moe/mk4esv.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> AGE<span class="operator">=</span><span class="number">20</span><span class="operator">||</span>AGE<span class="operator">=</span><span class="number">30</span> <span class="keyword">FROM</span> A;</span><br></pre></td></tr></table></figure>

<p><img src="https://files.catbox.moe/08jsqe.png"></p>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>位运算符参与运算的操作数按二进制位进行运算，包括位与（&amp;）、位或（|）、位非（~）、位异或（^）、左移（&lt;&lt;）、右移（&gt;&gt;）6种。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> AGE<span class="operator">^</span><span class="number">5</span> <span class="keyword">FROM</span> A;</span><br></pre></td></tr></table></figure>

<p><img src="https://files.catbox.moe/2lqxwi.png"></p>
]]></content>
  </entry>
  <entry>
    <title>JDBC连接数据库</title>
    <url>/2022/09/08/JDBC%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><p>在前面的学习，通过CMD命令窗口或者图形界面工具连接并使用MySQL数据库，在一款软件的开发过程中，我们一般使用命令窗口或者图形界面工具调试或者测试数据，用不同的语言去连接数据库，进行数据操作，以Java为例，Java为我们提供并封装了一系列操作数据库的接口（这里的数据库不单单指MySQL，也包括其他关系型数据库例如:SqlServer或者oracle等）。在本章节内，我们将详细学习如果使用。</p>
<h2 id="JDBC简介"><a href="#JDBC简介" class="headerlink" title="JDBC简介"></a>JDBC简介</h2><p>JDBC 的全称是 Java Database Connectivity，即 Java 数据库连接，它是一种可以执行 SQL 语句的 Java API。程序可通过 JDBC API 连接到关系数据库，并使用结构化查询语言（SOL，数据库标准的查询语言）来完成对数据库的查询、更新。 与其他数据库编程环境相比，JDBC 为数据库开发提供了标准的 API，所以使用 JDBC 开发的数据库应用可以跨平台运行，而且可以跨数据库（如果全部使用标准的 SQL）。也就是说，如果使用 JDBC开发一个数据库应用，则该应用既可以在 Windows 平台上运行，也可以在 UNIX 等其他平台上运行;既可以使用 MySQL 数据库，也可以使用 Oracle 等数据库，而程序无须进行任何修改。</p>
<p>Java 语言的各种跨平台特性，都采用相似的结构，因为它们都需要让相同的程序在不同的平台上运行，所以都需要中间的转换程序（为了实现 Java 程序的跨平台性，Java为不同的操作系统提供了不同的虚拟机）。同样，为了使JDBC程序可以跨平台，则需要不同的数据库厂商提供相应的驱动程序。</p>
<p><img src="https://files.catbox.moe/0j9zo2.png"></p>
<p>上图显示了JDBC驱动示意图。 正是通过 JDBC驱动的转换，才使得使用相同 JDBC API 编写的程序，在不同的数据库系统上运行良好。</p>
<p>Sun 提供的 JDBC 可以完成以下三个基本工作。  </p>
<ol>
<li>建立与数据库的连接</li>
<li>执行SQL语句</li>
<li>获取SQL语句的执行结果</li>
</ol>
<h2 id="JDBC常用接口和类"><a href="#JDBC常用接口和类" class="headerlink" title="JDBC常用接口和类"></a>JDBC常用接口和类</h2><p>学习JDBC之前需要先了解常用的接口和类，了解完这些接口和类以后就可以使用JDBC连接并操作数据库。</p>
<h3 id="DriverManager类"><a href="#DriverManager类" class="headerlink" title="DriverManager类"></a>DriverManager类</h3><p>该接口用于管理JDBC驱动的服务类，该类的主要作用是获取Java与数据库连接的Connection对象，Connection对象可以想象成Java与数据库通信的桥梁。DriverManager的主要方法如下：</p>
<ul>
<li>public static Connection getConnection(String url,String user, String password) throws SQLException：该方法用于获取url对应的数据库连接，user指数据库的用户名，password指数据库的用户密码</li>
</ul>
<h3 id="Connection接口"><a href="#Connection接口" class="headerlink" title="Connection接口"></a>Connection接口</h3><p>该接口代表数据库的连接对象，每个Connection代表一个物理连接会话，要想访问数据库，必须先获得数据库连接。该接口的常用方法如下：</p>
<ul>
<li>Statement createStatement（） throws SQLExcetpion∶ 该方法返回一个 Statement 对象。 </li>
<li>PreparedStatement prepareStatement（String sql）throws SQLExcetpion∶ 该方法返回预编译的 Statement 对象，即将 SOL 语句提交到数据库进行预编译。 </li>
<li>CallableStatement prepareCall（String sql） throws SQLExcetpion∶ 该方法返回 CallableStatement 对象，该对象用于调用存储过程。</li>
</ul>
<p>  </p>
<p>上面三个方法都返回用于执行 SQL 语句的 Statement 对象，PreparedStatement、CallableStatement是 Statement 的子类，只有获得了 Statement 之后才可执行 SQL 语句。</p>
<p>除此之外，Connection 还有如下几个用于控制事务的方法。</p>
<ul>
<li>Savepoint setSavepoint（）∶创建一个保存点。</li>
<li>Savepoint setSavepoint（String name）∶ 以指定名字来创建一个保存点。</li>
<li>void setTransactionIsolation（int level）∶ 设置事务的隔离级别。</li>
<li>void rollback（）∶ 回滚事务。 &gt; void rollback（Savepoint savepoint）∶ 将事务回滚到指定的保存点。</li>
<li>void setAutoCommit（boolean autoCommit）∶关闭自动提交，打开事务。&gt; void commit（）∶提交事务。</li>
</ul>
<h3 id="Statement接口"><a href="#Statement接口" class="headerlink" title="Statement接口"></a>Statement接口</h3><p>Statement∶用于执行 SQL 语句的工具接口。该对象既可用于执行DDL、DCL 语句，也可用于 执行 DML 语句，还可用于执行 SQL 查询。当执行 SQL 查询时，返回查询到的结果集。它的常用方法如下。 </p>
<ul>
<li>ResultSet executeQuery（String sql）throws SQLException∶该方法用于执行查询语句，并返回查 询结果对应的 ResultSet 对象。该方法只能用于执行查询语句。 </li>
<li>int executeUpdate（String sql）throws SQLExcetion∶ 该方法用于执行 DML 语句，并返回受影响 的行数; 该方法也可用于执行 DDL 语句，执行 DDL 语句将返回 0。 </li>
<li>boolean execute（String sql）throws SOLException∶ 该方法可执行任何 SOL 语句。如果执行后 第一个结果为 ResultSet 对象，则返回 true; 如果执行后第一个结果为受影响的行数或没有任何结果，则返回 false。</li>
</ul>
<p>PreparedStatement：预编译的 Statement 对象。PreparedStatement 是 Statement 的子接口，它允 许数据库预编译 SOL 语句（这些 SOL 语句通常带有参数），以后每次只改变 SOL 命令的参数，避免数据库每次都需要编译 SQL 语句，因此性能更好。相对于 Statement 而言，使用 PreparedStatement 执行 SOL 语句时，无须再传入 SOL 语句，只要为预编译的 SOL 语句传入参数值即可。所以它比 Statement 多了如下方法。 </p>
<ul>
<li>void setXxx（int parameterlndex，Xxx value）∶该方法根据传入参数值的类型不同，需要使用不 同的方法。传入的值根据索引传给 SQL 语句中指定位置的参数。</li>
</ul>
<h3 id="ResultSet接口"><a href="#ResultSet接口" class="headerlink" title="ResultSet接口"></a>ResultSet接口</h3><p>ResultSet：结果集对象。该对象包含访问查询结果的方法，ResultSet 可以通过列索引或列名获 得列数据。它包含了如下常用方法来移动记录指针。</p>
<ul>
<li>void close()：释放 ResultSet 对象。 </li>
<li>boolean absolute(int row)：将结果集的记录指针移动到第 row 行，如果 row 是负数，则移动 到倒数第 row 行。如果移动后的记录指针指向一条有效记录，则该方法返回 true。 </li>
<li>void beforeFirst()：将 ResultSet 的记录指针定位到首行之前，这是 ResultSet 结果集记录指针 的初始状态——记录指针的起始位置位于第一行之前。 </li>
<li>boolean first()：将 ResultSet 的记录指针定位到首行。如果移动后的记录指针指向一条有效记 录，则该方法返回 true。 </li>
<li>boolean previous()：将 ResultSet 的记录指针定位到上一行。如果移动后的记录指针指向一条 有效记录，则该方法返回 true。 </li>
<li>boolean next()：将 ResultSet 的记录指针定位到下一行，如果移动后的记录指针指向一条有效 记录，则该方法返回 true。 </li>
<li>boolean last()：将 ResultSet 的记录指针定位到最后一行，如果移动后的记录指针指向一条有 效记录，则该方法返回 true。 ·</li>
<li>void afterLast()： 将 ResultSet 的记录指针定位到最后一行之后。</li>
</ul>
<p> </p>
<p>当把记录指针移动到指定行之后，ResultSet 可通过 getXxx（int columnIndex）或 getXxx（String columnLabel）方法来获取当前行、指定列的值，前者根据列索引获取值，后者根据列名获取值。Java 7新增了<T>T getObject（int columnIndex，Class<T> type）和<T>T getObject（String columnLabel， Class<T> type）两个泛型方法，它们可以获取任意类型的值。 </p>
<h2 id="JDBC编程步骤"><a href="#JDBC编程步骤" class="headerlink" title="JDBC编程步骤"></a>JDBC编程步骤</h2><p>大致了解了JDBC API的相关接口和类之后，下面就可以进行 JDBC 编程了，JDBC编程大致按如下步骤进行。</p>
<ol>
<li>加载驱动</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载MySQL驱动</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line"><span class="comment">//如果要加载Oracle驱动</span></span><br><span class="line">Class.forName(<span class="string">&quot;Oracle.jdbc.driver.OracleDriver&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li>获取连接</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取连接</span></span><br><span class="line">DriverManager.getConnection(String url,String user,String pass);</span><br></pre></td></tr></table></figure>

<p>当使用 DriverManager 获取数据库连接时，通常需要传入三个参数;数据库 URL、登录数据库的用户名和密码。这三个参数中用户名和密码通常由 DBA（数据库管理员）分配，而且该用户还应该具有相应的权限，才可以执行相应的 SQL 语句。 数据库 URL通常遵循如下写法∶</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jdbc:subprotoclo:othre stuff</span><br></pre></td></tr></table></figure>

<p>上面 URL 写法中的 jdbc 是固定的，而 subprotocol 指定连接到特定数据库的驱动，而后面的 other和 stuff也是不固定的——也没有较强的规律，不同数据库的 URL 写法可能存在较大差异。例如，MySQL数据库的 URL写法如下∶ </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jdbc:mysql:<span class="comment">//hostname:port/databasename</span></span><br></pre></td></tr></table></figure>

<p>在上面的链接中hostname指的是数据库所在主机的IP或者域名，如果要连接本机则可以写作“localhost”或者“127.0.0.1”，port则是指数据库的端口号，MySQL的端口号默认是3306，database则是只要连接数据库的名称。</p>
<p>Oracle数据库的URL写法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jdbc:oracle:thin:<span class="meta">@hostname</span>:port:databasename</span><br></pre></td></tr></table></figure>

<ol>
<li>通过Connection获取Statement对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatemen();</span><br></pre></td></tr></table></figure>

<ol>
<li>使用Statement对象执行SQL语句</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO STUDENT VALUES(1,&#x27;张三&#x27;,18,&#x27;男&#x27;)&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> statement.executeUpdate(sql);</span><br></pre></td></tr></table></figure>

<ol>
<li>获取结果，此处使用的是Statement对象的executeUpdate方法，该方法返回的是影响的行数，如果要调用executeQuery方法，则返回值是一个ResultSet对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> statement.executeQuery(sql);</span><br><span class="line"><span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">	System.out.println(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">	System.out.println(rs.getString(<span class="string">&quot;student_name&quot;</span>));</span><br><span class="line">	System.out.println(rs.getInt(<span class="string">&quot;student_age&quot;</span>));</span><br><span class="line">	System.out.println(rs.getInt(<span class="string">&quot;gender&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>释放资源</li>
</ol>
<p>下面，将上述步骤进行整合，示范JDBC编程步骤：</p>
<p>首先创建数据库和数据表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">--创建数据库</span><br><span class="line">CREATE DATABASE TEST_DB;</span><br><span class="line">--切换数据库</span><br><span class="line">USE TEST_DB;</span><br><span class="line">--创建表</span><br><span class="line">CREATE TABLE <span class="title function_">STUDENT</span><span class="params">(</span></span><br><span class="line"><span class="params">  ID INT(<span class="number">11</span>)</span>,</span><br><span class="line">  STUDENT_NAME <span class="title function_">VARCHAR</span><span class="params">(<span class="number">25</span>)</span>,</span><br><span class="line">  STUDENT_AGE <span class="title function_">VARCHAR</span><span class="params">(<span class="number">11</span>)</span>,</span><br><span class="line">  STUDENT_GENDER <span class="title function_">CHAR</span><span class="params">(<span class="number">2</span>)</span></span><br><span class="line">);</span><br><span class="line">--插入数据</span><br><span class="line">INSERT INTO STUDENT <span class="title function_">VALUES</span> <span class="params">(<span class="number">1</span>,<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="string">&#x27;男&#x27;</span>)</span>;</span><br><span class="line">INSERT INTO STUDENT <span class="title function_">VALUES</span> <span class="params">(<span class="number">2</span>,<span class="string">&quot;李四&quot;</span>,<span class="number">18</span>,<span class="string">&#x27;男&#x27;</span>)</span>;</span><br><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test_db?serverTimezone=Asia/Shanghai&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">		<span class="comment">//1.加载驱动</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;驱动未加载&quot;</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//2.获取连接</span></span><br><span class="line">		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">			<span class="comment">//3.获取Statement</span></span><br><span class="line">			statement = connection.createStatement();</span><br><span class="line">			<span class="comment">//4.执行SQL语句</span></span><br><span class="line"><span class="comment">//			String sql = &quot;INSERT INTO STUDENT (1,&#x27;张三&#x27;,18,&#x27;男&#x27;)&quot;;</span></span><br><span class="line"><span class="comment">//			int k = statement.executeUpdate(sql);</span></span><br><span class="line">			<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM STUDENT&quot;</span>;</span><br><span class="line">			<span class="comment">//5.获取结果</span></span><br><span class="line">			<span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> statement.executeQuery(sql);</span><br><span class="line">			<span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">				System.out.print(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">				System.out.print(rs.getString(<span class="string">&quot;student_name&quot;</span>));</span><br><span class="line">				System.out.print(rs.getInt(<span class="string">&quot;student_age&quot;</span>));</span><br><span class="line">				System.out.print(rs.getString(<span class="string">&quot;gender&quot;</span>));</span><br><span class="line">				System.out.println();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				statement.close();</span><br><span class="line">				connection.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的程序，结果如下图：</p>
<p><img src="https://files.catbox.moe/lv8m1j.png"></p>
<h2 id="使用PrepareStatement执行SQL语句"><a href="#使用PrepareStatement执行SQL语句" class="headerlink" title="使用PrepareStatement执行SQL语句"></a>使用PrepareStatement执行SQL语句</h2><p>如果经常需要反复执行一条结构相似的 SQL 语句，例如如下两条 SQL 语句∶ </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">INSERT INTO STUDENT <span class="title function_">VALUES</span> <span class="params">(<span class="number">1</span>,<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="string">&#x27;男&#x27;</span>)</span>;</span><br><span class="line">INSERT INTO STUDENT <span class="title function_">VALUES</span> <span class="params">(<span class="number">2</span>,<span class="string">&quot;李四&quot;</span>,<span class="number">18</span>,<span class="string">&#x27;男&#x27;</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>对于这两条 SOL 语句而言，它们的结构基本相似，只是执行插入时插入的值不同而已。对于这种情况，可以使用带占位符（?）参数的 SOL语句来代替它; </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">INSERT INTO STUDENT <span class="title function_">VALUES</span> <span class="params">(?,?,?,?)</span>;</span><br></pre></td></tr></table></figure>

<p>但 Statement 执行 SOL 语句时不允许使用问号占位符参数，而且这个问号占位符参数必须获得值后才可以执行。为了满足这种功能，JDBC提供了PreparedStatement接口，它是 Statement接口的子接口，它可以预编译 SQL 语句，预编译后的 SQL 语句被存储在 PreparedStatement 对象中，然后可以使用该对象多次高效地执行该语句。简而言之，使用 PreparedStatement 比使用 Statement 的效率要高。 创建 PreparedStatement 对象使用 Connection 的 prepareStatement()方法，该方法需要传入一个 SQL字符串，该 SQL 字符串可以包含占位符参数。如下代码所示∶ </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO STUDENT (?,?,?,?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br></pre></td></tr></table></figure>

<p>PreparedStatement 也提供了execute()、executeUpdate()、executeQuery()三个方法来执行 SQL 语句，不过这三个方法无须参数，因为 PreparedStatement 已存储了预编译的 SOL 语句。 使用 PreparedStatement 预编译 SOL 语句时，该 SOL 语句可以带占位符参数，因此在执行 SOL 语句之前必须为这些参数传入参数值，PreparedStatement 提供了一系列的 setXxx（int index，Xxx value）方法来传入参数值。</p>
<p>下面通过示例学习PrepareStatement的用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCDemo2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test_db?serverTimezone=Asia/Shanghai&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">		<span class="comment">//1.加载驱动</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;驱动未加载&quot;</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//2.获取连接</span></span><br><span class="line">		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">			<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO STUDENT VALUES (?,?,?,?)&quot;</span>;</span><br><span class="line">			ps = connection.prepareStatement(sql);</span><br><span class="line">			ps.setInt(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">			ps.setString(<span class="number">2</span>, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line">			ps.setInt(<span class="number">3</span>, <span class="number">20</span>);</span><br><span class="line">			ps.setString(<span class="number">4</span>, <span class="string">&quot;女&quot;</span>);</span><br><span class="line">			<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> ps.executeUpdate();</span><br><span class="line">			System.out.println(k);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				ps.close();</span><br><span class="line">				connection.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是使用PrepareStatement的setXxx()方法时，第一个参数是占位符的索引，第二个参数是占位符的真实值，占位符的索引是从1开始。</p>
<p>总体来看，使用 PreparedStatement 比使用 Statement 多了如下三个好处。</p>
<ol>
<li>PreparedStatement 预编译 SQL 语句，性能更好。</li>
<li>PreparedStatement 无须拼接SQL 语句，编程更简单。</li>
<li>PreparedStatement 可以防止 SQL 注入，安全性更好。</li>
</ol>
<p> 基于以上三点，通常推荐避免使用 Statement 来执行 SQL 语句，改为使用 PreparedStatement 执行 SQL语句。</p>
<h2 id="可滚动的结果集"><a href="#可滚动的结果集" class="headerlink" title="可滚动的结果集"></a>可滚动的结果集</h2><p>前面提到，ResultSet 定位记录指针的方法有 absolute（O）、previous（等方法，但前面程序自始至终都只用了 next（）方法来移动记录指针，实际上也可以使用 absoluteO、previousO、lastO）等方法来移动记录 指针。可以使用 absolute（）、previous（、afterLast（）等方法自由移动记录指针的 ResultSet 被称为可滚动的结果集。  </p>
<p>在 JDK 1.4 以前，默认打开的 ResultSet 是不可滚动的，必须在创建 Statement 或 PreparedStatement 时传入额外的参数。从 Java 5.0 以后，默认打开的 ResultSet 就是可滚动的，无须传入额外的参数。 </p>
<p>以默认方式打开的 ResultSet 是不可更新的，如果希望创建可更新的 ResultSet，则必须在创建 Statement 或 PreparedStatement 时传入额外的参数。Connection 在创建 Statement 或 PreparedStatement 时还可额外传入如下两个参数。 </p>
<ol>
<li>resultSetType∶ 控制 ResultSet 的类型，该参数可以取如下三个值：</li>
</ol>
<ul>
<li><ul>
<li> ResultSet.TYPE FORWARD ONLY∶该常量控制记录指针只能向前移动。这是 JDK1.4 以前 的默认值。 </li>
<li>ResultSet.TYPE SCROLL INSENSITIVE∶该常量控制记录指针可以自由移动（可滚动结果 集），但底层数据的改变不会影响 ResultSet 的内容。 </li>
<li>ResultSet.TYPE SCROLL SENSITIVE∶该常量控制记录指针可以自由移动（可滚动结果集）， 而且底层数据的改变会影响 ResultSet 的内容。</li>
</ul>
</li>
</ul>
<p> </p>
<ol>
<li>resultSetConcurrency∶控制 ResultSet 的并发类型，该参数可以接收如下两个值 ·：</li>
</ol>
<ul>
<li><ul>
<li>ResultSet.CONCUR_READ_ONLY∶该常量指示 ResultSet 是只读的并发模式（默认）。·</li>
<li>ResultSet.CONCUR UPDATABLE∶该常量指示 ResultSet是可更新的并发模式。</li>
</ul>
</li>
</ul>
<p>注意：TYPE SCROLL INSENSITIVE、TYPE SCROLL SENSITIVE 两个常量的作用需要底层数据库驱动的支持，对于有些数据库驱动来说，这两个常量并没有太大的区别。 </p>
<p>需要指出的是，可更新的结果集还需要满足如下两个条件。</p>
<ol>
<li>所有数据都应该来自一个表。</li>
<li>选出的数据集必须包含主键列。</li>
</ol>
<p> </p>
<p>通过该 PreparedStatement 创建的 ResultSet 就是可滚动、可更新的，程序可调用 ResultSet 的 updateXxx（int columnIndex，Xxx value）方法来修改记录指针所指记录、特定列的值，最后调用 ResultSet的 updateRow()方法来提交修改。</p>
<p>下面通过示例来学习可滚动的结果集。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCDemo2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test_db?serverTimezone=Asia/Shanghai&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">		<span class="comment">//1.加载驱动</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;驱动未加载&quot;</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//2.获取连接</span></span><br><span class="line">		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">			<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM STUDENT&quot;</span>;</span><br><span class="line">			ps = connection.prepareStatement(sql,ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_UPDATABLE);</span><br><span class="line">			<span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> ps.executeQuery();</span><br><span class="line">			<span class="comment">//将游标定位到最后一行</span></span><br><span class="line">			rs.last();</span><br><span class="line">			<span class="comment">//获取总行数</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> rs.getRow();</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row; i &gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line">				<span class="comment">//定位读取的行数</span></span><br><span class="line">				rs.absolute(i);</span><br><span class="line">				System.out.print(rs.getInt(<span class="string">&quot;id&quot;</span>)+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">				System.out.print(rs.getString(<span class="string">&quot;student_name&quot;</span>)+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">				System.out.print(rs.getInt(<span class="string">&quot;student_age&quot;</span>)+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">				System.out.print(rs.getString(<span class="string">&quot;gender&quot;</span>)+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">				System.out.println();</span><br><span class="line">				<span class="comment">//更新第二列，即学生姓名</span></span><br><span class="line">				rs.updateString(<span class="number">2</span>, <span class="string">&quot;姓名&quot;</span>+i);</span><br><span class="line">				rs.updateRow();</span><br><span class="line">				System.out.println();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				ps.close();</span><br><span class="line">				connection.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的程序结果如下图：</p>
<p><img src="https://files.catbox.moe/tqdw0i.png"></p>
<p>从运算结果可以看出输入数据时是倒序输出的，这是因为在程序中先将游标定位到了最后一行，然后倒序循环，通过absolute()定位到每一行数据并读取。读取完数据后，将数据表中的第2列数据进行了修改，此时查询数据库如下图：</p>
<p><img src="https://files.catbox.moe/bb73ur.png"></p>
<h2 id="使用ResultSetMetaData分析结果集"><a href="#使用ResultSetMetaData分析结果集" class="headerlink" title="使用ResultSetMetaData分析结果集"></a>使用ResultSetMetaData分析结果集</h2><p>当执行 SOL 查询后可以通过移动记录指针来遍历 ResultSet 的每条记录，但程序可能不清楚该 ResultSet 里包含哪些数据列，以及每个数据列的数据类型，那么可以通过 ResultSetMetaData 来获取关于 ResultSet 的描述信息。</p>
<p>ResultSet 里包含一个 getMetaData()方法，该方法返回该 ResultSet 对应的 ResultSetMetaData 对象。一旦获得了 ResultSetMetaData 对象，就可通过 ResultSetMetaData 提供的大量方法来返回 ResultSet 的描述信息。常用的方法有如下三个。 </p>
<ul>
<li>int getColumnCount()∶ 返回该 ResultSet 的列数量。</li>
<li>String getColumnName(int column)∶返回指定索引的列名。</li>
<li>String getColumnClassName（int column）∶返回指定索引的列类型。</li>
</ul>
<p> </p>
<p>下面通过示例来学习ResultSetMetaData的用法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSetMetaData;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResultSetMetaDataDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test_db?serverTimezone=Asia/Shanghai&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">		<span class="comment">//1.加载驱动</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;驱动未加载&quot;</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//2.获取连接</span></span><br><span class="line">		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">			<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM STUDENT&quot;</span>;</span><br><span class="line">			ps = connection.prepareStatement(sql);</span><br><span class="line">			<span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> ps.executeQuery();</span><br><span class="line">			<span class="comment">//获取结果集元数据</span></span><br><span class="line">			<span class="type">ResultSetMetaData</span> <span class="variable">metaData</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line">			<span class="comment">//获取结果集列数</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> metaData.getColumnCount();</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= count; i++) &#123;</span><br><span class="line">				<span class="comment">//获取每列的字段名</span></span><br><span class="line">				System.out.print(metaData.getColumnName(i)+<span class="string">&quot;\t\t&quot;</span>);</span><br><span class="line">				<span class="comment">//获取每列的数据类型</span></span><br><span class="line">				System.out.print(metaData.getColumnTypeName(i)+<span class="string">&quot;\t\t&quot;</span>);</span><br><span class="line">				<span class="comment">//获取每列对应的Java数据类型</span></span><br><span class="line">				System.out.print(metaData.getColumnClassName(i)+<span class="string">&quot;\t\t&quot;</span>);</span><br><span class="line">				System.out.println();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				ps.close();</span><br><span class="line">				connection.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的程序，结果如下</p>
<p><img src="https://files.catbox.moe/j2v6oe.png"></p>
]]></content>
  </entry>
  <entry>
    <title>MySQL查询数据</title>
    <url>/2022/09/08/MySQL%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h1 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h1><p>数据库管理系统的一个重要功能就是数据查询，数据查询不应只是简单返回数据库中存储的数据，还应该根据需要对数据进行筛选以及确定数据以什么样的格式显示。MySQL提供了功能强大、灵活的语句来实现这些操作，本章将介绍如何使用SELECT语句查询数据表中的一列或多列数据、使用集合函数显示查询结果、连接查询、子查询</p>
<h2 id="基本查询语句"><a href="#基本查询语句" class="headerlink" title="基本查询语句"></a>基本查询语句</h2><p>MySQL从数据表中查询数据的基本语句为SELECT语句。SELECT语句的基本格式是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">&#123; <span class="operator">*</span> <span class="operator">|</span> 字段列表</span><br><span class="line">  [<span class="keyword">FROM</span> table1,table2...</span><br><span class="line">  [<span class="keyword">WHERE</span> <span class="operator">&lt;</span>exp<span class="operator">&gt;</span></span><br><span class="line">  [<span class="keyword">GROUP</span> <span class="keyword">BY</span> 字段]</span><br><span class="line">  [<span class="keyword">HAVING</span> <span class="operator">&lt;</span>EXP<span class="operator">&gt;</span>]</span><br><span class="line">  [<span class="keyword">ORDER</span> <span class="keyword">BY</span> 字段]</span><br><span class="line">  [LIMIT <span class="keyword">START</span>,<span class="keyword">END</span>]</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，各条子句的含义如下：</p>
<ul>
<li>{* | &lt;字段列表&gt;}包含星号通配符和字段列表，表示查询的字段。其中，字段列表至少包含一个字段名称，如果要查询多个字段，多个字段之间用逗号隔开，最后一个字段后不加逗号。</li>
<li>FROM &lt;表1&gt;,&lt;表2&gt;…，表1和表2表示查询数据的来源，可以是单个或者多个。</li>
<li>WHERE子句是可选项，如果选择该项，将限定查询行必须满足的查询条件。</li>
<li>GROUP BY &lt;字段&gt;，该子句告诉MySQL如何显示查询出来的数据，并按照指定的字段分组。</li>
<li>[ORDER BY &lt;字段&gt;]，该子句告诉MySQL按什么样的顺序显示查询出来的数据，可以进行的排序有升序（ASC）、降序（DESC）。</li>
<li>[LIMIT [&lt;offset&gt;,] &lt;row count&gt;]，该子句告诉MySQL每次显示查询出来的数据条数</li>
</ul>
<p>下面，我们通过示例来学习，先建一张表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE DB_STUDENT;</span><br><span class="line">USE DB_STUDENT;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> STUDENT(</span><br><span class="line">	ID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">  STUDENT_NAME <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">  STUDENT_AGE TINYINT,</span><br><span class="line">  STUDENT_GENDER <span class="type">CHAR</span>(<span class="number">4</span>)</span><br><span class="line"> );</span><br><span class="line"> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> STUDENT <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">&#x27;李信&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> STUDENT <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="string">&#x27;周瑜&#x27;</span>,<span class="number">19</span>,<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> STUDENT <span class="keyword">VALUES</span> (<span class="number">3</span>,<span class="string">&#x27;安其拉&#x27;</span>,<span class="number">20</span>,<span class="string">&#x27;女&#x27;</span>);</span><br><span class="line"> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> STUDENT <span class="keyword">VALUES</span> (<span class="number">4</span>,<span class="string">&#x27;妲己&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;女&#x27;</span>);</span><br><span class="line"> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> STUDENT <span class="keyword">VALUES</span> (<span class="number">5</span>,<span class="string">&#x27;花木兰&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;女&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>首先，我们对表内所有的数据进行查询。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ID,STUDENT_NAME,STUDENT_AGE,STUDENT_GENDER <span class="keyword">FROM</span> STUDENT;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> STUDENT;</span><br></pre></td></tr></table></figure>

<p><img src="https://files.catbox.moe/mqrd9b.png"></p>
<p>上面的两种写法都可以查询出表内的所有字段，在第一种写法中，查询多个字段，那么字段间使用”,”进行分割，第二种写法可以使用”*”代替所有的字段，但是一般不推荐第二种写法，因为如果表中字段过多的话，并且有些字段不是所必需的，使用第二种写法会大大降低查询效率，因此在查询中我们应该遵循一个原则就是：用什么，查什么。例如：现在需要查询所有学生的姓名和性别，sql语句就可按照以下方式书写。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> STUDENT_NAME,STUDENT_GENDER <span class="keyword">FROM</span> STUDENT;</span><br></pre></td></tr></table></figure>

<p><img src="https://files.catbox.moe/jkutbj.png"></p>
<h2 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h2><h3 id="查询指定记录"><a href="#查询指定记录" class="headerlink" title="查询指定记录"></a>查询指定记录</h3><p>数据库中包含大量的数据，根据特殊要求，可能只需要查询表中的指定数据，即对数据进行过滤。在SELECT语句中，通过WHERE子句可以对数据进行过滤，语法格式为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span>,字段<span class="number">2.</span>...字段n <span class="keyword">FROM</span> <span class="keyword">TABLE</span> <span class="keyword">WHERE</span> EXP;</span><br></pre></td></tr></table></figure>

<p>WHERE子句中，MySQL提供了一系列的条件判断符，查询结果如表</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>相等</td>
</tr>
<tr>
<td>&lt;&gt;,!&#x3D;</td>
<td>不相等</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>小于等于</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>大于等于</td>
</tr>
<tr>
<td>BETWEEN   AND</td>
<td>位于两个值之间</td>
</tr>
</tbody></table>
<p>查询18岁的学生的姓名和年龄。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> STUDENT_NAME,STUDENT_AGE <span class="keyword">FROM</span> STUDENT;</span><br></pre></td></tr></table></figure>

<p><img src="https://files.catbox.moe/r5sln3.png"></p>
<p>从查询结果可以看出只有张三和赵六两人年龄是18岁，不满足此条件的数据被过滤。<br>查询姓名为张三的所有信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ID,STUDENT_NAME,STUDENT_AGE,STUDENT_GENDER <span class="keyword">FROM</span> STUDENT WHRER STUDENT_NAME <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://files.catbox.moe/apth6c.png"></p>
<p>查询年龄大于18岁的学生信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ID,STUDENT_NAME,STUDENT_AGE,STUDENT_GENDER <span class="keyword">FROM</span> STUDENT <span class="keyword">WHERE</span> STUDENT_AGE <span class="operator">&gt;</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://files.catbox.moe/2i8ggx.png"></p>
<p>查询年龄在18到20之间的同学。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ID,STUDENT_NAME,STUDENT_AGE,STUDENT_GENDER <span class="keyword">FROM</span> STUDENT <span class="keyword">WHERE</span> STUDENT_AGE <span class="keyword">BETWEEN</span> <span class="number">18</span></span><br><span class="line"><span class="keyword">AND</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://files.catbox.moe/pnwxm2.png"></p>
<p>从结果可以看出查询出的数据包含了年龄为18和20的同学，说明使用BTWEEN时是一个左闭右闭区间。</p>
<h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><h4 id="LIKE关键字"><a href="#LIKE关键字" class="headerlink" title="LIKE关键字"></a>LIKE关键字</h4><p>在前面的检索操作中讲述了如何查询多个字段的记录，如何进行比较查询或者是查询一个条件范围内的记录，如果要查找姓张的所有同学，该如何查找呢？简单的比较操作在这里已经行不通了，需要使用通配符进行匹配查找，通过创建查找模式对表中的数据进行比较。执行这个任务的关键字是LIKE。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ID,STUDENT_NAME,STUDENT_AGE,STUDENT_GENDER <span class="keyword">FROM</span> STUDENT <span class="keyword">WHERE</span> STUDENT_NAME <span class="keyword">LIKE</span> <span class="string">&#x27;张%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>从查询结果可以看出，使用like查询出了所有张姓同学，这里需要注意的是，%是通配符，匹配任意长度的字符。也就是说%告诉MySQL，返回所有以张开头的记录，不管张后面有多少个字符。<br>在搜索匹配时通配符‘%’可以放在不同位置，例如：查询姓名中包含“三”的学生信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ID,STUDENT_NAME,STUDENT_AGE,STUDENT_GENDER <span class="keyword">FROM</span> STUDENT <span class="keyword">WHERE</span> STUDENT_NAME <span class="keyword">LIKE</span> <span class="string">&#x27;%三%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>我们知道%是指通配符，可以匹配任意个字符，但是如果要查询的字段当中包含%，并且需要筛选出包含了%的数据，就需要对%进行转义。MySQL中默认的转义字符是“\”,即在%前加“\”即可，当然也可是使用ESCAPE字句自定义转义字符。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ID,STUDENT_NAME,STUDENT_AGE,STUDENT_GENDER <span class="keyword">FROM</span> STUDENT <span class="keyword">WHERE</span> STUDENT_NAM <span class="keyword">LIKE</span> <span class="string">&#x27;%\%%&#x27;</span>;</span><br><span class="line"><span class="comment">--或者自定义转义字符</span></span><br><span class="line"><span class="keyword">SELECT</span> ID,STUDENT_NAME,STUDENT_AGE,STUDENT_GENDER <span class="keyword">FROM</span> STUDENT <span class="keyword">WHERE</span> STUDENT_NAM <span class="keyword">LIKE</span> <span class="string">&#x27;%1%%&#x27;</span> <span class="keyword">ESCAPE</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上例中第一条SQL 语句使用了默认的转义字符，第二条则使用ESCAPE字句自定义1为转义字符</p>
<h4 id="通配符"><a href="#通配符" class="headerlink" title="_通配符"></a>_通配符</h4><p>“_”通配符和“%”的不同之处就是，%可以匹配多个字符，但是“_”能且只能匹配一个字符。<br>例如：查询表中所有张某同学的信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ID,STUDENT_NAME,STUDENT_AGE,STUDENT_GENDER <span class="keyword">FROM</span> STUDENT <span class="keyword">WHERE</span> STUDENT_NAM <span class="keyword">LIKE</span> &quot;张_&quot;;</span><br></pre></td></tr></table></figure>

<p>同理，如果要查询张某某同学的信息，则使用两个“_”即可</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ID,STUDENT_NAME,STUDENT_AGE,STUDENT_GENDER <span class="keyword">FROM</span> STUDENT <span class="keyword">WHERE</span> STUDENT_NAM <span class="keyword">LIKE</span> &quot;张__&quot;;</span><br></pre></td></tr></table></figure>

<h3 id="查询空值"><a href="#查询空值" class="headerlink" title="查询空值"></a>查询空值</h3><p>在数据表中，有可能某些字段的值为NULL，如果要筛选出这些数据，并不是说在where字句后添加字段名&#x3D;NULL，测试发现，这种写法并不能查询出数据。如果要判断某个字段是否为NULL，要使用关键字IS.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ID,STUDENT_NAME,STUDENT_AGE,STUDENT_GENDER <span class="keyword">FROM</span> STUDENT <span class="keyword">WHERE</span> STUDENT_GENDER <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<h3 id="非空值查询"><a href="#非空值查询" class="headerlink" title="非空值查询"></a>非空值查询</h3><p>在上一小节我们使用IS关键字判断某个字段值是否为null，但是非空该如何判断呢？在这里，我们需要使用关键字NOT来判断字段是否为null</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ID,STUDENT_NAME,STUDENT_AGE,STUDENT_GENDER <span class="keyword">FROM</span> STUDENT <span class="keyword">WHERE</span> STUDENT_GENDER <span class="keyword">IS</span> <span class="keyword">NOT</span>  <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<h3 id="AND多条件查询"><a href="#AND多条件查询" class="headerlink" title="AND多条件查询"></a>AND多条件查询</h3><p>在大多数查询时可能会存在多个条件同时成立时的过滤，例如查看所有大于18岁的男生的信息，或者查看所有大于18岁女生的信息，再或者在电商系统中查询订单金额大于1000元并且已经支付的订单，这时就需要用到and关键字，也就是告诉数据库，我只查询and前后的条件都成立的数据，数据库会根据条件进行过滤。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ID,STUDENT_NAME,STUDENT_AGE,STUDENT_GENDER <span class="keyword">FROM</span> STUDENT <span class="keyword">WHERE</span> STUDENT_AGE <span class="operator">&gt;</span> <span class="number">18</span> <span class="keyword">AND</span> STUDENT_GENDER <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们查询了两个条件同时成立的数据，使用and也可以查询多个条件同时成立的数据。例如：查询年龄大于18岁，性别为女，姓名为王五的学生信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ID,STUDENT_NAME,STUDENT_AGE,STUDENT_GENDER <span class="keyword">FROM</span> STUDENT <span class="keyword">WHERE</span> STUDENT_AGE <span class="operator">=</span> <span class="number">18</span> <span class="keyword">AND</span> STUDENT_GENDER <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span> <span class="keyword">AND</span> STUDENT_NAME <span class="operator">=</span> <span class="string">&#x27;王五&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，使用and连接查询条件时，条件表达式的顺序并不是固定的，可以在and前后任意位置。</p>
<h3 id="OR多条件查询"><a href="#OR多条件查询" class="headerlink" title="OR多条件查询"></a>OR多条件查询</h3><p>有时查询数据时可能存在多个过滤条件，但是这些条件符合至少1个即可，此时就需要用关键字OR。表示OR前后的条件满意任意一个即可。同样，OR也可以查询多个条件，和上述一致只需要满足任意一个条件即可。<br>例如：查询年龄为18岁或者19岁的同学</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ID,STUDENT_NAME,STUDENT_AGE,STUDENT_GENDER <span class="keyword">FROM</span> STUDENT <span class="keyword">WHERE</span> STUDENT_AGE <span class="operator">&gt;</span><span class="number">18</span> <span class="keyword">OR</span> STUDENT_AGE<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="查询去重"><a href="#查询去重" class="headerlink" title="查询去重"></a>查询去重</h3><p>使用DISTINCT可以将重复的值过滤，只保留一个,例如：对学生进行性别去重</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> STUDENT_GENDER <span class="keyword">FROM</span> STUDENT;</span><br></pre></td></tr></table></figure>

<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="单列排序"><a href="#单列排序" class="headerlink" title="单列排序"></a>单列排序</h4><p>在查询过程中经常需要根据某个字段进行升序或者降序查询，此时就需要用到关键字ORDER BY，例如根据成绩进行升序处理。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ID,STUDENT_NAME,STUDENT_AGE,STUDENT_GENDER,SCORE <span class="keyword">FROM</span> STUDENT <span class="keyword">ORDER</span> <span class="keyword">BY</span> SCORE ;</span><br></pre></td></tr></table></figure>

<p>从查询结果来看，数据库默认是按照升序进行数据显示。</p>
<h4 id="升序和降序"><a href="#升序和降序" class="headerlink" title="升序和降序"></a>升序和降序</h4><p>上小节我们对成绩进行了升序排序，也可以使用关键字ASC，ASC写在GROUP BY后的字段名称以后，由于数据库默认是按照升序显示数据，因此ASC可以省略。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ID,STUDENT_NAME,STUDENT_AGE,STUDENT_GENDER,SCORE <span class="keyword">FROM</span> STUDENT <span class="keyword">ORDER</span> <span class="keyword">BY</span> SCORE <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<p>从结果可以看出，添加ASC和默认排序的结果是一致的。</p>
<p>如果我们要进行降序显示，我们只需要将关键字ASC更换为DESC即可，例如：对所有同学的分数进行降序排序。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ID,STUDENT_NAME,STUDENT_AGE,STUDENT_GENDER,SCORE <span class="keyword">FROM</span> STUDENT <span class="keyword">ORDER</span> <span class="keyword">BY</span> SCORE <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><h4 id="GROUP-BY分组"><a href="#GROUP-BY分组" class="headerlink" title="GROUP BY分组"></a>GROUP BY分组</h4><p>分组在数据库查询中也是出现频率比较高的需求，如果要对数据分组就要用到关键字GROUP BY，例如：对学生性别进行分组。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> STUDENT_GENDER <span class="keyword">FROM</span> STUDENT <span class="keyword">GROUP</span> <span class="keyword">BY</span> STUDENT_GENDER;</span><br></pre></td></tr></table></figure>

<h4 id="HAVING-过滤分组"><a href="#HAVING-过滤分组" class="headerlink" title="HAVING 过滤分组"></a>HAVING 过滤分组</h4><p>如果要对分组后的数据进行筛选，那么我们就要使用HAVING关键字，HAVING关键字是指对分组后的结果进行筛选，在前面的内容中，我们使用了WHERE对数据进行筛选，需要注意的是WHERE筛选的数据是分组前进行筛选，而HAVING则是分组后进行筛选。例如：查询分组查询出男生的平均成绩和女生的平均成绩，并筛选出大于60分的分组。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> STUDENT_GENDER,<span class="built_in">AVG</span>(SCORE) <span class="keyword">FROM</span> STUDENT <span class="keyword">GROUP</span> <span class="keyword">BY</span> STUDENT_GENDER <span class="keyword">HAVING</span> (<span class="built_in">AVG</span>(SCORE)<span class="operator">&gt;</span><span class="number">80</span>);</span><br></pre></td></tr></table></figure>

<p>上面的示例中，出现了avg()函数，这个函数是一个聚合函数，用于求平均值。</p>
<h5 id="分组后排序"><a href="#分组后排序" class="headerlink" title="分组后排序"></a>分组后排序</h5><p>例如：对上例中的结果进行降序处理。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> STUDENT_GENDER,<span class="built_in">AVG</span>(SCORE) <span class="keyword">FROM</span> STUDENT <span class="keyword">GROUP</span> <span class="keyword">BY</span> STUDENT_GENDER <span class="keyword">HAVING</span> (<span class="built_in">AVG</span>(SCORE)<span class="operator">&gt;</span><span class="number">80</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">AVG</span>(SCORE) <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<h5 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h5><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>COUNT()</td>
<td>计算总条数</td>
</tr>
<tr>
<td>AVG()</td>
<td>求字段的平均值</td>
</tr>
<tr>
<td>SUM()</td>
<td>求字段总和</td>
</tr>
<tr>
<td>MAX()</td>
<td>求最大值</td>
</tr>
<tr>
<td>MIN()</td>
<td>求最小值</td>
</tr>
</tbody></table>
<p>例如：查询数据表中总共有多少条数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> STUDENT;</span><br></pre></td></tr></table></figure>

<p>在上面的结果中，我们可以看出查询出数据库总共有10条记录，需要注意的是当COUNT()函数的参数为*时，会统计该表中总共的记录数，但是，如果参数传的是某个字段的话，则统计该字段有多少条数据，如果该字段中存在NULL值，则会忽略该行。我们在表中新增一条数据，将该条数据的SCORE字段置为NULL，然后使用COUNT()函数进行统计。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(SCORE) <span class="keyword">FROM</span> STUDENT;</span><br></pre></td></tr></table></figure>

<p>从结果中可以看到，统计时忽略了NULL值，并没有将该条记录统计在内。</p>
<p>AVG()函数则是用来统计平均值，例如上例中对学生根据性别进行分组，分组后统计男女同学的平均成绩，现在我们可以使用该函数统计所有同学的平均值。注意：如果传入的字段中存在NULL值，则忽略该行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(SCORE) <span class="keyword">FROM</span> STUDENT;</span><br></pre></td></tr></table></figure>

<p>SUM()函数则是对某个字段计算总和。例如求出所有同学的总成绩。注意：如果传入的字段中存在NULL值，则忽略该行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(SCORE) <span class="keyword">FROM</span> STUDENT;</span><br></pre></td></tr></table></figure>

<p>MAX()函数和MIN()函数则是获取某个字段的最大值和最小值，例如我们获取学生的最高成绩和最低成绩。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(SCORE),<span class="built_in">MIN</span>(SCORE) <span class="keyword">FROM</span> STUDENT;</span><br></pre></td></tr></table></figure>

<p>查询男生的最高成绩和最低成绩，以及女生的最高成绩和最低成绩。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(SCORE),<span class="built_in">MIN</span>(SCORE) <span class="keyword">FROM</span> STUDENT <span class="keyword">GROUP</span> <span class="keyword">BY</span> STUDENT_GENDER;</span><br></pre></td></tr></table></figure>

<h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>我们在查询过程中发现，有些数据量比较大的表，通常不是一次性显示所有数据，而是分页显示，如果要对查询结果进行分页，就要使用LIMIT关键字<br>例如：显示所有学生的5条数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ID,STUDENT_NAME,STUDENT_AGE,STUDENT_GENDER <span class="keyword">FROM</span> STUDENT LIMIT <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>此时，我们在LIMIT后只写了一个参数，代表查询出数据表中前5条数据。LIMIT也可以传入2个参数，第一个参数代表从第几条数据开始，第二个参数代表显示几条数据。需要注意的是，MySQL中第一条数据的编号是0.<br>例如：查询数据库中前三条数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ID,STUDENT_NAME,STUDENT_AGE,STUDENT_GENDER <span class="keyword">FROM</span> STUDENT LIMIT <span class="number">0</span>,<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><p>在开发过程中绝大多数情况都需要操作2张或者2张以上的表，因此在查询中就需要多表联查或者说多张表进行连接，在MySQL中连接查询分为内连接和外连接，其中外连接又分为左外连接和右外连接。<br>首先我先创建一张学生信息表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> STUDENT_INFO (</span><br><span class="line">  ID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">  ADDRESS <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">  TELPHONE <span class="type">VARCHAR</span>(<span class="number">14</span>),</span><br><span class="line">  STUDENT_ID <span class="type">INT</span></span><br><span class="line"> );</span><br><span class="line"> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> STUDENT_INFO (ADDRESS,TELPHONE,STUDENT_ID) <span class="keyword">VALUES</span> (<span class="string">&#x27;河南&#x27;</span>,<span class="string">&#x27;1999999999&#x27;</span>,<span class="number">1</span>),(<span class="string">&#x27;河北&#x27;</span>,<span class="string">&#x27;1999999999&#x27;</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p>当我们要连接查询的表存在1对1的关系时，我们就可以使用内连接，使用INNER JOIN将两张表进行连接，通常INNER可以省略，需要注意的是，如果要添加条件是用关键字ON，而不是使用WHERE.<br>例如：查询所有学生的基本信息及详细信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> STUDENT <span class="keyword">JOIN</span> STUDENT_INFO <span class="keyword">ON</span> STUDENT.ID <span class="operator">=</span> STUDENT_INFO.ID;</span><br></pre></td></tr></table></figure>

<h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p>在大多数情况下我们遇到的查询时一个对多或者多对多的情况，这时简单的内连接已经无法满足查询数据的需要了，这时就要用到外连接，外连接又分为左外连接和右外连接，关键字分别是LEFT JOIN 和RINGHT JOIN。其中，JOIN左边的表叫左表，JOIN右边的表叫右表。</p>
<h4 id="LEFT-JOIN左连接"><a href="#LEFT-JOIN左连接" class="headerlink" title="LEFT JOIN左连接"></a>LEFT JOIN左连接</h4><p>在左连接中，左表中的数据会全部显示，右表中的数据符合过滤条件的显示。不符合过滤条件的数据则以NULL填充</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Student(SId <span class="type">varchar</span>(<span class="number">10</span>),Sname <span class="type">varchar</span>(<span class="number">10</span>),Sage <span class="type">date</span>,Ssex <span class="type">varchar</span>(<span class="number">10</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">&#x27;01&#x27;</span> , <span class="string">&#x27;赵雷&#x27;</span> , <span class="string">&#x27;1990-01-01&#x27;</span> , <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">&#x27;02&#x27;</span> , <span class="string">&#x27;钱电&#x27;</span> , <span class="string">&#x27;1990-12-21&#x27;</span> , <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">&#x27;03&#x27;</span> , <span class="string">&#x27;孙风&#x27;</span> , <span class="string">&#x27;1990-12-20&#x27;</span> , <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">&#x27;04&#x27;</span> , <span class="string">&#x27;李云&#x27;</span> , <span class="string">&#x27;1990-12-06&#x27;</span> , <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">&#x27;05&#x27;</span> , <span class="string">&#x27;周梅&#x27;</span> , <span class="string">&#x27;1991-12-01&#x27;</span> , <span class="string">&#x27;女&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">&#x27;06&#x27;</span> , <span class="string">&#x27;吴兰&#x27;</span> , <span class="string">&#x27;1992-01-01&#x27;</span> , <span class="string">&#x27;女&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">&#x27;07&#x27;</span> , <span class="string">&#x27;郑竹&#x27;</span> , <span class="string">&#x27;1989-01-01&#x27;</span> , <span class="string">&#x27;女&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">&#x27;09&#x27;</span> , <span class="string">&#x27;张三&#x27;</span> , <span class="string">&#x27;2017-12-20&#x27;</span> , <span class="string">&#x27;女&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">&#x27;10&#x27;</span> , <span class="string">&#x27;李四&#x27;</span> , <span class="string">&#x27;2017-12-25&#x27;</span> , <span class="string">&#x27;女&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">&#x27;11&#x27;</span> , <span class="string">&#x27;李四&#x27;</span> , <span class="string">&#x27;2012-06-06&#x27;</span> , <span class="string">&#x27;女&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">&#x27;12&#x27;</span> , <span class="string">&#x27;赵六&#x27;</span> , <span class="string">&#x27;2013-06-13&#x27;</span> , <span class="string">&#x27;女&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">&#x27;13&#x27;</span> , <span class="string">&#x27;孙七&#x27;</span> , <span class="string">&#x27;2014-06-01&#x27;</span> , <span class="string">&#x27;女&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Course(CId <span class="type">varchar</span>(<span class="number">10</span>),Cname <span class="type">varchar</span>(<span class="number">10</span>),TId <span class="type">varchar</span>(<span class="number">10</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Course <span class="keyword">values</span>(<span class="string">&#x27;01&#x27;</span> , <span class="string">&#x27;语文&#x27;</span> , <span class="string">&#x27;02&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Course <span class="keyword">values</span>(<span class="string">&#x27;02&#x27;</span> , <span class="string">&#x27;数学&#x27;</span> , <span class="string">&#x27;01&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Course <span class="keyword">values</span>(<span class="string">&#x27;03&#x27;</span> , <span class="string">&#x27;英语&#x27;</span> , <span class="string">&#x27;03&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Teacher(TId <span class="type">varchar</span>(<span class="number">10</span>),Tname <span class="type">varchar</span>(<span class="number">10</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Teacher <span class="keyword">values</span>(<span class="string">&#x27;01&#x27;</span> , <span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Teacher <span class="keyword">values</span>(<span class="string">&#x27;02&#x27;</span> , <span class="string">&#x27;李四&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Teacher <span class="keyword">values</span>(<span class="string">&#x27;03&#x27;</span> , <span class="string">&#x27;王五&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> SC(SId <span class="type">varchar</span>(<span class="number">10</span>),CId <span class="type">varchar</span>(<span class="number">10</span>),score <span class="type">DEC</span>(<span class="number">18</span>,<span class="number">1</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;01&#x27;</span> , <span class="string">&#x27;01&#x27;</span> , <span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;01&#x27;</span> , <span class="string">&#x27;02&#x27;</span> , <span class="number">90</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;01&#x27;</span> , <span class="string">&#x27;03&#x27;</span> , <span class="number">99</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;02&#x27;</span> , <span class="string">&#x27;01&#x27;</span> , <span class="number">70</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;02&#x27;</span> , <span class="string">&#x27;02&#x27;</span> , <span class="number">60</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;02&#x27;</span> , <span class="string">&#x27;03&#x27;</span> , <span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;03&#x27;</span> , <span class="string">&#x27;01&#x27;</span> , <span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;03&#x27;</span> , <span class="string">&#x27;02&#x27;</span> , <span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;03&#x27;</span> , <span class="string">&#x27;03&#x27;</span> , <span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;04&#x27;</span> , <span class="string">&#x27;01&#x27;</span> , <span class="number">50</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;04&#x27;</span> , <span class="string">&#x27;02&#x27;</span> , <span class="number">30</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;04&#x27;</span> , <span class="string">&#x27;03&#x27;</span> , <span class="number">20</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;05&#x27;</span> , <span class="string">&#x27;01&#x27;</span> , <span class="number">76</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;05&#x27;</span> , <span class="string">&#x27;02&#x27;</span> , <span class="number">87</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;06&#x27;</span> , <span class="string">&#x27;01&#x27;</span> , <span class="number">31</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;06&#x27;</span> , <span class="string">&#x27;03&#x27;</span> , <span class="number">34</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;07&#x27;</span> , <span class="string">&#x27;02&#x27;</span> , <span class="number">89</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;07&#x27;</span> , <span class="string">&#x27;03&#x27;</span> , <span class="number">98</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;09&#x27;</span> , <span class="string">&#x27;01&#x27;</span> , <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p>例如：查询所有同学学习的课程成绩，因为学生和学习的课程是一对多的关系，所以我们在这里选用左外连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> STUDENT <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> SC  <span class="keyword">ON</span> STUDENT.SID <span class="operator">=</span> SC.SID;</span><br></pre></td></tr></table></figure>

<p>从结果中可以看出，学生表中的所有信息都显示了，但是由于张三，李四，李四，赵六，孙七没有学习课程，所以在SC表中没有相关记录，因为使用了左外连接，所以，右表中的数据不满足筛选条件的全部以NULL值填充。</p>
<h4 id="RIGHT-JOIN-右连接"><a href="#RIGHT-JOIN-右连接" class="headerlink" title="RIGHT JOIN 右连接"></a>RIGHT JOIN 右连接</h4><p>右连接和左连接的规则相反，是指右表的数据全部显示，左表中的数据满足筛选条件的显示，不满足的则以NULL值填充。<br>我们在SC表中删除任意一条数据的SID来进行验证。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> STUDENT <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> SC <span class="keyword">ON</span> STUDENT.SID <span class="operator">=</span> SC.SID;</span><br></pre></td></tr></table></figure>

<p>从结果中可以看出，删除了一个SID后，在左表中无法找到对应的学生信息，因此该条数据的左表字段全部以NULL填充。</p>
<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> STUDENT2(</span><br><span class="line">    ID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    STUDENT_NAME <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    STUDENT_AGE TINYINT,</span><br><span class="line">    STUDENT_GENDER <span class="type">CHAR</span>(<span class="number">4</span>)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> STUDENT2 <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">&#x27;李信&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> STUDENT2 <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="string">&#x27;周瑜&#x27;</span>,<span class="number">19</span>,<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> STUDENT2 <span class="keyword">VALUES</span> (<span class="number">3</span>,<span class="string">&#x27;安其拉&#x27;</span>,<span class="number">22</span>,<span class="string">&#x27;女&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> STUDENT2 <span class="keyword">VALUES</span> (<span class="number">4</span>,<span class="string">&#x27;妲己&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;女&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> STUDENT2 <span class="keyword">VALUES</span> (<span class="number">5</span>,<span class="string">&#x27;花木兰&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;女&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="ANY关键字"><a href="#ANY关键字" class="headerlink" title="ANY关键字"></a>ANY关键字</h3><p>满足ANY子查询中任意一个即可,也可以理解为满足ANY子查询中最小的一个即可。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> STUDENT <span class="keyword">WHERE</span> STUDENT_AGE<span class="operator">&gt;</span><span class="keyword">ANY</span>(<span class="keyword">SELECT</span> STUDENT_AGE <span class="keyword">FROM</span> STUDENT2);</span><br></pre></td></tr></table></figure>

<h3 id="ALL关键字"><a href="#ALL关键字" class="headerlink" title="ALL关键字"></a>ALL关键字</h3><p>满足ALL子查询中所有的条件。或者满足ALL子查询中最大的即可</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> STUDENT2 <span class="keyword">WHERE</span> STUDENT_AGE<span class="operator">&gt;</span><span class="keyword">ALL</span>(<span class="keyword">SELECT</span> STUDENT_AGE <span class="keyword">FROM</span> STUDENT);</span><br></pre></td></tr></table></figure>

<h3 id="EXISTS关键字"><a href="#EXISTS关键字" class="headerlink" title="EXISTS关键字"></a>EXISTS关键字</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> STUDENT <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span>(<span class="keyword">SELECT</span> ID <span class="keyword">FROM</span> STUDENT2 <span class="keyword">WHERE</span> STUDENT2.STUDENT_AGE<span class="operator">=</span>STUDENT.STUDENT_AGE);</span><br></pre></td></tr></table></figure>

<h3 id="IN关键字"><a href="#IN关键字" class="headerlink" title="IN关键字"></a>IN关键字</h3><p>IN关键字可以理解为OR，即满足括号中的A条件，或者B条件，或者C条件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> STUDENT <span class="keyword">WHERE</span> STUDENT_AGE <span class="keyword">IN</span>(<span class="keyword">SELECT</span> STUDENT_AGE <span class="keyword">FROM</span> STUDENT2);</span><br></pre></td></tr></table></figure>

<h3 id="比较运算符的子查询"><a href="#比较运算符的子查询" class="headerlink" title="比较运算符的子查询"></a>比较运算符的子查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> STUDENT2 <span class="keyword">WHERE</span> STUDENT_AGE<span class="operator">&gt;</span>(<span class="keyword">SELECT</span> STUDENT_AGE <span class="keyword">FROM</span> STUDENT <span class="keyword">WHERE</span> STUDENT_AGE<span class="operator">=</span><span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<h2 id="SQL语句执行顺序"><a href="#SQL语句执行顺序" class="headerlink" title="SQL语句执行顺序"></a>SQL语句执行顺序</h2><ol>
<li>FROM</li>
<li>ON</li>
<li>JOIN</li>
<li>WHERE</li>
<li>GROUP BY</li>
<li>HAVING</li>
<li>SELECT </li>
<li>DISTINCT</li>
<li>ORDER BY</li>
<li>LIMIT</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>MySQL函数</title>
    <url>/2022/09/09/MySQL%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h1 id="MySQL函数"><a href="#MySQL函数" class="headerlink" title="MySQL函数"></a>MySQL函数</h1><p>MySQL为我们提供了丰富的函数，所谓函数是对输入值返回一个特定运算结果的值，在数据管理和数据操作过程中不同场景下通常要使用不同的函数，例如：计算一个班级的平均成绩，统计电商平台的总金额等等，通过使用这些函数使得数据库的功能变的更加强大，MySQL提供了不同功能的函数，大致有以下几类：数学函数、字符串函数、日期时间函数、条件判断函数、系统信息函数、加密函数等其他函数。</p>
<h2 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h2><p>在本小节我们将学习数学函数。</p>
<h3 id="获取绝对值"><a href="#获取绝对值" class="headerlink" title="获取绝对值"></a>获取绝对值</h3><p>ABS(X):返回X的绝对值<br>SELECT ABS(-3.14);</p>
<p>运行SQL语句后我们可以发现结果输出了3.14，获取了-3.14的绝对值。</p>
<p>我们也可以在数据表中的字段上使用此函数。我们创建表测试该函数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#创建表并添加测试数据</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TEMP1(ID <span class="type">INT</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TEMP1 (ID) <span class="keyword">VALUES</span> (<span class="number">10</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TEMP2 (ID) <span class="keyword">VALUES</span> (<span class="number">-20</span>);</span><br><span class="line">#测试ABS函数</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">ABS</span>(ID) <span class="keyword">FROM</span> TEMP1;</span><br></pre></td></tr></table></figure>

<h3 id="三角函数和获取圆周率"><a href="#三角函数和获取圆周率" class="headerlink" title="三角函数和获取圆周率"></a>三角函数和获取圆周率</h3><p>PI():返回圆周率</p>
<p>SIN(X):返回X的正弦值，其中X为弧度制</p>
<p>COS(X):返回X的余弦值，其中X为弧度制</p>
<p>TAN(X):返回X的正切，其中X为弧度制</p>
<p>COT(X):返回X的余切，其中X为弧度制</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> PI(),<span class="built_in">SIN</span>(PI()),<span class="built_in">COS</span>(PI()),<span class="built_in">TAN</span>(PI()),COT(PI());</span><br></pre></td></tr></table></figure>

<h3 id="平方根函数和求余函数"><a href="#平方根函数和求余函数" class="headerlink" title="平方根函数和求余函数"></a>平方根函数和求余函数</h3><p>SQRT(X):返回非负数X的二次方根，如果X为负数则会返回NULL</p>
<p>MOD(X,Y):返回X被Y除后的余数，MOD()对于带小数部分的数值也起作用，返回除法运算后的余数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SQRT</span>(<span class="number">4</span>),<span class="built_in">SQRT</span>(<span class="number">-4</span>),<span class="built_in">MOD</span>(<span class="number">5</span>,<span class="number">3</span>),<span class="built_in">MOD</span>(<span class="number">5.3</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2021/png/2745416/1617605648301-48dbc0b9-288d-478e-af84-ccb479df09c1.png" alt="img"></h4><h3 id="向上取整和向下取整"><a href="#向上取整和向下取整" class="headerlink" title="向上取整和向下取整"></a>向上取整和向下取整</h3><p>CEIL(X):返回不小于X(或者说大于X)的最小整数值，即向上取整</p>
<p>CEILING(X):作用同上</p>
<p>FLOOR(X):返回不大于X(或者说小于)的最大整数值，即向下取整</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CEIL</span>(<span class="number">3.14</span>),<span class="built_in">CEIL</span>(<span class="number">-3.14</span>),<span class="built_in">FLOOR</span>(<span class="number">3.14</span>);</span><br></pre></td></tr></table></figure>

<h3 id="获取随机数"><a href="#获取随机数" class="headerlink" title="获取随机数"></a>获取随机数</h3><p>RAND(x)返回一个随机浮点值v，范围在0到1之间（0 ≤ v ≤ 1.0）。若已指定一个整数参数x，则它被用作种子值，用来产生重复序列。</p>
<p>使用RAND()获取随机数时，可以发现每次获得的随机数都不相同</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> rand(),rand(),rand();</span><br></pre></td></tr></table></figure>

<p>下面我们使用RAND(x)来获取随机数，从结果可以发现当参数相同时，产生的随机数是相同的。不同的参数产生的随机数不同。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> rand(<span class="number">10</span>),rand(<span class="number">10</span>),rand(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h3 id="近似值函数"><a href="#近似值函数" class="headerlink" title="近似值函数"></a>近似值函数</h3><p>ROUND(x)返回最接近于参数x的整数，对x值进行四舍五入。<br>使用ROUND(x)对浮点数进行四舍五入取整</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ROUND(<span class="number">-3.14</span>),ROUND(<span class="number">2.56</span>),ROUND(<span class="number">1.14</span>);</span><br></pre></td></tr></table></figure>

<p>从结果可以看出，四舍五入处理后，只保留了各个值的整数部分。<br>ROUND(x,y)返回最接近于参数x的数，其值保留到小数点后面y位，若y为负值，则将保留x值到小数点左边y位，并且会四舍五入。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ROUND(<span class="number">1.28</span>,<span class="number">1</span>),ROUND(<span class="number">1.38</span>,<span class="number">0</span>),ROUND(<span class="number">223.3</span>,<span class="number">-1</span>),ROUND(<span class="number">-1118.56</span>,<span class="number">-2</span>);</span><br></pre></td></tr></table></figure>

<p>TRUNCATE(x,y)返回被舍去至小数点后y位的数字x。若y的值为0，则结果不带有小数点或不带有小数部分。若y设为负数，则截去（归零）x小数点左起第y位开始后面所有低位的值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">TRUNCATE</span>(<span class="number">1.31</span>,<span class="number">1</span>),<span class="keyword">TRUNCATE</span>(<span class="number">1.99</span>,<span class="number">1</span>),<span class="keyword">TRUNCATE</span>(<span class="number">1.99</span>,<span class="number">0</span>),<span class="keyword">TRUNCATE</span>(<span class="number">19.99</span>,<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>

<p>TRUNCATE(1.31,1)和TRUNCATE(1.99,1)都保留小数点后1位数字，返回值分别为1.3和1.9；TRUNCATE(1.99,0)返回整数部分值1；TRUNCATE(19.99,-1)截去小数点左边第1位后面的值，并将整数部分的1位数字置0，结果为10。<br>需要注意的是：y为负数时，保留小数点左边相应位数直接保存为0，不会四舍五入。</p>
<h3 id="幂运算函数"><a href="#幂运算函数" class="headerlink" title="幂运算函数"></a>幂运算函数</h3><p>POW(x,y)或者POWER(x,y)函数返回x的y次乘方的结果值。<br>SELECT POW(2,5);</p>
<h3 id="弧度函数与角度函数"><a href="#弧度函数与角度函数" class="headerlink" title="弧度函数与角度函数"></a>弧度函数与角度函数</h3><p>RADIANS(x)将参数x由角度转化为弧度。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> RADIANS(<span class="number">90</span>);</span><br></pre></td></tr></table></figure>

<p>DEGREES(x)将参数x由弧度转化为角度。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DEGREES(<span class="number">3.14</span>);<span class="number">3.141592653589793238462643</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><p>字符串函数主要用来处理数据库中的字符串数据。MySQL中的字符串函数有计算字符串长度函数、字符串合并函数、字符串替换函数、字符串比较函数、查找指定字符串位置函数等。本节将介绍各种字符串函数的功能和用法。</p>
<h3 id="获取字符串字符数"><a href="#获取字符串字符数" class="headerlink" title="获取字符串字符数"></a>获取字符串字符数</h3><p>CHAR_LENGTH(str)返回值为字符串str所包含的字符个数。一个多字节字符算作一个单字符。LENGTH(str)返回值为字符串的字节长度，使用utf8（UNICODE的一种变长字符编码，又称万国码）编码字符集时，一个汉字是2字节，一个数字或字母算1字节。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CHAR_LENGTH</span>(<span class="string">&#x27;张&#x27;</span>),<span class="keyword">CHAR_LENGTH</span>(<span class="string">&#x27;DATE&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h3><p>CONCAT(s1,s2,…)返回结果为连接参数产生的字符串，或许有一个或多个参数。如有任何一个参数为NULL，则返回值为NULL。如果所有参数均为非二进制字符串，则结果为非二进制字符串。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="string">&#x27;Hello&#x27;</span>,<span class="string">&#x27;World&#x27;</span>),CONCAT(<span class="string">&#x27;MY&#x27;</span>,<span class="keyword">NULL</span>,<span class="string">&#x27;SQL&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>在CONCAT_WS(x,s1,s2,…)中，CONCAT_WS代表CONCAT With Separator，是CONCAT()的特殊形式。第一个参数x是其他参数的分隔符，分隔符的位置放在要连接的两个字符串之间。分隔符可以是一个字符串，也可以是其他参数。如果分隔符为NULL，则结果为NULL。函数会忽略任何分隔符参数后的NULL值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONCAT_WS(&quot;-&quot;,&quot;HELLO&quot;,&quot;WORLD&quot;),CONCAT_WS(<span class="keyword">NULL</span>,&quot;HELLO&quot;,&quot;WORLD&quot;),CONCAT_WS(&quot;,&quot;,&quot;HELLO&quot;,<span class="keyword">NULL</span>,&quot;WORLD&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="大小写字母转换"><a href="#大小写字母转换" class="headerlink" title="大小写字母转换"></a>大小写字母转换</h3><p>LOWER (str)或者LCASE (str)可以将字符串str中的字母字符全部转换成小写字母。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">LOWER</span>(<span class="string">&#x27;HELLO&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>使用UPPER函数或者UCASE函数将字符串中所有字母字符转换为大写</p>
<h3 id="删除空格"><a href="#删除空格" class="headerlink" title="删除空格"></a>删除空格</h3><p>LTRIM(s)返回字符串s，字符串左侧空格字符被删除。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="string">&#x27;(&#x27;</span>,LTRIM(<span class="string">&#x27;   BOOK    &#x27;</span>),<span class="string">&#x27;)&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>RTRIM(s)返回字符串s，字符串右侧空格字符被删除。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="string">&#x27;(&#x27;</span>,RTRIM(<span class="string">&#x27;   BOOK    &#x27;</span>),<span class="string">&#x27;)&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>TRIM(s1 FROM s)删除字符串s中两端所有的子字符串s1。s1为可选项，在未指定情况下，删除空格。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="string">&#x27;(&#x27;</span>,<span class="built_in">TRIM</span>(<span class="string">&#x27;  BOOK  &#x27;</span>),<span class="string">&#x27;)&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>从结果中可以看出当未指定参数s时，删除了 两端的空格。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">TRIM</span>(<span class="string">&#x27;123&#x27;</span> <span class="keyword">FROM</span> <span class="string">&#x27;1234512345123&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>从结果可以看出函数删除了两端的重复字符串123，并没有删除中间的重复字符串</p>
<h3 id="替换函数"><a href="#替换函数" class="headerlink" title="替换函数"></a>替换函数</h3><p>REPLACE(s,s1,s2)使用字符串s2替代字符串s中所有的字符串s1。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> REPLACE(<span class="string">&#x27;xxx.bytecollege.cn&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;w&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>REPLACE()函数将字符串中的”x”，全部替换成了”w”;</p>
<h3 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串"></a>截取字符串</h3><p>SUBSTRING(s,n,len)带有len参数的格式，从字符串s返回一个长度与len字符相同的子字符串，起始于位置n。也可能对n使用一个负值。假若这样，则子字符串的位置起始于字符串结尾的n字符，即倒数第n个字符，而不是字符串的开头位置。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUBSTRING</span>(<span class="string">&#x27;HELLOWORLD&#x27;</span>,<span class="number">5</span>),<span class="built_in">SUBSTRING</span>(<span class="string">&#x27;HELLOWORLD&#x27;</span>,<span class="number">2</span>,<span class="number">5</span>),<span class="built_in">SUBSTRING</span>(<span class="string">&#x27;HELLO&#x27;</span>,<span class="number">-3</span>),<span class="built_in">SUBSTRING</span>(<span class="string">&#x27;HELLOWORLD&#x27;</span>,<span class="number">-3</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>MID(s,n,len)与SUBSTRING(s,n,len)的作用相同。<br>如果对len使用的是一个小于1的值，则结果始终为空字符串。</p>
<h3 id="字符串逆序"><a href="#字符串逆序" class="headerlink" title="字符串逆序"></a>字符串逆序</h3><p>REVERSE(s)将字符串s反转，返回的字符串的顺序和s字符串顺序相反。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> REVERSE(<span class="string">&#x27;HELLO&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="日期和时间函数"><a href="#日期和时间函数" class="headerlink" title="日期和时间函数"></a>日期和时间函数</h2><p>日期和时间函数主要用来处理日期和时间值，一般的日期函数除了使用DATE类型的参数外，也可以使用DATETIME或者TIMESTAMP类型的参数，但会忽略这些值的时间部分。相同的，以TIME类型值为参数的函数，可以接受TIMESTAMP类型的参数，但会忽略日期部分，许多日期函数可以同时接受数字和字符串类型的两种参数，本节将介绍各种日期和时间函数的功能和用法。</p>
<h3 id="获取当前日期"><a href="#获取当前日期" class="headerlink" title="获取当前日期"></a>获取当前日期</h3><p>CURDATE()和CURRENT_DATE()函数的作用相同，将当前日期按照‘YYYY-MM-DD’或YYYYMMDD格式的值返回</p>
<h3 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h3><p>CURRENT_TIMESTAMP()、LOCALTIME()、NOW()和SYSDATE() 4个函数的作用相同，均返回当前日期和时间值，格式为‘YYYY-MM-DD HH:MM:SS’或YYYYMMDDHHMMSS</p>
<h3 id="获取月份"><a href="#获取月份" class="headerlink" title="获取月份"></a>获取月份</h3><p>MONTH(date)函数返回date对应的月份，范围值为1~12。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MONTH</span>(<span class="string">&#x27;2020-02-13&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="获取星期"><a href="#获取星期" class="headerlink" title="获取星期"></a>获取星期</h3><p>WEEK(d)计算日期d是一年中的第几周，取值范围是0-52；按周日为第一天。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> WEEK(<span class="string">&#x27;2018-02-11&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>WEEKOFYEAR(d)计算某天位于一年中的第几周，范围是1~53，周一为第一天。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  WEEKOFYEAR(<span class="string">&#x27;2018-02-11&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="获取天数"><a href="#获取天数" class="headerlink" title="获取天数"></a>获取天数</h3><p>DAYOFYEAR(d)函数返回d是一年中的第几天，范围是1~366。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DAYOFYEAR(<span class="string">&#x27;2018-02-11&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>DAYOFMONTH(d)函数返回是d时间月份中的第几天。</p>
<h3 id="获取年份、小时、分钟和秒钟的函数"><a href="#获取年份、小时、分钟和秒钟的函数" class="headerlink" title="获取年份、小时、分钟和秒钟的函数"></a>获取年份、小时、分钟和秒钟的函数</h3><p>YEAR(date)返回date对应的年份，范围是1970~2069。</p>
<p>HOUR(time)返回time对应的小时，范围是0-23；</p>
<p>MINUTE(time)返回time对应的分钟数，范围是0~59。</p>
<p>SECOND(time)返回time对应的秒数，范围是0~59。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">YEAR</span>(<span class="string">&#x27;2018-02-11 10:11:11&#x27;</span>),<span class="keyword">MINUTE</span>(<span class="string">&#x27;2018-02-11 10:11:11&#x27;</span>),<span class="keyword">SECOND</span>(<span class="string">&#x27;2018-02-11 10:11:11&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="计算日期和时间的函数"><a href="#计算日期和时间的函数" class="headerlink" title="计算日期和时间的函数"></a>计算日期和时间的函数</h3><p>计算日期和时间的函数有DATE_ADD()、ADDDATE()、DATE_SUB()、SUBDATE()、ADDTIME()</p>
<p>在DATE_ADD(date,INTERVAL expr type)和DATE_SUB(date,INTERVAL exprtype)中，date是一个DATETIME或DATE值，用来指定起始时间。expr是一个表达式，用来指定从起始日期添加或减去的时间间隔值。对于负值的时间间隔，expr可以以一个负号‘-’开头。type为关键词，指示了表达式被解释的方式。</p>
<h3 id="将日期和时间格式化的函数"><a href="#将日期和时间格式化的函数" class="headerlink" title="将日期和时间格式化的函数"></a>将日期和时间格式化的函数</h3><p>DATE_FORMAT(date,format)根据format指定的格式显示date值，主要format格式如表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATE_FORMAT(NOW(),<span class="string">&#x27;%Y-%m-%d %H:%i:%s&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="条件判断函数"><a href="#条件判断函数" class="headerlink" title="条件判断函数"></a>条件判断函数</h2><p>条件判断函数也称为控制流程函数，根据满足的不同条件，执行相应的流程。MySQL中进行条件判断的函数有IF、IFNULL和CASE。本节将分别介绍各个函数的用法。</p>
<h3 id="IF-expr-v1-v2-函数"><a href="#IF-expr-v1-v2-函数" class="headerlink" title="IF(expr,v1,v2)函数"></a>IF(expr,v1,v2)函数</h3><p>IF(expr, v1, v2)：如果表达式expr是TRUE(expr &lt;&gt; 0 and expr &lt;&gt; NULL)，则返回值为v1；否则返回值为v2。IF()的返回值为数字值或字符串值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> IF(<span class="number">1</span><span class="operator">&gt;</span><span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>),IF(<span class="number">1</span><span class="operator">&lt;</span><span class="number">2</span>,<span class="string">&#x27;YES&#x27;</span>,<span class="string">&#x27;NO&#x27;</span>),IF(<span class="string">&#x27;TEST&#x27;</span><span class="operator">=</span><span class="string">&#x27;TEST1&#x27;</span>,<span class="string">&#x27;YES&#x27;</span>,<span class="string">&#x27;NO&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="IFNULL-v1-v2-函数"><a href="#IFNULL-v1-v2-函数" class="headerlink" title="IFNULL(v1,v2)函数"></a>IFNULL(v1,v2)函数</h3><p>IFNULL(v1,v2)：假如v1不为NULL，则IFNULL()的返回值为v1；否则其返回值为v2。IFNULL()的返回值是数字或者字符串根据实际情况决定</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> IFNULL(<span class="number">1</span>,<span class="number">10</span>),IFNULL(<span class="keyword">NULL</span>,<span class="number">10</span>),IF(<span class="number">1</span><span class="operator">/</span><span class="number">0</span>,<span class="string">&#x27;WRONG&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>IFNULL(1,2)虽然第二个值也不为空，但返回结果依然是第一个值；IFNULL(NULL,10)第一个值为空，因此返回10；“1&#x2F;0”的结果为空，因此IFNULL(1&#x2F;0, ‘wrong’)返回字符串“wrong”。</p>
<h3 id="CASE函数"><a href="#CASE函数" class="headerlink" title="CASE函数"></a>CASE函数</h3><p>CASE expr WHEN v1 THEN r1 [WHEN v2 THEN r2]…[ELSE rn+1] END：如果expr值等于某个vn，则返回对应位置THEN后面的结果；如果与所有值都不相等，则返回ELSE后面的rn+1。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CASE</span> <span class="number">2</span> <span class="keyword">WHEN</span> <span class="number">1</span> <span class="keyword">THEN</span> <span class="string">&#x27;一&#x27;</span> <span class="keyword">WHEN</span> <span class="number">2</span> <span class="keyword">THEN</span> <span class="string">&#x27;二&#x27;</span> <span class="keyword">ELSE</span> <span class="string">&#x27;WRONG&#x27;</span> <span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p>CASE后面的值为2，与第二条分支语句WHEN后面的值相等，因此返回结果为“二”。CASE　WHEN v1 THEN r1 [WHEN v2 THEN r2]… ELSE rn+1] END：某个vn值为TRUE时，返回对应位置THEN后面的结果；如果所有值都不为TRUE，则返回ELSE后的rn+1</p>
<h2 id="系统信息函数"><a href="#系统信息函数" class="headerlink" title="系统信息函数"></a>系统信息函数</h2><h3 id="获取MySQL版本号、连接数和数据库名的函数"><a href="#获取MySQL版本号、连接数和数据库名的函数" class="headerlink" title="获取MySQL版本号、连接数和数据库名的函数"></a>获取MySQL版本号、连接数和数据库名的函数</h3><p>VERSION()返回指示MySQL服务器版本的字符串</p>
<p>CONNECTION_ID()返回MySQL服务器当前连接的次数，每个连接都有各自唯一的ID。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> VERSION(),CONNECTION_ID();</span><br></pre></td></tr></table></figure>

<h3 id="获取用户名的函数"><a href="#获取用户名的函数" class="headerlink" title="获取用户名的函数"></a>获取用户名的函数</h3><p>USER()、CURRENT_USER()、SYSTEM_USER()和SESSION_USER()这几个函数返回当前被MySQL服务器验证的用户名和主机名组合。这个值符合确定当前登录用户存取权限的MySQL账户。一般情况下，这几个函数的返回值是相同的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>(),<span class="built_in">CURRENT_USER</span>(),<span class="built_in">SYSTEM_USER</span>();</span><br></pre></td></tr></table></figure>

<h3 id="获取字符串的字符集"><a href="#获取字符串的字符集" class="headerlink" title="获取字符串的字符集"></a>获取字符串的字符集</h3><p>CHARSET(str)返回字符串str自变量的字符集。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CHARSET(<span class="string">&#x27;ABC&#x27;</span>),CHARSET(VERSION());</span><br></pre></td></tr></table></figure>

<h3 id="获取最后一个自动生成的ID值的函数"><a href="#获取最后一个自动生成的ID值的函数" class="headerlink" title="获取最后一个自动生成的ID值的函数"></a>获取最后一个自动生成的ID值的函数</h3><p>LAST_INSERT_ID()函数返回最后生成的AUTO_INCREMENT值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> STUDENT(</span><br><span class="line">	ID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">  NAME <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> STUDENT (NAME) <span class="keyword">VALUES</span> (<span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> LAST_INSERT_ID();</span><br></pre></td></tr></table></figure>

<p>查看已经插入的数据可以发现，最后一条插入的记录的Id字段值为2，使用LAST_INSERT_ID()查看最后自动生成的Id值：</p>
<h2 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a>加密函数</h2><p>加密函数主要用来对数据进行加密和界面处理，以保证某些重要数据不被别人获取。这些函数在保证数据库安全时非常有用。本节将介绍各种加密函数的作用和使用方法。</p>
<h3 id="加密函数MD5-str"><a href="#加密函数MD5-str" class="headerlink" title="加密函数MD5(str)"></a>加密函数MD5(str)</h3><p>MD5(str)为字符串算出一个MD5 128比特校验和。该值以32位十六进制数字的二进制字符串形式返回，若参数为NULL，则会返回NULL。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> MD5(<span class="string">&#x27;ADMIN&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="加密函数SHA-str"><a href="#加密函数SHA-str" class="headerlink" title="加密函数SHA(str)"></a>加密函数SHA(str)</h3><p>SHA(str)从原明文密码str计算并返回加密后的密码字符串，当参数为NULL时，返回NULL。SHA加密算法比MD5更加安全。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SHA(<span class="string">&#x27;ADMIN&#x27;</span>);</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>Sql代码练习</title>
    <url>/2022/09/09/Sql%E4%BB%A3%E7%A0%81%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h1 id="SQL题一"><a href="#SQL题一" class="headerlink" title="SQL题一"></a>SQL题一</h1><h5 id="表字段"><a href="#表字段" class="headerlink" title="表字段"></a>表字段</h5><ol>
<li><p>学生表<br>Student(SId,Sname,Sage,Ssex)</p>
<p>SId 学生编号,<br>Sname 学生姓名,<br>Sage 出生年月,<br>Ssex 学生性别</p>
</li>
<li><p>课程表<br>Course(CId,Cname,TId)</p>
<p>CId 课程编号,</p>
<p>Cname 课程名称,</p>
</li>
<li><p>教师表<br>Teacher(TId,Tname)</p>
<p>TId 教师编号,<br>Tname 教师姓名</p>
</li>
<li><p>成绩表<br>SC(SId,CId,score)</p>
<p>SId 学生编号,CId 课程编号,<br>score 分数</p>
</li>
</ol>
<h5 id="初始化数据"><a href="#初始化数据" class="headerlink" title="初始化数据"></a>初始化数据</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table Student(SId varchar2(10),Sname varchar2(10),Sage date,Ssex varchar2(10));</span><br><span class="line">insert into Student values(&#x27;01&#x27; , &#x27;赵雷&#x27; , to_date(&#x27;1990-01-01&#x27;,&#x27;YYYY-MM-DD&#x27;) , &#x27;男&#x27;);</span><br><span class="line">insert into Student values(&#x27;02&#x27; , &#x27;钱电&#x27; , to_date(&#x27;1990-12-21&#x27;,&#x27;YYYY-MM-DD&#x27;) , &#x27;男&#x27;);</span><br><span class="line">insert into Student values(&#x27;03&#x27; , &#x27;孙风&#x27; , to_date(&#x27;1990-12-20&#x27;,&#x27;YYYY-MM-DD&#x27;) , &#x27;男&#x27;);</span><br><span class="line">insert into Student values(&#x27;04&#x27; , &#x27;李云&#x27; , to_date(&#x27;1990-12-06&#x27;,&#x27;YYYY-MM-DD&#x27;) , &#x27;男&#x27;);</span><br><span class="line">insert into Student values(&#x27;05&#x27; , &#x27;周梅&#x27; , to_date(&#x27;1991-12-01&#x27;,&#x27;YYYY-MM-DD&#x27;) , &#x27;女&#x27;);</span><br><span class="line">insert into Student values(&#x27;06&#x27; , &#x27;吴兰&#x27; , to_date(&#x27;1992-01-01&#x27;,&#x27;YYYY-MM-DD&#x27;) , &#x27;女&#x27;);</span><br><span class="line">insert into Student values(&#x27;07&#x27; , &#x27;郑竹&#x27; , to_date(&#x27;1989-01-01&#x27;,&#x27;YYYY-MM-DD&#x27;) , &#x27;女&#x27;);</span><br><span class="line">insert into Student values(&#x27;09&#x27; , &#x27;张三&#x27; , to_date(&#x27;2017-12-20&#x27;,&#x27;YYYY-MM-DD&#x27;) , &#x27;女&#x27;);</span><br><span class="line">insert into Student values(&#x27;10&#x27; , &#x27;李四&#x27; , to_date(&#x27;2017-12-25&#x27;,&#x27;YYYY-MM-DD&#x27;) , &#x27;女&#x27;);</span><br><span class="line">insert into Student values(&#x27;11&#x27; , &#x27;李四&#x27; , to_date(&#x27;2012-06-06&#x27;,&#x27;YYYY-MM-DD&#x27;) , &#x27;女&#x27;);</span><br><span class="line">insert into Student values(&#x27;12&#x27; , &#x27;赵六&#x27; , to_date(&#x27;2013-06-13&#x27;,&#x27;YYYY-MM-DD&#x27;) , &#x27;女&#x27;);</span><br><span class="line">insert into Student values(&#x27;13&#x27; , &#x27;孙七&#x27; , to_date(&#x27;2014-06-01&#x27;,&#x27;YYYY-MM-DD&#x27;) , &#x27;女&#x27;);</span><br><span class="line"></span><br><span class="line">create table Course(CId varchar2(10),Cname varchar2(10),TId varchar2(10));</span><br><span class="line">insert into Course values(&#x27;01&#x27; , &#x27;语文&#x27; , &#x27;02&#x27;);</span><br><span class="line">insert into Course values(&#x27;02&#x27; , &#x27;数学&#x27; , &#x27;01&#x27;);</span><br><span class="line">insert into Course values(&#x27;03&#x27; , &#x27;英语&#x27; , &#x27;03&#x27;);</span><br><span class="line"></span><br><span class="line">create table Teacher(TId varchar2(10),Tname varchar2(10));</span><br><span class="line">insert into Teacher values(&#x27;01&#x27; , &#x27;张三&#x27;);</span><br><span class="line">insert into Teacher values(&#x27;02&#x27; , &#x27;李四&#x27;);</span><br><span class="line">insert into Teacher values(&#x27;03&#x27; , &#x27;王五&#x27;);</span><br><span class="line"></span><br><span class="line">create table SC(SId varchar2(10),CId varchar2(10),score NUMBER(18,1));</span><br><span class="line">insert into SC values(&#x27;01&#x27; , &#x27;01&#x27; , 80);</span><br><span class="line">insert into SC values(&#x27;01&#x27; , &#x27;02&#x27; , 90);</span><br><span class="line">insert into SC values(&#x27;01&#x27; , &#x27;03&#x27; , 99);</span><br><span class="line">insert into SC values(&#x27;02&#x27; , &#x27;01&#x27; , 70);</span><br><span class="line">insert into SC values(&#x27;02&#x27; , &#x27;02&#x27; , 60);</span><br><span class="line">insert into SC values(&#x27;02&#x27; , &#x27;03&#x27; , 80);</span><br><span class="line">insert into SC values(&#x27;03&#x27; , &#x27;01&#x27; , 80);</span><br><span class="line">insert into SC values(&#x27;03&#x27; , &#x27;02&#x27; , 80);</span><br><span class="line">insert into SC values(&#x27;03&#x27; , &#x27;03&#x27; , 80);</span><br><span class="line">insert into SC values(&#x27;04&#x27; , &#x27;01&#x27; , 50);</span><br><span class="line">insert into SC values(&#x27;04&#x27; , &#x27;02&#x27; , 30);</span><br><span class="line">insert into SC values(&#x27;04&#x27; , &#x27;03&#x27; , 20);</span><br><span class="line">insert into SC values(&#x27;05&#x27; , &#x27;01&#x27; , 76);</span><br><span class="line">insert into SC values(&#x27;05&#x27; , &#x27;02&#x27; , 87);</span><br><span class="line">insert into SC values(&#x27;06&#x27; , &#x27;01&#x27; , 31);</span><br><span class="line">insert into SC values(&#x27;06&#x27; , &#x27;03&#x27; , 34);</span><br><span class="line">insert into SC values(&#x27;07&#x27; , &#x27;02&#x27; , 89);</span><br><span class="line">insert into SC values(&#x27;07&#x27; , &#x27;03&#x27; , 98);</span><br></pre></td></tr></table></figure>

<h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--1查询&quot; 01 &quot;课程比&quot; 02 &quot;课程成绩高的学生的信息及课程分数</span><br><span class="line">--2.查询同时存在&quot; 01 &quot;课程和&quot; 02 &quot;课程的情况</span><br><span class="line">--3.查询存在&quot; 01 &quot;课程但可能不存在&quot; 02 &quot;课程的情况(不存在时显示为 </span><br><span class="line">--4.查询不存在&quot; 01 &quot;课程但存在&quot; 02 &quot;课程的情况(考了02但是没考01)</span><br><span class="line">--5.查询平均成绩大于等于 60 分的同学的学生编号和学生姓名和平均成绩</span><br><span class="line">--6.查询在 SC 表存在成绩的学生信息</span><br><span class="line">--7.查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩(没成绩的显示为 null )</span><br><span class="line">--8.查有成绩的学生信息</span><br><span class="line">--9.查询「李」姓老师的数量</span><br><span class="line">--10.查询学过「张三」老师授课的同学的信息</span><br><span class="line">	--1.TEACHER表中查询出张三老师的TID    </span><br><span class="line">	--2.COURSE表中根据1中的TID查询出张老师的CID</span><br><span class="line">	--3.SC表中查询出有CID = 2的同学SID</span><br><span class="line">	--4.STUDENT表中查询学生信息</span><br><span class="line">--11.查询没有学全所有课程的同学的信息</span><br><span class="line">	--1.获取所有的课程数量</span><br><span class="line">	--2.根据SID分组，并统计每个学生学习的课程数</span><br><span class="line">	--3.分组后筛选，课程数小于总课程数的同学</span><br><span class="line">--12.查询至少有一门课与学号为&quot; 01 &quot;的同学所学相同的同学的信息</span><br><span class="line">	--1.先查询出01同学学了的课</span><br><span class="line">	--2.找出和01同学学相同课的同学</span><br><span class="line">--13.查询和&quot; 01 &quot;号的同学学习的课程完全相同的其他同学的信息</span><br><span class="line">    --1.查询01同学的所有的课程</span><br><span class="line">    --2.查询课程和01同学所有课程都一样的同学SID</span><br><span class="line">    --3.查询学生信息</span><br><span class="line">--13.查询和&quot; 05 &quot;号的同学学习的课程完全相同的其他同学的信息</span><br><span class="line">    --1查学生5的所学科目</span><br><span class="line">    --2查找和5所学科目不相等的SID</span><br><span class="line">    --3在2的基础上not in排除和5不是相同科目的学生</span><br><span class="line">--14.查询没学过&quot;张三&quot;老师讲授的任一门课程的学生姓名</span><br><span class="line">--15.查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩</span><br><span class="line">--15.查询出同学所有成绩的平均值，然后筛选出有两门及以上不及格</span><br><span class="line">--16.检索&quot; 01 &quot;课程分数小于 60，按分数降序排列的学生信息</span><br><span class="line">--17.按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩</span><br><span class="line">--18.查询各科成绩最高分、最低分和平均分</span><br><span class="line">--如下形式显示：课程 ID，课程 name，最高分，最低分，平均分，及格率，中等率，优良率</span><br><span class="line">--优秀率及格为&gt;=60，</span><br><span class="line">--中等为：70-80，</span><br><span class="line">--优良为：80-90，</span><br><span class="line">--优秀为：&gt;=90</span><br><span class="line">--要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列</span><br><span class="line"></span><br><span class="line">--及格率</span><br><span class="line"></span><br><span class="line">--中等率</span><br><span class="line"></span><br><span class="line">--优良率</span><br><span class="line"></span><br><span class="line">--优秀率</span><br><span class="line"></span><br><span class="line">--19.按各科成绩进行排序，并显示排名， Score 重复时保留名次空缺</span><br><span class="line">--语文成绩排序</span><br><span class="line"></span><br><span class="line">--数学</span><br><span class="line"></span><br><span class="line">--英语</span><br><span class="line"> </span><br><span class="line">--20.按各科成绩进行排序，并显示排名， Score 重复时合并名次</span><br><span class="line">--21.查询学生的总成绩，并进行排名，总分重复时保留名次空缺</span><br><span class="line">--22.查询学生的总成绩，并进行排名，总分重复时不保留名次空缺</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--缓冲区</span><br><span class="line">SELECT MAX(SCORE),MIN(SCORE),AVG(SCORE) FROM SC GROUP BY CID;</span><br></pre></td></tr></table></figure>

<ol>
<li>统计各科成绩各分数段人数：课程编号，课程名称，[100-85]，[85-70]，[70-60]，[60-0] 及所占百分比<ol>
<li>查询各科成绩前三名的记录<br>.	查询每门课程被选修的学生数<br>.	查询出只选修两门课程的学生学号和姓名<br>.	查询男生、女生人数<br>.	查询名字中含有「风」字的学生信息<br>.	查询同名同性学生名单，并统计同名人数<br>.	查询 1990 年出生的学生名单<br>.	查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列<br>.	查询平均成绩大于等于 85 的所有学生的学号、姓名和平均成绩<br>.	查询课程名称为「数学」，且分数低于 60 的学生姓名和分数<br>.	查询所有学生的课程及分数情况（存在学生没成绩，没选课的情况）<br>.	查询任何一门课程成绩在 70 分以上的姓名、课程名称和分数<br>.	查询不及格的课程<br>.	查询课程编号为 01 且课程成绩在 80 分以上的学生的学号和姓名<br>.	求每门课程的学生人数<br>.	成绩不重复，查询选修「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩<br>.	成绩有重复的情况下，查询选修「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩<br>.	查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩<br>.	查询每门功成绩最好的前两名<br>.	统计每门课程的学生选修人数（超过 5 人的课程才统计）。<br>.	检索至少选修两门课程的学生学号<br>.	查询选修了全部课程的学生信息<br>.	查询各学生的年龄，只按年份来算<br>.	按照出生日期来算，当前月日 &lt; 出生年月的月日则，年龄减一<br>.	查询本周过生日的学生<br>.	查询下周过生日的学生<br>.	查询本月过生日的学生<br>.	查询下月过生日的学生</li>
</ol>
</li>
</ol>
<h1 id="SQL题二"><a href="#SQL题二" class="headerlink" title="SQL题二"></a>SQL题二</h1><h5 id="初始化数据-1"><a href="#初始化数据-1" class="headerlink" title="初始化数据"></a>初始化数据</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--班级表</span><br><span class="line">--classid 班级id</span><br><span class="line">--classname 班级名称</span><br><span class="line">create table class          </span><br><span class="line">(</span><br><span class="line">	classid number(5),</span><br><span class="line">	classname varchar2(20)</span><br><span class="line">)</span><br><span class="line">insert into class values(1,&#x27;G1T01&#x27;);</span><br><span class="line">insert into class values(2,&#x27;G1T02&#x27;);</span><br><span class="line">insert into class values(3,&#x27;G1T03&#x27;);</span><br><span class="line">insert into class values(4,&#x27;G1T04&#x27;);</span><br><span class="line">insert into class values(5,&#x27;G1T05&#x27;);</span><br><span class="line">insert into class values(6,&#x27;G1T06&#x27;);</span><br><span class="line">insert into class values(7,&#x27;G1T07&#x27;);</span><br><span class="line">--学生表</span><br><span class="line">--studentid 学生ID</span><br><span class="line">--studentname 学生姓名</span><br><span class="line">--studentage 学生年龄</span><br><span class="line">--studentsex 学生性别</span><br><span class="line">--studentaddress 学生地址</span><br><span class="line">--classid 学生id</span><br><span class="line">create table student</span><br><span class="line">(</span><br><span class="line">	studentid varchar2(20) ,</span><br><span class="line">	studentname varchar2(20),</span><br><span class="line">	studentage number(5),</span><br><span class="line">	studentsex char(10),</span><br><span class="line">	studentaddress varchar2(50),</span><br><span class="line">	classid number(5)</span><br><span class="line">)</span><br><span class="line">insert into student values(&#x27;2010001&#x27;,&#x27;Jack&#x27;,21,&#x27;男&#x27;,&#x27;湖北襄樊&#x27;,1);  </span><br><span class="line">insert into student values(&#x27;2010002&#x27;,&#x27;Scott&#x27;,22,&#x27;男&#x27;,&#x27;湖北武汉&#x27;,2);  </span><br><span class="line">insert into student values(&#x27;2010003&#x27;,&#x27;Lucy&#x27;,23,&#x27;女&#x27;,&#x27;湖北武汉&#x27;,3);   </span><br><span class="line">insert into student values(&#x27;2010004&#x27;,&#x27;Alan&#x27;,19,&#x27;女&#x27;,&#x27;湖北襄樊&#x27;,4);   </span><br><span class="line">insert into student values(&#x27;2010005&#x27;,&#x27;Bill&#x27;,20,&#x27;男&#x27;,&#x27;湖北襄樊&#x27;,5);   </span><br><span class="line">insert into student values(&#x27;2010006&#x27;,&#x27;Bob&#x27;,21,&#x27;男&#x27;,&#x27;湖北宜昌&#x27;,6);    </span><br><span class="line">insert into student values(&#x27;2010007&#x27;,&#x27;Colin&#x27;,22,&#x27;女&#x27;,&#x27;湖北襄樊&#x27;,6);</span><br><span class="line">insert into student values(&#x27;2010008&#x27;,&#x27;Fred&#x27;,19,&#x27;男&#x27;,&#x27;湖北宜昌&#x27;,5);</span><br><span class="line">insert into student values(&#x27;2010009&#x27;,&#x27;Hunk&#x27;,19,&#x27;男&#x27;,&#x27;湖北武汉&#x27;,4);</span><br><span class="line">insert into student values(&#x27;2010010&#x27;,&#x27;Jim&#x27;,18,&#x27;男&#x27;,&#x27;湖北襄樊&#x27;,3);</span><br><span class="line">--计算机课成绩</span><br><span class="line">--studentid 学生id</span><br><span class="line">--score 学生成绩</span><br><span class="line">create table computer</span><br><span class="line">(</span><br><span class="line">	studentid varchar2(20),</span><br><span class="line">	score number(3,1)</span><br><span class="line">)</span><br><span class="line">insert into computer values(&#x27;2010001&#x27;,90);</span><br><span class="line">insert into computer values(&#x27;2010002&#x27;,80);</span><br><span class="line">insert into computer values(&#x27;2010003&#x27;,70);</span><br><span class="line">insert into computer values(&#x27;2010004&#x27;,60);</span><br><span class="line">insert into computer values(&#x27;2010005&#x27;,75);</span><br><span class="line">insert into computer values(&#x27;2010006&#x27;,85);</span><br><span class="line">insert into computer values(&#x27;2010007&#x27;,70);</span><br><span class="line">insert into computer values(&#x27;2010008&#x27;,60);</span><br><span class="line">insert into computer values(&#x27;2010009&#x27;,75);</span><br><span class="line">insert into computer values(&#x27;2010010&#x27;,85);</span><br><span class="line"></span><br><span class="line">select * from class;</span><br><span class="line">select * from computer;</span><br><span class="line">select * from student;</span><br></pre></td></tr></table></figure>

<p>题目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--1查询出学生的编号，姓名，计算机成绩</span><br><span class="line"></span><br><span class="line">--2查询参加过考试的学生信息</span><br><span class="line"></span><br><span class="line">--3查询出学生的编号、姓名、所在班级名称、计算机成绩</span><br><span class="line"></span><br><span class="line">--4查询出年龄大于19岁的学生编号、姓名、计算机成绩</span><br><span class="line"></span><br><span class="line">--5查询出姓名中包含有c的学生编号、姓名、计算机成绩</span><br><span class="line"></span><br><span class="line">--6查询出计算机成绩大于80分的学生编号、姓名、班级名称</span><br><span class="line"></span><br><span class="line">--7查询出所有学生的信息和计算机成绩信息</span><br><span class="line"></span><br><span class="line">--8查询出每个班的学生的计算机成绩的平均分，最高分，最低分</span><br><span class="line"></span><br><span class="line">--9查询显示出班级的计算机平均分大于80的班级名称、平均分信息，并按照平均分降序显示</span><br><span class="line"></span><br><span class="line">--10查询出和Jim住在同一个地方的学生的基本信息</span><br><span class="line"></span><br><span class="line">--11查询出班级编号大于3的学生基本信息</span><br><span class="line"></span><br><span class="line">--12查询出班级编号大于3的学生的计算机平均分信息  </span><br><span class="line"></span><br><span class="line">--13查询出班级编号大于3的男生的学生信息</span><br><span class="line"></span><br><span class="line">--14查询男、女生的计算机平均成绩、最高分、最低分</span><br><span class="line"></span><br><span class="line">--15将参加过考试的学生的年龄更改为20</span><br><span class="line"></span><br><span class="line">--16查询出每个班级的学生的平均分（查询的结果中包含平均分和班级名称）</span><br><span class="line"></span><br><span class="line">--17删除姓名包含“c”字符的学生计算机成绩</span><br><span class="line"></span><br><span class="line">--18查询出G1T07班学生的编号、姓名、班级名称、计算机成绩</span><br><span class="line"></span><br><span class="line">--19查询出年龄在20-25之间的学生的编号、姓名、年龄、计算机成绩</span><br><span class="line"></span><br><span class="line">--20查询出成绩最高的学生的编号、姓名、计算机成绩、所在班级名称</span><br><span class="line">--先查询最大值</span><br><span class="line">--再查询最大值的学生ID</span><br><span class="line"></span><br><span class="line">--21查询统计出每个班的平均分、显示平均分超过70分的信息、并按照降序显示信息</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
