<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.2.0">

<link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/manifest.json">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic%7CLobster+Two:300,300italic,400,400italic,700,700italic%7CAmita:300,300italic,400,400italic,700,700italic%7CMontserrat:300,300italic,400,400italic,700,700italic%7CPT+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"airui520.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":"true`","version":"8.12.1","exturl":false,"sidebar":{"position":"left","width":300,"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="blog">
<meta property="og:title" content="Java面向对象(基础)">
<meta property="og:url" content="https://airui520.github.io/2022/07/20/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E5%9F%BA%E7%A1%80)/index.html">
<meta property="og:site_name" content="Fei的博客">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://files.catbox.moe/vakrmb.png">
<meta property="og:image" content="https://files.catbox.moe/1biox2.png">
<meta property="og:image" content="https://files.catbox.moe/3eo9gj.png">
<meta property="og:image" content="https://files.catbox.moe/lbzdgw.png">
<meta property="og:image" content="https://files.catbox.moe/rsluwt.png">
<meta property="og:image" content="https://files.catbox.moe/52mn1j.png">
<meta property="article:published_time" content="2022-07-20T10:38:37.000Z">
<meta property="article:modified_time" content="2022-07-23T00:14:28.348Z">
<meta property="article:author" content="Fei">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://files.catbox.moe/vakrmb.png">


<link rel="canonical" href="https://airui520.github.io/2022/07/20/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E5%9F%BA%E7%A1%80)/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://airui520.github.io/2022/07/20/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E5%9F%BA%E7%A1%80)/","path":"2022/07/20/Java面向对象(基础)/","title":"Java面向对象(基础)"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java面向对象(基础) | Fei的博客</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-XXXXXXXX-X"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-XXXXXXXX-X","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Fei的博客</p>
      <i class="logo-line"></i>
    </a>
      <img class="custom-logo-image" src="/images/bg.jpg" alt="Fei的博客">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">59</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">面向对象（基础篇）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.1.</span> <span class="nav-text">类和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E7%B1%BB"><span class="nav-number">1.1.1.</span> <span class="nav-text">定义类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%92%8C%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.2.</span> <span class="nav-text">创建对象和使用对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.</span> <span class="nav-text">基本类型和引用类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.4.</span> <span class="nav-text">this关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.5.</span> <span class="nav-text">方法详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E5%92%8C%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="nav-number">1.5.1.</span> <span class="nav-text">实例方法和类方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="nav-number">1.5.2.</span> <span class="nav-text">方法的参数传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="nav-number">1.5.3.</span> <span class="nav-text">可变参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="nav-number">1.5.4.</span> <span class="nav-text">方法重载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-number">1.6.</span> <span class="nav-text">成员变量和局部变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.6.1.</span> <span class="nav-text">成员变量和局部变量是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="nav-number">1.6.2.</span> <span class="nav-text">成员变量初始化机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="nav-number">1.6.3.</span> <span class="nav-text">局部变量的初始化机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.7.</span> <span class="nav-text">static关键字</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Fei"
      src="/images/head.jpg">
  <p class="site-author-name" itemprop="name">Fei</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">59</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/AiRui520" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AiRui520" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2813764348@qq.com" title="E-Mail → mailto:2813764348@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://xiguayaaaaa.github.io/" title="https:&#x2F;&#x2F;xiguayaaaaa.github.io" rel="noopener" target="_blank">xigua</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://simon-yian.com/" title="https:&#x2F;&#x2F;simon-yian.com" rel="noopener" target="_blank">banana</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/AiRui520" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://airui520.github.io/2022/07/20/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E5%9F%BA%E7%A1%80)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="Fei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fei的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java面向对象(基础) | Fei的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java面向对象(基础)<a href="https://github.com/AiRui520/next/edit/main/subdirectory-name/_posts/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E5%9F%BA%E7%A1%80).md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pen-nib"></i></a>
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-20 18:38:37" itemprop="dateCreated datePublished" datetime="2022-07-20T18:38:37+08:00">2022-07-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-23 08:14:28" itemprop="dateModified" datetime="2022-07-23T08:14:28+08:00">2022-07-23</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h1 id="面向对象（基础篇）"><a href="#面向对象（基础篇）" class="headerlink" title="面向对象（基础篇）"></a>面向对象（基础篇）</h1><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>类：可以被理解为一种自定义的数据类型，可以使用类定义变量，所有使用类定义的变量都是引用类型。类是一系列具有相同行为和属性的对象的集合，用于描述客观世界中一类对象的共同特征。</p>
<p>对象：是具体的，是类的实例，类是对象的模板，对象是类的实例</p>
<h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><p>面向对象的程序设计中有两个重要的概念：类（class）和对象（Object，也叫做实例）。其中类是对一批对象的抽象，可以把类理解成某个群体，对象则是具体的存在。</p>
<p><strong>Java中定义类的简单语法如下：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] class 类名&#123;</span><br><span class="line"> 	<span class="number">0</span>个或者多个构造器</span><br><span class="line">    <span class="number">0</span>个或者多个成员变量</span><br><span class="line">    <span class="number">0</span>个或者多个方法</span><br><span class="line">    <span class="comment">//另外，类中还可以包含内部类，内部枚举等等    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于一个类来说，最常见的可以包含：构造器、成员变量和方法，并且这个组成部分都可以包含0个或者多个。一般来说这3个组成部分至少会包含1个组成部分，如果3部分都不包含实际上定义了一个空类，这样做没有任何意义。</p>
<p><strong>定义成员变量语法如下：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 数据类型 成员变量 [=默认值]</span><br></pre></td></tr></table></figure>

<p><strong>修饰符：</strong>修饰符可以省略，也可以是public、protected、private、static、.final、transient,其中public、protected、private.只能选一个，可以与final、static组合来修饰成员变量<br><strong>类型：</strong>类型可以是Java允许的任意类型，可以是基本类型、也可以是引用类型<br><strong>成员变量名：</strong>成员变量名只要是一个合法的标识符即可，成员变量的命名一般使用camel命名法，第一个单词首字母小写，其余单词的首字母均大写，单词间不用任何分隔符，并且要做到见名知意，尽量避免用单个字母命名<br><strong>默认值：</strong>成员变量可以指定默认值，也可以不指定，当不指定时在创建对象时，Java会提供默认值，其中整型默认值为0，浮点型默认值为0.0,布尔型默认值为false,字符型默认值为’\u0000’。</p>
<p><strong>定义成员方法语法如下：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 方法返回值类型 方法名(形参列表)&#123;</span><br><span class="line"> 	<span class="comment">//方法体   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法返回值类型：</strong>返回值类型可以是v允许的任意数据类型、包括基本类型和引用类型；如果声明了返回值类型、则方法体中必须有一个有效的return语句，该语句返回一个变量或者表达式，这个变量或表达式的类型必须与声明的类型匹配，此外，如果一个方法没有返回值，则返回值类型用void代替，表明该方法没有返回值。<br><strong>方法名：</strong>方法名的命名规则同成员变量的命名规则基本一致。<br><strong>形参列表：</strong>形参用于定义该方法可以接受的参数，形参列表可以由0个或者多个参数组成，参数之间用逗号隔开。一旦方法定义时定义了形参列表，则调用该方法时必须传入对应类型的参数值。即谁调用，谁传参。</p>
<p><strong>构造体(构造方法)的定义</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 方法名(形参列表)&#123;</span><br><span class="line"> 	方法体   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造器则是一种特殊的方法，其作用是用于创建对象，Java语言通过new关键字来调用构造方法，从而返回该类的实例。构造器是一个类创建对象的基本方法，如果一个类没有构造器，这个类也就无法创建实例了。因此Java语言提供了一个功能：<strong>如果开发者没有为类编写构造器，编译器会为该类提供一个默认无参数的构造器，一旦开发者提供了构造器，则编译器不在提供构造器。</strong></p>
<p><strong>需要注意的是构造器是一种特殊的方法，其方法名和类名相同，但没有方法返回值，也不用void修饰。</strong></p>
<p><strong>修饰符：</strong>修饰符可以省略，也可以是public、protected、private其中之一，如果构造器的修饰符为private,则不能通过new调用，也就是说当一个类的构造器被private修饰，该类则不能通过new来创建对象<br><strong>方法名：</strong>必须与类名相同<br><strong>形参列表：</strong>和方法中的形参格式完全相同</p>
<p><strong>陷阱:给定一个方法名称和类名相同，但是有返回值或者使用了void修饰，要求你判断是否是构造方法。有void的方法就不是构造方法！！！</strong></p>
<h2 id="创建对象和使用对象"><a href="#创建对象和使用对象" class="headerlink" title="创建对象和使用对象"></a>创建对象和使用对象</h2><p>创建对象最根本的途径是调用构造器，Java中通过new关键字来调用构造器创建对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个Student类型的对象，也可以说是定义了一个Student类型的变量</span></span><br><span class="line">Student s;</span><br><span class="line"><span class="comment">//通过new关键字调用构造方法，返回Student对象</span></span><br><span class="line"><span class="comment">//将返回的对象赋值给变量s</span></span><br><span class="line">s = <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="comment">//简写为</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br></pre></td></tr></table></figure>

<p>创建好对象后，可以对对象进行如下操作：</p>
<p>1、访问对象的实例变量</p>
<p>2、调用对象的方法</p>
<h2 id="基本类型和引用类型"><a href="#基本类型和引用类型" class="headerlink" title="基本类型和引用类型"></a>基本类型和引用类型</h2><p>基本类型：int i &#x3D; 10; 执行该代码时，其在内存中的结构如下图所示：</p>
<p><img src="https://files.catbox.moe/1biox2.png"></p>
<p>引用类型：Student s &#x3D; new Student(); 执行该代码时，其在内存的示意图如下所示：</p>
<p><img src="https://files.catbox.moe/3eo9gj.png"></p>
<p>从上图中我们可以看出，Studenty对象包含两个实例变量，而变量是需要内存来存储的，当创建Student对象时，必然要有对应的内存来存储对象的实例变量，Student对象由多块内存组成，不同的内存分别存储着Student对象的不同成员变量，当把Student对象赋值给一个引用变量时，<br>Java会将对象的地址保存在变量中，也就是保存在栈中，也就是说<strong>变量中仅仅保存的是一个引用或者说地址，而不是真实的对象</strong>，由该变量中的引用指向该对象。对象的成员变量数据实际存放在堆中，<br>当访问对象的成员变量和方法时，实际上访问的是变量所指向的对象的成员变量和方法。<br>综上所述，可以简单的理解为基本类型在栈中保存的是变量真实的值，而引用类型保存的并不是对象而是一个地址或者说引用，这就是基本类型和引用类型的根本区别，这也就是说我们通常判断基本类型相等时，用双等号即可，而判断引用类型则不能用双等号。</p>
<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>Java提供了一个this关键字，this关建字可以指代当前对象，根据this出现的位置不同，this作为当前对象的默认引用有两种使用方式<br>1.构造器中使用this可以调用其他构造器<br>2.方法中使用this可以方问其他方法或者实例变量，通常this可以省咯。<br>this关键字最大的作用就是让类中一个方法，访问该类里的另一个方法或实例变量<br>this关键字最大的作用就是上类中的方法访问类中的另一个方法或者实例变量，假设定义了一个Animal类，这个Animal对象的run()方法需要调用它的jump方法，就可以使用this关键字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">	String name;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">//在run方法中调用jump</span></span><br><span class="line">		<span class="built_in">this</span>.jump();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jump</span><span class="params">()</span> &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>在Java中一个成员直接调用另一个成员时，this可以省略。也就是说上述的代码可以修改为如下形式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">//在run方法中调用jump</span></span><br><span class="line">		jump();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jump</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>这是Java中规定，当在构造方法中调用其它构造方法时，不需要些构造方法的名字，因为所有构造方法的名称都是一样的，唯一不同的就是参数列表，JVM会通过this后传入的参数列表来确定究竟调用哪一个构造方法.<strong>需要注意的是，this调用构造方法只能在构造方法中使用，不能写在实例方法中，并且要放在构造方法中代码的第一行。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">	<span class="comment">//实例变量</span></span><br><span class="line">	String name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="comment">//提供无参的构造方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>(<span class="string">&quot;猫咪&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//提供有参的构造方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>(<span class="string">&quot;猫咪&quot;</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：this不能出现在类方法中，因为类方法在类加载后，创建对象前就已经准备完毕，此时还没有对象，也就不存在this</strong></p>
<h2 id="方法详解"><a href="#方法详解" class="headerlink" title="方法详解"></a>方法详解</h2><p>方法是类或对象的行为特征的抽象，方法是类或对象最重要的组成部分。但从功能上来看，方法完全类似于传统结构化程序设计里的函数。值得指出的是，Java 里的方法不能独立存在，所有的方法都必须定义在类里。方法在逻辑上要么属于类，要么属于对象。</p>
<h3 id="实例方法和类方法"><a href="#实例方法和类方法" class="headerlink" title="实例方法和类方法"></a>实例方法和类方法</h3><p>·被static修饰的方法叫做类方法，方法属于类，调用时不依赖于对象，通过类名.方法名即可调用。<br>·不被static修饰的方法叫做实例方法，方法属于对象，调用时依赖对象，必须先创建对象才能调用，因此其调用方式是对象名.方法名</p>
<p>**这里可能产生一个问题;同一个类里不同方法之间相互调用时，不就可以直接调用吗?**这里需要指出; 同一个类的一个方法调用另外一个方法时，如果被调方法是普通方法，则默认使用 this 作为调用者;如果被调方法是静态方法，则默认使用类作为调用者。也就是说，表面上看起来某些方法可以被独立执行，但实际上还是使用 this 或者类来作为调用者。</p>
<p>·永远不要把方法当成独立存在的实体，正如现实世界由类和对象组成，而方法只能作为类和对象的附属，Java语言里的方法也是一样。Java语言里方法的所属性主要体现在如下几个方面。方法不独立定义，方法只能在类体里定义。<br>·从逻辑意义上来看，方法要么属于该类本身，要么属于该类的一个对象。<br>·永远不能独立执行方法，执行方法必须使用类或对象作为调用者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="comment">//定义一个类方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">makeMoney</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//定义一个实例方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法的参数传递"><a href="#方法的参数传递" class="headerlink" title="方法的参数传递"></a>方法的参数传递</h3><p>前面已经介绍了Java里的方法是不能独立存在的，调用方法也必须使用类或对象作为主调者。如果声明方法时包含了形参声明，则调用方法时必须给这些形参指定参数值，调用方法时实际传给形参的参数值也被称为实参。那么，Java的实参值是如何传入方法的呢？这是由java方法的参数传递机制来控制的，Java方法的参数传递方式只有一种值传递。所谓值传递，就是将实际参数值的副本（复制品）传入方法内，而参数本身不会受到任何影响。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwapDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">		swap(a, b);</span><br><span class="line">		System.out.println(<span class="string">&quot;main=====a:&quot;</span>+a);<span class="comment">//5</span></span><br><span class="line">		System.out.println(<span class="string">&quot;main=====b:&quot;</span>+b);<span class="comment">//3</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 定义方法交换两个变量</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> b</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">		a = a^b;</span><br><span class="line">		b = a^b;</span><br><span class="line">		a = a^b;</span><br><span class="line">		System.out.println(<span class="string">&quot;swap=====a:&quot;</span>+a);<span class="comment">//3</span></span><br><span class="line">		System.out.println(<span class="string">&quot;swap=====b:&quot;</span>+b);<span class="comment">//5</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>从结果可以看出在swap方法中交换了变量a和变量b的值，但是在main方法中变量a和变量b的值并没有发生变化，这是因为在方法传递参数时传递的是实参的副本，也就是说在main方法中调用swap方法传递参数时，会将变量保存在钱内存中的真实值复制一份传递给swap方法，这样并不影响原来变量的值。</p>
<p><strong>以上情况是基本类型的，那么引用类型的又是怎样的呢，现在我们定义一个Teacher类，类中只包含一个int类型的age变量。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Teacher</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">		t1.age = <span class="number">18</span>;</span><br><span class="line">		change(t1);</span><br><span class="line">		System.out.println(<span class="string">&quot;main=====t:&quot;</span>+t1.age);<span class="comment">//20</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(Teacher t2)</span> &#123;</span><br><span class="line">		t2.age = <span class="number">20</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;change=====t:&quot;</span>+t2.age);<span class="comment">//20</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当代码执行到12行时，此时调用了change()方法，并传入了t1对象，此时并不是将对象直接传递，传递的是t1中保存的引用或地址。</p>
<p><img src="https://files.catbox.moe/lbzdgw.png"></p>
<p>在change方法中修改了对象的年龄，也就是说在change方法中修改的也是t1指向的对象，所以当在main方法中打印对象的年龄时，t1的年龄也变成了20。所以在Java中不存在引用传递，<strong>所谓的引用传递本质上都是值传递</strong></p>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>JDK 1.5 以后Java允许定义形参个数可变的参数，从而允许为方法指定数量不确定的参数，如果在定义方法时，最后一个参数的类型后添加三点，则表明该形参可以接收多个参数指，多个参数值被当做数组传入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Varargs</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//可变参数可以单独传递</span></span><br><span class="line">		test(<span class="number">100</span>, <span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">		String[] strs = &#123;<span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;赵敏&quot;</span>,<span class="string">&quot;张三丰&quot;</span>&#125;;</span><br><span class="line">		<span class="comment">//可变参数可以传入数组</span></span><br><span class="line">		test(<span class="number">200</span>, strs);</span><br><span class="line">		<span class="comment">//也可以不传递</span></span><br><span class="line">		test(<span class="number">300</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a,String...names)</span> &#123;</span><br><span class="line">		System.out.println(a);</span><br><span class="line">		<span class="keyword">if</span>(names!=<span class="literal">null</span>&amp;&amp;names.length&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">				System.out.println(name);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>null和空的区别，int[] a;不初始化数组，则它为null；int[] a &#x3D; {};初始化数组,但不为它赋值，则为空。</p>
<p>例如有一张白纸，上面不写东西则为空；没有白纸，则为null</p>
<p>从上面的示例可以看出，当一个方法中有可变参数时，参数可以分开传递，也可以放入数组，然后将数组传递给可变参数，也可以不传递，因此，我们在使用可变参数时，首先要判断可变参数是否为null，其次因为可变参数的本质是数组，因此还需要判断数组中是否存在元素。<br>注意的是：可<strong>变参数只能处于参数列表的最后一个参数，一个方法中只能包含一个可变参数，可变参数的本质就是一个数组。</strong></p>
<h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>在Java中允许同一个类中定义多个同名的方法，但是要保证参数列表不同，也就是说同一个类中包含了两个或者两个以上方法名相同，但是参数列表不同，则被称为方法重载。这里需要注意的是方法重载与访问修饰符无关、方法返回值无关、方法抛出异常无关，只与方法的参数列表有关。<br>那么什么叫做参数列表不同呢，参数列表不同需要注意以下几点：<br>1.个数不同<br>2.数据类型不同<br>例如下面的两个方法就不构成方法重载，因为两个方法方法名相同，但是参数数据类型相同，都是一个double类型和一个int类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalcArea</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">area</span><span class="params">(<span class="type">int</span> width,<span class="type">double</span> height)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> width*height;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">area</span><span class="params">(<span class="type">double</span> width)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="type">int</span>)width*height;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，当我们调用方法时，如果区分究竟调用的是哪个方法呢，如果你还记得我们使用this调用构造方法时，这个问题就会迎刃而解，当我们调用重载的方法时，也是通过传入的参数由JVM决定调用哪个方法。这个过程叫做<strong>重载解析</strong>。</p>
<h2 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h2><p>在 Java 语言中，根据定义变量位置的不同，可以将变量分成两大类; 成员变量和局部变量。成员变量和局部变量的运行机制存在较大差异</p>
<h3 id="成员变量和局部变量是什么"><a href="#成员变量和局部变量是什么" class="headerlink" title="成员变量和局部变量是什么"></a>成员变量和局部变量是什么</h3><p>成员变量指的是在类里定义的变量，也就是前面所介绍的filed;局部变量指的是在方法里定义的变量。</p>
<p><img src="https://files.catbox.moe/rsluwt.png"></p>
<p>成员变量被分为类变量和实例变量两种，定义成员变量设有static修饰的就是实例变量，有static修饰的就是类变量。其中类变量从该类的准备阶段起开始存在，直到系统完全销毁这个类，类变量的作用域与这个类的生存范围相同：而实例变量则从该类的实例被创建起开始存在，直到系统完全销毁这个实例，实例变量的作用域与对应实例的生存范围相同。</p>
<p><strong>一个类在使用之前要经过类加载、类验证、类准备、类解析、类初始化等几个阶段。</strong></p>
<p>正是基于这个原因，可以把类变量和实例变量统称为成员变量，其中类变量可以里解为类成员变量，它作为类本身的一个成员，与类本身共存亡实例变量侧可理解为实例成员变量，它作为实例的一个成员，与实例共存亡。只要类存在，程序就可以访问该类的类变量。在程序中访问类<br><strong>变量通过如下语法：类.类变量、实例.实例变量、实例.类变量</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//创建两个对象</span></span><br><span class="line">		<span class="type">School</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">School</span>();</span><br><span class="line">		<span class="type">School</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">School</span>();</span><br><span class="line">		<span class="comment">//修改s1对象的number</span></span><br><span class="line">		s1.number = <span class="number">1000</span>;</span><br><span class="line">		<span class="comment">//因为static修饰的是所有对象共有的</span></span><br><span class="line">		<span class="comment">//所以s1的number也是1000</span></span><br><span class="line">		System.out.println(s2.number);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>从上例的实例可以看出当修改s1的number属性时，s2的number属性也发生了变化，这是因为，static修饰的变量属于对象所属的类，被所有对象所共享。但是我们并不推荐使用对象来访问类变量，类变量应该通过类名访问。</p>
<p>局部变量根据定义形左式的不同，又可以被分为如下三种。<br><strong>形参：</strong>在定义方法签名时定义的变量，形参的作用域在整个方法内有效。<br><strong>方法局部变量：</strong>在方法体内定义的局部变量，它的作用域是从定义该变量的地方生效，到该方法结束时失效。<br><strong>代码块局部变量：</strong>在代码块中定义的局部变量，这个局部变量的作用域从定义该变量的地方生效，到该代码块结束时失效。与成员变量不同的是，局部变量除形参之外，都必须显式初始化。也就是说，必须先给方法局部变量和代码块局部变量指定初始值，否则不可以访问它们。</p>
<p>在同一个类里，成员变量的作用范围是整个类内有效。一个类里不能定义两个同名的成员变量，即使一个是类变量，一个是实例变量也不行；一个方法里不能定义两个同名的方法局部变量，方法局部变量与形参也不同名：同一个方法中不同代码块内的代码块局部变量可以同名：如果先定义代码块局部变量，后定义方法局部变量，前面定义的代码块局部变量与后面定义的方法局部变量也可以同名。Java允许局部变量和成员变量同名，如果方法里的局部变量和成员变量同名，局部变量会覆盖成员变量，如果需要在这个方法里引用被覆盖的成员变量，则可使用this(对于实例变量)或类名（对于类变量）作为调用者来限定问成员变量</p>
<h3 id="成员变量初始化机制"><a href="#成员变量初始化机制" class="headerlink" title="成员变量初始化机制"></a>成员变量初始化机制</h3><p>当系统加载类或创建该类的实例时，系统自动为成员变量分配内存空间，并在分配内存空间后，自动为成员变量指定初始值，下面我们通过图示来学习。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"> 	<span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    System.out.print(s.age);</span><br><span class="line">    s.age = <span class="number">18</span>;</span><br><span class="line">    System.out.print(s.age);       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当代码执行到第3行，我们发现打印了0<br>当代码执行到第2行时，JVM在堆中分配了一块内存区域，这块内存区域中保存这实例变量āge,并为其赋默认值。此时内存结构如下：</p>
<p><img src="https://files.catbox.moe/52mn1j.png"></p>
<p>当执行第4行代码时，JVM将堆内存中age的值修改为18.</p>
<h3 id="局部变量的初始化机制"><a href="#局部变量的初始化机制" class="headerlink" title="局部变量的初始化机制"></a>局部变量的初始化机制</h3><p>局部变量定义后，必须经过显式初始化后才能使用，系统不会为局部变量执行初始化。这意味着定义局部变量后，系统并未为这个变量分配内存空间，直到等到程序为这个变量赋初始值时，系统才会为局部变量分配内存，并将初始值保存到这块内存中。<br>与成员变量不同，局部变量不属于任何类或实例，因此它总是保存在其所在方法的浅内存中。如果局部变量是基本类型的变量，则直接把这个变量的值保存在该变量对应的内存中，如果局部变量是一个引用类型的变量，则这个变量里存放的是地址，通过该地址引用到该变量实际引用的对<br>象或数组。栈内存中的变量无需系统垃圾回收，往往随方法或代码块的运行结束而结束。因此，局部变量的作用域是从初始化该变量开始，直到该方法或该代码块运行完成而结束。因为局部变量只保存基本类型的值或者对象的引用，因此局部变量所占的内存区通常比较小。</p>
<h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>在前面的内容中我们可以总结出static用于修饰方法和示例变量，使用static修饰的方法叫做类方法，使用static修饰的变量叫放类变量,static还可以修饰代码块，无论是类变量还是类方法，都属于类，而不属于对象，是所有对象共享的。<br>类变量属于整个类，当系统第一次准备使用该类时，系统会为该类变量分配内存空间，类变量开始生效，直到该类被卸载，该类的类变量所占有的内存才被系统的垃圾回收机制回收。类变量生存范围几乎等同于该类的生存范围。当类初始化完成后，类变量也被初始化完成。类变量既可通<br>过类来访问，也可通过类的对象来访问。但通过类的对象来访问类变量时，实际上并不是访问该对象所拥有的变量，因为当系统创建该类的对象时，系统不会再为类变量分配内存，也不会再次对类变量进行初始化，也就是说，对象根本不拥有对应类的类变量。通过对象访问类变量只是一<br>种假象，通过对象访问的依然是该类的类变量，可以这样理解：当通过对象来访问类变量时，系统会在底层转换为通过该类来访问类变量。<br>由于对象实际上并不特有类变量，类变量是由该类持有的，同一个类的所有对象问类变量时，实际上方间的都是孩类所特有的变量。因此，从程序运行表面来看，即可看到同一类的所有实例的类变量共享同一块内存区。<br>类方法也是类成员的一种，类方法也是属于类的，通常直接使用类作为调用者来调用类方法，但也可以使用对象来调用类方法。与类变量类似，使使用对象来调用类方法，其效果也与用类来调用类方法完全一样。</p>

    </div>

    
    
    
      


    <footer class="post-footer">
          <div class="reward-container">
  <div></div>
  <button>
    赞赏
  </button>
  <div class="post-reward">

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Fei
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://airui520.github.io/2022/07/20/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E5%9F%BA%E7%A1%80)/" title="Java面向对象(基础)">https://airui520.github.io/2022/07/20/Java面向对象(基础)/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/07/19/Java%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B%E5%92%8C%E6%95%B0%E7%BB%84/" rel="prev" title="Java控制流程和数组">
                  <i class="fa fa-chevron-left"></i> Java控制流程和数组
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/07/21/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E9%AB%98%E7%BA%A7/" rel="next" title="Java面向对象(高级)">
                  Java面向对象(高级) <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2001 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fei</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">1.1m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">16:43</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
  <div class="addthis_inline_share_toolbox">
    <script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=your_add_this_id" async="async"></script>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>
<script class="next-config" data-name="chatra" type="application/json">{"enable":true,"async":true,"id":null}</script>
<script src="/js/third-party/chat/chatra.js"></script>
<script async src="https://call.chatra.io/chatra.js"></script>





  





</body>
</html>
