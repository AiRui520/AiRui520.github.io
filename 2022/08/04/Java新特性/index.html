<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.2.0">

<link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/manifest.json">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic%7CLobster+Two:300,300italic,400,400italic,700,700italic%7CAmita:300,300italic,400,400italic,700,700italic%7CMontserrat:300,300italic,400,400italic,700,700italic%7CPT+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"airui520.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":"true`","version":"8.12.1","exturl":false,"sidebar":{"position":"left","width":300,"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="blog">
<meta property="og:title" content="Java新特性">
<meta property="og:url" content="https://airui520.github.io/2022/08/04/Java%E6%96%B0%E7%89%B9%E6%80%A7/index.html">
<meta property="og:site_name" content="Fei的博客">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://files.catbox.moe/vakrmb.png">
<meta property="article:published_time" content="2022-08-04T13:06:41.000Z">
<meta property="article:modified_time" content="2022-08-04T13:14:54.081Z">
<meta property="article:author" content="Fei">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://files.catbox.moe/vakrmb.png">


<link rel="canonical" href="https://airui520.github.io/2022/08/04/Java%E6%96%B0%E7%89%B9%E6%80%A7/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://airui520.github.io/2022/08/04/Java%E6%96%B0%E7%89%B9%E6%80%A7/","path":"2022/08/04/Java新特性/","title":"Java新特性"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java新特性 | Fei的博客</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-XXXXXXXX-X"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-XXXXXXXX-X","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Fei的博客</p>
      <i class="logo-line"></i>
    </a>
      <img class="custom-logo-image" src="/images/bg.jpg" alt="Fei的博客">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">33</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.</span> <span class="nav-text">Java新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8"><span class="nav-number">1.1.</span> <span class="nav-text">Lambda表达式入门</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.2.</span> <span class="nav-text">函数式接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E4%B8%8E%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8"><span class="nav-number">1.3.</span> <span class="nav-text">方法引用与构造器引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.1.</span> <span class="nav-text">引用类方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.2.</span> <span class="nav-text">引用对象的实例方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">1.3.3.</span> <span class="nav-text">引用构造器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.</span> <span class="nav-text">Lambda表达式和匿名内部类的联系和区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stream"><span class="nav-number">1.5.</span> <span class="nav-text">Stream</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Fei"
      src="/images/head.jpg">
  <p class="site-author-name" itemprop="name">Fei</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/AiRui520" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AiRui520" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2813764348@qq.com" title="E-Mail → mailto:2813764348@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://xiguayaaaaa.github.io/" title="https:&#x2F;&#x2F;xiguayaaaaa.github.io" rel="noopener" target="_blank">xigua</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://simon-yian.com/" title="https:&#x2F;&#x2F;simon-yian.com" rel="noopener" target="_blank">banana</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/AiRui520" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://airui520.github.io/2022/08/04/Java%E6%96%B0%E7%89%B9%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="Fei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fei的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java新特性 | Fei的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java新特性<a href="https://github.com/AiRui520/next/edit/main/subdirectory-name/_posts/Java%E6%96%B0%E7%89%B9%E6%80%A7.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pen-nib"></i></a>
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-08-04 21:06:41 / 修改时间：21:14:54" itemprop="dateCreated datePublished" datetime="2022-08-04T21:06:41+08:00">2022-08-04</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p><img src="https://files.catbox.moe/vakrmb.png"></p>
<span id="more"></span>

<h1 id="Java新特性"><a href="#Java新特性" class="headerlink" title="Java新特性"></a>Java新特性</h1><p>Lambda表达式是Java8中新增的特性，lambda表达式是一个可传递的代码块，可以在以后执行一次或多次。在以前定义的方法中，只能将基本类型或者引用类型的变量作为方法参数，在Java 8以后可以将一个代码片段作为方法参数。</p>
<h2 id="Lambda表达式入门"><a href="#Lambda表达式入门" class="headerlink" title="Lambda表达式入门"></a>Lambda表达式入门</h2><p>在集合中Java为开发者提供了遍历集合的简洁方式，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		list.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		list.forEach(e-&gt;System.out.println(e));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，调用了list对象的foreach方法，从程序可以看出，传入foreach的并不是一个变量，而是一段代码，这就是Lambda表达式。从上面的语法可以看出，Lambda表达式的主要作用就是代替匿名内部类的烦琐语法。<br>Lambda由3部分组成：</p>
<ol>
<li>形参列表：形参列表允许省略形参的数据类型，如果形参列表中有且只有1个参数，可以省略形参列表的括号</li>
<li>箭头函数：-&gt;必须有横线和大于号组成</li>
<li>代码块。如果代码块只包含一条语句，Lambda表达式允许省略代码块的花括号。</li>
</ol>
<p>下面，通过示例来学习Lambda的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表达式只有1个参数</span></span><br><span class="line">(a)-&gt;&#123;</span><br><span class="line">    System.out.print(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//表达式可以简写为</span></span><br><span class="line">a-&gt;&#123;</span><br><span class="line">    System.out.print(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果代码块中只有1条语句，可以省略大括号</span></span><br><span class="line">a-&gt;System.out.print(a)</span><br></pre></td></tr></table></figure>

<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>Lambda表达式的目标类型必须是函数式接口，所谓函数式接口代表只包含一个抽象方法的接口，函数式接口可以包含多个默认方法、类方法，但是只能声明一个抽象方法。</p>
<p>如果采用匿名内部类语法来创建函数式接口的实例，则只需要实现一个抽象方法，在这种情况下可采用Lambda表达式来创建对象。</p>
<p>注意：Java8 专门为函数式接口提供了@FunctionalInterface注解，该注解通常放在接口定义前，该注解对程序功能没有任何作用，它的作用是用于告诉编译器执行更严格的检查，检查该接口必须是函数式接口，否则编译器出错。</p>
<p>Lambda表达式的结果就是被作为对象，程序中晚期可以使用Lambda表达式进行赋值，例如在多线程Thread类的构造器中可以传入Runnable接口的子类对象。查看Runnable接口发现，该接口也被声明为一个函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，就可以使用Lambda表达式来创建线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLambdaDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">				System.out.println(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		thread.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lambda 表达式实现的是匿名方法——因此它只能实现特定函数式接口中的唯一方法。这意味着 Lambda 表达式有如下两个限制。</p>
<ul>
<li>Lambda 表达式的目标类型必须是明确的函数式接口。</li>
<li>Lambda 表达式只能为函数式接口创建对象。Lambda 表达式只能实现一个方法，因此它只能为 只有一个抽象方法的接口（函数式接口）创建对象。</li>
</ul>
<p>下面定义一个函数式接口深入学习Lambda表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"><span class="comment">//函数式接口只能有一个抽象方法，并且要使用@FunctionalInterface声明</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个方法，方法参数是Consumer接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(Consumer consumer)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">		<span class="keyword">return</span> consumer.add(a, b);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> test((a,b)-&gt;&#123;</span><br><span class="line">			<span class="keyword">return</span> a+b;</span><br><span class="line">		&#125;);</span><br><span class="line">		System.out.println(k);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上例中定义了一个函数式接口，在测试类的test方法传入了接口并调用了Consumer接口的add方法，需要注意的是，此时add方法并没有方法实现，在main方法中调用了test，并将一段代码（即add方法的实现）也就是lambda表达式当做参数传入了test方法。换句话说在上例中使用了lambda表达替代了烦琐的匿名内部类。对比下面的代码就可以看出Lambda表达式的独到之处。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(Consumer consumer)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">		<span class="keyword">return</span> consumer.add(a, b);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> test(<span class="keyword">new</span> <span class="title class_">Consumer</span>() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> a+b;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		System.out.println(k);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从前面的程序可以看出Lambda表达式的使用离不开函数式接口，通常函数式接口中有且只能有1个抽象方法，这样使用Lambda表达式时也就明确了是哪个抽象方法的实现，如果接口中出现了多个抽象方法，那么就不能在接口上使用@FunctionInterface注解，会编译出错。因此，Java 8在java.util.function包中预定义了大量函数式接口，通常情况下这些接口完全可以满足开发需要：</p>
<ul>
<li>XxxFunction∶ 这类接口中通常包含一个 apply()抽象方法，该方法对参数进行处理、转换（apply() 方法的处理逻辑由 Lambda 表达式来实现），然后返回一个新的值。该函数式接口通常用于对指定数据进行转换处理。</li>
<li>XxxConsumer∶ 这类接口中通常包含一个 accept()抽象方法，该方法与 XxxFunction 接口中的 apply()方法基本相似，也负责对参数进行处理，只是该方法不会返回处理结果。</li>
<li>XxxxPredicate∶这类接口中通常包含一个 test()抽象方法，该方法通常用来对参数进行某种判断 test()方法的判断逻辑由 Lambda 表达式来实现），然后返回一个 boolean 值。该接口通常用于判断参数是否满足特定条件，经常用于进行筛滤数据。</li>
<li>XxxSupplier∶ 这类接口中通常包含一个 getAsXxx()抽象方法，该方法不需要输入参数，该方法会按某种逻辑算法（getAsXxx()方法的逻辑算法由 Lambda 表达式来实现）返回一个数据。综上所述，不难发现 Lambda 表达式的本质很简单，就是使用简洁的语法来创建函数式接口的实例——这种语法避免了匿名内部类的烦琐。</li>
</ul>
<p>下面在程序中示范上述接口的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据转换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MR.W</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CastUtil</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 定义方法将Object类型转换为String类型</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> function</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">castToString</span><span class="params">(Function&lt;Object, String&gt; function, Integer a)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> function.apply(a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的CastUtil类中定义了castToString，在该方法中第一个参数是一个Java 8 预定义的函数式接口，在方法内调用了Function接口的apply()方法，作用是将任意类型转换成String。但是此时这个方法并没有方法的实现，需要在调用此方法时传入方法的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.lambda;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10010</span>;</span><br><span class="line">		<span class="comment">//使用Lambda表达式，此时castToString方法的第一个参数</span></span><br><span class="line">		<span class="comment">//就是Function函数式接口apply()的实现</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> CastUtil.castToString((o)-&gt;&#123;</span><br><span class="line">			<span class="keyword">return</span> String.valueOf(o);</span><br><span class="line">		&#125;, a);</span><br><span class="line">		System.out.println(s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在测试类中，调用了CastUtil的castToString()方法，并传入了Lambda表达式，以此Lambda表达式作为apply()方法的实现，在表达式中使用了String.valueOf()方法将对象转换成String类型。</p>
<h2 id="方法引用与构造器引用"><a href="#方法引用与构造器引用" class="headerlink" title="方法引用与构造器引用"></a>方法引用与构造器引用</h2><p>前面已经介绍过，如果Lambda 表达式的代码块只有一条代码，程序就可以省略 Lambda 表达式中代码块的花括号。不仅如此，如果Lambda 表达式的代码块只有一条代码，还可以在代码块中使用方法引用和构造器引用。 方法引用和构造器引用可以让 Lambda表达式的代码块更加简洁。方法引用和构造器引用都需要使用两个英文冒号。<br>Lambda 表达式支持如下表所示的几种引用方式。</p>
<h3 id="引用类方法"><a href="#引用类方法" class="headerlink" title="引用类方法"></a>引用类方法</h3><p>下面的示例将演示类方法的引用，首先定义一个函数式接口，接口中定义抽象方法castToString()，该方法的作用是将一个对象转换成String对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.lambda;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span>&lt;T,R&gt; &#123;</span><br><span class="line">	R <span class="title function_">castToString</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在String的学习中可以知道，String类有提供了类方法valueOf(Object o)，该方法可以将任意对象转换成String类型，因此可以使用该方法作为Lambda表达式的实现代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Function&lt;Object, String&gt; function = a-&gt;&#123;</span><br><span class="line">			<span class="keyword">return</span> String.valueOf(a);</span><br><span class="line">		&#125;;</span><br><span class="line">		System.out.println(function.castToString(<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，创建了Lambda表达式作为了Function接口中castToString()方法的实现。在Lambda表达式中调用了String.valueOf()方法来进行对象到字符串的转换，在代码第8行调用了function接口的castToString()方法，实际上调用了就是代码第5行创建的Lambda表达式。<br>上面的Lambda表达式的代码块只有一行调用类方法的代码，因此可以使用如下方法引用进行替换。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Function&lt;Object, String&gt; function = String::valueOf;</span><br><span class="line">		System.out.println(function.castToString(<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面的类方法的引用，也就是调用了String类的valueOf()方法来实现Function函数式接口中唯一抽象方法。当调用castToString()方法时，调用参数将会传给String类的valueOf()类方法。</p>
<h3 id="引用对象的实例方法"><a href="#引用对象的实例方法" class="headerlink" title="引用对象的实例方法"></a>引用对象的实例方法</h3><p>下面演示第二种方法引用，引用对象的实例方法，首先使用Lambda表达式创建一个Function接口的子类对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Object, String&gt; function = o-&gt;o.toString();</span><br></pre></td></tr></table></figure>

<p>上面的Lambda表达式只有一条语句，因此省略了该代码的花括号。<br>接下来程序调用function对象的castToString()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.lambda;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Function&lt;Object, String&gt; function = o-&gt;o.toString();</span><br><span class="line">		System.out.println(function.castToString(<span class="number">100</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序调用了function对象的castToString()方法时，由于function对象是Lambda表达式创建，castToString()方法的执行体就是Lambda表达式的代码部分，因此上面的程序输出了100.<br>上面的Lambda表达式代码只有一行，且调用了对象的o的toString()实例方法。因此代码可以进行如下替换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.lambda;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Function&lt;Object, String&gt; function = Object::toString;</span><br><span class="line">		System.out.println(function.castToString(<span class="number">100</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的Lambda表达式的代码只有一条语句，因此省略了代码块的花括号；而且由于表达式实现的castToString方法需要返回值，因此Lambda表达会将这行代码的值作为返回值。此时就可以使用方法引用进行替换，直接引用Object的toString()方法作为Lambda表达式的代码块。其中Function接口的castToString方法有个参数，当执行Lambda表达式代码块时，会自动调用传入参数的toString()方法。</p>
<h3 id="引用构造器"><a href="#引用构造器" class="headerlink" title="引用构造器"></a>引用构造器</h3><p>下面的实例将演示如何引用构造器，首先定义函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.lambda;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">	StringBuilder <span class="title function_">get</span><span class="params">(String s)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数式接口包含了一个get()抽象方法，该方法的作用是使用String对象生成一个StringBuilder对象，接着使用Lambda表达式创建一个MyInterface的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.lambda;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefTest3</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">MyInterface</span> <span class="variable">myInterface</span> <span class="operator">=</span> (s)-&gt; <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s);</span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> myInterface.get(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码调用了myInterface对象的get()方法时，由于该对象是Lambda表达式创建的，因此get()方法执行体就是Lambda表达式的代码块部分，即执行体就是执行new StringBuilder(a)语句，并将这条语句的值作为方法的返回值。因此上面代码中Lambda表达式的代码可以进行如下替换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefTest3</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">MyInterface</span> <span class="variable">myInterface</span> <span class="operator">=</span> StringBuilder::<span class="keyword">new</span>;</span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> myInterface.get(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面的构造器引用，也就是调用StringBuilder类的构造方法来实现MyInteface函数式接口中唯一的抽象方法，当调用MyInterface接口的test()方法是，调用参数会传给StringBuilder构造器，从上面的程序中可以看出，调用myInterface对象的get()方法时，实际只传入了一个String类型的参数，这个String类型的参数会被传给StringBuilder的构造器。</p>
<h2 id="Lambda表达式和匿名内部类的联系和区别"><a href="#Lambda表达式和匿名内部类的联系和区别" class="headerlink" title="Lambda表达式和匿名内部类的联系和区别"></a>Lambda表达式和匿名内部类的联系和区别</h2><p>从前面介绍可以看出，Lambda 表达式是匿名内部类的一种简化，因此它可以部分取代匿名内部类的作用，Lambda 表达式与匿名内部类存在如下相同点。</p>
<ul>
<li>Lambda 表达式与匿名内部类一样，都可以直接访问”effectively final”的局部变量，以及外部 类的成员变量（包括实例变量和类变量）。</li>
<li>Lambda 表达式创建的对象与匿名内部类生成的对象一样，都可以直接调用从接口中继承的默认 方法。</li>
</ul>
<p>首先创建函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.ano;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Display</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.ano;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTest</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Byte科技&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">book</span> <span class="operator">=</span> <span class="string">&quot;Java编程思想&quot;</span>;</span><br><span class="line">		<span class="type">Display</span> <span class="variable">display</span> <span class="operator">=</span> (a,b)-&gt;&#123;</span><br><span class="line">			<span class="comment">//访问外部类的实例变量</span></span><br><span class="line">			System.out.println(age);</span><br><span class="line">			<span class="comment">//访问外部类的类变量</span></span><br><span class="line">			System.out.println(name);</span><br><span class="line">			<span class="comment">//访问局部变量</span></span><br><span class="line">			System.out.println(book);</span><br><span class="line">			<span class="keyword">return</span> a+b;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">//调用display对象从接口继承的默认方法</span></span><br><span class="line">		display.print();</span><br><span class="line"><span class="comment">//		book = &quot;Java核心技术卷&quot;;</span></span><br><span class="line">		System.out.println(display.add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.ano;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">LambdaTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LambdaTest</span>();</span><br><span class="line">		test.test();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序使用Lambda表达式创建了一个Display接口的对象，Lambda表达式分别访问了外部类的实例变量，类变量从这些来看Lambda表达式的代码块和匿名内部类的方法体是相同的。<br>和匿名内部类相似，由于Lambda表达式访问了了book局部变量，因此该局部变量相当于有一个隐式的final修饰，不允许对book局部变量重新赋值。<br>当程序使用 Lambda 表达式创建了 Display 的对象之后，该对象不仅可调用接口中唯一的抽象方法，也可调用接口中的默认方法。<br>Lambda表达式与匿名内部类主要存在如下区别:</p>
<ul>
<li>匿名内部类可以为任意接口创建实例——不管接口包含多少个抽象方法，只要匿名内部类实现 所有的抽象方法即可;但 Lambda 表达式只能为函数式接口创建实例。</li>
<li>匿名内部类可以为抽象类甚至普通类创建实例;但 Lambda 表达式只能为函数式接口创建实例。</li>
<li>匿名内部类实现的抽象方法的方法体允许调用接口中定义的默认方法;但 Lambda 表达式的代 码块不允许调用接口中定义的默认方法。</li>
</ul>
<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>Java8 还新增了Stream、IntStream、LongStream、DoubleStream等流式API（注意：这里的Stream并不是IO中的Stream），这些API代表多个支持串行和并行聚集操作的元素。上面的4个接口中，Stream是一个通用的流接口，而IntStream、LongStream、DoubleStream则代表元素类型为int、long、double的流。<br>Java 8 还为上面每个流式 API 提供了对应的 Builder，例如 Stream.Builder、IntStream.Builder、 LongStream.Builder、DoubleStream.Builder，开发者可以通过这些 Builder 来创建对应的流 独立使用 Stream 的步骤如下∶</p>
<ol>
<li>使用 Stream 或 XxxStream 的 builder()类方法创建该 Stream 对应的 Builder。</li>
<li>重复调用 Builder 的 add()方法向该流中添加多个元素。</li>
<li>调用 Builder 的 build()方法获取对应的 Stream。</li>
<li>调用 Stream 的聚集方法。</li>
</ol>
<p>Stream提供了大量的方法进行聚集操作，这些方法可以是中间的，也可以是末端的。</p>
<ul>
<li>中间方法∶中间操作允许流保持打开状态，并允许直接调用后续方法。也就是说中间方法可以连续调用。</li>
<li>末端方法; 末端方法是对流的最终操作。当对某个 Stream 执行末端方法后，该流将会被”消耗” 且不再可用。换句话说就是末端方法一旦调用后就会关闭流，再不能对流进行操作，否则会抛出异常。</li>
</ul>
<p>下面先介绍Stream常用的中间方法：</p>
<ul>
<li>filter(Predicate predicate)∶ 过滤 Stream 中所有不符合 predicate 的元素。</li>
<li>mapToXxx(ToXxxFunction mapper)∶使用 ToXxxFunction 对流中的元素执行一对一的转换，该方 法返回的新流中包含了ToXxxFunction 转换生成的所有元素。</li>
<li>peek(Consumer action)∶ 依次对每个元素执行一些操作，该方法返回的流与原有流包含相同的元 素。该方法主要用于调试。</li>
<li>distinct()∶该方法用于排序流中所有重复的元素（判断元素重复的标准是使用 equals（）比较返回 true）。这是一个有状态的方法。</li>
<li>sorted()∶该方法用于保证流中的元素在后续的访问中处于有序状态。这是一个有状态的方法。</li>
<li>limit(long maxSize)∶ 该方法用于保证对该流的后续访问中最大允许访问的元素个数。这是一个 有状态的、短路方法。</li>
</ul>
<p>下面简单介绍一下 Stream 常用的末端方法。</p>
<ul>
<li>forEach(Consumer action)∶ 遍历流中所有元素，对每个元素执行 action。</li>
<li>toArray()∶将流中所有元素转换为一个数组。</li>
<li>reduce（）∶该方法有三个重载的版本，都用于通过某种操作来合并流中的元素。</li>
<li>min()∶ 返回流中所有元素的最小值。</li>
<li>max()∶ 返回流中所有元素的最大值。</li>
<li>count()∶ 返回流中所有元素的数量。</li>
<li>anyMatch(Predicate predicate)：判断流中是否至少包含一个元素符合 Predicate 条件。</li>
<li>allMatch(Predicate predicate)：判断流中是否每个元素都符合 Predicate 条件。</li>
<li>noneMatch(Predicate predicate)∶判断流中是否所有元素都不符合 Predicate 条件。</li>
<li>findFirst()∶ 返回流中的第一个元素。</li>
<li>findAny()∶返回流中的任意一个元素。</li>
</ul>
<p>下面，通过示例来学习Stream的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntStreamTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">IntStream</span> <span class="variable">is</span> <span class="operator">=</span> IntStream.builder()</span><br><span class="line">				.add(<span class="number">100</span>)</span><br><span class="line">				.add(<span class="number">10</span>)</span><br><span class="line">				.add(<span class="number">30</span>)</span><br><span class="line">				.add(<span class="number">40</span>)</span><br><span class="line">				.build();</span><br><span class="line">		<span class="comment">//调用聚集方法,下列方法都是末端方法，因此同时只能调用1个</span></span><br><span class="line"><span class="comment">//		System.out.println(&quot;最大值：&quot;+is.max().getAsInt());</span></span><br><span class="line"><span class="comment">//		System.out.println(&quot;最小值：&quot;+is.min().getAsInt());</span></span><br><span class="line"><span class="comment">//		System.out.println(&quot;总和：&quot;+is.sum());</span></span><br><span class="line"><span class="comment">//		System.out.println(&quot;总数&quot;+is.count());</span></span><br><span class="line"><span class="comment">//		System.out.println(&quot;平均值&quot;+is.average());</span></span><br><span class="line"><span class="comment">//		System.out.println(&quot;判断所有元素的是否都大于10:&quot;+is.allMatch(e-&gt;e&gt;10));</span></span><br><span class="line"><span class="comment">//		System.out.println(&quot;判断是否任意一个元素都大于10:&quot;+is.anyMatch(e-&gt;e&gt;20));</span></span><br><span class="line">		</span><br><span class="line">		is.forEach(System.out::println);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，Java8允许使用流式API来操作集合，这也是Stream的重要使用场景之一，Collection接口提供了stream()默认方法，该方法可以返回该集合对应的流，下面使用Stream来操作集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListStreamDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="comment">//list中添加元素</span></span><br><span class="line">		list.add(<span class="string">&quot;Java编程思想&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;Java核心技术卷&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;Effective Java&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;Spring 入门与精通&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;并发编程之美&quot;</span>);</span><br><span class="line">		<span class="comment">//获取Stream</span></span><br><span class="line">		Stream&lt;String&gt; stream = list.stream();</span><br><span class="line">		<span class="comment">//统计包含Java字符串的元素总数</span></span><br><span class="line"><span class="comment">//		System.out.println(stream.filter(e-&gt;e.contains(&quot;Java&quot;)).count());</span></span><br><span class="line">		<span class="comment">//取出前3个元素</span></span><br><span class="line">		stream.limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的实例中首先获取了List的Stream，在代码20行对stream进行了过滤，筛选出了包含Java的字符串，然后调用了count()统计了过滤后的字符串个数。因为count()是末端方法，因此调用后再不能进行后续操作。代码22行是用limit取出了前3个元素，并对其进行了遍历。<br>需要注意的是，Stream对集合的操作并不影响List中保存的数据。</p>

    </div>

    
    
    
      


    <footer class="post-footer">
          <div class="reward-container">
  <div></div>
  <button>
    赞赏
  </button>
  <div class="post-reward">

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Fei
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://airui520.github.io/2022/08/04/Java%E6%96%B0%E7%89%B9%E6%80%A7/" title="Java新特性">https://airui520.github.io/2022/08/04/Java新特性/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/08/04/Java%E5%BC%82%E5%B8%B8/" rel="prev" title="Java异常">
                  <i class="fa fa-chevron-left"></i> Java异常
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/08/04/JavaIO%E6%B5%81/" rel="next" title="JavaIO流">
                  JavaIO流 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2001 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fei</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">375k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">5:41</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
  <div class="addthis_inline_share_toolbox">
    <script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=your_add_this_id" async="async"></script>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>
<script class="next-config" data-name="chatra" type="application/json">{"enable":true,"async":true,"id":null}</script>
<script src="/js/third-party/chat/chatra.js"></script>
<script async src="https://call.chatra.io/chatra.js"></script>





  





</body>
</html>
